======================================================================
Python 入門［２＆３対応］読書ノート
======================================================================

Python 関連の本を持っていないと思って、書店でテキトーに選んで買ったもの。
入門書を謳っているのに話題が豊富。物量的にも 500 ページちょいとなって CP がよい。
書いてあるコードを自分で再現するだけで、かなりのテクニックが身に付く。

:著者: 株式会社エスキュービズム／細田謙二／オレンジ岸本／石井光次郎／岩川建彦／岡田正彦
:出版社: 秀和システム
:ISBN: 978-4-7980-2655-8 C3055

.. contents:: ノート目次

ノートの方針
===================================
Windows XP の Python 2.6.6 を利用して、本書を読み解いていく。
文章を読むだけではなく、可能な限りサンプルコードを実際にタイプして実行することを基本作業とする。

インターネットに接続できない環境で作業をするため、それ系の機能は残念ながら試せない。

第 1 章 Python へようこそ
===================================
イントロダクション。

1.1 Python の特徴
-----------------------------------
* <マジックメソッドによるアスペクト指向プログラミング> (p. 16) なる用語がいきなり出てくる。
  本書は Python の入門書であり、プログラミングの入門書ではないように感じた。

* <Python では C や C++ との連携が配慮されています。
  （略）速度のボトルネックになる部分はほんの一部の特定の処理の場合が多いため、
  その部分だけ C や C++ で書いて、後は Python で書くことで生産性が高くなります> (pp. 16-17)
  これは是非挑戦してみたい。

* Disney
* Ohloh.net - 後で見ておくこと。

1.2 本書について
-----------------------------------
* <本書の目的は、Python の魅力を伝えることです> (p. 19) これは果たせていると思う。
* この人気モジュールベストテンの表は面白い。
  ベストファイブまでは納得のラインナップなのだが、それ以下が意外。
  例えばこの本を読むまで logging なんて使ったことがない。

* 2-15 章が文法編で、それ以降が実践編。
  当ノートは実践編を重視する。

第 2 章 実行環境の用意
===================================
2.1 Python のインストール
-----------------------------------
``C:\Python26`` に加え ``C:\Python26\Scripts`` も PATH 環境変数に追加したいところ。

2.2 起動と終了
-----------------------------------
* ``help`` 関数が便利。

2.3 Python 開発環境
-----------------------------------
テキストエディター対 IDE なわけだが、ここは読む価値がある。

* PyDev は試していない。Eclipse のプラグインと聞いては……。
* Komodo Edit は高機能っぽい。ちょっと使って疲れてやめた。メモリ消費量がちと多めか。
* PyScriptor はまあまあいい。

  * どういうわけかたまに ini ファイルが壊れるのが痛い。
  * プロジェクトファイルの扱いが面倒過ぎて泣ける。

最近 PyScriptor で固定にした。
テキスト編集はいつもの Xyzzy で、実行周りを PyScriptor でやる。

第 3 章 Python の基本
===================================
3.1 基本操作
-----------------------------------
* <従来の割り算はスラッシュ 2 つの ``//`` 演算子に置き換わりました> (p. 36)
* 括弧内ならば自由に改行できる。(p. 40)

3.2 複合文
-----------------------------------
* <1 つのインデントは（略）慣例的にスペース 4 つを使うことが推奨されています> (p. 41)
  エディターや IDE の設定を確認しておくこと。

* ``print`` は Python 2 系では式だが、3 系からは関数に変わる。
  <``print('a')`` という書き方に関しては、2 系、3 系で互換性があるので、
  本書では基本的にこの書き方を用いています> (p. 45)

3.3 オブジェクト
-----------------------------------
* <全てのデータは「オブジェクト」> (p. 46)
* 「変更可能」と「変更不可能」の意味がよくわからない。
  p. 47 のコード例は正直、理解不能。なんで 1 足したくらいで別物になるのだ？

第 4 章 リスト
===================================
4.4 リストの更新
-----------------------------------
* <メソッドである ``sort`` と ``reverse`` は自分自身を変更し、組み込み関数である
  ``sorted`` と ``reversed`` は新たなリストとして結果を戻します> (p. 64)

* 囲み記事の <要素の比較の度に比較関数を呼び出すよりも、
  全ての要素にキー関数を適用してから比較を行う方が、実行効率が良い> (p. 67)
  の意味がわからない。

4.6 その他のリストの操作
-----------------------------------
* ``b = a[:]`` はコピーだと思っていたが、厳密に言えば「浅いコピー」だ。
  <深いコピーは ``copy`` モジュールの ``deepcopy`` 関数を使用して行います> (p. 71)

* リスト内包表記は習得すること。

第 5 章 辞書
===================================
5.2 辞書の作成
-----------------------------------
* 辞書オブジェクトのコピーは ``copy`` メソッドを利用する。
* ``dict.fromkeys`` メソッドでキーのコレクションから辞書オブジェクトを作成できる。

5.4 辞書の更新
-----------------------------------
* ``setdefault`` メソッドは C++ の STL で言うところの
  ``std::map::operator[]`` みたいなものか。

5.5 
-----------------------------------
囲み記事 (p. 90) の ``OrderedDict`` はリストじゃだめなんですか？

5.6 その他の辞書の操作
-----------------------------------
* 辞書オブジェクトのコピーも
  <コンテナ型オブジェクトのため、コピーの際には浅いコピーと深いコピーの使い分けが必要です> (p. 91)

* <Python 3 から、リスト内包表記のように辞書でも内包表記が使える> (p. 93)

第 6 章
===================================
* コレクションオブジェクトを要素列から作成するときいは、
  列末尾にカンマを入れておく習慣をつけたほうがいいかもしれない。

第 7 章 セット
===================================
7.1 セットの概要
-----------------------------------
C++ STL の ``set`` みたいなものか。

7.2 セットの作成
-----------------------------------
集合演算を行うメソッド名が、馴染みがある名前で助かる。

7.3 セットの読み込み
-----------------------------------
``issubset`` と ``issuperset`` はどちらかがあればもう一方は要らない？

7.4 セットの更新
-----------------------------------
集合演算名と ``update`` がメソッド名になっているものがある。

7.5 セットの削除
-----------------------------------
* <指定した要素が存在しない場合、
  ``remove`` メソッドは ``KeyError`` 例外が発生しますが、
  ``discard`` メソッドは発生しません> (p. 123)

第 8 章 条件分岐とループ
===================================
8.1 条件分岐
-----------------------------------
* Python は ``elif`` を使う。
* Python には switch 文は存在しない。
* ``bool(-1)`` は私の環境では ``True`` になるのだが？
* <論理演算の戻り値は少し特殊で、演算対象のオブジェクトそのものが返されます> (p. 134)

8.2 ループ
-----------------------------------
* <複数の変数に同時に代入する方法を「アンパック代入」と言い> (p. 137)
* <特殊な構文として、
  ``for`` 文や ``while`` 文のループ処理の後に、
  ``else`` 節が記述できます。
  ``break`` 文でループが中断されなかった場合に限り、
  ``else`` ブロックが実行されます> (p. 139)

第 9 章 イテレータ
===================================
* ストリーム処理のためのポインタ的な役割
* 遅延評価

9.1 イテレータとは
-----------------------------------
* Python におけるイテレータとは、 ``next`` メソッドを実装するオブジェクトのこと。
* ``next`` メソッドと ``StopIteration`` 例外を理解しておく。
  イテレータが ``next`` し切れなくなったら、そこから例外が送出されるイメージ。

* 囲み記事。Python 3 からは一部の関数がイテレータを返すように仕様変更になっている。
  特に、イテレータの ``next`` メソッドがなくなり、単なるフリー関数になるようだ。
  ``it.next()`` ではなく ``next(it)`` ということ。

9.2 ジェネレーター
-----------------------------------
この本はなぜか語尾の -or のカタカナ表記が揺らいでいる。

* <関数に結びつく広義のイテレータ> (p. 146)
* <ジェネレーターの特徴は、イテレータを進めるまで、関数内のローカル変数を保持したまま、
  次のシーケンス要素生成までの評価が中断されることです> (p. 146)

* <ジェネレーターも内包表記で書くことができます> (p. 148)

  >>> gen = (i * 3 for i in range(10)) # (p. 148)
  >>> gen.next()
  0
  >>> gen.next()
  3
  >>> gen.next()
  6

* 囲み記事の ``send`` は読みとばす。

第 10 章 文字列
===================================
10.1 文字列の概要
-----------------------------------
* どういうわけか、手許の IDLE だと ``len(u'日本語')`` が 6 を返す。3 が正解。
* ``u'日本語'.encode('utf8')`` のタイプは ``str`` だ。

10. 2 文字列の作成
-----------------------------------
* <``r`` の文字を置くとエスケープシーケンスを無視する raw 文字列のリテラル表現になります> (p. 154)
* <``%`` 演算子を利用した旧来の方法は、今後廃止される予定です> (p. 157)
* Python 3 風 ``format`` の使い方がすぐに理解できない。後で復習。

* ``join`` メソッドには慣れておくこと。例えば CSV テキストを文字列リストから素早く構築できる。

10.3 文字列の読み込み
-----------------------------------
* 文字検索には ``find``, ``rfind`` と ``index``, ``rindex`` メソッドが使える。
  見つからなかったときに例外 ``ValueError`` を投げるのが ``index`` 系。(p. 159)

* ``isdigit``, ``isnumeric`` メソッドは
  <Unicode 型および Python 3 からは全角に対応しています> (p. 162)
  とある。全角文字の１やらローマ数字やらを試して遊んでみよう。

* <printable な文字とは、
  ``print`` 関数で何かしらの文字列が
  ``sys.stdout`` に表示される文字のこと> (p. 165)

10.4 文字列の更新
-----------------------------------
これが理解するのが難しかった。

* <変更したように見える操作もありますが、新しく文字列を作成して、そのコピーを返しているだけ> (p. 166)
  らしい。

* ``split`` メソッドは、<何も指定しないか、None を指定した場合は、分割アルゴリズムが変わります> (p. 167)
  空白文字がきれいにトリムされるようだ。

* ``splitlines`` という、改行文字に特化した ``split`` のようなメソッドがある。
* ``partition``, ``rpartition`` は ``split`` の弱いやつか。

整形系メソッドは興味がわいたら読み返す。

10.5 文字列の削除
-----------------------------------
削除に見えても、実は新しくオブジェクトを作って返す操作だ。

10.6 Unicode 文字列と文字コード変換
-----------------------------------
* <Unicode は 18 ビットで 1 文字を表現する> (p. 175) とあるが、それは真実なのか。
* Unicode 文字列のほうは、<``isdecimal`` メソッドと ``isnumeric`` メソッドの
  2 つが追加されています> (p. 176)

* sitecustomize.py で ``sys.setdefaultencoding('utf-8')`` する例が書いてある。(p. 177)

* <``unicode`` 関数と ``decode`` メソッドは、ともに、通常の文字列を
  Unicode 文字列に変換します> (p. 177)

* <``str`` 関数については、必ずデフォルトエンコーディングで変換されます> (p. 179)
  ``encode`` メソッドのほうが柔軟だということか。

* 囲み記事。文字列の他に ``bytes``, ``bytearray`` 型というのがある。
  後者はバイナリの取り扱いに有効らしいので、イメージファイルを解析するのに応用してみたい。

第 11 章 ファイル入出力
===================================
11.1 ファイルの基本操作
-----------------------------------
* ``read`` メソッドはファイルの内容を一気に文字列として読み込む。
* ``read``, ``readlines``, ``write``, ``writelines`` を使い分ける。
  lines 系は各文字列の末尾に改行文字が付く。

11.2 日本語ファイルを扱う
-----------------------------------
* 前章の文字列メソッドを駆使して、ファイルの文字列の文字コードをプログラム中で適宜変換する。
* ``codecs`` というモジュールがあり、ファイルオープン時に文字コードを指定することができる。(p. 189)

  >>> import codecs
  >>> f = codecs.open('temp.txt', 'w', 'utf8', 'ignore')
  >>> f.write(u'あいう') # ファイル内に UTF-8 で出力される。
  >>> f.close()

  読み込みも同様。

* <BOM 付きファイルを適切に読み取るには、明示的にその BOM を取り除くか、
  ``codecs`` モジュールにおいて ``utf_8_sig`` という名のエンコードを指定します> (p. 190)
  掲載のサンプルコードでは ``lstrip(codecs.BOM_UTF8)`` と
  ``codes.open('temp.txt', 'r', 'utf_8_sig', 'ignore')`` の両方の手法を紹介している。

11.3 パスの構築
-----------------------------------
ファイルパスの文字列を取り扱う方法を習得すること。

* <セパレーターは ``os.path.sep`` または ``os.sep`` に格納されています> (p. 191)
  手元の環境で調べたら、両者は同じものだ。

* <パスを分解する方法は幾つかあります> (p. 193)
  基本的には split と名の付く関数を利用する。

* ``os.path.commonprefix`` 関数は使いどころがわからない。

11.4 ファイルシステム上の操作
-----------------------------------
ファイルの移動・コピー・属性操作関連の処理を習得すること。

* それらしい機能を探すときは ``os.path``, ``shutil``, ``os``
  モジュールを当たるとよさそうだ。

* ``os.mkdirs`` (p. 197) は UNIX で言うところの ``mkdir -p`` のようなもの。
* ディレクトリ削除が色々ある。直感的には ``shutil.rmtree`` が普通の削除に相当するような。
* これ重要。
  ``shutil.copy2`` 関数は <最終アクセス時間や最終更新時間などのメタデータもコピー> (p. 199)
  する。

* ディレクトリのコピーは ``shutil.copytree`` (p. 201) を利用する。引数が多い。

* ``os.walk`` 関数ではディレクトリを <デフォルトでは最上層から下に辿っていきます。
  引数で ``topdown=False`` とすると、最下層から辿るようになります> (p. 202)

* ``os.environ`` 変数に環境変数が格納されている。(p. 205)

  >>> os.environ['PATH'].split(';')
  ['C:\\WINDOWS\\system32',
   'C:\\WINDOWS',
   'C:\\WINDOWS\\System32\\Wbem',
   'C:\\cygwin\\bin',
   'D:\\Python26\\Scripts',
   'D:\\Python26\\Lib\\site-packages\\PyQt4\\bin',
   'C:\\Program Files\\SlikSvn\\bin\\',
   'C:\\Program Files\\TortoiseSVN\\bin']

11.5 テンポラリファイルの作成
-----------------------------------
* ``tempfile.mkdtemp`` 関数で一時ディレクトリを作成する。
* ``tempfile.mkstemp`` と ``tempfile.NamedTemporaryFile`` 関数で一時ファイルを作成する。
  ファイルを削除するのを自分でやりたければ前者を利用する、という具合に使い分ける。

11.6 ファイルライクオブジェクト
-----------------------------------
* <文字列オブジェクトをファイルオブジェクトのように扱う> (p. 208) クラスが ``StringIO`` なのか。
* <``StringIO`` の内部を C で実装した ``cStringIO`` モジュール> (p. 208) は速そうだが、
  ユニコード周りで制限あり。

* 囲み記事で紹介されている Python 3 の ``io`` モジュール。
  Python 2.6.5 でも使用可能になっていた。

第 12 章 関数
===================================
12.1 関数の引数
-----------------------------------
* キーワード引数の指定は順不同。(p. 213)
* 可変長引数は面白い。

  * <シーケンス型と辞書型の 2 つの指定方法があります。（略）
    引数宣言の前に "*" を付けると、複数の引数をタプル型として受け入れます> (p. 214)

  * <引数宣言の前に "**" を付けると、キーワード付き引数を辞書型として受け入れます> (p. 215)

  * 実引数の順序は、

    #. 一般的な変数、
    #. デフォルト値のある引数、
    #. シーケンス型の可変長引数、
    #. 辞書型の可変長引数

    の順でなければならない。(p. 216)

* 引数は <変更不可能なオブジェクトの場合は、実質的に値渡しとなります> (p. 216)

* 囲み記事の <ある種グローバルな変数> (p. 218) の指摘を心に留めておく。

12.3 関数オブジェクト
-----------------------------------
* <制限のないオブジェクト> (p. 221) の意味がまったくわからない。

12.4 デコレーター
-----------------------------------
これがまったくわからない。コードを手で打ち込んで実行してみても何をされたのかわからない。

* <デコレーターは関数を受け取り、修飾した関数を返す関数です> (p. 223)
* 修飾のしかたは、修飾したい関数の定義の前に ``@デコレーター関数`` と書くだけ。
* <デコレーター関数内で新たに関数を定義することが多い> (p. 224)
* デコレーターはネストできる。

* <デコレーターがよく用いられる用途としては、
  時間計測や型チェック、キャッシュ、アクセス制御、初期化・後始末の処理、トレースなどがあります>
  (p. 226) とあるので、存在意義は小さくないはずなのだが、わからない。

なんでデコレーターになじめないんだろう。

12.5 スコープ
-----------------------------------
* 関数内ではグローバル変数を無条件に右辺値参照できる。
  ただし、たまたま同名なローカル変数として解釈されるため、左辺値参照はできない。

  * そのような場合は ``global`` 文に頼ればよい。

* ``globals``, ``locals`` 関数で、グローバル変数、ローカル変数をそれぞれ表示できる。

第 13 章 クラス
===================================
今まで散々オブジェクトがどうのこうのと話があったのに、このタイミングでクラスとは。

13.1 インスタンスの係わる文法
-----------------------------------
* <全てのクラスは、この ``object`` を根底に継承します> (p. 232)
* <Python のオブジェクトとは、クラスのインスタンスだけでなく、クラスや関数自身も該当します> (p. 233)
* <特殊メソッドの名前は ``__xxx__`` のように 2 つのアンダースコアが両端に付いたものになります> (p. 234)
* ``property`` はおさえておく。

13.2 クラスに係わる文法
-----------------------------------
* クラス属性は C++ で言うところの static メンバーみたいなものらしい。
* ``@classmethod`` と ``@staticmethod`` の使い分けかたがわからない。

13.3 継承
-----------------------------------
あとで読む。

第 14 章 例外処理
===================================
14.1 処理の分岐
-----------------------------------
* Python 独特の ``else`` だが、
  ``try`` の本処理の後に行うような（本来捕捉したくない部分だということを）
  コードに示すという狙いがあるのか。

* ``finally`` よりは ``with`` の利用を好む。

14.2 例外情報を取り出す
-----------------------------------
* Python 2.6 以降では ``except ... as ...:`` が使える。(p. 252)

14.4 独自の例外
-----------------------------------
* <全ての例外クラスは、
  ``Exception`` クラスを継承して作ります> (p. 256)

第 15 章
===================================

第 16 章
===================================

第 17 章
===================================

第 18 章
===================================

第 19 章
===================================

第 20 章
===================================

第 21 章
===================================

第 22 章
===================================

第 23 章
===================================

第 24 章
===================================

第 25 章
===================================

第 26 章
===================================

第 27 章
===================================

第 28 章
===================================
