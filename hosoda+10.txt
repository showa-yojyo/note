======================================================================
Python 入門［２＆３対応］読書ノート
======================================================================

Python 関連の本を持っていないと思って、書店でテキトーに選んで買ったもの。
入門書を謳っているのに話題が豊富。物量的にも 500 ページちょいとなって CP がよい。
書いてあるコードを自分で再現するだけで、かなりのテクニックが身に付く。

:著者: 株式会社エスキュービズム／細田謙二／オレンジ岸本／石井光次郎／岩川建彦／岡田正彦
:出版社: 秀和システム
:ISBN: 978-4-7980-2655-8 C3055

.. contents:: ノート目次

ノートの方針
===================================
Windows XP の Python 2.6.6 を利用して、本書を読み解いていく。
文章を読むだけではなく、可能な限りサンプルコードを実際にタイプして実行することを基本作業とする。

インターネットに接続できない環境で作業をするため、それ系の機能は残念ながら試せない。

第 1 章 Python へようこそ
===================================
イントロダクション。

1.1 Python の特徴
-----------------------------------
* <マジックメソッドによるアスペクト指向プログラミング> (p. 16) なる用語がいきなり出てくる。
  本書は Python の入門書であり、プログラミングの入門書ではないように感じた。

* <Python では C や C++ との連携が配慮されています。
  （略）速度のボトルネックになる部分はほんの一部の特定の処理の場合が多いため、
  その部分だけ C や C++ で書いて、後は Python で書くことで生産性が高くなります> (pp. 16-17)
  これは是非挑戦してみたい。

* Disney
* Ohloh.net - 後で見ておくこと。

1.2 本書について
-----------------------------------
* <本書の目的は、Python の魅力を伝えることです> (p. 19) これは果たせていると思う。
* この人気モジュールベストテンの表は面白い。
  ベストファイブまでは納得のラインナップなのだが、それ以下が意外。
  例えばこの本を読むまで logging なんて使ったことがない。

* 2-15 章が文法編で、それ以降が実践編。
  当ノートは実践編を重視する。

第 2 章 実行環境の用意
===================================
2.1 Python のインストール
-----------------------------------
``C:\Python26`` に加え ``C:\Python26\Scripts`` も PATH 環境変数に追加したいところ。

2.2 起動と終了
-----------------------------------
* ``help`` 関数が便利。

2.3 Python 開発環境
-----------------------------------
テキストエディター対 IDE なわけだが、ここは読む価値がある。

* PyDev は試していない。Eclipse のプラグインと聞いては……。
* Komodo Edit は高機能っぽい。ちょっと使って疲れてやめた。メモリ消費量がちと多めか。
* PyScriptor はまあまあいい。

  * どういうわけかたまに ini ファイルが壊れるのが痛い。
  * プロジェクトファイルの扱いが面倒過ぎて泣ける。

最近 PyScriptor で固定にした。
テキスト編集はいつもの Xyzzy で、実行周りを PyScriptor でやる。

第 3 章 Python の基本
===================================
3.1 基本操作
-----------------------------------
* <従来の割り算はスラッシュ 2 つの ``//`` 演算子に置き換わりました> (p. 36)
* 括弧内ならば自由に改行できる。(p. 40)

3.2 複合文
-----------------------------------
* <1 つのインデントは（略）慣例的にスペース 4 つを使うことが推奨されています> (p. 41)
  エディターや IDE の設定を確認しておくこと。

* ``print`` は Python 2 系では式だが、3 系からは関数に変わる。
  <``print('a')`` という書き方に関しては、2 系、3 系で互換性があるので、
  本書では基本的にこの書き方を用いています> (p. 45)

3.3 オブジェクト
-----------------------------------
* <全てのデータは「オブジェクト」> (p. 46)
* 「変更可能」と「変更不可能」の意味がよくわからない。
  p. 47 のコード例は正直、理解不能。なんで 1 足したくらいで別物になるのだ？

第 4 章 リスト
===================================
4.4 リストの更新
-----------------------------------
* <メソッドである ``sort`` と ``reverse`` は自分自身を変更し、組み込み関数である
  ``sorted`` と ``reversed`` は新たなリストとして結果を戻します> (p. 64)

* 囲み記事の <要素の比較の度に比較関数を呼び出すよりも、
  全ての要素にキー関数を適用してから比較を行う方が、実行効率が良い> (p. 67)
  の意味がわからない。

4.6 その他のリストの操作
-----------------------------------
* ``b = a[:]`` はコピーだと思っていたが、厳密に言えば「浅いコピー」だ。
  <深いコピーは ``copy`` モジュールの ``deepcopy`` 関数を使用して行います> (p. 71)

* リスト内包表記は習得すること。

第 5 章 辞書
===================================
5.2 辞書の作成
-----------------------------------
* 辞書オブジェクトのコピーは ``copy`` メソッドを利用する。
* ``dict.fromkeys`` メソッドでキーのコレクションから辞書オブジェクトを作成できる。

5.4 辞書の更新
-----------------------------------
* ``setdefault`` メソッドは C++ の STL で言うところの
  ``std::map::operator[]`` みたいなものか。

5.5 
-----------------------------------
囲み記事 (p. 90) の ``OrderedDict`` はリストじゃだめなんですか？

5.6 その他の辞書の操作
-----------------------------------
* 辞書オブジェクトのコピーも
  <コンテナ型オブジェクトのため、コピーの際には浅いコピーと深いコピーの使い分けが必要です> (p. 91)

* <Python 3 から、リスト内包表記のように辞書でも内包表記が使える> (p. 93)

第 6 章
===================================
* コレクションオブジェクトを要素列から作成するときいは、
  列末尾にカンマを入れておく習慣をつけたほうがいいかもしれない。

第 7 章 セット
===================================
7.1 セットの概要
-----------------------------------
C++ STL の ``set`` みたいなものか。

7.2 セットの作成
-----------------------------------
集合演算を行うメソッド名が、馴染みがある名前で助かる。

7.3 セットの読み込み
-----------------------------------
``issubset`` と ``issuperset`` はどちらかがあればもう一方は要らない？

7.4 セットの更新
-----------------------------------
集合演算名と ``update`` がメソッド名になっているものがある。

7.5 セットの削除
-----------------------------------
* <指定した要素が存在しない場合、
  ``remove`` メソッドは ``KeyError`` 例外が発生しますが、
  ``discard`` メソッドは発生しません> (p. 123)

第 8 章 条件分岐とループ
===================================
8.1 条件分岐
-----------------------------------
* Python は ``elif`` を使う。
* Python には switch 文は存在しない。
* ``bool(-1)`` は私の環境では ``True`` になるのだが？
* <論理演算の戻り値は少し特殊で、演算対象のオブジェクトそのものが返されます> (p. 134)

8.2 ループ
-----------------------------------
* <複数の変数に同時に代入する方法を「アンパック代入」と言い> (p. 137)
* <特殊な構文として、
  ``for`` 文や ``while`` 文のループ処理の後に、
  ``else`` 節が記述できます。
  ``break`` 文でループが中断されなかった場合に限り、
  ``else`` ブロックが実行されます> (p. 139)

第 9 章 イテレータ
===================================
* ストリーム処理のためのポインタ的な役割
* 遅延評価

9.1 イテレータとは
-----------------------------------
* Python におけるイテレータとは、 ``next`` メソッドを実装するオブジェクトのこと。
* ``next`` メソッドと ``StopIteration`` 例外を理解しておく。
  イテレータが ``next`` し切れなくなったら、そこから例外が送出されるイメージ。

* 囲み記事。Python 3 からは一部の関数がイテレータを返すように仕様変更になっている。
  特に、イテレータの ``next`` メソッドがなくなり、単なるフリー関数になるようだ。
  ``it.next()`` ではなく ``next(it)`` ということ。

9.2 ジェネレーター
-----------------------------------
この本はなぜか語尾の -or のカタカナ表記が揺らいでいる。

* <関数に結びつく広義のイテレータ> (p. 146)
* <ジェネレーターの特徴は、イテレータを進めるまで、関数内のローカル変数を保持したまま、
  次のシーケンス要素生成までの評価が中断されることです> (p. 146)

* <ジェネレーターも内包表記で書くことができます> (p. 148)

  >>> gen = (i * 3 for i in range(10)) # (p. 148)
  >>> gen.next()
  0
  >>> gen.next()
  3
  >>> gen.next()
  6

* 囲み記事の ``send`` は読みとばす。

第 10 章 文字列
===================================
10.1 文字列の概要
-----------------------------------
* どういうわけか、手許の IDLE だと ``len(u'日本語')`` が 6 を返す。3 が正解。
* ``u'日本語'.encode('utf8')`` のタイプは ``str`` だ。

10. 2 文字列の作成
-----------------------------------
* <``r`` の文字を置くとエスケープシーケンスを無視する raw 文字列のリテラル表現になります> (p. 154)
* <``%`` 演算子を利用した旧来の方法は、今後廃止される予定です> (p. 157)
* Python 3 風 ``format`` の使い方がすぐに理解できない。後で復習。

* ``join`` メソッドには慣れておくこと。例えば CSV テキストを文字列リストから素早く構築できる。

10.3 文字列の読み込み
-----------------------------------
* 文字検索には ``find``, ``rfind`` と ``index``, ``rindex`` メソッドが使える。
  見つからなかったときに例外 ``ValueError`` を投げるのが ``index`` 系。(p. 159)

* ``isdigit``, ``isnumeric`` メソッドは
  <Unicode 型および Python 3 からは全角に対応しています> (p. 162)
  とある。全角文字の１やらローマ数字やらを試して遊んでみよう。

* <printable な文字とは、
  ``print`` 関数で何かしらの文字列が
  ``sys.stdout`` に表示される文字のこと> (p. 165)

10.4 文字列の更新
-----------------------------------
これが理解するのが難しかった。

* <変更したように見える操作もありますが、新しく文字列を作成して、そのコピーを返しているだけ> (p. 166)
  らしい。

* ``split`` メソッドは、<何も指定しないか、None を指定した場合は、分割アルゴリズムが変わります> (p. 167)
  空白文字がきれいにトリムされるようだ。

* ``splitlines`` という、改行文字に特化した ``split`` のようなメソッドがある。
* ``partition``, ``rpartition`` は ``split`` の弱いやつか。

整形系メソッドは興味がわいたら読み返す。

10.5 文字列の削除
-----------------------------------
削除に見えても、実は新しくオブジェクトを作って返す操作だ。

10.6 Unicode 文字列と文字コード変換
-----------------------------------
* <Unicode は 18 ビットで 1 文字を表現する> (p. 175) とあるが、それは真実なのか。
* Unicode 文字列のほうは、<``isdecimal`` メソッドと ``isnumeric`` メソッドの
  2 つが追加されています> (p. 176)

* sitecustomize.py で ``sys.setdefaultencoding('utf-8')`` する例が書いてある。(p. 177)

* <``unicode`` 関数と ``decode`` メソッドは、ともに、通常の文字列を
  Unicode 文字列に変換します> (p. 177)

* <``str`` 関数については、必ずデフォルトエンコーディングで変換されます> (p. 179)
  ``encode`` メソッドのほうが柔軟だということか。

* 囲み記事。文字列の他に ``bytes``, ``bytearray`` 型というのがある。
  後者はバイナリの取り扱いに有効らしいので、イメージファイルを解析するのに応用してみたい。

第 11 章 ファイル入出力
===================================
11.1 ファイルの基本操作
-----------------------------------
* ``read`` メソッドはファイルの内容を一気に文字列として読み込む。
* ``read``, ``readlines``, ``write``, ``writelines`` を使い分ける。
  lines 系は各文字列の末尾に改行文字が付く。

11.2 日本語ファイルを扱う
-----------------------------------
* 前章の文字列メソッドを駆使して、ファイルの文字列の文字コードをプログラム中で適宜変換する。
* ``codecs`` というモジュールがあり、ファイルオープン時に文字コードを指定することができる。(p. 189)

  >>> import codecs
  >>> f = codecs.open('temp.txt', 'w', 'utf8', 'ignore')
  >>> f.write(u'あいう') # ファイル内に UTF-8 で出力される。
  >>> f.close()

  読み込みも同様。

* <BOM 付きファイルを適切に読み取るには、明示的にその BOM を取り除くか、
  ``codecs`` モジュールにおいて ``utf_8_sig`` という名のエンコードを指定します> (p. 190)
  掲載のサンプルコードでは ``lstrip(codecs.BOM_UTF8)`` と
  ``codes.open('temp.txt', 'r', 'utf_8_sig', 'ignore')`` の両方の手法を紹介している。

11.3 パスの構築
-----------------------------------
ファイルパスの文字列を取り扱う方法を習得すること。

* <セパレーターは ``os.path.sep`` または ``os.sep`` に格納されています> (p. 191)
  手元の環境で調べたら、両者は同じものだ。

* <パスを分解する方法は幾つかあります> (p. 193)
  基本的には split と名の付く関数を利用する。

* ``os.path.commonprefix`` 関数は使いどころがわからない。

11.4 ファイルシステム上の操作
-----------------------------------
ファイルの移動・コピー・属性操作関連の処理を習得すること。

* それらしい機能を探すときは ``os.path``, ``shutil``, ``os``
  モジュールを当たるとよさそうだ。

* ``os.mkdirs`` (p. 197) は UNIX で言うところの ``mkdir -p`` のようなもの。
* ディレクトリ削除が色々ある。直感的には ``shutil.rmtree`` が普通の削除に相当するような。
* これ重要。
  ``shutil.copy2`` 関数は <最終アクセス時間や最終更新時間などのメタデータもコピー> (p. 199)
  する。

* ディレクトリのコピーは ``shutil.copytree`` (p. 201) を利用する。引数が多い。

* ``os.walk`` 関数ではディレクトリを <デフォルトでは最上層から下に辿っていきます。
  引数で ``topdown=False`` とすると、最下層から辿るようになります> (p. 202)

* ``os.environ`` 変数に環境変数が格納されている。(p. 205)

  >>> os.environ['PATH'].split(';')
  ['C:\\WINDOWS\\system32',
   'C:\\WINDOWS',
   'C:\\WINDOWS\\System32\\Wbem',
   'C:\\cygwin\\bin',
   'D:\\Python26\\Scripts',
   'D:\\Python26\\Lib\\site-packages\\PyQt4\\bin',
   'C:\\Program Files\\SlikSvn\\bin\\',
   'C:\\Program Files\\TortoiseSVN\\bin']

11.5 テンポラリファイルの作成
-----------------------------------
* ``tempfile.mkdtemp`` 関数で一時ディレクトリを作成する。
* ``tempfile.mkstemp`` と ``tempfile.NamedTemporaryFile`` 関数で一時ファイルを作成する。
  ファイルを削除するのを自分でやりたければ前者を利用する、という具合に使い分ける。

11.6 ファイルライクオブジェクト
-----------------------------------
* <文字列オブジェクトをファイルオブジェクトのように扱う> (p. 208) クラスが ``StringIO`` なのか。
* <``StringIO`` の内部を C で実装した ``cStringIO`` モジュール> (p. 208) は速そうだが、
  ユニコード周りで制限あり。

* 囲み記事で紹介されている Python 3 の ``io`` モジュール。
  Python 2.6.5 でも使用可能になっていた。

第 12 章 関数
===================================
12.1 関数の引数
-----------------------------------
* キーワード引数の指定は順不同。(p. 213)
* 可変長引数は面白い。

  * <シーケンス型と辞書型の 2 つの指定方法があります。（略）
    引数宣言の前に "*" を付けると、複数の引数をタプル型として受け入れます> (p. 214)

  * <引数宣言の前に "**" を付けると、キーワード付き引数を辞書型として受け入れます> (p. 215)

  * 実引数の順序は、

    #. 一般的な変数、
    #. デフォルト値のある引数、
    #. シーケンス型の可変長引数、
    #. 辞書型の可変長引数

    の順でなければならない。(p. 216)

* 引数は <変更不可能なオブジェクトの場合は、実質的に値渡しとなります> (p. 216)

* 囲み記事の <ある種グローバルな変数> (p. 218) の指摘を心に留めておく。

12.3 関数オブジェクト
-----------------------------------
* <制限のないオブジェクト> (p. 221) の意味がまったくわからない。

12.4 デコレーター
-----------------------------------
これがまったくわからない。コードを手で打ち込んで実行してみても何をされたのかわからない。

* <デコレーターは関数を受け取り、修飾した関数を返す関数です> (p. 223)
* 修飾のしかたは、修飾したい関数の定義の前に ``@デコレーター関数`` と書くだけ。
* <デコレーター関数内で新たに関数を定義することが多い> (p. 224)
* デコレーターはネストできる。

* <デコレーターがよく用いられる用途としては、
  時間計測や型チェック、キャッシュ、アクセス制御、初期化・後始末の処理、トレースなどがあります>
  (p. 226) とあるので、存在意義は小さくないはずなのだが、わからない。

なんでデコレーターになじめないんだろう。

12.5 スコープ
-----------------------------------
* 関数内ではグローバル変数を無条件に右辺値参照できる。
  ただし、たまたま同名なローカル変数として解釈されるため、左辺値参照はできない。

  * そのような場合は ``global`` 文に頼ればよい。

* ``globals``, ``locals`` 関数で、グローバル変数、ローカル変数をそれぞれ表示できる。

第 13 章 クラス
===================================
今まで散々オブジェクトがどうのこうのと話があったのに、このタイミングでクラスとは。

13.1 インスタンスの係わる文法
-----------------------------------
* <全てのクラスは、この ``object`` を根底に継承します> (p. 232)
* <Python のオブジェクトとは、クラスのインスタンスだけでなく、クラスや関数自身も該当します> (p. 233)
* <特殊メソッドの名前は ``__xxx__`` のように 2 つのアンダースコアが両端に付いたものになります> (p. 234)
* ``property`` はおさえておく。

13.2 クラスに係わる文法
-----------------------------------
* クラス属性は C++ で言うところの static メンバーみたいなものらしい。
* ``@classmethod`` と ``@staticmethod`` の使い分けかたがわからない。

13.3 継承
-----------------------------------
あとで読む。

第 14 章 例外処理
===================================
14.1 処理の分岐
-----------------------------------
* Python 独特の ``else`` だが、
  ``try`` の本処理の後に行うような（本来捕捉したくない部分だということを）
  コードに示すという狙いがあるのか。

* ``finally`` よりは ``with`` の利用を好む。

14.2 例外情報を取り出す
-----------------------------------
* Python 2.6 以降では ``except ... as ...:`` が使える。(p. 252)

14.4 独自の例外
-----------------------------------
* <全ての例外クラスは、
  ``Exception`` クラスを継承して作ります> (p. 256)

第 15 章 モジュール
===================================
15.1 単一ファイルのモジュール
-----------------------------------
* ``import`` 文で参照したいファイルは、
  <ファイルのディレクトリをカレントディレクトリとすれば> (p. 262) 可能。

15.2 複数ファイルのモジュール
-----------------------------------
* ``__init__.py`` のあるフォルダをパッケージと呼ぶ。
  パッケージは入れ子になっていることがある。

15.3 モジュールのパスを通す
-----------------------------------
* <モジュールをインポートする時に、どのフォルダ・ファイルを参照するかは、
  ``sys`` モジュールの ``sys.path`` にリストとして格納されているモジュールの検索パスに基づいて決められます>
  (p. 266)

  リスト ``sys.path`` を Python 実行中に直接変更することができる。

15.4 スクリプト化
-----------------------------------
.. code-block:: python

   if __name__ == '__main__':
       # スクリプトとして実行された場合、ここに来る。

15.5 ライブラリの利用
-----------------------------------
* PyPI (http://pypi.python.org/pypi) では、いろんな人が作ったライブラリーを配布している。
  ライブラリーを指定して easy_install を実行してインストールする。

  * easy_install を入手するには、ez_setup.py を入手する必要がある。
    入手して Python で実行すると、easy_install 自体がインストールされる。

    インターネットに接続できない環境では、
    setuptools のインストーラー (exe) を先に入手しておく必要があるのか。

* bitbucket は知らなかった。後で調べよう。

第 16 章 日時の操作
===================================
16.1 datetime クラス
-----------------------------------
* ``now`` メソッドはクラスメソッド。
* ``weekday`` メソッドの戻り値は、0 が月曜日なので注意。

* ``timedelta`` クラスで加算や減算を行う例がある (p. 276) が、
  ありがたいことに乗算もできる。

  >>> print(datetime.timedelta(seconds=38) * 20)  # 38 秒の 20 倍はいくらだ？
  0:12:40

* ``strftime`` メソッドで、日時を書式化した文字列を得られる。
  書式の仕様を見ると ANSI C のそれの簡略版みたい。

16.2 date クラス
-----------------------------------
* <``datetime`` クラスは ``date`` クラスのサブクラス> (p. 280)
* <現在日付の取得には ``now`` 関数ではなく ``today`` 関数を使います> (p. 281)
* ``datetime`` オブジェクトと ``date`` オブジェクトの比較・変換が面倒みたい。

16.3 dateutils モジュール
-----------------------------------
* ``easy_install dateutils`` でインストールできるモジュール。
* 名前については、コードでは ``import dateutil`` のように末尾に s がつかないのが正。
* ``dateutil.relativedelta`` クラスを使った加算処理、月始・月末の取得。
* ``dateutil.parser.parse`` 関数による「特定規格の日付文字列」の解析。

第 17 章 正規表現
===================================
ページ数をもっと割いて解説してもよかったのでは。

17.1 re モジュールの基本
-----------------------------------
* ``match`` と ``search`` の違いが文書化されているようなので、後で見ておく。
* <Unicode 表と厳密に対応させたい場合は ``\uXXXX`` の表記を用いる> (p. 292)

  >>> import re
  >>> re.compile(u'[\u3041-\u3093]')   # 同ページより。ひらがな全て。

* 部分一致の説明にある例コードのおかげで ``groupdict`` メソッドの意義がわかった。

* <``escape`` メソッドは、全てのメタ文字をエスケープした文字列を返します> (p. 295)
* 先読み、後読みの概念がわからないので、勉強する。

17.2 便利なテクニック
-----------------------------------
* Wikipedia の Unicode 表が便利らしい。
* ``re.U`` による全角文字マッチオプション有効化が便利らしい。

第 18 章 データのやり取り
===================================
18.3 XML データの利用
-----------------------------------
* ``lxml`` モジュールを紹介している。
  ネットに接続している環境では ``easy_install lxml`` で楽にインストールできる。

  * XML を探索・編集することができる。
  * うれしいことに XPath が使える。

    >>> # p. 310 より
    >>> from lxml import etree
    >>> xml = '<root><node key="value"><node>leaf</node></node></root>'
    >>> root = etree.fromstring(xml)
    >>> nodes = root.xpath('//node/node')
    >>> for node in nodes: print(etree.tostring(node))
    ... 
    <node>leaf</node>

18.4 CSV データの読み書き
-----------------------------------
これは実践しようと思っていて、まだ現場で試せていないモジュールだ。

* <Python の CSV の操作には、 ``csv`` モジュールを使用します> (p. 312)
* ``csv.reader`` にファイルハンドラを渡して for ループで回す。
  <``dialect`` 引数のデフォルト値は ``csv.excel`` となっています> (p. 313)
* CSV ファイルへの書き込みには ``csv.writer`` 関数を利用する。

18.5 データベースの利用
-----------------------------------
Python が標準で提供している ``sqlite3`` モジュールと、
MySQL と接続するための ``MySQLdb`` モジュールの説明。

MySQL 5.1 をインストールしてあると、MySQLdb の配布版がまだ対応していなかったのか、通らなかった。
それでソースコードを入手して、若干コンフィグファイル的なものを修正してから
setup を試みたが、vcvarsall.bat が見つかりませんとかいうエラーで詰んだ。
VC がインストールされていない環境では駄目か。

第 19 章 ウェブの基本ツール
===================================
HTTP, SMTP, CGI ネタだが、当環境がネットから孤立しているためコードを試せず習得を断念。

第 20 章 メディアファイルの作成
===================================
20.1 画像の作成
-----------------------------------
PIL を紹介している。ImageMagick みたいなことをしてくれるライブラリー。
個人的には PyOpenGL でテクスチャーイメージをメモリに読み込むときに利用する。

* easy_install でのインストールと、ソースからのインストールとではモジュール配置が異なる。 (p. 340)
* <PIL の ``save`` メソッドは、末尾の拡張子から、自動的にフォーマットを判定して変換します> (p. 341)
* <画像フォーマットを GIF から JPEG に変換する場合には、カラーモードを RGB に変更しておく必要があります>
  (p. 342) GIF のカラーモードがパレットモードというものであることによる。

* 画像のリサイズで、比率を維持する場合は ``thumbnail`` メソッドを使用する。(p. 344)

20.2 PDF の作成
-----------------------------------
ReportLab を紹介している。

* ネットに接続して ``easy_install reportlab`` でインストールできる。
* 基本的に Python のコード一丁で PDF を生成する。面倒くさい。

  .. code-block:: python

     from reportlab import canvas

     canvas = canvas.Canvas('helloworld.pdf')
     ... canvas に色々施す。
     canvas.save()

* <組み込みの日本語フォント> (p. 355)
* テンプレート機能もあるようだ。でも面倒くさい。
* PIL がインストール済みならば、画像も配置できる。

第 21 章 ウェブフレームワーク
===================================
この手のフレームワークは個人的になじみのない分野なので、勉強になる。

21.1 - 21.5 Django
-----------------------------------
* <Python で代表的に利用されているウェブフレームワーク> (p. 362)
* ネットに接続していれば ``easy_install django`` でインストールできる。
  本書ではバージョン 1.1.1 を解説しているが、1.2.3 をインストールした。

* ``django-admin.py`` でプロジェクト作成、
  生成された ``manage.py`` でアプリを作成したり、開発サーバーを起動したりする。

* ``settings.py``, ``urls.py``, ``views.py``
* HTML テンプレート
* 管理画面
* モデルフィールド

21.6 - 21.13 Web2py
-----------------------------------
こちらはまだノートを取れるほど動かしていないが、

* 単なるパッケージではなさそうだ。
* Python 2.6 用がない？
* Google App Engine なるものが気になる。
  <Google 社が管理するデータセンターの上で、ウェブサービスを展開できるプラットフォーム> (p. 410)
  だそうだ。

第 22 章 
===================================

第 23 章
===================================

第 24 章
===================================

第 25 章
===================================

第 26 章
===================================

第 27 章
===================================

第 28 章
===================================
