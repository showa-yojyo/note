
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 2/3 &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 3/3" href="note3.html" />
    <link rel="prev" title="オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 1/3" href="note1.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note1.html" title="Previous document">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 1/3</a>
        </li>
        <li>
          <a href="note3.html" title="Next document">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 3/3</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="id1">
<h1><a class="toc-backref" href="#id7" role="doc-backlink">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 2/3</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">著者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Eric Gamma, Richard Helm, Ralph Johnson, John Vlissides</p>
</dd>
<dt class="field-even">監訳者<span class="colon">:</span></dt>
<dd class="field-even"><p>本位田真一、吉田和樹</p>
</dd>
<dt class="field-odd">出版社<span class="colon">:</span></dt>
<dd class="field-odd"><p>ソフトバンク クリエイティブ株式会社</p>
</dd>
<dt class="field-even">発行年<span class="colon">:</span></dt>
<dd class="field-even"><p>1999 年</p>
</dd>
<dt class="field-odd">ISBN<span class="colon">:</span></dt>
<dd class="field-odd"><p>978-4-7973-1112-9</p>
</dd>
</dl>
<nav class="contents" id="id2">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id7">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 2/3</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id8">第 3 章 生成に関するパターン</a></p>
<ul>
<li><p><a class="reference internal" href="#abstract-factory" id="id9">Abstract Factory</a></p></li>
<li><p><a class="reference internal" href="#builder" id="id10">Builder</a></p></li>
<li><p><a class="reference internal" href="#factory-method" id="id11">Factory Method</a></p></li>
<li><p><a class="reference internal" href="#prototype" id="id12">Prototype</a></p></li>
<li><p><a class="reference internal" href="#singleton" id="id13">Singleton</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id14">まとめ</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id5" id="id15">第 4 章 構造に関するパターン</a></p>
<ul>
<li><p><a class="reference internal" href="#adapter" id="id16">Adapter</a></p></li>
<li><p><a class="reference internal" href="#bridge" id="id17">Bridge</a></p></li>
<li><p><a class="reference internal" href="#composite" id="id18">Composite</a></p></li>
<li><p><a class="reference internal" href="#decorator" id="id19">Decorator</a></p></li>
<li><p><a class="reference internal" href="#facade" id="id20">Facade</a></p></li>
<li><p><a class="reference internal" href="#flyweight" id="id21">Flyweight</a></p></li>
<li><p><a class="reference internal" href="#proxy" id="id22">Proxy</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id23">まとめ</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="id3">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">第 3 章 生成に関するパターン</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>&lt;クラス継承よりもオブジェクトコンポジションに頼る形でシステムを発展させていく場合に、生成に関するパターンは重要になる&gt; (p. 89)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MazeGame::CreateMaze</span></code> についての考察が数ページ続くが、高密度な記述ゆえに上手い形にノートにまとめられない。</p>
<ul>
<li><p>2 つの部屋からなる簡単な迷路を作っているだけなのに、コードが複雑 (p. 92)</p></li>
<li><p>迷路構成を変更しようとすると、メンバ関数のオーバーライド（実質再定義）か、それと同等の仕事が必要となる (p. 92)</p></li>
</ul>
</li>
<li><p>&lt;より柔軟な設計（必ずしも、コードを短くするわけではない）&gt; (p. 93) このカッコ内がポイント。</p></li>
<li><p>&lt;インスタンス化されるクラスがコード中に直接書かれていることが最大の問題&gt;
(p. 93)</p></li>
</ul>
<section id="abstract-factory">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Abstract Factory</a><a class="headerlink" href="#abstract-factory" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>Motif とか Presentation Manager とかって何？</p></li>
<li><p>&lt;各種の基本ウィジェットを生成するためのインタフェースを宣言した抽象クラス
<code class="docutils literal notranslate"><span class="pre">WidgetFactory</span></code> を定義する&gt; (p. 95)</p></li>
<li><p>各種のウィジェットに対する抽象クラスを作成したら、 &lt;その具象クラスで特定の
look-and-feel 規格のもとでの実装を与える&gt; (p. 95)</p></li>
<li><p>&lt;たとえば Motif ではスクロールバーはボタンやテキストエディタとともに使わなければならないといった制約が、<code class="docutils literal notranslate"><span class="pre">MotifWidgetFactory</span></code> クラスを利用する結果として自動的に規定されることになる&gt; (p. 96)</p></li>
<li><p>このパターンでは Client は <code class="docutils literal notranslate"><span class="pre">AbstractFactory</span></code> と <code class="docutils literal notranslate"><span class="pre">AbstractProduct</span></code> で宣言されたインタフェースのみを利用する (p. 97)</p></li>
<li><p>&lt;普通、<code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> クラスのインスタンスは実行時に生成される&gt; (p. 97)
とあるが、実行時に生成されないインスタンスなど考えられる？</p></li>
<li><p>新たな種類の部品への対応は <code class="docutils literal notranslate"><span class="pre">AbstractFactory</span></code> とそのすべてのサブクラスについて、インタフェースの修正が必要となる。これが面倒。</p></li>
<li><p>部品を実際に生成するのは <code class="docutils literal notranslate"><span class="pre">ConcreteProduct</span></code> クラスになるが、各部品について
factory method を定義する方法がよく用いられる (p. 98)</p></li>
<li><p>Prototype パターンを使って <code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> クラスを実装する方法がある。部品の集合が多数存在する場合にそうすることができる (p. 98)</p></li>
<li><p>&lt;クラスをオブジェクトとして扱うことのできる言語では、prototype を用いたアプローチに変化をつけることが可能になる&gt; (p. 99)</p></li>
<li><p>生成する部品の種類を表すパラメータを取る AbstractFactory の手法は、&lt;C++ を使うときには、すべてのオブジェクトが同じ抽象基底クラスを持つ場合か、要求を出すクライアントにより部品オブジェクトが正しい型に変換できる場合にのみ、適用することができる&gt; (p. 100)</p>
<p>この条件はそんなにきつくない。&lt;サブクラスに特有のオペレーション&gt; (p. 100) をする必要がない場合は、この手法の採用の検討に値する。</p>
</li>
</ul>
<p>サンプルコードで <code class="docutils literal notranslate"><span class="pre">MazeGame::CreateMaze</span></code> を Abstract Factory パターンで実装している。</p>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">MazeFactory</span></code> クラスは、単に factory method を集めたものになっているが、これは Abstract Factory パターンを実装するときにもっとも一般的な方法である&gt;
(p. 102)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AbstractFactory</span></code> が <code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> を兼ねるのも一般的な実装方法 (p.
102)</p></li>
</ul>
</section>
<section id="builder">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Builder</a><a class="headerlink" href="#builder" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>同じ作成過程で異なる表現形式の複合オブジェクトを生成できる (p. 105)</p></li>
<li><p>&lt;変換すべきフォーマットのすべてを事前に確定できるとは限らないので、読み取り部を修正することなく、新たに与えられたフォーマットへの変換が容易に行えるようにしておくことが望ましい&gt; (p. 105)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">RTFReader</span></code> オブジェクトが RTF の文書の構文解析を行い、その結果を
<code class="docutils literal notranslate"><span class="pre">TextConverter</span></code> オブジェクトを使って変換する&gt; (p. 105)</p>
<p>「何に」変換するかはまだ言及していないことに注意。</p>
</li>
<li><p>この各変換クラスを <em class="dfn">builder</em> と呼び、読み取り部のクラスを <em class="dfn">director</em>
と呼ぶ (p. 106)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">RTFReader</span></code> クラスの構文解析アルゴリズムは再利用することができる&gt; (p. 106)</p></li>
<li><p>オブジェクトの作成プロセスが、多様な表現を認めるようにしておける (p. 106)</p></li>
<li><p>当パターンのクラス構造を見ると、<code class="docutils literal notranslate"><span class="pre">Director</span></code> が <code class="docutils literal notranslate"><span class="pre">Builder</span></code> を持っている。面白いのは <code class="docutils literal notranslate"><span class="pre">Director</span></code> が <code class="docutils literal notranslate"><span class="pre">Builder::BuildPart</span></code> メソッドしか利用していないこと。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ConcreteBuilder</span></code> は &lt;<code class="docutils literal notranslate"><span class="pre">Product</span></code> オブジェクトを取り出すためのインターフェイスを提供する&gt; (p. 107)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Product</span></code> クラスは &lt;多くの構成要素からなる複合オブジェクト&gt; (p. 107) である。</p></li>
</ul>
</li>
</ul>
<p>このパターンはトレード・オフがないのか。</p>
<ul>
<li><p>&lt;別の <code class="docutils literal notranslate"><span class="pre">Director</span></code> オブジェクトが同じ構成要素からなる <code class="docutils literal notranslate"><span class="pre">Product</span></code> オブジェクトを作成する場合に、それを再利用することができるようになる&gt; (p. 108)</p>
<p>各 <code class="docutils literal notranslate"><span class="pre">ConcreteBuilder</span></code> がそのまま（変更せずに）再利用できると強調している。</p>
</li>
<li><p>&lt;生成要求の結果を、それまでに得られている <code class="docutils literal notranslate"><span class="pre">Product</span></code> オブジェクトに単純に追加していくだけのモデルで十分な場合が多い&gt; (p. 109)</p></li>
<li><p>&lt;異なる <code class="docutils literal notranslate"><span class="pre">Product</span></code> オブジェクトに共通の親クラスを作るメリットは少ない&gt; (p.
109)</p>
<p>なるほど。</p>
</li>
</ul>
<p>サンプルコードでは <code class="docutils literal notranslate"><span class="pre">MazeGame</span></code> の例を Builder パターンを導入して書き直している。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MazeBuilder</span></code> クラスにメソッド群 <code class="docutils literal notranslate"><span class="pre">BuildXXXX</span></code> を定義するメリットは、各
<code class="docutils literal notranslate"><span class="pre">Product</span></code> (<code class="docutils literal notranslate"><span class="pre">Room</span></code>, <code class="docutils literal notranslate"><span class="pre">Door</span></code>) の生成ロジックを隠蔽することにある。 &lt;異なる種類の迷路を作成する場合に <code class="docutils literal notranslate"><span class="pre">MazeBuilder</span></code> クラスを再利用できることを意味している&gt; (p. 110)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">MazeBuilder</span></code> クラスは迷路そのものを作るのではなく、迷路作成のためのインターフェイスを定義しているにすぎない&gt; (p. 110)</p></li>
<li><p>&lt;しかし、<code class="docutils literal notranslate"><span class="pre">Maze</span></code> クラスを小さくしておくことで理解や修正が容易になるという利点があり、また、<code class="docutils literal notranslate"><span class="pre">StandardMazeBuilder</span></code> クラスは <code class="docutils literal notranslate"><span class="pre">Maze</span></code> クラスから容易に分離することもできる。もっと重要なことは、この 2 つを分離しておくことにより、部屋、壁、ドアに対して、異なるクラスを使ってさまざまな <code class="docutils literal notranslate"><span class="pre">MazeBuilder</span></code> クラスを作れるようになるという点である&gt; (p. 112)</p></li>
<li><p>Abstract Factory パターンは &lt;複合オブジェクトを作成するという点で Builder パターンに類似している&gt; (p. 114)</p></li>
</ul>
</section>
<section id="factory-method">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Factory Method</a><a class="headerlink" href="#factory-method" title="Permalink to this heading">¶</a></h3>
<p>フレームワーク寄りのデザインパターンらしい。</p>
<ul>
<li><p>フレームワークにしばしば見られる特徴 (p. 115):</p>
<ul class="simple">
<li><p>オブジェクト間の関係を表現するのに、抽象クラスを用いる。</p></li>
<li><p>（具象型のわからない）オブジェクトの生成を行う責任がある。</p></li>
</ul>
</li>
<li><p>フレームワークの立場としては、&lt;<code class="docutils literal notranslate"><span class="pre">Application</span></code> クラスは <code class="docutils literal notranslate"><span class="pre">Document</span></code> のどのサブクラスがインスタンス化されるのかを事前に知ることはできない&gt; (p. 115) ので、
<code class="docutils literal notranslate"><span class="pre">Application``クラスに</span> <span class="pre">``Document</span></code> を生成するオーバーライド可能なメソッド
<code class="docutils literal notranslate"><span class="pre">CreateDocument</span></code> を用意し、ユーザーにサブクラス型を返すような実装をさせる。</p>
<p>この <code class="docutils literal notranslate"><span class="pre">CreateDocument</span></code> みたいなものを一般に factory method と呼ぶ。</p>
</li>
<li><p>&lt;クラス内部でオブジェクトを生成する場合、直接生成するよりも factory method を使うほうが柔軟性を高める&gt; (p. 117)</p></li>
<li><p>図形操作ツールの話 (pp. 118-119) が面白かったので、後でもう一回読んでみる。
<code class="docutils literal notranslate"><span class="pre">Figure</span></code> インタフェースに <code class="docutils literal notranslate"><span class="pre">CreateManipulator</span></code> (factory method) を与えておき、各 <code class="docutils literal notranslate"><span class="pre">Figure</span></code> のサブクラスがそれに応じた <code class="docutils literal notranslate"><span class="pre">Manipulator</span></code> のサブクラスを生成する、というトリック。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Creator</span></code> クラスを抽象クラスにして、factory method を空にする場合と、
<code class="docutils literal notranslate"><span class="pre">Creator</span></code> クラスを具象クラスにして、factory method にデフォルト実装を与える場合がある(p. 118)</p></li>
<li><p>Factory Method パターンの変形として、&lt;factory method が数種類の
<code class="docutils literal notranslate"><span class="pre">ConcreteProduct</span></code> オブジェクトを生成できるようにしておく&gt; (p. 119) ものがある。種類を表すパラメータを取るようなメソッドにするらしい。</p>
<ul class="simple">
<li><p>この手法はシリアライズ実装で使うというようなことが書かれている。</p></li>
</ul>
</li>
<li><p>言語によっては &lt;インスタンス化されるクラスを返すメソッド&gt; (p. 120) を使う。オブジェクトではなく、クラス自体を返すということ。</p></li>
<li><p>C++ では <code class="docutils literal notranslate"><span class="pre">Creator</span></code> クラスのコンストラクタ内で factory method を呼び出せない
(p. 121)</p>
<p>そんなことをしたら実行時エラーが起こって即終了。</p>
</li>
<li><p>C++ ではさらに &lt;テンプレートを用いてサブクラス化を避ける&gt; (p. 121) 技法も駆使したい。</p></li>
<li><p>factory method には、見てそれとわかる名前を付けると便利 (p. 122)</p></li>
</ul>
<p>サンプルコードでは <code class="docutils literal notranslate"><span class="pre">MazeGame::CreateMaze</span></code> を factory method で実装している。</p>
<ul class="simple">
<li><p>&lt;factory method は、ツールキットやフレームワークの中で広く採用されている&gt;
(p. 124)</p></li>
<li><p>Abstract Factory パターンは factory method を使って実装されることが多い
(p. 125)</p></li>
</ul>
</section>
<section id="prototype">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Prototype</a><a class="headerlink" href="#prototype" title="Permalink to this heading">¶</a></h3>
<p>既存インスタンスをコピーすることで新たなオブジェクトの生成を行うパターン。</p>
<ul>
<li><p>「動機」に書いてあること</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Graphics</span></code>: 音符、休止符、譜表、等々の図形オブジェクトを表現するための抽象クラス</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tool</span></code>: ツールパレット上のツールを定義するための抽象クラス</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GraphicTool</span></code>: <code class="docutils literal notranslate"><span class="pre">Graphics</span></code> をドキュメントに追加するための <code class="docutils literal notranslate"><span class="pre">Tool</span></code> のサブクラス</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">GraphicTool</span></code> クラスは、音符などのクラスのインスタンスを楽譜に加えるためにどのように生成したらよいのかを知らない&gt; (p. 127)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Graphic</span></code> のサブクラスのインスタンスをクローン化して、新たなオブジェクトを生成する方法&gt; (p. 127) によって得られるインスタンスのことを
<em class="dfn">prototype</em> と呼ぶ。</p></li>
</ul>
</li>
<li><p>&lt;Prototype パターンは、<code class="docutils literal notranslate"><span class="pre">Client</span></code> オブジェクトに対してインスタンス化する具象クラスを隠蔽している&gt; (p. 129)</p></li>
<li><p>&lt;たとえば回路設計エディタでは、回路をいくつかの部分回路から作成するようになっている&gt; (p. 130)</p>
<p>つまり、部分回路が繰り返し使われる状況である可能性が高く、そうなれば当パターンの守備範囲だ。</p>
</li>
<li><p>&lt;C++ のようにクラスが first-class オブジェクトとして扱われない言語&gt; (p. 130)
にとっては、<code class="docutils literal notranslate"><span class="pre">Creator</span></code> のクラス階層を作らずに済む当パターンにメリットがある。</p></li>
<li><p>&lt;prototype マネージャ&gt; (p. 130)</p></li>
<li><p>&lt;その内部に複製をサポートしていないオブジェクトや循環する参照を持つオブジェクトを含む場合&gt; (p. 131) 等、 prototype 各サブクラスで <code class="docutils literal notranslate"><span class="pre">Clone</span></code> を実装するのが困難な場合もある。</p></li>
</ul>
<p>実装ポイント</p>
<ul>
<li><p>Prototype パターンは C++ のような静的な言語において有効なパターンである
(p. 131)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Client</span></code> オブジェクトは prototype を直接扱うのではなく、登録されている
prototype オブジェクトを検索したり、新たに登録したりする&gt; (p. 131)</p>
<p>prototype マネージャは連想配列ベースのデータ構造。</p>
</li>
<li><p>&lt;もっとも困難な点は、<code class="docutils literal notranslate"><span class="pre">Clone</span></code> オペレーションを正しく実装することである&gt;
(p. 131)</p>
<ul class="simple">
<li><p>&lt;複製を行うということを、元のインスタンス変数を共有させることにするのか、またはインスタンス変数の複製を行うことにするのか&gt; (p. 131)</p></li>
<li><p>お手軽な <code class="docutils literal notranslate"><span class="pre">Clone</span></code> の実装例として、もしオブジェクトが <code class="docutils literal notranslate"><span class="pre">Save</span></code>/<code class="docutils literal notranslate"><span class="pre">Load</span></code> オペレーションを提供しているのであれば、これで実装できると言っている (p. 132)</p></li>
</ul>
</li>
</ul>
<p>サンプルコードのページでは <code class="docutils literal notranslate"><span class="pre">MazeFactory</span></code> の Prototype パターン版を紹介。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MazePrototypeFactory</span></code> では &lt;生成オブジェクトをあらかじめ prototype として持つように初期化&gt; (p. 132) する。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">MazePrototypeFactory::MakeXXXX</span></code> では <code class="docutils literal notranslate"><span class="pre">XXXX</span></code> 型メンバーデータの
prototype に対して <code class="docutils literal notranslate"><span class="pre">Clone</span></code> を呼び出し、戻り値をそのまま返す。</p>
<ul>
<li><p>場合によっては <code class="docutils literal notranslate"><span class="pre">Clone</span></code> のパラメータを修正する。</p></li>
</ul>
</li>
<li><p>&lt;他の迷路を作成する場合には、<code class="docutils literal notranslate"><span class="pre">MazePrototypeFactory</span></code> オブジェクトを別の
prototype で初期化すればよい&gt; (p. 133)</p></li>
</ul>
</li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Client</span></code> オブジェクトの側では、<code class="docutils literal notranslate"><span class="pre">Clone</span></code> オペレーションの返却値を望む型にダウンキャストしなくてもよいようにしておくべきである&gt; (p. 135)</p></li>
</ul>
</section>
<section id="singleton">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Singleton</a><a class="headerlink" href="#singleton" title="Permalink to this heading">¶</a></h3>
<p>ここは読まなくていいや。</p>
</section>
<section id="id4">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">まとめ</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>オブジェクトを生成するクラスをサブクラス化する方法</p>
<ul>
<li><p>Factory Method パターンを使うことに対応。</p></li>
</ul>
</li>
<li><p>生成するオブジェクトのクラスを把握しているオブジェクトを定義してから、それをパラメータにする方法</p>
<ul>
<li><p>Abstract Factory, Builder, Prototype パターンの基本。設計は柔軟だが、より複雑 (p. 146)</p></li>
</ul>
</li>
<li><p>図形エディタフレームワークを設計するのならば、Factory Method パターンがもっとも使いやすいパターン (p. 145) だが、<code class="docutils literal notranslate"><span class="pre">GraphicTool</span></code> のサブクラスが多く必要になる。</p></li>
<li><p>&lt;全般的に見て、Prototype パターンが図形エディタフレームワークにとって、おそらく最適なパターンになるだろう&gt; (p. 146) <code class="docutils literal notranslate"><span class="pre">Graphic::Clone</span></code> のオーバーライドだけでよいから。</p></li>
<li><p>&lt;Factory Method パターンを使うことで、設計はカスタマイズが容易になると同時に若干複雑になる&gt; (p. 146)</p></li>
<li><p>設計の初期段階では Factory Method パターンを採用しておき、様子を見て他のパターンに発展させていくやり方がよい (p. 146)</p></li>
</ul>
<p>どの方法も複雑であると言っている？</p>
</section>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">第 4 章 構造に関するパターン</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>&lt;クラスやオブジェクトを合成する方法に関係している&gt; (p. 147) なるほど。構造イコール合成なのか。</p></li>
<li><p>構造に関するパターンも、「オブジェクトに適用するもの」と「クラスに適用するもの」がある。前者が動的で後者が静的な性質のものだということなのだろう。</p></li>
</ul>
<section id="adapter">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Adapter</a><a class="headerlink" href="#adapter" title="Permalink to this heading">¶</a></h3>
<p>このセクションは他のパターンのそれに比べて妙に長く感じた。</p>
<ul class="simple">
<li><p>&lt;再利用を目的として設計されたツールキットクラスは、そのインタフェースがアプリケーションの要求するドメインに特化したインタフェースと一致しないというだけの理由で、再利用できないことがある&gt; (p. 149) もったいない話だ。</p></li>
</ul>
<p>既存のツールキットクラス <code class="docutils literal notranslate"><span class="pre">TextView</span></code> をうまく再利用して、<code class="docutils literal notranslate"><span class="pre">LineShape</span></code> や
<code class="docutils literal notranslate"><span class="pre">PolygonShape</span></code> のテキスト版と言える <code class="docutils literal notranslate"><span class="pre">TextShape</span></code> というクラスを定義できないかを議論している。</p>
<ul>
<li><p>&lt;それに対して、テキストの表示と編集を行う <code class="docutils literal notranslate"><span class="pre">TextShape</span></code> クラスは、基本的なテキスト編集の歳にも、複雑な画面の更新やバッファの管理などをしなければならないため、実装はより困難であると考えられる&gt; (p. 149)</p></li>
<li><p>&lt;しかし <code class="docutils literal notranslate"><span class="pre">TextView</span></code> クラスを変更するのは勧められない。なぜならば、このツールキットが、ある 1 つのアプリケーションを動作させるためだけに、ドメインに特化したインタフェースを採用したとすると、このツールキット自体が汎用性を欠くものになってしまうからである&gt; (p. 149)</p></li>
<li><p>ここでやりたいことは <code class="docutils literal notranslate"><span class="pre">TextView</span></code> を <code class="docutils literal notranslate"><span class="pre">Shape</span></code> に適合させること。</p>
<ul class="simple">
<li><p>方法 1: <code class="docutils literal notranslate"><span class="pre">Shape</span></code> のインタフェースと <code class="docutils literal notranslate"><span class="pre">TextView</span></code> の実装を継承したクラスを定義する。</p></li>
<li><p>方法 2: <code class="docutils literal notranslate"><span class="pre">TextView</span></code> を持ったクラスを定義し、それは <code class="docutils literal notranslate"><span class="pre">Shape</span></code> インタフェースを有する。</p></li>
</ul>
<p>→クラスに適用する <code class="docutils literal notranslate"><span class="pre">Adapter</span></code> と、オブジェクトに適用するパターン (p. 152) があるということ。</p>
</li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Shape</span></code> のどのオブジェクトも、ユーザがインタラクティブにドラッグして別の場所に移すことができるようになっているべきである。ところが、<code class="docutils literal notranslate"><span class="pre">TextView</span></code> クラスは、それができるように設計されていない&gt; (p. 150)</p></li>
</ul>
<p>考慮すべき問題点を挙げている。</p>
<ul class="simple">
<li><p>何らかのインタフェースに一致させる作業が必要になるが、&lt;作業の範囲は、オペレーションの名前を変えるだけの簡単なインタフェースの変更から、まったく異なるオペレーションの集合をサポートすることまでが考えられる&gt; (p. 152)</p></li>
<li><p>&lt;インタフェースの適合機能が作りこまれているクラスを <em class="dfn">pluggable adapter</em>
と呼んでいる&gt; (p. 153) の例として、<code class="docutils literal notranslate"><span class="pre">TreeDisplay</span></code> を紹介している。</p>
<ul>
<li><p>異なる木構造は異なるインタフェースを持つことになるだろう。</p></li>
<li><p>言い換えると、<code class="docutils literal notranslate"><span class="pre">TreeDisplay</span></code> ウィジェットはインタフェース適合機能を内部に組み込むべきなのである。</p></li>
</ul>
</li>
</ul>
<p>実装にも問題点が色々。</p>
<ul class="simple">
<li><p>C++ の場合、クラスに適合するタイプの <code class="docutils literal notranslate"><span class="pre">Adapter</span></code> では、<code class="docutils literal notranslate"><span class="pre">Adaptee</span></code> 側クラスを
<code class="docutils literal notranslate"><span class="pre">private</span></code> 継承する。ということは、<code class="docutils literal notranslate"><span class="pre">Adapter</span></code> クラスは <code class="docutils literal notranslate"><span class="pre">Adaptee</span></code> クラスのサブクラスではなくなる (p. 154)</p></li>
<li><p>適合させなければならない最小限のオペレーションの集合を意識すること (p. 154)</p></li>
</ul>
<p>サンプルコード。&lt;オブジェクトを基にした adapter の方が、コードの作成では若干の労力が必要になるが、より柔軟なものになっている&gt; (p. 159) ポイントは、<code class="docutils literal notranslate"><span class="pre">TextView</span></code>
のサブクラスでも OK だというところ。</p>
<p>関連パターン。&lt;アプリケーションにとっては、adapter よりも decorator の方が透過性が高い&gt; (p. 161)</p>
</section>
<section id="bridge">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Bridge</a><a class="headerlink" href="#bridge" title="Permalink to this heading">¶</a></h3>
<p>最初に書いてある &lt;抽出したクラスと実装を分離&gt; の意味がわからない。</p>
<p>別名が Handle/Body とある。</p>
<p>動機ではクロスプラットフォームなウィンドウクラスライブラリの話を例に出している。</p>
<ul class="simple">
<li><p>&lt;さらに悪いことには、すべての種類のウィンドウに対して、2 つずつ新たなクラスを定義していかなければならなくなるだろう&gt; (p. 163)</p></li>
<li><p>&lt;この <code class="docutils literal notranslate"><span class="pre">Window</span></code> クラスと <code class="docutils literal notranslate"><span class="pre">WindowImp</span></code> クラスの間の関係を <em class="dfn">bridge</em> と呼ぶ&gt; (p. 164)</p></li>
</ul>
<p>適用可能性を見ると、クロスプラットフォーム以外にも使い途がある。特に C++ で威力を発揮するケースがあるようだ。</p>
<ul>
<li><p>&lt;クライアントのコードを再コンパイルしなくても済む&gt; (p. 165)</p></li>
<li><p>&lt;クラスの実装をクライアントから完全に隠蔽したい場合。C++ では、クラスの内部表現はクラスのインタフェイスで見ることができてしまう&gt; (p. 165)</p>
<p>Exceptional C++ とかで議論していた Pimpl パターンの話を思い出す。</p>
</li>
</ul>
<p>クラス構造を見ると一発で理解できる。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Implementor</span></code> クラスが一種類しかない場合でも、クラスの実装上の変化がクライアントに影響を与えることがあってはならない場合には、<code class="docutils literal notranslate"><span class="pre">Abstraction</span></code>/<code class="docutils literal notranslate"><span class="pre">Implementor</span></code>
分離は有効 (p. 167)</p></li>
<li><p>C++ の場合、<code class="docutils literal notranslate"><span class="pre">Implementor</span></code> の宣言を &lt;私的なヘッダファイル&gt; (p. 167) で行う。要するにクライアントが include できないファイルで宣言する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Implementor</span></code> の決定を他のオブジェクトに完全に委譲するという方法もある (p. 167)</p>
<p>例えば <code class="docutils literal notranslate"><span class="pre">Implementor</span></code> の決定を専用の factory が行うことにすると、
<code class="docutils literal notranslate"><span class="pre">Abstraction</span></code> クラスと <code class="docutils literal notranslate"><span class="pre">Implementor</span></code> クラスの結合も間接的になる。</p>
</li>
</ul>
<p>サンプルコードを検討すると、次のことに気付く。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Window</span></code> のサブクラスのメソッドの実装は、すべて <code class="docutils literal notranslate"><span class="pre">WindowImp</span></code> のメソッドで実装している。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 170</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Window::DrawRect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p2</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">WindowImp</span><span class="o">*</span><span class="w"> </span><span class="n">imp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetWindowImp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">DeviceRect</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">X</span><span class="p">(),</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">Y</span><span class="p">(),</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">X</span><span class="p">(),</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">Y</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">WindowImp</span></code> のサブクラスでのメソッド実装は、そのプラットフォームの API で実装している。例えば <code class="docutils literal notranslate"><span class="pre">XWindowImp::DeviceRect</span></code> は関数 <code class="docutils literal notranslate"><span class="pre">XDrawRectanele</span></code> で矩形を描画する、といった具合だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Window::GetWindowImp</span></code> は Abstract Factory パターンでインスタンスを取得している。</p></li>
</ul>
</section>
<section id="composite">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Composite</a><a class="headerlink" href="#composite" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;オブジェクトを木構造に組み立てる&gt; (p. 175)</p></li>
<li><p>&lt;個々のオブジェクトとオブジェクトを合成したものを一様に扱うことができる&gt;
(p. 175)</p></li>
<li><p>&lt;Composite パターンの特徴は、1 つの抽象クラスがプリミティブとコンテナの両方を表すことである&gt; (p. 175)</p></li>
<li><p>プリミティブの意味がよくわからんが、&lt;プリミティブなオブジェクトは子を持たないため、子オブジェクトに関するオペレーションは実装しない&gt; (p. 176)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Draw</span></code> オペレーションをその子オブジェクトの <code class="docutils literal notranslate"><span class="pre">Draw</span></code> オペレーションを呼び出すように実装し、またそれ以外にも、子オブジェクトに関連するオペレーションを実装する&gt; (p. 176)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Picture</span></code> オブジェクトは別の <code class="docutils literal notranslate"><span class="pre">Picture</span></code> オブジェクトを再帰的に生成していくことができる&gt; (p. 176)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Component</span></code> クラスにおいて、親にあたる <code class="docutils literal notranslate"><span class="pre">composite</span></code> にアクセスするインタフェースを宣言するのはオプション (p. 177)</p></li>
<li><p>ある要求を <code class="docutils literal notranslate"><span class="pre">composite</span></code> が受け取ったとき、&lt;通常、その要求を子にあたる
<code class="docutils literal notranslate"><span class="pre">component</span></code> に転送し、さらに転送の前後に付加的なオペレーションを実行することもある&gt; (p. 177)</p></li>
</ul>
<p>実装のセクションにある記述が濃い。</p>
<ul class="simple">
<li><p>親オブジェクトへの参照を持たせる場合、<code class="docutils literal notranslate"><span class="pre">composite</span></code> 構造の走査や管理が簡単になるが、「ある <code class="docutils literal notranslate"><span class="pre">composite</span></code> のすべての子オブジェクトは、その親オブジェクトとしてそれを持つ」という制約を壊さないように注意しないといけない (p. 178)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Component</span></code> クラスでサポートされているが、<code class="docutils literal notranslate"><span class="pre">Leaf</span></code> クラスには無意味なオペレーションも多く存在する&gt; (p. 179)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Add</span></code>/<code class="docutils literal notranslate"><span class="pre">Remove</span></code> オペレーションをどのクラスで宣言するかは重要な問題。この議論に 2 ページ近くを割いている。普通は安全性を捨てて、透過性をとる方向に解決するのだろう。</p></li>
<li><p>多くの設計では、&lt;子オブジェクトの順番を明確にする&gt; (p. 182)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">composite</span></code> に、自身が削除されるときにその子オブジェクトの削除も一緒に行わせるようにするのが、通常ではもっとも良い&gt; (p. 182) が、子オブジェクトが共有されているような場合は話は別だ。</p></li>
</ul>
</section>
<section id="decorator">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Decorator</a><a class="headerlink" href="#decorator" title="Permalink to this heading">¶</a></h3>
<p>&lt;サブクラス化よりも柔軟な機能拡張方法&gt; (p. 187) を動的に行えるようだ。</p>
<ul class="simple">
<li><p>&lt;クラス全体に対してではなく、個々のオブジェクトに責任を追加したくなることがある&gt; (p. 187)</p></li>
<li><p>いつぞやのスクロールバー付き枠付き <code class="docutils literal notranslate"><span class="pre">TextView</span></code> の例を持ちだしている。</p>
<ul>
<li><p>&lt;常にスクロールバーが必要とは限らない&gt;</p></li>
<li><p>&lt;必要になったときには <code class="docutils literal notranslate"><span class="pre">ScrollDecorator</span></code> オブジェクトを用いてスクロールバーを追加する&gt; (p. 188)</p></li>
</ul>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Decorator</span></code> クラスの構造は、</p>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">component</span></code> または <code class="docutils literal notranslate"><span class="pre">decorator</span></code> への参照を保持する&gt;</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Component</span></code> クラスのインタフェースと一致したインタフェースを定義する&gt; (p.
189)</p></li>
</ul>
<p>の二点。</p>
<ul>
<li><p>&lt;Decorator パターンを用いると、<code class="docutils literal notranslate"><span class="pre">decorator</span></code> を付けたりはずしたりして、実行時に簡単に責任の追加や削除ができる&gt; (p. 190)</p>
<p>個人的には削除の例は見たことがない。</p>
</li>
<li><p>&lt;1 つの単純なクラスを定義し、<code class="docutils literal notranslate"><span class="pre">decorator</span></code> を用いて機能を段階的に追加していく&gt;
(p. 190)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Component</span></code> クラスを軽く保つことが重要。メンバーデータは極力サブクラスに持たせる (p. 191)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Component</span></code> クラスが本質的に重く、そのため <code class="docutils literal notranslate"><span class="pre">Decorator</span></code> パターンを適用するにはコストがかかりすぎるような状況では <code class="docutils literal notranslate"><span class="pre">Strategy</span></code> パターンを選択する方がよい
&gt; (p. 191)</p></li>
</ul>
<p>サンプルコード。コンストラクタの呼び出し方にインパクトあり。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 194</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetContents</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="n">BorderDecorator</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">ScrollDecorator</span><span class="p">(</span><span class="n">textView</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>使用例。</p>
<ul class="simple">
<li><p>&lt;ストリームはほとんどの I/O 機構に存在する基本的な抽象概念である&gt; (p. 195)</p></li>
<li><p>decorator は adapter とは異なる。責任を変えるだけで、インタフェースまでは変えない (p. 196)</p></li>
<li><p>オブジェクトを変化させる方法には、decorator と strategy の 2 通りが考えられる
(p. 196)</p></li>
</ul>
</section>
<section id="facade">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Facade</a><a class="headerlink" href="#facade" title="Permalink to this heading">¶</a></h3>
<p>後回し。</p>
</section>
<section id="flyweight">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Flyweight</a><a class="headerlink" href="#flyweight" title="Permalink to this heading">¶</a></h3>
<p>このパターンは細かいオブジェクトの共有を目的とする。</p>
<ul class="simple">
<li><p>&lt;<em class="dfn">flyweight</em> とは、複数の文脈で同時に利用され得る共有オブジェクトのことである&gt; (p. 207)</p>
<ul>
<li><p>文脈とは何か。</p></li>
<li><p>共有オブジェクトということは、状態の持ち方に特別な何かがありそうだ。</p></li>
</ul>
</li>
<li><p>&lt;ここでキーとなる概念は <em class="dfn">intrinsic</em> 状態と <em class="dfn">extrinsic</em> 状態の区別である&gt; (p. 208)</p>
<ul>
<li><p>intrinsic 状態は flyweight オブジェクトの内部に格納。</p>
<ul>
<li><p>文脈とは依存しない、独立した情報。</p></li>
<li><p>共有できる情報。</p></li>
</ul>
</li>
<li><p>extrinsic 状態は</p>
<ul>
<li><p>文脈に依存する情報。</p></li>
<li><p>共有できない情報。</p></li>
</ul>
</li>
<li><p>文書エディタの例で言うと、</p>
<ul>
<li><p>各文字が flyweight オブジェクトであり、</p></li>
<li><p>文字コードは intrinsic 状態。</p></li>
<li><p>座標位置、フォントは extrinsic 状態。</p></li>
</ul>
</li>
</ul>
</li>
<li><p>&lt;extrinsic 状態に依存する可能性のあるオペレーションは、extrinsic 状態をパラメータとして渡される&gt; (pp. 208-209)</p></li>
</ul>
<p>適用可能性は、それを見極めるのがわかりやすいようだ。</p>
<ul>
<li><p>非常に多くのオブジェクトを利用する。</p></li>
<li><p>そのためにメモリ消費コストが高くつく。</p></li>
<li><p>&lt;オブジェクトの状態を構成するほとんどの情報を extrinsic にできる&gt; (p. 209)</p></li>
<li><p>あとはオブジェクトを共有できるかどうか。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">flyweight</span></code> が機能するために必要な状態は、intrinsic 状態か extrinsic 状態のどちらかに分類されなければならない&gt; (p. 211)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">flyweight</span></code> オブジェクトは &lt;<code class="docutils literal notranslate"><span class="pre">FlyweightFactory</span></code> オブジェクトから入手しなければならない&gt; (p. 211)</p>
<p>便宜上 Factory という単語を使っているだけであって、アクセスの度に常にオブジェクトを生成しているわけではない。</p>
</li>
<li><p>&lt;格納コストをもっとも節約できるのは、オブジェクトが intrinsic 状態とextrinsic
状態の両方についてかなりの量の情報を持ち、しかも extrinsic 状態が格納されるのではなくて計算できる場合&gt; (p. 212)</p></li>
<li><p>&lt;オブジェクトは共有されるので、クライアントがそれらを直接インスタンス化すべきではない&gt; (p. 212)</p></li>
<li><p>&lt;オブジェクトの共有では、<code class="docutils literal notranslate"><span class="pre">flyweight</span></code> が不要になったときに（略）何らかの形の参照数管理やガーベッジコレクションが必要になる&gt; (p. 213)</p></li>
</ul>
<p>サンプルコードの見どころは <code class="docutils literal notranslate"><span class="pre">GlyphContext</span></code> クラス。一見しただけでは何を管理しているのか理解できない。</p>
<p>使用例</p>
<ul>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">flyweight</span></code> の概念は、InterViews 3.0 における設計テクニックとして初めて記述され、研究された。その開発者は、この概念を立証するために、Doc と呼ばれる強力な文書エディタを構築した&gt; (p. 218)</p>
<p>180000 文字を含む文書を 480 個の文字オブジェクトで賄えるケースがあったとか。</p>
</li>
</ul>
</section>
<section id="proxy">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Proxy</a><a class="headerlink" href="#proxy" title="Permalink to this heading">¶</a></h3>
<p>&lt;オブジェクトの代理、または入れ物&gt; (p. 221)</p>
<ul>
<li><p>&lt;そのオブジェクトを実際に利用する必要が生じるまで、そのオブジェクトの生成と初期化にコストをかけるのを延期する&gt; (p. 221)</p></li>
<li><p>&lt;生成に高いコストのかかるオブジェクトをすべて同時に生成するのは避けることにする&gt; (p. 221)</p></li>
<li><p>&lt;文書の中には画像の代わりに何を置いておけばよいのだろうか&gt; (p. 221)</p></li>
<li><p>&lt;要求があり次第画像が生成されるという事実を隠蔽するにはどうしたらよいのだろうか&gt; (p. 221)</p>
<p>→画像 proxy なるものを導入することで解決する。</p>
</li>
</ul>
<p>適用可能性として、4 種類の proxy を分類している。</p>
<ul>
<li><p>remote proxy</p></li>
<li><p>virtual proxy</p></li>
<li><p>protection proxy: &lt;実オブジェクトへのアクセスを制御する&gt; (p. 223)</p>
<p>オブジェクトごとに異なるアクセス権が必要な場合に有用らしい。</p>
</li>
<li><p>smart reference: &lt;通常のポインタに代わるもの&gt; (p. 223)</p></li>
</ul>
<p>結果の説明でコピーオンライトについて言及がある。</p>
<ul class="simple">
<li><p>&lt;もしコピーされたオブジェクトが変更されないのであれば、このコストを発生させる必要はない。コピーするプロセスを延期するために proxy を使えば、そのオブジェクトが変更されたときにのみ、そのオブジェクトをコピーすればよいようにできる&gt;
(p. 225)</p></li>
</ul>
<p>実装</p>
<ul class="simple">
<li><p>&lt;メンバアクセスオペレータをオーバーロードする方法は、どのような種類の proxy に対しても良い解決法になるとは限らない&gt; (p. 226)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Proxy</span></code> クラスが <code class="docutils literal notranslate"><span class="pre">RealSubject</span></code> クラスをインスタンス化する場合（略）には、<code class="docutils literal notranslate"><span class="pre">Proxy</span></code> クラスはその具象クラスを知っていなければならない&gt; (p. 227)</p></li>
</ul>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">まとめ</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<p>Composite, Decorator, Proxy の比較 (p. 234) が面白かった。</p>
<ul class="simple">
<li><p>Decorator は退化した Composite ではない。</p>
<ul>
<li><p>両者は目的が異なっている。</p></li>
<li><p>ということは、相補的に利用できる。</p></li>
</ul>
</li>
<li><p>Decorator も Proxy も、クライアントに合成前のインタフェースと同じものを与えるが、Proxy に関しては</p>
<ul>
<li><p>特性を動的に加えたりはずしたりしない。</p></li>
<li><p>再帰的な合成のために設計されていない。</p></li>
</ul>
</li>
</ul>
</section>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note1.html" title="Previous document">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 1/3</a>
        </li>
        <li>
          <a href="note3.html" title="Next document">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 3/3</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a><ul>
      <li>Previous: <a href="note1.html" title="previous chapter">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 1/3</a></li>
      <li>Next: <a href="note3.html" title="next chapter">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 3/3</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>