<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>OpenGL: A Primer Second Edition 読書ノート 4/4</title>
    
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="top" title="読書ノート" href="index.html" />
    <link rel="up" title="OpenGL: A Primer Second Edition 読書ノート" href="angel05.html" />
    <link rel="next" title="入門 xyzzy 読書ノート" href="yamamoto05.html" />
    <link rel="prev" title="OpenGL: A Primer Second Edition 読書ノート 3/4" href="angel05-note3.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート</a> &raquo;</li>
          <li><a href="angel05.html" accesskey="U">OpenGL: A Primer Second Edition 読書ノート</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="opengl-a-primer-second-edition-4-4">
<h1><a class="toc-backref" href="#id2">OpenGL: A Primer Second Edition 読書ノート 4/4</a><a class="headerlink" href="#opengl-a-primer-second-edition-4-4" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="angel05-note3.html"><em>OpenGL: A Primer Second Edition 読書ノート 3/4</em></a> からの続き。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Edward Angel</td>
</tr>
<tr class="field-even field"><th class="field-name">出版社:</th><td class="field-body">Peason Education, Inc.</td>
</tr>
<tr class="field-odd field"><th class="field-name">ISBN:</th><td class="field-body">0-321-26982-9</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#opengl-a-primer-second-edition-4-4" id="id2">OpenGL: A Primer Second Edition 読書ノート 4/4</a><ul>
<li><a class="reference internal" href="#texture-mapping" id="id3">Texture Mapping</a><ul>
<li><a class="reference internal" href="#what-is-a-texture-map" id="id4">What Is a Texture Map?</a></li>
<li><a class="reference internal" href="#constructing-a-texture-map" id="id5">Constructing a Texture Map</a></li>
<li><a class="reference internal" href="#texture-coordinates" id="id6">Texture Coordinates</a></li>
<li><a class="reference internal" href="#texture-parameters" id="id7">Texture Parameters</a></li>
<li><a class="reference internal" href="#a-rotating-cube-with-texture" id="id8">A Rotating Cube with Texture</a></li>
<li><a class="reference internal" href="#applying-textures-to-surfaces" id="id9">Applying Textures to Surfaces</a></li>
<li><a class="reference internal" href="#borders-and-sizing" id="id10">Borders and Sizing</a></li>
<li><a class="reference internal" href="#mipmaps" id="id11">Mipmaps</a></li>
<li><a class="reference internal" href="#automatic-texture-coorinate-generation" id="id12">Automatic Texture Coorinate Generation</a></li>
<li><a class="reference internal" href="#texture-objects" id="id13">Texture Objects</a></li>
<li><a class="reference internal" href="#texture-maps-for-image-manipulation" id="id14">Texture Maps for Image Manipulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#curves-and-surfaces" id="id15">Curves and Surfaces</a><ul>
<li><a class="reference internal" href="#parameteric-curves" id="id16">Parameteric Curves</a></li>
<li><a class="reference internal" href="#parameteric-surfaces" id="id17">Parameteric Surfaces</a></li>
<li><a class="reference internal" href="#bezier-curves-and-surfaces" id="id18">Bezier Curves and Surfaces</a></li>
<li><a class="reference internal" href="#one-dimensional-opengl-evaluators" id="id19">One-Dimensional OpenGL Evaluators</a></li>
<li><a class="reference internal" href="#two-dimensional-evaluators" id="id20">Two-Dimensional Evaluators</a></li>
<li><a class="reference internal" href="#other-types-of-curves" id="id21">Other Types of Curves</a><ul>
<li><a class="reference internal" href="#b-splines" id="id22">B-Splines</a></li>
<li><a class="reference internal" href="#nurbs" id="id23">NURBS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-utah-teapot" id="id24">The Utah Teapot</a></li>
<li><a class="reference internal" href="#normals-and-shading" id="id25">Normals and Shading</a></li>
<li><a class="reference internal" href="#texturing-surfaces" id="id26">Texturing Surfaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#putting-it-together-and-moving-on" id="id27">Putting It Together and Moving On</a><ul>
<li><a class="reference internal" href="#a-demo-program" id="id28">A Demo Program</a><ul>
<li><a class="reference internal" href="#a-virtual-trackball" id="id29">A Virtual Trackball</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-opengl-features" id="id30">Other OpenGL Features</a></li>
<li><a class="reference internal" href="#buffers" id="id31">Buffers</a><ul>
<li><a class="reference internal" href="#the-accumulation-buffer" id="id32">The Accumulation Buffer</a></li>
<li><a class="reference internal" href="#the-stencil-buffer" id="id33">The Stencil Buffer</a></li>
<li><a class="reference internal" href="#fragment-tests" id="id34">Fragment Tests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-portable-efficient-robust-code" id="id35">Writing Portable, Efficient, Robust Code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#looking-to-the-future" id="id36">Looking to the Future</a><ul>
<li><a class="reference internal" href="#versions-and-extensions" id="id37">Versions and Extensions</a><ul>
<li><a class="reference internal" href="#opengl-version-1-1" id="id38">OpenGL Version 1.1</a></li>
<li><a class="reference internal" href="#opengl-version-1-2" id="id39">OpenGL Version 1.2</a></li>
<li><a class="reference internal" href="#opengl-version-1-3" id="id40">OpenGL Version 1.3</a></li>
<li><a class="reference internal" href="#opengl-version-1-4" id="id41">OpenGL Version 1.4</a></li>
<li><a class="reference internal" href="#opengl-version-1-5" id="id42">OpenGL Version 1.5</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengl-extensions" id="id43">OpenGL Extensions</a></li>
<li><a class="reference internal" href="#going-beyond-read-time-graphics" id="id44">Going Beyond Read-Time Graphics</a></li>
<li><a class="reference internal" href="#programmable-pipelines" id="id45">Programmable Pipelines</a><ul>
<li><a class="reference internal" href="#vertex-shaders" id="id46">Vertex Shaders</a></li>
<li><a class="reference internal" href="#fragment-shaders" id="id47">Fragment Shaders</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shading-languages" id="id48">Shading Languages</a><ul>
<li><a class="reference internal" href="#renderman-shading-language" id="id49">RenderMan Shading Language</a></li>
<li><a class="reference internal" href="#the-opengl-shading-language" id="id50">The OpenGL Shading Language</a></li>
<li><a class="reference internal" href="#cg" id="id51">Cg</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="texture-mapping">
<h2><a class="toc-backref" href="#id3">Texture Mapping</a><a class="headerlink" href="#texture-mapping" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>&lt;Texture mapping combines pixels with geometric objects&gt; (p. 169)</li>
</ul>
<div class="section" id="what-is-a-texture-map">
<h3><a class="toc-backref" href="#id4">What Is a Texture Map?</a><a class="headerlink" href="#what-is-a-texture-map" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>ピクセル配列を二次元のパラメータ区間に写像する。
このパラメータ区間から、三次元空間上の曲面に写像する。
この合成写像がテクスチャーマッピングだと大雑把に読み取れた。</li>
<li>テクスチャー座標は記号 (s, t) で表現する。</li>
</ul>
</div>
<div class="section" id="constructing-a-texture-map">
<h3><a class="toc-backref" href="#id5">Constructing a Texture Map</a><a class="headerlink" href="#constructing-a-texture-map" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>テクスチャーのイメージを準備する。イメージの表現については前章参照。</li>
<li>テクスチャーマッピングのためのパラメータを指定する。</li>
<li>頂点に対してテクスチャー座標を定義する。</li>
</ol>
<ul>
<li><p class="first">&lt;Two dimensional texture mapping is the most familiar case&gt; (p. 171)</p>
</li>
<li><p class="first">二次元的なイメージは、二次元多様体にマップするのが自然だろう。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">myimage</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">イメージの縦横サイズは、2 のベキ乗の形をしていなければならない。
註によると、新しいグラフィックカードは任意の縦横サイズを許しているようだ。</p>
</li>
<li><p class="first">&lt;It may take a significant amount of time to move a texture image from
processor memory to texture memory&gt; (p. 173)</p>
</li>
</ul>
</div>
<div class="section" id="texture-coordinates">
<h3><a class="toc-backref" href="#id6">Texture Coordinates</a><a class="headerlink" href="#texture-coordinates" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">&lt;Just as with vertices, texture coordinates are represented internally
in four dimensions that conventionally use the letters (s, t, r, q) to
denote the coordinates&gt; (p. 173)</p>
</li>
<li><p class="first">テクスチャーマッピングを試すためのコツを以下のように述べている。
&lt;Checkerboards are especially useful for demonstrating the various
options and seeing how OpenGL implements texture mapping&gt; (p. 174)</p>
</li>
<li><p class="first">&lt;We see that OpenGL renders the quadrilateral as two triangles&gt; (p. 174)</p>
</li>
<li><p class="first">頂点座標と同様に、テクスチャー座標を行列を用いて変換することができる。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_TEXTURE</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="texture-parameters">
<h3><a class="toc-backref" href="#id7">Texture Parameters</a><a class="headerlink" href="#texture-parameters" title="Permalink to this headline">¶</a></h3>
<p>テクスチャー座標やテクスチャー画像以外にも、
テクスチャーマッピングが要求するパラメータがいくつもある。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">glTexParameter(target,</span> <span class="pre">name,</span> <span class="pre">value)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">target:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_TEXTURE_2D</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">name:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_TEXTURE_xxx</span></tt></td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">&lt;The required parameters determine what happens when values of
s, t, r, or q go outside the range (0, 1) and how sampling and
filtering are applied&gt; (p. 176)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">GL_TEXTURE_WRAP_(S|T)</span></tt>, <tt class="docutils literal"><span class="pre">GL_(REPEAT|CLAMP)</span></tt> を憶える。</p>
</li>
<li><p class="first">magnification と minification の考え方を習得する。
一つのテクスチャー画素が複数のピクセルに写像する方が magnification</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">GL_TEXTURE_(MAG|MIN)_FILTER</span></tt> を <tt class="docutils literal"><span class="pre">GL_NEAREST</span></tt> にすると速い。</p>
</li>
<li><p class="first">透視図法でシーンを描いている場合、テクスチャーが歪む場合がよくある。
そういう場合は <tt class="docutils literal"><span class="pre">glHint</span></tt> を呼ぶ。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glHint</span><span class="p">(</span><span class="n">GL_PERSPECTIVE_CORRECTION_HINT</span><span class="p">,</span> <span class="n">GL_NICEST</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">glHint</span></tt> は他のレンダリングオプションにも利用できる。調べる。</p>
</li>
</ul>
</div>
<div class="section" id="a-rotating-cube-with-texture">
<h3><a class="toc-backref" href="#id8">A Rotating Cube with Texture</a><a class="headerlink" href="#a-rotating-cube-with-texture" title="Permalink to this headline">¶</a></h3>
<p>省略。</p>
</div>
<div class="section" id="applying-textures-to-surfaces">
<h3><a class="toc-backref" href="#id9">Applying Textures to Surfaces</a><a class="headerlink" href="#applying-textures-to-surfaces" title="Permalink to this headline">¶</a></h3>
<p>ポリゴンの地の色とテクスチャーマッピングをミックスする方法について。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">glTexEnv(target,</span> <span class="pre">param,</span> <span class="pre">value)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">target:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_TEXTURE_ENV</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">param:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_TEXTURE_ENV_MODE</span></tt> とか <tt class="docutils literal"><span class="pre">GL_TEX_ENV_COLOR</span></tt> とか。</td>
</tr>
<tr class="field-odd field"><th class="field-name">value:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_(MODULATE|REPLACE|BLEND|DECAL)</span></tt> とか色とか。</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">&lt;The default mode of operation is called modulation.
Here the texture color multiplies the color computed for each face&gt;
(p. 181)</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glTexEnvi</span><span class="p">(</span><span class="n">GL_TEXTURE_ENV</span><span class="p">,</span> <span class="n">GL_TEXTURE_ENV_MODE</span><span class="p">,</span> <span class="n">GL_MODULATE</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="borders-and-sizing">
<h3><a class="toc-backref" href="#id10">Borders and Sizing</a><a class="headerlink" href="#borders-and-sizing" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">テクスチャーマッピングは、テクスチャーイメージ境界付近の処理が難しい。</p>
</li>
<li><p class="first">&lt;One difficulty that arises when we use linear filtering is what happens
at the edges of the texture where we lack one or more texels to use
in the filtering&gt; (p. 181)</p>
</li>
<li><p class="first">テクスチャーに枠を付加するという仕様がある。
もし枠を指示するのなら、テクスチャーの縦横サイズを 2 のベキ乗 + 2 の形にする。</p>
</li>
<li><p class="first">枠の色を別途指示することができる。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glTexParameter3fv</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_BORDER_COLOR</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">フレームバッファ内のイメージからテクスチャーマップを得ることができる。
ただし「出力先」はテクスチャーメモリー。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glCopyTexImage2D</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">iformat</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">border</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">既に存在するテクスチャーから、その部分のコピーを（バイナリの形で）得ることもできる。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glTexSubImage2D</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">xoffset</span><span class="p">,</span> <span class="n">yoffset</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">texels</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">応用例がちょっと思いつかないが、テクスチャーメモリ内でコピーすることもできる。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glCopyTexSubImage2D</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">xoffset</span><span class="p">,</span> <span class="n">yoffset</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="mipmaps">
<h3><a class="toc-backref" href="#id11">Mipmaps</a><a class="headerlink" href="#mipmaps" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Mipmap とはテクスチャーマッピングの LOD の技法。
広い領域にマップするデータと、狭い領域にマップするデータを使い分ける。</p>
</li>
<li><p class="first">&lt;What we would prefer is to have a texture value that is the average of
the texels values over a large area of the texture&gt; (p. 183)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glTexImage2D</span></tt> の第二引数 (<tt class="docutils literal"><span class="pre">level</span></tt>) に応じて、イメージを変える。
本文の例では、レベルが低いほど詳細なイメージを指示している。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST_MIPMAP_NEAREST</span><span class="p">);</span>
</pre></div>
</div>
<p>&lt;This is the lowest quality option&gt; (p. 183)</p>
</li>
<li><p class="first">ミップマップセットを生成し、テクスチャーメモリに格納してくれる GLU の関数がある。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">gluBuild2DMipmaps</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">iformat</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">texels</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="automatic-texture-coorinate-generation">
<h3><a class="toc-backref" href="#id12">Automatic Texture Coorinate Generation</a><a class="headerlink" href="#automatic-texture-coorinate-generation" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">頂点に対してテクスチャー座標を決める作業は一般的には難しい。
しかし、GLU 二次曲面はテクスチャー座標を生成する関数が提供されている。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">gluQuadricTexture(obj,</span> <span class="pre">mode)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">mode:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_(TRUE|FALSE)</span></tt></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p class="first">&lt;OpenGL allows us to generate texture coordinates that are measured as
distances from a plane in either object space or eye space&gt; (p. 186)
だそうだが、平面からの距離で決まる座標というのが解りにくい。</p>
</li>
<li><p class="first">&lt;The value ax + by + cz + dw is proportional to the distance from
(x, y, z, w) to the plane determined by (a, b, c, d)&gt; (p. 186)</p>
</li>
<li><p class="first">テクスチャー座標自動生成には、例えば (s, t) の場合は以下の呼び出しが必要。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_GEN_S</span><span class="p">);</span>
<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_GEN_T</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glTexGen(texcoord,</span> <span class="pre">param,</span> <span class="pre">value)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">texcoord:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_[STRQ]</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">param:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_TEXTURE_GENMODE</span></tt> か <tt class="docutils literal"><span class="pre">GL_(OBJECT|EYE)_LINEAR</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">value:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_(OBJECT|EYE)_LINEAR</span></tt> か平面の係数配列</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">視点座標でテクスチャーを貼る：
&lt;If we use the <tt class="docutils literal"><span class="pre">GL_EYE_LINEAR</span></tt> mode, texture coordinates are based on
the vertex positions in eye space so that when we move the object,
the texture coordinates assigned to vertices change&gt; (p. 188)</p>
</li>
</ul>
</div>
<div class="section" id="texture-objects">
<h3><a class="toc-backref" href="#id13">Texture Objects</a><a class="headerlink" href="#texture-objects" title="Permalink to this headline">¶</a></h3>
<p>テクスチャーもまた OpenGL の「状態」の一部だ。
glTexImage を実行するときに、システムメモリからテクスチャーメモリへ
移動する。テクスチャーを何種類も利用する場合は、移動にコストをつけたくない。
そこで texture object というものを提供している。</p>
<ul>
<li><p class="first">&lt;If there is not sufficient memory for all the textures that we need,
we can prioritize the texture objects to minimize the amount of
data movement from the processor to texture memory&gt; (p. 188)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glGenTextures(n,</span> <span class="pre">name)</span></tt> で <tt class="docutils literal"><span class="pre">n</span></tt> 個の texture objects を新規作成する。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glIsTexture(name)</span></tt> で <tt class="docutils literal"><span class="pre">name</span></tt> が texture object か否かをテストする。</p>
</li>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">glBindTexture()</span></tt>, that both switches between texture objects and
forms new texture objects&gt; (p. 189)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glBindTexture(target,</span> <span class="pre">name)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">target:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_TEXTURE_[123]D</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">name:</th><td class="field-body">texture object の ID</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glBindTexture</span></tt> の振る舞いは、次の三つのどれか。</p>
<ul class="simple">
<li>case 1: &lt;If we call <tt class="docutils literal"><span class="pre">glBindTexture()</span></tt> with name and name has not been
used before, the subsequent calls to the various texture functions
define the texture object with the id name&gt;</li>
<li>case 2: &lt;If name already exists from a previous call to <tt class="docutils literal"><span class="pre">glBindTexture()</span></tt>,
then that texture object becomes the present texture and is applied
to surfaces until the next call to <tt class="docutils literal"><span class="pre">glBindTexture()</span></tt>&gt;</li>
<li>case 3: &lt;If <tt class="docutils literal"><span class="pre">glBindTexture()</span></tt> is called with name set to 0, then the
normal texture calls apply and the present texture that is part of
the OpenGL state and the current values of the texture parameters
both apply&gt;</li>
</ul>
</li>
<li><p class="first">テクスチャーオブジェクトを破棄したい場合は <tt class="docutils literal"><span class="pre">glDeleteTextures</span></tt> を呼ぶ。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">glDeleteTextures(n,</span> <span class="pre">namearray)</span></tt></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="texture-maps-for-image-manipulation">
<h3><a class="toc-backref" href="#id14">Texture Maps for Image Manipulation</a><a class="headerlink" href="#texture-maps-for-image-manipulation" title="Permalink to this headline">¶</a></h3>
<p>テクスチャーパラメータのセットだけだが、サンプルコードのラストが参考になる。</p>
</div>
</div>
<div class="section" id="curves-and-surfaces">
<h2><a class="toc-backref" href="#id15">Curves and Surfaces</a><a class="headerlink" href="#curves-and-surfaces" title="Permalink to this headline">¶</a></h2>
<p>ベジエ中心の話題。</p>
<div class="section" id="parameteric-curves">
<h3><a class="toc-backref" href="#id16">Parameteric Curves</a><a class="headerlink" href="#parameteric-curves" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>この本にしては例外的に数学の話が多くなるが、
「コンピューターには区分的パラメトリック曲線が相性がいい」
のようなことを述べている。</li>
<li>&lt;Parametric curves give a point in homogeneous coordinate space (x(u),
y(u), z(u), w(u)) for each value of u&gt; (p. 193)</li>
<li>簡単にするため、当分 w = 1 と固定して話を進める。</li>
<li>指定した点を通過するような n 次多項式を決めるには、
3(n + 1) 個の係数を求める必要があるので、3(n + 1) 個の
独立した条件を与える必要がある。</li>
<li>以降、基本的に 3 次式の話になる。4 つの点を決めれば、多項式の係数が求まる。</li>
<li>&lt;However, in computer graphics, interpolating curves usually
are not the most useful type due to their lack of smoothness&gt;
(p. 194) 通過点を指定する曲線の決め方は、コントロールが難しい。</li>
</ul>
</div>
<div class="section" id="parameteric-surfaces">
<h3><a class="toc-backref" href="#id17">Parameteric Surfaces</a><a class="headerlink" href="#parameteric-surfaces" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>曲面を二変数関数で表現する。
CG での曲面関数は通常は bicubic polynomial だと言っている。
曲線を curve segment の継ぎはぎで表現したのと同じ発想で、
曲面を surface patch で表現する。</li>
</ul>
</div>
<div class="section" id="bezier-curves-and-surfaces">
<h3><a class="toc-backref" href="#id18">Bezier Curves and Surfaces</a><a class="headerlink" href="#bezier-curves-and-surfaces" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>三次ベジエ多項式の性質についてザッと説明している。<ul>
<li>コントロールポイントが 4 つ (Q0, Q1, Q2, Q3) ある。</li>
<li>Q0 と Q3 は曲線の始点と終点にそれぞれ一致する。</li>
<li>直線 Q0Q1 と Q2Q3 は、それぞれ曲線の始点と終点の接線だ。</li>
<li>曲線全体は多角形 Q0Q1Q2Q3 に内包される。
これを convex hull property という。</li>
<li>Bernstein 多項式として知られる多項式の族である。
Bernstein 多項式はとても効率的に実装できる。</li>
</ul>
</li>
<li>任意の多項式曲線、多項式曲面はベジエ曲線、ベジエ曲面から得られる。</li>
<li>&lt;OpenGL implements Bezier curves and surfaces through a mechanism known
as <strong>evaluators</strong>&gt; (p. 197)</li>
<li>&lt;such as line segments and polygons that approximate the curve or surface&gt;
(p. 197)</li>
</ul>
</div>
<div class="section" id="one-dimensional-opengl-evaluators">
<h3><a class="toc-backref" href="#id19">One-Dimensional OpenGL Evaluators</a><a class="headerlink" href="#one-dimensional-opengl-evaluators" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">まず <tt class="docutils literal"><span class="pre">glMap1</span></tt> 関数の紹介から始まる。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">glMap1(entity,</span> <span class="pre">u0,</span> <span class="pre">u1,</span> <span class="pre">stride,</span> <span class="pre">order,</span> <span class="pre">data)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">entity:</th><td class="field-body">この曲線が何の値を表現しているのかを指定する。
&lt;If we want a curve, we set entity to <tt class="docutils literal"><span class="pre">GL_MAP1_VERTEX_3</span></tt>&gt; (p. 198)
ただし <tt class="docutils literal"><span class="pre">glEnable(GL_MAP1_VERTEX_3)</span></tt> の呼び出しが別途必要。</td>
</tr>
<tr class="field-even field"><th class="field-name">order:</th><td class="field-body">ベジエ曲線の次数プラス 1 を与える。
すなわち、制御点の総数を意味する。</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glMap1</span></tt> で曲線を定義したら、その計算をし、結果を取得する。
それには <tt class="docutils literal"><span class="pre">glEvalCoord1</span></tt> を用いる。
今までは <tt class="docutils literal"><span class="pre">glVertex</span></tt> 等を利用していたところを <tt class="docutils literal"><span class="pre">glEvalCoord1</span></tt> に置き換わる感じ。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">glEvalCoord1(u)</span></tt></li>
</ul>
</li>
<li><p class="first">ところで、パラメータ u をいちいち手計算して与えるのは面倒だ。そんなときには
&lt;OpenGL provides an alternative for equally spaced values of u&gt;
(p. 199)</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">glMapGrid1(n,</span> <span class="pre">u0,</span> <span class="pre">u1)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">n:</th><td class="field-body">区分数を意味する。</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glEvalMesh1(mode,</span> <span class="pre">first,</span> <span class="pre">last)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">mode:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_(LINE|POINT)</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">first, last:</th><td class="field-body">0 以上 <tt class="docutils literal"><span class="pre">glMapGrid1</span></tt> で与えた n 以下の数。</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="two-dimensional-evaluators">
<h3><a class="toc-backref" href="#id20">Two-Dimensional Evaluators</a><a class="headerlink" href="#two-dimensional-evaluators" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>次の関数を利用して二次元 Bernstein 多項式を評価することができる。
すなわち、ベジエ曲面を描画できる。<ul>
<li><tt class="docutils literal"><span class="pre">glMap2(entity,</span> <span class="pre">u0,</span> <span class="pre">u1,</span> <span class="pre">ustride,</span> <span class="pre">uorder,</span> <span class="pre">v0,</span> <span class="pre">v1,</span> <span class="pre">vstride,</span> <span class="pre">vorder,</span> <span class="pre">data)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">glEvalCoord2(u,</span> <span class="pre">v)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">glMapGrid(n,</span> <span class="pre">u0,</span> <span class="pre">u1,</span> <span class="pre">m,</span> <span class="pre">v0,</span> <span class="pre">v1)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">glEvalMesh2(mode,</span> <span class="pre">ufirst,</span> <span class="pre">ulast,</span> <span class="pre">vfirst,</span> <span class="pre">vlast)</span></tt></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="other-types-of-curves">
<h3><a class="toc-backref" href="#id21">Other Types of Curves</a><a class="headerlink" href="#other-types-of-curves" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;In other words, a cubic polynomial is both a Bezier curve and
an interpolating curve for different set of control points&gt; (p. 203)</li>
<li>通過点から制御点を求める行列を紹介している。憶えなくてよい。</li>
</ul>
<div class="section" id="b-splines">
<h4><a class="toc-backref" href="#id22">B-Splines</a><a class="headerlink" href="#b-splines" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>まず、ベジエ曲線・曲面はスプライン曲線・曲面の一種であることをおさえる。</li>
<li>B スプラインもキュービックが基本。
&lt;The most popular type of spline is the cubic B-spline&gt; (p. 204)</li>
<li>キュービックスプラインの制御点を、同一形状のベジエ曲線の制御点に
変換する行列を紹介している。憶えなくてよい。</li>
</ul>
</div>
<div class="section" id="nurbs">
<h4><a class="toc-backref" href="#id23">NURBS</a><a class="headerlink" href="#nurbs" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>OpenGL では GLU が NURBS をサポートしている。</li>
<li>NURBS のキモは w 成分にあるようだ。</li>
</ul>
</div>
</div>
<div class="section" id="the-utah-teapot">
<h3><a class="toc-backref" href="#id24">The Utah Teapot</a><a class="headerlink" href="#the-utah-teapot" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>例のティーポットの構成を説明。
&lt;The teapot is composed of 32 cubic Bezier surface patches, defined
by 306 distinct control points.  The data set is widely available
and usually is given as 32 lines, each of 16 integers in the range
of 1-192.  Each integer is a pointer to one of the 306 (x, y, z)
values&gt; (p. 207)</li>
</ul>
</div>
<div class="section" id="normals-and-shading">
<h3><a class="toc-backref" href="#id25">Normals and Shading</a><a class="headerlink" href="#normals-and-shading" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">曲面 evaluator が内部的に生成する頂点に対して法線を指定するには、</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_AUTO_NORMAL</span><span class="p">);</span>
</pre></div>
</div>
<p>するだけでよい。</p>
</li>
</ul>
</div>
<div class="section" id="texturing-surfaces">
<h3><a class="toc-backref" href="#id26">Texturing Surfaces</a><a class="headerlink" href="#texturing-surfaces" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">&lt;We can also use evaluators to generate normals for shading and
texture coordinates&gt; (p. 213)</p>
<p>どうするかというと、 <tt class="docutils literal"><span class="pre">glMap2</span></tt> で実現できる。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glMap2f</span><span class="p">(</span><span class="n">GL_MAP2_TEXTURE_COORD_2</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="putting-it-together-and-moving-on">
<h2><a class="toc-backref" href="#id27">Putting It Together and Moving On</a><a class="headerlink" href="#putting-it-together-and-moving-on" title="Permalink to this headline">¶</a></h2>
<p>今まで紹介した機能プラスアルファで、デモプログラムを作る。
目玉はトラックボールとフォグか。</p>
<div class="section" id="a-demo-program">
<h3><a class="toc-backref" href="#id28">A Demo Program</a><a class="headerlink" href="#a-demo-program" title="Permalink to this headline">¶</a></h3>
<div class="section" id="a-virtual-trackball">
<h4><a class="toc-backref" href="#id29">A Virtual Trackball</a><a class="headerlink" href="#a-virtual-trackball" title="Permalink to this headline">¶</a></h4>
<p>マウスの動きから仮想的なトラックボールを作る。方針は
&lt;by projecting the position of the mouse upward to the virtual
hemisphere, as in Figure 10.2.  As the mouse moves, the program
tracks the change in position on the hemisphere.  Two positions
on the hemisphere determine both an axis of rotation and an
angle to rotate about this axis, as shown in Figure 10.3&gt; (p. 216)</p>
</div>
</div>
<div class="section" id="other-opengl-features">
<h3><a class="toc-backref" href="#id30">Other OpenGL Features</a><a class="headerlink" href="#other-opengl-features" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>OpenGL tessellator で凸多角形制限をかわすことができる。</li>
<li>&lt;the use of NURBS requires more understanding of their mathematical
underpinnings than we can present here&gt; (pp. 230-231)</li>
</ul>
</div>
<div class="section" id="buffers">
<h3><a class="toc-backref" href="#id31">Buffers</a><a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">OpenGL は色々なバッファをサポートしているが &lt;not all of these buffers
need be available on all implementations&gt; (p. 231) だ。</p>
</li>
<li><p class="first">accumulation バッファや stencil バッファを利用するプログラムでは、
<tt class="docutils literal"><span class="pre">glutInitDisplayMode</span></tt> の引数に、そのことを明示的に指示する。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">glutInitDisplayMode</span><span class="p">(</span><span class="n">GL_XXX</span> <span class="o">|</span> <span class="n">GL_STENCIL</span> <span class="o">|</span> <span class="n">GL_ACCUM</span><span class="p">);</span>

<span class="n">glClear</span><span class="p">(</span><span class="n">GL_XXX</span> <span class="o">|</span> <span class="n">GL_ACCUM_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_STENCIL_BUFFER_BIT</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">auxiliary バッファはマルチパスレンダリングに利用するかもしれない。</p>
</li>
</ul>
<div class="section" id="the-accumulation-buffer">
<h4><a class="toc-backref" href="#id32">The Accumulation Buffer</a><a class="headerlink" href="#the-accumulation-buffer" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">カラーバッファの精度に不足がある場合にこのバッファが役に立つらしい。
まさに CPU レジスタの accumulator のような働きをするようだ。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">glAccum(operation,</span> <span class="pre">value)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">operation:</th><td class="field-body"><tt class="docutils literal"><span class="pre">GL_(ACCUM|LOAD|RETURN|ADD|MULT)</span></tt></td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">カメラがブレているような画像効果を狙ったマルチパスレンダリングに応用する
ことが考えられる。</p>
</li>
</ul>
</div>
<div class="section" id="the-stencil-buffer">
<h4><a class="toc-backref" href="#id33">The Stencil Buffer</a><a class="headerlink" href="#the-stencil-buffer" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>&lt;Stencils are masks that we can use to determine where to draw&gt; (p. 232)</li>
</ul>
</div>
<div class="section" id="fragment-tests">
<h4><a class="toc-backref" href="#id34">Fragment Tests</a><a class="headerlink" href="#fragment-tests" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>&lt;in OpenGL the rasterizer produces <strong>fragments</strong>, which contain all the
information needed to update pixels in the frame buffer pixel&gt; (p. 233)</li>
<li>&lt;Fragments that are produced by the rasterizer go through a sequence of
tests&#8211;scissor, alpha, stencil, depth&#8211;and operations&#8211;blending,
dithering, logical&#8211;on their way to the color buffer&gt; (p. 233)</li>
</ul>
</div>
</div>
<div class="section" id="writing-portable-efficient-robust-code">
<h3><a class="toc-backref" href="#id35">Writing Portable, Efficient, Robust Code</a><a class="headerlink" href="#writing-portable-efficient-robust-code" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>OpenGL はポータブルとはいえ、当然その実装によっては制限がある。</li>
<li>&lt;One is that once we start using advanced features, such as the
accumulation and stencil buffers, we often lose portability,
as these features are not supported on all implementations&gt; (p. 233)</li>
<li>&lt;We do not know&#8211;nor do we usually need to know&gt; (p. 234)</li>
</ul>
</div>
</div>
<div class="section" id="looking-to-the-future">
<h2><a class="toc-backref" href="#id36">Looking to the Future</a><a class="headerlink" href="#looking-to-the-future" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>&lt;OpenGL version 1.0 was released in 1992&gt; (p. 235)</li>
</ul>
<div class="section" id="versions-and-extensions">
<h3><a class="toc-backref" href="#id37">Versions and Extensions</a><a class="headerlink" href="#versions-and-extensions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;extensions may apply to only some systems&gt;</li>
</ul>
<div class="section" id="opengl-version-1-1">
<h4><a class="toc-backref" href="#id38">OpenGL Version 1.1</a><a class="headerlink" href="#opengl-version-1-1" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>1995 年に登場。このバージョンが特に重要な理由は
&lt;Version 1.1 is still the most widely used version&gt; (p.235)
だから。</li>
<li>頂点配列、テクスチャー操作、RGBA 色に対する論理演算、
ポリゴンオフセットが導入された。</li>
</ul>
</div>
<div class="section" id="opengl-version-1-2">
<h4><a class="toc-backref" href="#id39">OpenGL Version 1.2</a><a class="headerlink" href="#opengl-version-1-2" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>1998 年に登場。三次元テクスチャーマッピング機能。</li>
<li>imaging subset の追加</li>
</ul>
</div>
<div class="section" id="opengl-version-1-3">
<h4><a class="toc-backref" href="#id40">OpenGL Version 1.3</a><a class="headerlink" href="#opengl-version-1-3" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>2001 年に登場。テクスチャー処理性能を向上させる目的の機能追加。</li>
<li>転置行列関数もこのバージョンで登場した機能。
これで Fortran 式の column order な配列だけでなく、
C 言語風の row order 配列もそのまま使えるようになった。</li>
</ul>
</div>
<div class="section" id="opengl-version-1-4">
<h4><a class="toc-backref" href="#id41">OpenGL Version 1.4</a><a class="headerlink" href="#opengl-version-1-4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>2002 年に登場。かつての拡張機能がコアに追加された。</li>
</ul>
</div>
<div class="section" id="opengl-version-1-5">
<h4><a class="toc-backref" href="#id42">OpenGL Version 1.5</a><a class="headerlink" href="#opengl-version-1-5" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>2003 年に登場。コアにマイナーチェンジを施しただけ。</li>
</ul>
</div>
</div>
<div class="section" id="opengl-extensions">
<h3><a class="toc-backref" href="#id43">OpenGL Extensions</a><a class="headerlink" href="#opengl-extensions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;Individual manufacturers can propose and implement extensions&gt; (p. 237)</li>
<li>&lt;As hardware evolves, high-end features that were only available
as extensions become part of later versions of OpenGL&gt; (p. 237)</li>
</ul>
</div>
<div class="section" id="going-beyond-read-time-graphics">
<h3><a class="toc-backref" href="#id44">Going Beyond Read-Time Graphics</a><a class="headerlink" href="#going-beyond-read-time-graphics" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;Pixar&#8217;s RenderMan interface&gt;</li>
<li>&lt;we cannot edit OpenGL display lists&gt; (p. 238)</li>
<li>&lt;all the information about the image is in the tree of Figure 11.1.
This tree is known as a <strong>scene graph</strong>&gt; (p. 238)</li>
<li>シーングラフを設計するのは難しい。
&lt;The answer today should be a set of atomic primitives that can take
advantage of the existing hardware and APIs&gt; (p. 239)</li>
<li>&lt;an application programer who wants to use scene graphs can often
avoid writing a program using the scene graph API by specifying
the scene through a text file that provides an alternate method
of describing the tree&gt; (p.239)</li>
</ul>
</div>
<div class="section" id="programmable-pipelines">
<h3><a class="toc-backref" href="#id45">Programmable Pipelines</a><a class="headerlink" href="#programmable-pipelines" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>パイプラインの一部をユーザープログラムで置き換えるような造りを考える。</li>
<li>&lt;Graphics processors have become programmable&gt; (p. 240)</li>
<li>vertex shader と fragment shader の 2 ブロックがそうだ。</li>
</ul>
<div class="section" id="vertex-shaders">
<h4><a class="toc-backref" href="#id46">Vertex Shaders</a><a class="headerlink" href="#vertex-shaders" title="Permalink to this headline">¶</a></h4>
<p>例えば Phong モデル以外の照光モデルで頂点の色を計算できる。</p>
</div>
<div class="section" id="fragment-shaders">
<h4><a class="toc-backref" href="#id47">Fragment Shaders</a><a class="headerlink" href="#fragment-shaders" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>&lt;In particular, the fragment shader can access one or more texture
coordinates, light properties, normals, and camera properties&gt;
(p. 241)</li>
</ul>
</div>
</div>
<div class="section" id="shading-languages">
<h3><a class="toc-backref" href="#id48">Shading Languages</a><a class="headerlink" href="#shading-languages" title="Permalink to this headline">¶</a></h3>
<div class="section" id="renderman-shading-language">
<h4><a class="toc-backref" href="#id49">RenderMan Shading Language</a><a class="headerlink" href="#renderman-shading-language" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>&lt;Once we realize that the Phong shader can be written as a tree data
structure, it is fairly simple to extend this concept to other shaders
by adding nodes to the tree and altering the contents of its node.
This concept of a <strong>shading tree</strong> is fundamental to much recent work
on shading languages&gt; (pp. 242-243)</li>
</ul>
</div>
<div class="section" id="the-opengl-shading-language">
<h4><a class="toc-backref" href="#id50">The OpenGL Shading Language</a><a class="headerlink" href="#the-opengl-shading-language" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>2003 年に ARB が extension として採用したのが OpenGL シェーディング言語。
C 言語がベースで、vertex shader と fragment shader の両方に用いられる。</li>
</ul>
</div>
<div class="section" id="cg">
<h4><a class="toc-backref" href="#id51">Cg</a><a class="headerlink" href="#cg" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>&lt;Rather than have separate APIs for accessing programmable hardware
for OpenGL and Direct3D, NVIDIA and Microsoft developed the Cg
(C for graphics) language&gt; (p. 244)</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート</a> &raquo;</li>
          <li><a href="angel05.html" >OpenGL: A Primer Second Edition 読書ノート</a> &raquo;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2014,
        プレハブ小屋
        All rights reserved.
      </div>
      <div id="footer_spacer">
        <p>
          Last updated at 2014/11/02 (Sun) 02:17:41.
        </p>
      </div>
    </div>
  </body>
</html>