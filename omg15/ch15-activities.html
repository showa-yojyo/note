<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>15 Activities &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="16 Actions" href="ch16-actions.html" />
    <link rel="prev" title="14 StateMachines" href="ch14-statemachines.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="ch14-statemachines.html" title="Previous document">14 StateMachines</a>
        </li>
        <li>
          <a href="ch16-actions.html" title="Next document">16 Actions</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="activities">
<h1><a class="toc-backref" href="#id37" role="doc-backlink">15 Activities</a><a class="headerlink" href="#activities" title="Permalink to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#activities" id="id37">15 Activities</a></p>
<ul>
<li><p><a class="reference internal" href="#summary" id="id38">15.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id39">15.2 Activities</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id40">15.2.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#abstract-syntax" id="id41">15.2.2 Abstract Syntax</a></p></li>
<li><p><a class="reference internal" href="#semantics" id="id42">15.2.3 Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id43">15.2.3.1 Activities</a></p></li>
<li><p><a class="reference internal" href="#activity-nodes" id="id44">15.2.3.2 Activity Nodes</a></p></li>
<li><p><a class="reference internal" href="#activity-edges" id="id45">15.2.3.3 Activity Edges</a></p></li>
<li><p><a class="reference internal" href="#object-flows" id="id46">15.2.3.4 Object Flows</a></p></li>
<li><p><a class="reference internal" href="#variables" id="id47">15.2.3.5 Variables</a></p></li>
<li><p><a class="reference internal" href="#activity-execution" id="id48">15.2.3.6 Activity Execution</a></p></li>
<li><p><a class="reference internal" href="#activity-generalization" id="id49">15.2.3.7 Activity Generalization</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#notation" id="id50">15.2.4 Notation</a></p></li>
<li><p><a class="reference internal" href="#examples" id="id51">15.2.5 Examples</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#control-nodes" id="id52">15.3 Control Nodes</a></p>
<ul>
<li><p><a class="reference internal" href="#id4" id="id53">15.3.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id54">15.3.2 Abstract Syntax</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id55">15.3.3 Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#initial-node" id="id56">15.3.3.1 Initial Node</a></p></li>
<li><p><a class="reference internal" href="#final-nodes" id="id57">15.3.3.2 Final Nodes</a></p></li>
<li><p><a class="reference internal" href="#fork-nodes" id="id58">15.3.3.3 Fork Nodes</a></p></li>
<li><p><a class="reference internal" href="#join-nodes" id="id59">15.3.3.4 Join Nodes</a></p></li>
<li><p><a class="reference internal" href="#merge-nodes" id="id60">15.3.3.5 Merge Nodes</a></p></li>
<li><p><a class="reference internal" href="#decision-nodes" id="id61">15.3.3.6 Decision Nodes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id7" id="id62">15.3.4 Notation</a></p>
<ul>
<li><p><a class="reference internal" href="#initial-and-final-nodes" id="id63">15.3.4.1 Initial and Final Nodes</a></p></li>
<li><p><a class="reference internal" href="#fork-and-join-nodes" id="id64">15.3.4.2 Fork and Join Nodes</a></p></li>
<li><p><a class="reference internal" href="#merge-nodes-and-decision-nodes" id="id65">15.3.4.3 Merge Nodes and Decision Nodes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id8" id="id66">15.3.5 Examples</a></p>
<ul>
<li><p><a class="reference internal" href="#initial-nodes" id="id67">15.3.5.1 Initial Nodes</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id68">15.3.5.2 Fork and Join Nodes</a></p></li>
<li><p><a class="reference internal" href="#merge-and-decision-nodes" id="id69">15.3.5.3 Merge and Decision Nodes</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id70">15.3.5.4 Final Nodes</a></p></li>
<li><p><a class="reference internal" href="#various-control-nodes" id="id71">15.3.5.5 Various Control Nodes</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#object-nodes" id="id72">15.4 Object Nodes</a></p>
<ul>
<li><p><a class="reference internal" href="#id11" id="id73">15.4.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id74">15.4.2 Abstract Syntax</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id75">15.4.3 Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#id14" id="id76">15.4.3.1 Object Nodes</a></p></li>
<li><p><a class="reference internal" href="#activity-parameter-nodes" id="id77">15.4.3.2 Activity Parameter Nodes</a></p></li>
<li><p><a class="reference internal" href="#central-buffer-nodes" id="id78">15.4.3.3 Central Buffer Nodes</a></p></li>
<li><p><a class="reference internal" href="#data-store-nodes" id="id79">15.4.3.4 Data Store Nodes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id15" id="id80">15.4.4 Notation</a></p>
<ul>
<li><p><a class="reference internal" href="#id16" id="id81">15.4.4.1 Object Nodes</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id82">15.4.4.2 Activity Parameter Nodes</a></p></li>
<li><p><a class="reference internal" href="#central-buffer-and-data-store-nodes" id="id83">15.4.4.3 Central Buffer and Data Store Nodes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id18" id="id84">15.4.5 Examples</a></p>
<ul>
<li><p><a class="reference internal" href="#id19" id="id85">15.4.5.1 Activity Parameter Nodes</a></p></li>
<li><p><a class="reference internal" href="#id20" id="id86">15.4.5.2 Central Buffer and Data Store Nodes</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#executable-nodes" id="id87">15.5 Executable Nodes</a></p>
<ul>
<li><p><a class="reference internal" href="#id21" id="id88">15.5.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#id22" id="id89">15.5.2 Abstract Syntax</a></p></li>
<li><p><a class="reference internal" href="#id23" id="id90">15.5.3 Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#id24" id="id91">15.5.3.1 Executable Nodes</a></p></li>
<li><p><a class="reference internal" href="#exceptions-and-exception-handlers" id="id92">15.5.3.2 Exceptions and Exception Handlers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id25" id="id93">15.5.4 Notation</a></p>
<ul>
<li><p><a class="reference internal" href="#id26" id="id94">15.5.4.1 Executable Nodes</a></p></li>
<li><p><a class="reference internal" href="#exception-handlers" id="id95">15.5.4.2 Exception Handlers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id27" id="id96">15.5.5 Examples</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#activity-groups" id="id97">15.6 Activity Groups</a></p>
<ul>
<li><p><a class="reference internal" href="#id28" id="id98">15.6.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#id29" id="id99">15.6.2 Abstract Syntax</a></p></li>
<li><p><a class="reference internal" href="#id30" id="id100">15.6.3 Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#activity-partitions" id="id101">15.6.3.1 Activity Partitions</a></p></li>
<li><p><a class="reference internal" href="#interruptible-activity-regions" id="id102">15.6.3.2 Interruptible Activity Regions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id31" id="id103">15.6.4 Notation</a></p>
<ul>
<li><p><a class="reference internal" href="#id32" id="id104">15.6.4.1 Activity Partitions</a></p></li>
<li><p><a class="reference internal" href="#id33" id="id105">15.6.4.2 Interruptible Activity Regions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id34" id="id106">15.6.5 Examples</a></p>
<ul>
<li><p><a class="reference internal" href="#id35" id="id107">15.6.5.1 Activity Partitions</a></p></li>
<li><p><a class="reference internal" href="#id36" id="id108">15.6.5.2 Interruptible Activity Regions</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#classifier-descriptions" id="id109">15.7 Classifier Descriptions</a></p></li>
<li><p><a class="reference internal" href="#association-descriptions" id="id110">15.8 Association Descriptions</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="summary">
<h2><a class="toc-backref" href="#id38" role="doc-backlink">15.1 Summary</a><a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>Activity とは Behavior の一種であって、辺により相互接続される節点のグラフとして指定される (<a class="reference internal" href="ch13-common-behavior.html"><span class="doc">13 Common Behavior</span></a>)。</p>
<ul class="simple">
<li><p>その節点の部分集合は、その Activity 全体の低水準手順を具体化する実行可能節点だ。</p></li>
<li><p>オブジェクト節点は実行可能節点に入出力するデータを保持し、オブジェクトフロー辺を縦断して移動する。</p></li>
</ul>
<p>こういう計算モデルが実質的に同時処理であることを理解する：</p>
<blockquote>
<div><p>Activities are essentially what are commonly called “control and data flow”
models. Such models of computation are inherently concurrent, as any
sequencing of activity node execution is modeled explicitly by activity
edges, and no ordering is mandated for any computation not explicitly
sequenced.</p>
</div></blockquote>
<p>Activities は何を記述するものなのか：</p>
<blockquote>
<div><p>Activities may be applied to organizational modeling for business process
engineering and workflow. In this context, events often originate from inside
the system, such as the finishing of a task, but also from outside the
system, such as a customer call. Activities can also be used for information
system modeling to specify system level processes.</p>
</div></blockquote>
<p>この章の残りは、活動モデルがどのように構造化されるのか、さまざまな種類のオブジェクト節点と制御節点について述べられる。</p>
<p>UML では実行可能節点は Actions (<a class="reference internal" href="ch16-actions.html"><span class="doc">16 Actions</span></a>) しかない。</p>
<blockquote>
<div><p>Actions are required for any significant capabilities of Activities. Actions
invoke other Behaviors and Operations (see above), access and modify objects,
as well as link them together, and perform more advanced coordination of
other Actions (Structured Actions). They are central to the “data flow”
aspects of Activities, introducing a specialized form of object node (Pins)
for object flows to get and provide data to Actions.</p>
</div></blockquote>
<ul class="simple">
<li><p>Actions を表す具体的構文は Activities を表す具体的構文の部分集合であり、一部は本章で規定される。</p></li>
<li><p>Action 表記法は Activity 図でしか現れない。</p></li>
</ul>
<p>この章では実行可能節点を使うことで Actions からある程度の独立性を実現するが、それでも <a class="reference internal" href="ch16-actions.html"><span class="doc">16 Actions</span></a> と一緒に読む必要がある。</p>
</section>
<section id="id1">
<h2><a class="toc-backref" href="#id39" role="doc-backlink">15.2 Activities</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<section id="id2">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">15.2.1 Summary</a><a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>An Activity is a Behavior specified as sequencing of subordinate units, using
a control and data flow model.</p>
</div></blockquote>
<ul class="simple">
<li><p>実行の流れは ActivityEdges によって接続される ActivityNodes としてモデル化される。</p></li>
<li><p>ExecutableNode は、算術計算、操作の呼び出し、オブジェクト内容の操縦など、従属的挙動の実行であることがある。</p></li>
<li><p>ActivityNodes は、同期、決定、同時制御のような、制御の流れに関する構成要素をも含む。</p></li>
</ul>
<blockquote>
<div><p>This sub clause describes the basic structure and flow semantics of an
activity model as a graph of nodes and edges. Subsequent sub clauses then
describe the various kinds of ActivityNodes that an Activity may contain and
how those nodes may be grouped within the Activity.</p>
</div></blockquote>
</section>
<section id="abstract-syntax">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">15.2.2 Abstract Syntax</a><a class="headerlink" href="#abstract-syntax" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 15.1 Activities</p>
</div></blockquote>
<p>Activity, Variable, ActivityNode, ActivityEdge, ObjectFlow, ControlFlow 周りを見ていく。Flow とは Edge の一種らしい。</p>
</section>
<section id="semantics">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">15.2.3 Semantics</a><a class="headerlink" href="#semantics" title="Permalink to this heading">¶</a></h3>
<section id="id3">
<h4><a class="toc-backref" href="#id43" role="doc-backlink">15.2.3.1 Activities</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h4>
<p>Activity における ActivityNode 一つの実行は、その Activity 内にある他の
ActivityNodes の実行に影響を与えたり影響されたりすることがある。このような辺はこの ActivityNodes を相互に接続する ActivityEdges で表される。</p>
<p>トークンの流れ：</p>
<blockquote>
<div><p>The effect of one ActivityNode on another is specified by the <em>flow of
tokens</em> over the ActivityEdges between the ActivityNodes.</p>
</div></blockquote>
<p>トークン：</p>
<blockquote>
<div><p><em>Tokens</em> are not explicitly modeled in an Activity, but are used for
describing the execution of an Activity.</p>
</div></blockquote>
<p>オブジェクトトークンと ObjectFlow をペアで理解する：</p>
<blockquote>
<div><p>An <em class="dfn">object token</em> is a container for a value that flows over ObjectFlow
edges (some object tokens can flow over ControlFlow edges, as specified by
the modeler, see <code class="docutils literal notranslate"><span class="pre">isControlType</span></code> for ObjectNodes in sub clause 15.4).</p>
</div></blockquote>
<p>空トークンと制御トークン：</p>
<blockquote>
<div><p>An object token with no value in it is called a <em>null</em> token. A <em>control
token</em> affects execution of ActivityNodes, but does not carry any data, and
flows only over ControlFlow edges.</p>
</div></blockquote>
<p>同じ値を含んでいるとしても、トークンは他のトークンとは区別される。</p>
<p>ActivityEdge とトークン：</p>
<blockquote>
<div><p>ActivityEdges are directed, with tokens flowing from the <code class="docutils literal notranslate"><span class="pre">source</span></code>
ActivityNode to the <code class="docutils literal notranslate"><span class="pre">target</span></code> ActivityNode.</p>
</div></blockquote>
<p>トークンが辺を流れるには条件があるらしい：</p>
<blockquote>
<div><p>However, tokens <em>offered</em> to an ActivityEdge by the <code class="docutils literal notranslate"><span class="pre">source</span></code> ActivityNode
may not immediately flow along the edge. Instead, the tokens only move when
the offer is <em>accepted</em> by the ActivityEdge, which requires at least the
<code class="docutils literal notranslate"><span class="pre">target</span></code> ActivityNode to accept them also, which in turn might depend on
acceptance of cascading offers of the same tokens to edges and nodes further
downstream of the <code class="docutils literal notranslate"><span class="pre">target</span></code>.</p>
</div></blockquote>
<ul class="simple">
<li><p>オブジェクトトークンは ObjectNodes によってしか受理されなければならない。</p></li>
<li><p>制御トークンは ExecutableNodes によってしか受理されなければならない。</p></li>
</ul>
<p>ControlNode の用途：</p>
<blockquote>
<div><p>ControlNodes are used to control the routing of offers through a network of
ActivityEdges, controlling the flow of accepted tokens.</p>
</div></blockquote>
<p>節点と辺には名前があるが、一意的とは限らない：</p>
<blockquote>
<div><p>ActivityNodes and ActivityEdges may be named, however, the <code class="docutils literal notranslate"><span class="pre">nodes</span></code> and
<code class="docutils literal notranslate"><span class="pre">edges</span></code> of an Activity are not required to have unique names within that
Activity.</p>
</div></blockquote>
<p>類似する節点に同じ名前を付けるなど、便利なことがあるらしい。</p>
<p>Activity は Namespace の一種であり、その <code class="docutils literal notranslate"><span class="pre">members</span></code> は区別できる必要があるのだが、Activity の <code class="docutils literal notranslate"><span class="pre">nodes</span></code> と <code class="docutils literal notranslate"><span class="pre">edges</span></code> は <code class="docutils literal notranslate"><span class="pre">ownMembers</span></code> ではなく
<code class="docutils literal notranslate"><span class="pre">ownElements</span></code> であるため、この必要性は節点と辺の名前付けに影響しない。</p>
<blockquote>
<div><p>Even though an Activity is a Namespace (a Behavior is a Class, which is a
Classifier, which is a Namespace), and the members of a Namespace are
required to be distinguishable (see sub clause 7.4), this constraint does not
affect the naming of Activity nodes and edges because the nodes and edges of
an Activity are ownedElements but not ownedMembers of the Activity.</p>
</div></blockquote>
<p>Activities は Classes であり、次のような Properties を支援することが許される：</p>
<ul class="simple">
<li><p>工程の実行時間、コストなど。</p></li>
<li><p>実行者、完了報告先、使用中の資源のような、オブジェクトに関するリンクを指定する
Associations</p></li>
<li><p>開始、停止、中断などのオブジェクトの実行を管理する Operations</p></li>
<li><p>開始、一時停止などの実行の状態を決定する StateMachines</p></li>
</ul>
</section>
<section id="activity-nodes">
<h4><a class="toc-backref" href="#id44" role="doc-backlink">15.2.3.2 Activity Nodes</a><a class="headerlink" href="#activity-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>ActivityNodes are used to model the individual steps in the behavior
specified by an Activity.</p>
</div></blockquote>
<p>ActivityNode が実行される条件にはトークンが関係している：</p>
<blockquote>
<div><p>An ActivityNode is enabled to begin execution when specified conditions are
satisfied on the tokens offered to it on <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdges; the
conditions depend on the kind of node. When an ActivityNode begins execution,
tokens are accepted from some or all of its <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdges and a
token is <em>placed on</em> the node.</p>
</div></blockquote>
<p>節点が実行を完了すると、トークンはそこから除去されて、この節点の <code class="docutils literal notranslate"><span class="pre">outgoing</span></code>
ActivityEdges の一部または全部に供給される。</p>
<p>ActivityNodes の実行順序について：</p>
<blockquote>
<div><p>All restrictions on the relative execution order of two or more ActivityNodes
are explicitly constrained by ActivityEdge relationships. If two
ActivityNodes are not ordered by ActivityEdge relationships, -略- they may
execute concurrently.</p>
</div></blockquote>
<p>本文で言う concurrent は一貫して there is no required order in which … の意味にとるのがいい。</p>
<p>先のトークン一意性が次の仕様に効いてくる：</p>
<blockquote>
<div><p>As an ActivityNode may be the <code class="docutils literal notranslate"><span class="pre">source</span></code> for multiple ActivityEdges, the same
token can be offered to multiple <code class="docutils literal notranslate"><span class="pre">targets</span></code>. However, the same token can
only be accepted at one <code class="docutils literal notranslate"><span class="pre">target</span></code> at a time</p>
</div></blockquote>
<p>トークン一つが同時に複数の ActivityNodes に供給された場合、そのうちの高々一つの
ActivityNode が受理するものとする。どの節点に受理されるかは Activity 流通意味によっては完全には決定されない。</p>
<p>ActivityNodes には以下の三種類がある：</p>
<dl>
<dt>ControlNodes</dt><dd><p>ActivityEdges 上のトークンの流通を管理する交通スイッチとして機能する。トークンは ControlNodes 上で休止することは不可能だ。</p>
</dd>
<dt>ObjectNodes</dt><dd><p><code class="docutils literal notranslate"><span class="pre">incoming</span></code> ObjectFlows から受理したオブジェクトトークンを保持して、その後それらを <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ObjectFlows に対して捧げることがある。ControlFlow については設計者が指定した例外がある (15.4)。</p>
</dd>
<dt>ExecutableNodes</dt><dd><p>Activity の所望の挙動を実際に実施する。</p>
<blockquote>
<div><p>If an ExecutableNode has <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ControlFlows, then there must be
tokens <em>offered</em> on all these flows that it accepts before beginning
execution. While executing, an ExecutableNode is considered to hold a
single control token indicating it is executing. When it completes
execution, it offers control tokens on all <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ControlFlows. All
<code class="docutils literal notranslate"><span class="pre">incoming</span></code> and <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges of an ExecutableNode must be
ControlFlows.</p>
</div></blockquote>
</dd>
</dl>
</section>
<section id="activity-edges">
<h4><a class="toc-backref" href="#id45" role="doc-backlink">15.2.3.3 Activity Edges</a><a class="headerlink" href="#activity-edges" title="Permalink to this heading">¶</a></h4>
<p>ActivityEdge の定義と言っていい：</p>
<blockquote>
<div><p>An ActivityEdge is a directed connection between two ActivityNodes along
which tokens may flow, from the <code class="docutils literal notranslate"><span class="pre">source</span></code> ActivityNode to the <code class="docutils literal notranslate"><span class="pre">target</span></code>
ActivityNode.</p>
</div></blockquote>
<p>トークンと辺の関連：</p>
<blockquote>
<div><p>Tokens are <em>offered</em> to an ActivityEdge by the <code class="docutils literal notranslate"><span class="pre">source</span></code> ActivityNode of the
edge. Offers propagate through ActivityEdges and ControlNodes, according to
the rules associated with ActivityEdges (see below) and each kind of
ControlNode (see sub clause 15.3) until they reach an ObjectNode (for object
tokens) or an ExecutableNode (for control tokens and some object tokens as
specified by modelers, see ObjectNodes in sub clause 15.4).</p>
</div></blockquote>
<p>ObjectNode および ExecutableNode の各種には、供給されたトークンがいつ受理されるかの規則がある。この種の節点がトークンを受理すると、そのトークンは最初の供給元
ActivityNode から受理側 ActivityNode に流れる。</p>
<p>辺に対するガードの概念：</p>
<blockquote>
<div><p>An ActivityEdge may have a <code class="docutils literal notranslate"><span class="pre">guard</span></code>, which is a ValueSpecification that is
evaluated for each token offered to the edge. An offer shall only pass along
an ActivityEdge if the <code class="docutils literal notranslate"><span class="pre">guard</span></code> for the edge evaluates to true for the
offered token.</p>
</div></blockquote>
<p>ガードのない辺は任意のトークンに対して真と評価されるガードのある辺と等価だ。</p>
<p>ガートは一般的には DecisionNodes で用いられるが、どの ActivityEdge でも用いてよい。</p>
<p>トークンの流通量を辺の <code class="docutils literal notranslate"><span class="pre">weight</span></code> が規定することがある：</p>
<blockquote>
<div><p>Any number of tokens can pass along an ActivityEdge, in groups at one time,
or individually at different times. The <code class="docutils literal notranslate"><span class="pre">weight</span></code> property dictates the
minimum number of tokens that must traverse the edge at the same time. It is
a ValueSpecification that is evaluated every time a new token is offered by
the <code class="docutils literal notranslate"><span class="pre">source</span></code> ActivityNode. It must evaluate to a positive
LiteralUnlimitedNatural and may be a constant.</p>
</div></blockquote>
<p>トークン供給が失敗する状況。All or nothing 方式か：</p>
<blockquote>
<div><p>If the ActivityEdge has a <code class="docutils literal notranslate"><span class="pre">guard</span></code>, the <code class="docutils literal notranslate"><span class="pre">guard</span></code> must evaluate to true for
each token offered to the edge that counts towards the minimum. If the
<code class="docutils literal notranslate"><span class="pre">guard</span></code> fails for any of the tokens, and this reduces the number of tokens
that can be offered to the <code class="docutils literal notranslate"><span class="pre">target</span></code> to less than the <code class="docutils literal notranslate"><span class="pre">weight</span></code>, then all
the tokens fail to be offered.</p>
</div></blockquote>
<ul class="simple">
<li><p>無制限の場合にはトークンは辺を流れる前にすべて受理されなければならない。</p></li>
<li><p>辺に重みが指定されていない場合、それに 1 を指定することと同値とする。</p></li>
</ul>
<p>ActivityEdges には以下の二種類がある：</p>
<dl>
<dt>ControlFlow</dt><dd><p>制御トークンしか渡さない ActivityEdge だ。ActivityNodes の実行を明示的に順序立てるために用いられる。</p>
</dd>
<dt>ObjectFlow</dt><dd><p>オブジェクトトークンがそれに沿って引き渡すことができる ActivityEdge
だ。ObjectNodes 間の値の流通をモデル化する。</p>
<blockquote>
<div><p>Tokens are offered to the <code class="docutils literal notranslate"><span class="pre">target</span></code> ActivityNode in the same order as
they are offered from the <code class="docutils literal notranslate"><span class="pre">source</span></code>. If multiple tokens are offered at
the same time, then the tokens are offered in the same order as if they
had been offered one at a time from the <code class="docutils literal notranslate"><span class="pre">source</span></code>. If the <code class="docutils literal notranslate"><span class="pre">source</span></code> is
an ObjectNode with an ordering specified, then tokens from the <code class="docutils literal notranslate"><span class="pre">source</span></code>
are offered to the ObjectFlow in that order and, consequently, are offered
from the ObjectFlow to the <code class="docutils literal notranslate"><span class="pre">target</span></code> in the same order.</p>
</div></blockquote>
</dd>
</dl>
<p>ControlFlows とは異なり、ObjectFlows は多重送受信、ObjectNodes からのトークン選択、トークン変換に対しての支援をも備えている。</p>
</section>
<section id="object-flows">
<h4><a class="toc-backref" href="#id46" role="doc-backlink">15.2.3.4 Object Flows</a><a class="headerlink" href="#object-flows" title="Permalink to this heading">¶</a></h4>
<p>オブジェクトトークンの立場から ObjectFlow を理解すると：</p>
<blockquote>
<div><p>Object tokens pass over ObjectFlows, carrying data through an Activity via
their values, or carrying no data (<em>null tokens</em>).</p>
</div></blockquote>
<p>空トークンはオプションの値を生成しなかったことを明示的に示す目的などに用いられる。</p>
<p>ObjectFlow は変換動作を有することがある：</p>
<blockquote>
<div><p>An ObjectFlow may have a <code class="docutils literal notranslate"><span class="pre">transformation</span></code> Behavior that has a single input
Parameter and a single output Parameter. If a <code class="docutils literal notranslate"><span class="pre">transformation</span></code> Behavior is
specified, then the Behavior is invoked for each object token offered to the
ObjectFlow, with the value in the token passed to the Behavior as input (for
a null token, the behavior is invoked but no value is passed). The output of
the Behavior is put in an object token that is offered to the <code class="docutils literal notranslate"><span class="pre">target</span></code>
ActivityNode instead of the original object token.</p>
</div></blockquote>
<ul class="simple">
<li><p>変換動作の出力引数の多重度上限値が 1 以上であり、この変換が複数値を生成する場合、値それぞれが別々のオブジェクトトークンに入れられ、すべてが <code class="docutils literal notranslate"><span class="pre">target</span></code> に渡される。</p></li>
<li><p>出力引数の多重度下限値が 0 で、この変換が値を生成しない場合、<code class="docutils literal notranslate"><span class="pre">target</span></code> に空トークンが供給される。</p></li>
</ul>
<p>ObjectFlow は選択動作を有することがある：</p>
<blockquote>
<div><p>An ObjectFlow may have a <code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior that has a single input
Parameter and a single output Parameter. The input Parameter of the Behavior
must be unordered, nonunique and have a multiplicity of <code class="docutils literal notranslate"><span class="pre">0..*</span></code> (a “bag”),
and the output Parameter must have a multiplicity upper bound of 1.</p>
</div></blockquote>
<p>ObjectFlow に新しいトークンが供給されたり撤回されたりするたびに、ObjectFlow に現在供給されているオブジェクトトークンすべての値が Behavior の入力 Parameter に渡され、<code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior が呼び出される。この選択動作は入力された値の中から一つ選択し、出力する。この出力値はオブジェクトトークンに入れられ、<code class="docutils literal notranslate"><span class="pre">target</span></code>
ActivityNode に渡される。<code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior が出力を生成しない場合、空トークンが渡される。</p>
<p>ObjectFlow に <code class="docutils literal notranslate"><span class="pre">transformation</span></code> と <code class="docutils literal notranslate"><span class="pre">selection</span></code> の両方があるならば：</p>
<blockquote>
<div><p>then the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> Behavior is invoked first when a new token is
offered to the ObjectFlow and the resulting value is used in the invocation
of the <code class="docutils literal notranslate"><span class="pre">selection</span></code> behavior.</p>
</div></blockquote>
<p>トークンが <code class="docutils literal notranslate"><span class="pre">target</span></code> 節点に向けて与えられる間に <code class="docutils literal notranslate"><span class="pre">transformation</span></code> または
<code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior が使われるので、そのトークンが <code class="docutils literal notranslate"><span class="pre">target</span></code> 節点に受け入れられる前に何度も同じトークンで実行されることがある。この事は、その Behavior に副作用があってはならないことを意味する。</p>
<blockquote>
<div><p>but transformations may for example, navigate from one object to another, get
an attribute value from an object, or replace a data value with another.</p>
</div></blockquote>
<p>多重送信と多重受信：</p>
<blockquote>
<div><p>Multicasting and multireceiving are used in conjunction with
ActivityPartitions (see sub clause 15.6) to model flows between Behaviors
that are the responsibility of objects determined by a publish and subscribe
facility. However, the particular publish/subscribe semantics used are not
specified in this standard.</p>
</div></blockquote>
</section>
<section id="variables">
<h4><a class="toc-backref" href="#id47" role="doc-backlink">15.2.3.5 Variables</a><a class="headerlink" href="#variables" title="Permalink to this heading">¶</a></h4>
<p>ObjectFlows が Activity 内でデータを移動するための主な手段であるならば、
Variables はデータを間接的に引き渡すための代替法だと言える。</p>
<ul class="simple">
<li><p>Activity の実行中、この Activity の Variables のそれぞれは一つ以上の値を保持することが許される。Variables に値を書き込み、その後 Variables から値を読み取る
Actions がある (16.9)。</p></li>
<li><p>Activity の Variables は Namespace としての Activity の <code class="docutils literal notranslate"><span class="pre">ownMembers</span></code> であるが、この Activity に対して局所的であり、外部からは見えない。</p></li>
</ul>
<p>間接的なデータ移動経路：</p>
<blockquote>
<div><p>The use of a Variable effectively provides indirect data flow paths from the
point at which a value is written to the Variable to all the points at which
the value is read from the Variable.</p>
</div></blockquote>
<p>Variable は ConnectableElement の一種であり、それ自体が TypedElement だ。
Variable に保持される値はいずれも Variable の Type と適合しなければならない。
<a class="reference internal" href="ch11-structured-classifiers.html"><span class="doc">11 Structured Classifiers</span></a> および <a class="reference internal" href="ch07-common-structure.html"><span class="doc">7 Common Structure</span></a> 参照。</p>
<p>Variable は MultiplicityElement でもある。<a class="reference internal" href="ch07-common-structure.html"><span class="doc">7 Common Structure</span></a> 参照。</p>
<p>Variable に値を書き込む唯一の方法が Activity 内の Actions であるため、多重度の強制が必ずしも可能とは限らない。</p>
</section>
<section id="activity-execution">
<h4><a class="toc-backref" href="#id48" role="doc-backlink">15.2.3.6 Activity Execution</a><a class="headerlink" href="#activity-execution" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>An Activity may have <code class="docutils literal notranslate"><span class="pre">precondition</span></code> and <code class="docutils literal notranslate"><span class="pre">postcondition</span></code> Constraints, as
inherited from Behavior (see sub clause 13.2).</p>
</div></blockquote>
<ul class="simple">
<li><p>これらは Activity の全呼び出しに対して大局的に適用される。</p></li>
<li><p>Activity 内の Actions は局所的 <code class="docutils literal notranslate"><span class="pre">precondition</span></code> と <code class="docutils literal notranslate"><span class="pre">postcondition</span></code> を持つことがある。</p></li>
</ul>
<p>Behavior であるので、Activity には Parameters があってもよい。このような
Parameter それぞれに対し、Activity には対応する ActivityParameterNode という節点がある。</p>
<ul class="simple">
<li><p>inout Parameter の場合には入力用と出力用の二つを持つ。</p></li>
<li><p>ActivityParameterNode は Activity 内で Parameter の値を入手できるようにする
ObjectNode だ。</p></li>
</ul>
<p>Activity が呼び出されると、入力 Parameters に渡された値がオブジェクトトークンに置かれ、Activity の対応する入力 ActivityParameterNode に置かれる。</p>
<ul class="simple">
<li><p>入力 Paramters に値がない場合は空トークンが置かれる。</p></li>
<li><p>これらの ActivityParameterNodes はトークンを <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges に与える。</p></li>
</ul>
<p>Activity 呼び出しの最初は、一般の節点はトークンを持っていない：</p>
<blockquote>
<div><p>However, nodes that do not have incoming edges and require no input data to
execute are immediately enabled. A single control token is placed on each
enabled node and they begin executing concurrently. Such nodes include
ExecutableNodes (see sub clause 15.5) with no incoming ControlFlows and no
mandatory input data and InitialNodes (see sub clause 15.3).</p>
</div></blockquote>
<p>次はわかりにくい <code class="docutils literal notranslate"><span class="pre">isSingleExecution</span></code> の仕様だ：</p>
<blockquote>
<div><p>On each subsequent invocation of the Activity, the <code class="docutils literal notranslate"><span class="pre">isSingleExecution</span></code>
property indicates whether the same execution of the Activity handles tokens
for all invocations, or a separate execution of the Activity is created for
each invocation.</p>
</div></blockquote>
<p>単一実行は読んでもよくわからないので飛ばす。既定の個別実行は：</p>
<blockquote>
<div><p>If a separate execution of the Activity is used for each invocation (this is
the default), tokens from the various invocations do not interact. For
example, an Activity that is a <code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code> is invoked when the
Classifier is instantiated (see sub clause 13.2),</p>
</div></blockquote>
<p>Activity に <code class="docutils literal notranslate"><span class="pre">streaming</span></code> Parameters がある場合、単一実行の途中であっても（対応する ActivityParameterNodes を経て）トークンがその Activity に出入りすることがある。</p>
<p><code class="docutils literal notranslate"><span class="pre">streaming</span></code> Parameters のない Activity の実行が完了するのは、実行している節点がすでになく、実行可能節点がないときか、または ActivityFinalNode (15.3) を用いることで明示的に停止されたときだ。その他方：</p>
<blockquote>
<div><p>The execution of an Activity with streaming input Parameters shall not
terminate until the cumulative number of values posted to each of those input
Parameters (by the invoker of the Activity) is at least equal to the
Parameter multiplicity lower bound. The execution of an Activity with
streaming output Parameters shall not terminate until the cumulative number
of values posted to each of those output Parameters (by the Activity itself)
is at least equal to the Parameter multiplicity lower bound.</p>
</div></blockquote>
<p>完了時の出力：</p>
<blockquote>
<div><p>When the execution of an Activity completes, all ActivityParameterNodes
corresponding to non-streaming output Parameters shall hold at least as many
non-null object tokens as given by the corresponding Parameter multiplicity
lower bound.</p>
</div></blockquote>
<p>各出力 ActivityParameterNode のオブジェクトトークンに関連付けられた値は、対応する出力 Parameter で Activity から渡され、Activity の呼び出し元が利用できるようになる。</p>
<p>出力引数が例外の場合：</p>
<blockquote>
<div><p>An output Parameter may also be identified as an <em>exception</em> Parameter by
having <code class="docutils literal notranslate"><span class="pre">isException</span></code> = true (see sub clause 9.4).</p>
</div></blockquote>
<ul class="simple">
<li><p>例外 Parameter に送られた出力は Behavior の他の出力 Parameters に送られることを妨げる。</p></li>
<li><p>例外 Parameter に関連付けられた出力 ActivityParameterNode にオブジェクトトークンが到着する場合、Activity の実行は直ちに停止する。トークンの値は例外
Parameter に渡されるが、非 streaming Parameter に関連付けられた他の出力
ActivityParameterNodes 上のトークンは失われ、その値は関連 Parameters に渡されない。</p></li>
<li><p>Activity が停止する前に streaming 出力 Parameters に送られた値は影響を受けない。</p></li>
</ul>
<p>例外を使用する状況は：</p>
<blockquote>
<div><p>Use exception Parameters on Activities only if it is desired to abort all
flows in the Activity. For example, if the same execution of an activity is
being used for all its invocations (i.e., <code class="docutils literal notranslate"><span class="pre">isSingleExecution</span></code> = true), then
multiple streams of tokens will be flowing through the same Activity.</p>
</div></blockquote>
<p>この場合、一つが例外出力に到達したからというだけで、流れのすべてを中断することはまず望ましくない。</p>
<blockquote>
<div><p>Arrange for separate invocations of the Activity to use separate executions
of the Activity (i.e., <code class="docutils literal notranslate"><span class="pre">isSingleExecution</span></code> = false) when employing
exception Parameters, so flows from separate executions will not affect each
other.</p>
</div></blockquote>
</section>
<section id="activity-generalization">
<h4><a class="toc-backref" href="#id49" role="doc-backlink">15.2.3.7 Activity Generalization</a><a class="headerlink" href="#activity-generalization" title="Permalink to this heading">¶</a></h4>
<p>Activity は Classifier であり、Generalization 関係に関与してよい。</p>
<blockquote>
<div><p>A specialized Activity inherits the <code class="docutils literal notranslate"><span class="pre">nodes</span></code> and <code class="docutils literal notranslate"><span class="pre">edges</span></code> of its general
Activities. ActivityNodes and ActivityEdges are RedefinableElements (see sub
clause 9.2) that may be redefined in a specialized Activity.</p>
</div></blockquote>
<p>再定義は置き換えということか：</p>
<blockquote>
<div><p>An ActivityNode in a specialized Activity that redefines an ActivityNode from
a general Activity is considered to replace the redefined ActivityNode for
any inherited ActivityEdges that had the redefined ActivityNode as a source
or target.</p>
</div></blockquote>
<p>総体的 Activity から ActivityEdge を再定義する ActivityEdge は、再定義先の
ActivityEdge を到着または出発辺として持っていた継承先 ActivityNode のいずれに対しても再定義元 ActivityEdge を置き換えるとみなされる。</p>
<blockquote>
<div><p>If the redefined ActivityEdge is an incoming or outgoing edge for any
ActivityNode that is not inherited but is itself redefined, then the
ActivityEdge is replaced for the redefining ActivityNode.</p>
</div></blockquote>
<p>特殊化 Activity の実行に用いられる節点と辺の有効な集合は、継承先節点と辺（再定義元節点と辺を含まない）と、その特殊 Activity で定義された節点と辺（再定義先節点と辺を含む）との和集合だ。</p>
<blockquote>
<div><p>The execution of the specialized Activity then proceeds as usual, but using a
graph of nodes and edges constructed from the union sets.</p>
</div></blockquote>
</section>
</section>
<section id="notation">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">15.2.4 Notation</a><a class="headerlink" href="#notation" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>This notation is optional in that a conforming tool may use a textual
concrete syntax instead.</p>
</div></blockquote>
<p>Activity の記法は ActivityNodes と ActivityEdges の記法の組み合わせに加え、枠線と左上に表示される名前を加えたものだ。</p>
<ul>
<li><p>ActivityParameterNodes は Activity の枠線上に表示する。</p></li>
<li><p>Behavior から継承した事前条件と事後条件を、キーワード <code class="docutils literal notranslate"><span class="pre">«precondition»</span></code>,
<code class="docutils literal notranslate"><span class="pre">«postcondition»</span></code> と共にテキスト上の式としてそれぞれ示す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSingleExecution</span></code> が真 Activities については、キーワード
<code class="docutils literal notranslate"><span class="pre">«singleExecution»</span></code> を用いる。</p>
<blockquote>
<div><p>Figure 15.2 Activity notation</p>
</div></blockquote>
</li>
<li><p>図の丸角縁は <a class="reference internal" href="ana-diagrams.html"><span class="doc">Annex A: Diagrams</span></a> で述べられた枠記法で置き換えてよい。</p></li>
<li><p>丸角縁にせよ枠にせよ完全に省略してよい。その場合には ActivityParameterNodes
は図式内のどこに現れてもよい。</p>
<blockquote>
<div><p>Figure 15.3 Activity class notation</p>
</div></blockquote>
</li>
</ul>
<p>この図のように Classes を表す表記法を Activity の特徴を図表化するのに利用することもある。キーワードは <code class="docutils literal notranslate"><span class="pre">«activity»</span></code> だ。</p>
<blockquote>
<div><p>Figure 15.4 ActivityNode notation</p>
</div></blockquote>
<p>ActivityNodes 各種の記法のカタログ。次の節と <a class="reference internal" href="ch16-actions.html"><span class="doc">16 Actions</span></a> で詳しく議論する。</p>
<blockquote>
<div><p>Figure 15.5 ActivityEdge notation</p>
</div></blockquote>
<p>ActivityEdges 各種の記法のカタログ。</p>
<ul class="simple">
<li><p>鏃はすべて開いた形状を用いる。</p></li>
<li><p>辺に名前がある場合は矢印の近くに表記する。</p></li>
<li><p>イラストにはないが <code class="docutils literal notranslate"><span class="pre">guards</span></code> を記すには矢印末尾にある角括弧の中にテキスト表示する。</p></li>
</ul>
<blockquote>
<div><p>Figure 15.6 ActivityEdge connector notation</p>
</div></blockquote>
<p>ActivityEdge は連結器を使って記すことも許されている。連結器は辺の名前が中に書かれた小さい丸だ。この記法はまともに描くと矢印が長くなるときに採用すればよい。</p>
<p>ラベルの付いたすべての接続器は、同一 Activity 図で同一ラベルのついた他のものの正確に一つに対して対になっていなければならない。</p>
<blockquote>
<div><p>Figure 15.7 ActivityEdge notation</p>
</div></blockquote>
<p>ActivityEdge の重みは中括弧で囲んで表記する：</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nc">weight-annotation</span><span class="p">&gt;</span> :: =‘{’ ‘weight’ ‘=’ <span class="p">&lt;</span><span class="nc">value-specification</span><span class="p">&gt;</span> ‘}’
</pre></div>
</div>
<p>重みは定数であってもよい値仕様であり、ゼロでない無制限の自然数として評価される。無制限の重みは <code class="docutils literal notranslate"><span class="pre">*</span></code> と表記される。<a class="reference internal" href="ch08-values.html"><span class="doc">ValueSpecifications</span></a> の記法を参照。</p>
<p>InterruptibleActivityRegion の <code class="docutils literal notranslate"><span class="pre">interruptingEdge</span></code> は稲妻型の矢印とする。
(15.6) も参照。</p>
<blockquote>
<div><p>Figure 15.8 ControlFlow notation</p>
</div></blockquote>
<p>制御フローは二つの行動を接続する矢印で示す。</p>
<blockquote>
<div><p>Figure 15.9 ObjectFlow notations</p>
</div></blockquote>
<p>オブジェクトフローも矢印として示す。この図の右上と下は同じ意味。(16.2) も参照。
Pins を用いる記法のほうがよい？</p>
<blockquote>
<div><p>Figure 15.10 Specifying selection behavior on an ObjectFlow</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior の記法にはキーワード <code class="docutils literal notranslate"><span class="pre">«selection»</span></code> を註釈記号に入れ、適切な ObjectFlow 記号に取り付けて指定する。</p>
<p><code class="docutils literal notranslate"><span class="pre">transformation</span></code> Behavior も同様に、キーワードは <code class="docutils literal notranslate"><span class="pre">«transformation»</span></code> を使って指定する。</p>
<p>コメントとしては Behavior をテキスト表現したもの（例えば OpaqueBehavior の本文など）やテキスト的に表現されていない Behavior の名前を書いてもよい。</p>
<blockquote>
<div><p>Figure 15.11 Eliding objects flowing on the edge</p>
</div></blockquote>
<p>複雑な図式では乱雑さを避けるために Pins を省略してよい。省略されていることを示唆するために、小さい正方形を矢印の上に表示してよい。</p>
<p><code class="docutils literal notranslate"><span class="pre">effect</span></code> のような、通常 Pin の近くにあるような装飾を流線の端子に表示することが可能だ。</p>
<p>多重送信および多重受信はそれぞれ ObjectFlow に <code class="docutils literal notranslate"><span class="pre">«multicast»</span></code> または
<code class="docutils literal notranslate"><span class="pre">«multireceive»</span></code> と註釈を付すことで指定する。</p>
</section>
<section id="examples">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">15.2.5 Examples</a><a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 15.12 Activity node example (where the arrowed lines are the only
non-activity node symbols)</p>
</div></blockquote>
<p>次の種類の ActivityNodes の記法の見本となる。</p>
<ul class="simple">
<li><p>ExecutableNodes: <code class="docutils literal notranslate"><span class="pre">Receive</span> <span class="pre">Order</span></code>, <code class="docutils literal notranslate"><span class="pre">Fill</span> <span class="pre">Order</span></code>, etc.</p></li>
<li><p>ObjectNodes: <code class="docutils literal notranslate"><span class="pre">Invoice</span></code></p></li>
<li><p>ControlNodes:</p>
<ul>
<li><p>InitialNode: 先頭の黒丸</p></li>
<li><p>DecisionNode: 始めの方のダイヤモンド</p></li>
<li><p>ForkNode, JoinNode: Ship Order 前後の縦棒</p></li>
<li><p>MergeNode: 終わりの方のダイヤモンド</p></li>
<li><p>ActivityFinalNode: 末尾の目玉</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>Figure 15.13 ActivityEdge examples</p>
</div></blockquote>
<p>矢印は ControlFlow か ObjectFlow だ。</p>
<p>左上。<code class="docutils literal notranslate"><span class="pre">Fill</span> <span class="pre">Order</span></code> と <code class="docutils literal notranslate"><span class="pre">Ship</span> <span class="pre">Order</span></code> を結ぶ矢印は ControlFlow 辺だ。<code class="docutils literal notranslate"><span class="pre">Fill</span>
<span class="pre">Order</span></code> が完了すると <code class="docutils literal notranslate"><span class="pre">Ship</span> <span class="pre">Order</span></code> に制御が移ることを示している。<code class="docutils literal notranslate"><span class="pre">Filled</span></code> とあるのは辺の名前だ。</p>
<p>左下のも同じ意味。矢印をマル A で接続している。</p>
<p>右上。ObjectNode <code class="docutils literal notranslate"><span class="pre">Invoice</span></code> の前後にある矢印は両方 ObjectFlow だ。<code class="docutils literal notranslate"><span class="pre">Invoice</span></code>
オブジェクトが <code class="docutils literal notranslate"><span class="pre">Send</span> <span class="pre">Invoice</span></code> から <code class="docutils literal notranslate"><span class="pre">Make</span> <span class="pre">Payment</span></code> へ移動することを示す。</p>
<blockquote>
<div><p>Figure 15.14 ObjectFlow example</p>
</div></blockquote>
<p>両者の意味は同じ。オブジェクト <code class="docutils literal notranslate"><span class="pre">Order</span></code> の移動を暗示している。目新しいのは右側：</p>
<blockquote>
<div><p>The example on the right has one arrowed line starting from a <code class="docutils literal notranslate"><span class="pre">Fill</span> <span class="pre">Order</span></code>
OutputPin (an ObjectNode) and ends at a <code class="docutils literal notranslate"><span class="pre">Ship</span> <span class="pre">Order</span></code> InputPin.</p>
</div></blockquote>
<p>左側の <code class="docutils literal notranslate"><span class="pre">Order</span></code> が CentralBufferNode ではないという仮定が必要だが。</p>
<blockquote>
<div><p>Figure 15.15 Eliding objects flowing on the edge</p>
</div></blockquote>
<p>省略版だとオブジェクトの個数に関わらず小さい正方形が一つになる？</p>
<blockquote>
<div><p>Figure 15.16 Specifying <code class="docutils literal notranslate"><span class="pre">selection</span></code> and <code class="docutils literal notranslate"><span class="pre">transformation</span></code> Behaviors on an
ObjectFlow</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">selection</span></code> および <code class="docutils literal notranslate"><span class="pre">transformation</span></code> Behaviors の見本。註釈頼み。</p>
<ul class="simple">
<li><p>左の図は <code class="docutils literal notranslate"><span class="pre">Order</span></code> が <code class="docutils literal notranslate"><span class="pre">Order</span> <span class="pre">Priority</span></code> に基づいて出荷され、同じ優先度のものは FIFO 方式でなるべく <code class="docutils literal notranslate"><span class="pre">Filled</span></code> されることを示す。</p></li>
<li><p>右の図は <code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Order</span></code> の結果 <code class="docutils literal notranslate"><span class="pre">Closed</span></code> な <code class="docutils literal notranslate"><span class="pre">Order</span></code> を生成する。<code class="docutils literal notranslate"><span class="pre">Send</span>
<span class="pre">Customer</span> <span class="pre">Notice</span></code> は <code class="docutils literal notranslate"><span class="pre">Customer</span></code> オブジェクトを必要とする。この変換は
<code class="docutils literal notranslate"><span class="pre">Order</span></code> を受け取り、関連する <code class="docutils literal notranslate"><span class="pre">Customer</span></code> オブジェクトを生成する問い合わせ操作の呼び出しを指定する。</p></li>
</ul>
<blockquote>
<div><p>Figure 15.17 Linking a class diagram to an object node</p>
</div></blockquote>
<p>Activity 図内の ObjectNode <code class="docutils literal notranslate"><span class="pre">Order</span></code> と、Class <code class="docutils literal notranslate"><span class="pre">Order</span></code> を述べるクラス図とのリンクを表現している。</p>
<blockquote>
<div><p>The class diagram shows that filling an order requires order, line item, and
the customer’s trim-and-finish requirements.</p>
</div></blockquote>
<p>とあるが、この図式からそこまでは読み取れないだろう？</p>
<blockquote>
<div><p>Figure 15.18 Specifying multicast and multireceive on the edge</p>
</div></blockquote>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">«multicast»</span></code> と <code class="docutils literal notranslate"><span class="pre">«multireceive»</span></code> の見本。</p>
<p><code class="docutils literal notranslate"><span class="pre">RFQs</span></code> は特定の複数 <code class="docutils literal notranslate"><span class="pre">Seller</span></code> に送信され、各 <code class="docutils literal notranslate"><span class="pre">Seller</span></code> による見積もり回答が求められる。その後、いくつかの <code class="docutils literal notranslate"><span class="pre">Seller</span></code> が <code class="docutils literal notranslate"><span class="pre">Quote</span> <span class="pre">Responses</span></code> を返す。複数の応答を受信することができるため、辺には <code class="docutils literal notranslate"><span class="pre">«multireceive»</span></code> オプションのラベルが付けられる。</p>
<blockquote>
<div><p>Publish/subscribe and other brokered mechanisms can be handled using the
multicast and multireceive mechanisms.</p>
</div></blockquote>
<p>スイムレーンは送信者と受信者を示す重要な機能だ。</p>
<blockquote>
<div><p>Figure 15.19 ActivityEdge connector example</p>
</div></blockquote>
<p>図式中の fork と merge の間にまともに矢印を描くのは面倒なので、このようなワープのような記法の支援がある。</p>
<blockquote>
<div><p>Figure 15.20 Equivalent model</p>
</div></blockquote>
<p>Fig. 15.19 のワープ記法不採用版。</p>
<blockquote>
<div><p>Figure 15.21 ActivityEdge weight examples</p>
</div></blockquote>
<p>左上。定数 <code class="docutils literal notranslate"><span class="pre">weight</span></code> を要求する。11 人いないと Form Cricket Team 不能。</p>
<p>右上。変数 <code class="docutils literal notranslate"><span class="pre">weight</span></code> を要求する。</p>
<p>下。入札期間が終わるとイベント <code class="docutils literal notranslate"><span class="pre">Ready</span> <span class="pre">to</span> <span class="pre">award</span> <span class="pre">bid</span></code> が発生し、<code class="docutils literal notranslate"><span class="pre">Award</span> <span class="pre">Bid</span></code> が入札すべてを一度に受け取り、落札する一件を選ぶ。この凹五角形節点の記法の意味はまだやっていない？</p>
<blockquote>
<div><p>Figure 15.22 Example of an activity with input parameter</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Requested</span> <span class="pre">Order</span></code> とあるのが入力引数に対応する ActivityParameterNode だ。呼び出しのすべてが同じ実行を使用する。</p>
<blockquote>
<div><p>Figure 15.23 Part selection workflow example</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Standards</span> <span class="pre">Engineer</span></code> は <code class="docutils literal notranslate"><span class="pre">Provide</span> <span class="pre">Required</span> <span class="pre">Part</span></code> の部分段階が指定された順序、指定された条件下で実施されることを保証するが、その段階を必ずしも実施するわけではない。<code class="docutils literal notranslate"><span class="pre">Standards</span> <span class="pre">Engineer</span></code> が工程を管理していても、この部分段階のいくつかは
<code class="docutils literal notranslate"><span class="pre">Design</span> <span class="pre">Engineer</span></code> が実施する。</p>
<p><code class="docutils literal notranslate"><span class="pre">Expert</span> <span class="pre">Part</span> <span class="pre">Search</span></code> では、部品が見つかる場合と見つからない場合がある。見つからない場合は <code class="docutils literal notranslate"><span class="pre">Assign</span> <span class="pre">Standards</span> <span class="pre">Engineer</span></code> が呼び出される。</p>
<p><code class="docutils literal notranslate"><span class="pre">Specify</span> <span class="pre">Part</span> <span class="pre">Mod</span> <span class="pre">Workflow</span></code> は、実行される作業を表す <code class="docutils literal notranslate"><span class="pre">Activity</span></code> のオブジェクトである値を生成する。これらは、スケジューリングと実行のために後続のアクションに渡される (e.g. <code class="docutils literal notranslate"><span class="pre">Schedule</span> <span class="pre">Part</span> <span class="pre">Mod</span> <span class="pre">Workflow</span></code>, <code class="docutils literal notranslate"><span class="pre">Execute</span> <span class="pre">Part</span> <span class="pre">Mod</span> <span class="pre">Workflow</span></code>,
<code class="docutils literal notranslate"><span class="pre">Research</span> <span class="pre">Production</span> <span class="pre">Possibility</span></code>)。</p>
<blockquote>
<div><p>As Activities are Classes, instances of them can be passed in object tokens
and then later be executed. This is an example of runtime Activity
instantiation and execution.</p>
</div></blockquote>
<blockquote>
<div><p>Figure 15.24 Trouble ticket workflow example</p>
</div></blockquote>
<p>よくあるチケット管理の Activity だろう。</p>
<blockquote>
<div><p>Figure 15.25 Activity with attributes and operations</p>
</div></blockquote>
<p>Activity のクラスの特徴を Class の記法で示す見本。</p>
</section>
</section>
<section id="control-nodes">
<h2><a class="toc-backref" href="#id52" role="doc-backlink">15.3 Control Nodes</a><a class="headerlink" href="#control-nodes" title="Permalink to this heading">¶</a></h2>
<section id="id4">
<h3><a class="toc-backref" href="#id53" role="doc-backlink">15.3.1 Summary</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>A ControlNode is a kind of ActivityNode (see sub clause 15.2.2) used to
manage the flow of tokens between other nodes in an Activity.</p>
</div></blockquote>
<p>InitialNodes, FinalNodes, ForkNodes, JoinNodes, MergeNodes, DecisionNodes など、さまざまな ControlNode の具象型について述べられる。</p>
</section>
<section id="id5">
<h3><a class="toc-backref" href="#id54" role="doc-backlink">15.3.2 Abstract Syntax</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 15.26 Control Nodes</p>
</div></blockquote>
<p>ControlNode は ActivityNode から派生した型で、ControlNode からもかなりの数のクラスが派生している。</p>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id55" role="doc-backlink">15.3.3 Semantics</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<section id="initial-node">
<h4><a class="toc-backref" href="#id56" role="doc-backlink">15.3.3.1 Initial Node</a><a class="headerlink" href="#initial-node" title="Permalink to this heading">¶</a></h4>
<p>InitialNode の定義：</p>
<blockquote>
<div><p>An InitialNode is a ControlNode that acts as a starting point for executing
an Activity.</p>
</div></blockquote>
<p>Activity に InitialNode が複数あっても構わない。その場合、Activity を呼び出すと
InitialNode のそれぞれに対して一つずつ、複数の同時制御フローが開始する。</p>
<blockquote>
<div><p>An InitialNode shall not have any <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdges</p>
</div></blockquote>
<p>Activity が所有する InitialNode はこの Activity が実行を開始すると常に有効になり、そのような InitialNode のそれぞれに制御トークンが一つずつ置かれる。</p>
<p>InitialNode の <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges はすべてが ControlFlows でなければならない。InitialNode に配置された制御トークンはすべて <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ControlFlows に同時に供給される。</p>
<blockquote>
<div><p>InitialNodes are an exception to the rule that ControlNodes cannot “hold”
tokens, but only manage their flow.</p>
</div></blockquote>
</section>
<section id="final-nodes">
<h4><a class="toc-backref" href="#id57" role="doc-backlink">15.3.3.2 Final Nodes</a><a class="headerlink" href="#final-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A FinalNode is a ControlNode at which a flow in an Activity stops.</p>
</div></blockquote>
<ul class="simple">
<li><p>FinalNode には <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges がないものとする。</p></li>
<li><p>FinalNode は <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdges で供給されたトークンすべてを受理する。</p></li>
</ul>
<p>FinalNode には FlowFinalNode と ActivityFinalNode の二種類がある。</p>
<p>FlowFinalNode とは一つの流れを停止する FinalNode だ。FlowFinalNode が受理したトークンは全て破壊される。Activity 内の他の流れには影響しない。</p>
<p>ActivityFinalNode とは Activity の流れすべてを停止する節点だ。</p>
<ul>
<li><p>Activity が所有する ActivityFinalNode にトークンが到達すると、その Activity の実行が停止する。</p>
<blockquote>
<div><p>If an Activity owns more than one ActivityFinalNode, then the first one to
accept a token (if any) terminates the execution of the Activity, including
the execution of any other ActivityFinalNodes.</p>
</div></blockquote>
</li>
<li><p>Activity の実行が停止すると、出力 ActivityParameterNodes 以外の ObjectNodes に保持されているトークンをすべて破壊し、かつ、Activity から同期的に呼び出されている Behaviors の実行を停止する。ただし非同期的に呼び出されている Behaviors の実行には影響しない。</p></li>
<li><p>Activity の実行が停止すると、15.2.3 節で述べたようにその Activity の呼び出しが完了する。</p></li>
</ul>
<p>Activity の流れの全てを中止するのが望みでなければ、FlowFinalNode を使う。
ActivityFinalNode は使わない。</p>
</section>
<section id="fork-nodes">
<h4><a class="toc-backref" href="#id58" role="doc-backlink">15.3.3.3 Fork Nodes</a><a class="headerlink" href="#fork-nodes" title="Permalink to this heading">¶</a></h4>
<p>ForkNode の定義。前後の辺の本数と性質に注意：</p>
<blockquote>
<div><p>A ForkNode is a ControlNode that splits a flow into multiple concurrent
flows. A ForkNode shall have exactly one <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdge, though it
may have multiple <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges. If the <code class="docutils literal notranslate"><span class="pre">incoming</span></code> edge is a
ControlFlow, then all <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edges shall be ControlFlows and, if the
<code class="docutils literal notranslate"><span class="pre">incoming</span></code> edge is an ObjectFlow, then all <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edges shall be
ObjectFlows.</p>
</div></blockquote>
<p>ForkNode とトークンの関係：</p>
<blockquote>
<div><p>Tokens offered to a ForkNode are offered to all <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges of
the node. If at least one of these offers is accepted, the offered tokens are
removed from their original source and the acceptor receives a copy of the
tokens. Any other offer that was not accepted on an <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge due to
the failure of the target to accept it remains pending from that edge and may
be accepted by the target at a later time. These edges effectively accept
separate copies of the offered tokens, and offers made to the edges shall
stand to their targets in the order in which they were accepted by the edge
(first in, first out).</p>
</div></blockquote>
<p>これは ActivityEdges が下流への移動をブロックされている場合、トークンを保持できないという規則の例外だ。ForkNodes から出る ActivityEdge は保留中の供給がすべて目標に受理されるまで、受理したトークンを保持し続ける。</p>
<ul class="simple">
<li><p>目標ではなく、それらの <code class="docutils literal notranslate"><span class="pre">guard</span></code> の失敗が原因で供給を受理されなかった
<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges は、それらのトークンの複製を受理しないものとする。</p></li>
<li><p>ForkNode から出発した ActivityEdges に <code class="docutils literal notranslate"><span class="pre">guards</span></code> が使われている場合、防御された辺を通過するトークンの到着に下流 JoinNodes が依存しないように設計する必要がある。それが回避できない場合には、ForkNode とその防御のある辺の間に
DecisionNode をなるべく導入し、防御が失敗する場合にトークンが下流 JoinNode に退避させるようにする。</p></li>
</ul>
</section>
<section id="join-nodes">
<h4><a class="toc-backref" href="#id59" role="doc-backlink">15.3.3.4 Join Nodes</a><a class="headerlink" href="#join-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A JoinNode is a ControlNode that synchronizes multiple flows.</p>
</div></blockquote>
<ul class="simple">
<li><p>JoinNode には厳密に一つの <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdge があるが、<code class="docutils literal notranslate"><span class="pre">incoming</span></code>
ActivityEdges が複数あることは許される。</p></li>
<li><p>JoinNode の <code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺のどれかが ObjectFlows である場合、<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺は ObjectFlow であるものとする。そうでない場合は <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺は ControlFlow
であるものとする。</p></li>
</ul>
<p>次に <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> を理解する：</p>
<blockquote>
<div><p>Join nodes may have a <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code>, which is a ValueSpecification that
determines the condition under which the join will emit a token.</p>
</div></blockquote>
<ul class="simple">
<li><p>JoinNode が <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> を持つ場合、この ValueSpecification は JoinNode に新しいトークンが供給されるたびに評価される。この評価は、評価中に新しいトークンが供給されても中断されないものとし、同時評価が開始されないものとする。</p></li>
<li><p>ValueSpecification は真偽値で評価されなければならない。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> ValueSpecification がテキスト式で与えられる場合、<code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺の名前を次のものを示すために使ってよい：</p>
<ul class="simple">
<li><p>ControlFlow からの供給の有無を示す真偽値</p></li>
<li><p>ObjectFlow から供給されたオブジェクトトークンに関連付けられた値（あれば）</p></li>
</ul>
<p>別の方法としては、<code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> は一つの真偽値演算子の名前を持つ Expression で構成され、オペランドは指定されない。</p>
<p><code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> を持たない場合：</p>
<blockquote>
<div><p>If a JoinNode does not have a <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code>, then this is equivalent to a
<code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> Expression with the Boolean operator “and.”</p>
</div></blockquote>
<p>つまり、暗黙の既定 <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> 条件は、<code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdge のそれぞれに少なくとも一つのトークンが与えられていることだ。</p>
<p>JoinNode の <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> が真の場合に何が起こるのか：</p>
<blockquote>
<div><p>If the (implicit or explicit) <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> of a JoinNode evaluates to true,
then tokens are offered on the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdge of the JoinNode
according to the following rules:</p>
</div></blockquote>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺に供給されるトークンがすべて制御トークンである場合、その一つが
<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺に供給される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺に供給されるトークンの一部が制御トークンで、多がオブジェクトトークンである場合、オブジェクトトークンのみが <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺に与えられる。</p>
<blockquote>
<div><p>Tokens are offered on the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge in the same order they were
offered to the join. If <code class="docutils literal notranslate"><span class="pre">isCombinedDuplicate</span></code> is true for the JoinNode,
then before object tokens are offered to the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge, those
containing objects with the same identity are combined into one token.</p>
</div></blockquote>
</li>
</ol>
<p>この規則を同じ <code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺から供給される複数トークンの場合を含め、JoinNode
に供給されるトークンすべてに適用する。</p>
<p>トークンが出発辺に供給されると何が起こるか：</p>
<blockquote>
<div><p>If any tokens are offered to the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdge of a JoinNode,
they shall be accepted by the target or rejected for traversal over the edge
(e.g., due to a failed guard) before any more tokens are offered to the
<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge.</p>
</div></blockquote>
<ul class="simple">
<li><p>トークンが縦断拒否された場合、それらはもはや <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺に供給されないものとする。</p></li>
<li><p>JoinNode がその <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺でトークンを供給することを遮断されている場合、不要な <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> 評価を省略することが許される。</p></li>
</ul>
</section>
<section id="merge-nodes">
<h4><a class="toc-backref" href="#id60" role="doc-backlink">15.3.3.5 Merge Nodes</a><a class="headerlink" href="#merge-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A MergeNode is a control node that brings together multiple flows without
synchronization.</p>
</div></blockquote>
<ul class="simple">
<li><p>MergeNode には厳密に一つの <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdge があるものとする。</p></li>
<li><p>MergeNode の <code class="docutils literal notranslate"><span class="pre">incoming</span></code> と <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> の辺の型は一致しているものとする。
MergeNode の <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺が ControlFlow ならば <code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺はすべて
ControlFlows でなければならず、<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺が ObjectFlow ならば
<code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺はすべて ObjectFlows でなければならない。</p></li>
</ul>
<p>MergeNode の <code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺に供給されたトークンはすべて、<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺に供給される。流れの同期またはトークンの結合はない。</p>
</section>
<section id="decision-nodes">
<h4><a class="toc-backref" href="#id61" role="doc-backlink">15.3.3.6 Decision Nodes</a><a class="headerlink" href="#decision-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A DecisionNode is a ControlNode that chooses between <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> flows.</p>
</div></blockquote>
<p>DecisionNode は少なくとも一つ、多くても二つの <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdge と、少なくとも一つの <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdge を持たなければならない。</p>
<p>二つある到着辺は平等に扱わない：</p>
<blockquote>
<div><p>If it has two <code class="docutils literal notranslate"><span class="pre">incoming</span></code> edges, then one shall be identified as the
<code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code>, the other being called the <em class="dfn">primary incoming
edge</em>.</p>
</div></blockquote>
<p>DecisionNode の <code class="docutils literal notranslate"><span class="pre">incoming</span></code> 辺が一つだけの場合、それが主到着辺となる。</p>
<ul class="simple">
<li><p>主到着辺が ControlFlow である場合、<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺はすべて ControlFlow でなければならない。</p></li>
<li><p>主到着辺が ObjectFlow である場合、<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺はすべて ObjectFlow でなければならない。</p></li>
</ul>
<p>DecisionNode はトークンをどう処理するか：</p>
<blockquote>
<div><p>A DecisionNode accepts tokens on its primary incoming edge and offers them to
all its <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edges. However, each token offered on the primary
incoming edge shall traverse at most one <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge. Tokens are not
duplicated.</p>
</div></blockquote>
<p>DecisionNode の <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺のいずれかにガードがある場合、これらのガードは各到着トークンに対して評価される。</p>
<ul class="simple">
<li><p>評価順序は定義されておらず、同時に評価されることがある。</p></li>
<li><p>DecisionNode の主到着辺が ObjectFlow で、DecisionNode が <code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> または <code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code> を持っていない場合、到着オブジェクトトークンに含まれる値は、<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ObjectFlow のガードの評価に使用されることがある。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code> の役割：</p>
<blockquote>
<div><p>If a DecisionNode has a <code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code>, then a token must be offered
on both the primary incoming edge and the <code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code> before the
token from the primary incoming edge is offered to the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edges.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> という Bahavior があることがある：</p>
<blockquote>
<div><p>If a DecisionNode has a <code class="docutils literal notranslate"><span class="pre">decisionInput</span></code>, then this must be a Behavior with
a return Parameter and no other output Parameters.</p>
</div></blockquote>
<p>この Behavior はトークンが入力されるたびに呼び出され、Behavior が返す結果は出発辺の <code class="docutils literal notranslate"><span class="pre">guards</span></code> の評価で利用できる。</p>
<p><code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> は副作用を持ってはならない。オブジェクトを修正してはならないが、例えば、オブジェクトから属性値を取得するために、あるオブジェクトから別のオブジェクトに回航することはできる。</p>
<blockquote>
<div><p>If the primary incoming edge of a DecisionNode is a ControlFlow, and the
DecisionNode has a <code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> but not a <code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code>, then
the <code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> shall have no input Parameters.</p>
</div></blockquote>
<p>ところが、DecisionNode に <code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> と <code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code> の両方がある場合、<code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> には入力 Parameter が一つあり、Behavior が呼び出されると、<code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code> で供給されるオブジェクトトークンに含まれる値がこの
Parameter を介して渡されるものとする。</p>
<p>DecisionNode の主到着辺上に供給されるトークンは流通経路に制限がある：</p>
<blockquote>
<div><p>A token offered on the primary incoming edge of a DecisionNode shall not
traverse any <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge for which the <code class="docutils literal notranslate"><span class="pre">guard</span></code> evaluates to false.</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">guard</span></code> を持たないか、または真と評価される <code class="docutils literal notranslate"><span class="pre">guard</span></code> を持つ出発辺が複数存在する場合、到着トークンはこれらの辺の高々一つを渡らなければならない。</p></li>
<li><p>遮断されていない出発辺のちょうど一つの対象がトークンを受理する場合、トークンは対応する辺を通過し、他のすべての供給は撤回される。</p></li>
<li><p>複数の複数が同時にトークンを受理した場合、トークンは受理した複数に対応する辺の一つだけを渡る。どの辺を渡るかはこの仕様では決定されない。</p></li>
</ul>
<p>非決定的な挙動を回避するべく、設計者は <code class="docutils literal notranslate"><span class="pre">incoming</span></code> トークンそれぞれに対して高々一つの <code class="docutils literal notranslate"><span class="pre">guard</span></code> が真であると評価されるようになるべく取り決めることだ。</p>
<p>真偽テストの短絡評価が認められている：</p>
<blockquote>
<div><p>If it can be ensured that only one <code class="docutils literal notranslate"><span class="pre">guard</span></code> will evaluate to true, a
conforming implementation is not required to evaluate the <code class="docutils literal notranslate"><span class="pre">guards</span></code> on all
outgoing edges once one has been found to evaluate to true.</p>
</div></blockquote>
<p>DecisionNode 限定で <code class="docutils literal notranslate"><span class="pre">else</span></code> という定義済み <code class="docutils literal notranslate"><span class="pre">guard</span></code> が使われることがある：</p>
<blockquote>
<div><p>For use only with DecisionNodes, a predefined <code class="docutils literal notranslate"><span class="pre">guard</span></code> “else” (represented
as an Expression with “else” as its operator and no operands) may be used for
at most one <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge. This guard evaluates to true only if the token
is not accepted by any other <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge from the DecisionNode.</p>
</div></blockquote>
</section>
</section>
<section id="id7">
<h3><a class="toc-backref" href="#id62" role="doc-backlink">15.3.4 Notation</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<section id="initial-and-final-nodes">
<h4><a class="toc-backref" href="#id63" role="doc-backlink">15.3.4.1 Initial and Final Nodes</a><a class="headerlink" href="#initial-and-final-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.27 InitialNode notation</p>
</div></blockquote>
<p>InitialNodes は黒塗りの丸として記す。</p>
<blockquote>
<div><p>Figure 15.28 FinalNode notation</p>
</div></blockquote>
<ul class="simple">
<li><p>ActivityFinalNodes は白丸に囲まれた黒丸として記す。</p></li>
<li><p>FlowFinalNodes はバツが内側にある丸として記す。</p></li>
</ul>
</section>
<section id="fork-and-join-nodes">
<h4><a class="toc-backref" href="#id64" role="doc-backlink">15.3.4.2 Fork and Join Nodes</a><a class="headerlink" href="#fork-and-join-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.29 ForkNode and JoinNode notation</p>
</div></blockquote>
<p>ForkNode と JoinNode の両者に対する表記法は、単に線分だ。この線分に
<code class="docutils literal notranslate"><span class="pre">outgoing</span></code>/<code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdges の記号を必要に応じて接続する。</p>
<blockquote>
<div><p>Figure 15.30 joinSpec notation</p>
</div></blockquote>
<p>JoinNode 上の <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> は JoinNode 記号の近くの註釈で示される。</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nc">join-spec-annotation</span><span class="p">&gt;</span> <span class="o">::=</span> ‘{’ ‘joinSpec’ ‘=’ <span class="p">&lt;</span><span class="nc">value-specification</span><span class="p">&gt;</span> ‘}’
</pre></div>
</div>
<blockquote>
<div><p>Figure 15.31 Combined JoinNode/ForkNode notation</p>
</div></blockquote>
<p>JoinNode と ForkNode の機能はこの図のように同じ節点記号を使って組み合わせることが可能だ。</p>
<blockquote>
<div><p>This notation maps to a model containing a JoinNode with all the <code class="docutils literal notranslate"><span class="pre">incoming</span></code>
ActivityEdges shown in the diagram and one <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdge to a
ForkNode that has all the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges shown in the diagram.</p>
</div></blockquote>
</section>
<section id="merge-nodes-and-decision-nodes">
<h4><a class="toc-backref" href="#id65" role="doc-backlink">15.3.4.3 Merge Nodes and Decision Nodes</a><a class="headerlink" href="#merge-nodes-and-decision-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.32 MergeNode notation</p>
</div></blockquote>
<p>MergeNodes と DecisionNodes の記法は菱形だ。</p>
<ul>
<li><p>MergeNode には二つ以上の <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdges および単一の <code class="docutils literal notranslate"><span class="pre">outgoing</span></code>
ActivityEdge が必要だ。</p></li>
<li><p>DecisionNode には単一の <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdge （<code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code> の可能性を除く）と、複数の <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges が必要だ。</p>
<blockquote>
<div><p>Figure 15.33 DecisionNode notation</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> はキーワード <code class="docutils literal notranslate"><span class="pre">«decisionInput»</span></code> と共に註釈の記法で示す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code> はその流れを註釈するキーワード <code class="docutils literal notranslate"><span class="pre">«decisionInputFlow»</span></code>
によって識別される。</p>
<blockquote>
<div><p>Figure 15.34 Combined MergeNode/DecisionNode notation</p>
</div></blockquote>
</li>
</ul>
<p>MergeNode と DecisionNode の機能は同じ節点記号を用いることで組み合わせることが可能だ。<code class="docutils literal notranslate"><span class="pre">incoming</span></code> 流れの高々一つが <code class="docutils literal notranslate"><span class="pre">decisionInputFlow</span></code> として註釈されることがある。</p>
<blockquote>
<div><p>This notation maps to a model containing a MergeNode with all the
<code class="docutils literal notranslate"><span class="pre">incoming</span></code> edges shown in the diagram and one <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edge to a
DecisionNode that has all the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edges shown in the diagram.</p>
</div></blockquote>
</section>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id66" role="doc-backlink">15.3.5 Examples</a><a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<section id="initial-nodes">
<h4><a class="toc-backref" href="#id67" role="doc-backlink">15.3.5.1 Initial Nodes</a><a class="headerlink" href="#initial-nodes" title="Permalink to this heading">¶</a></h4>
<p>黒丸ノード。</p>
<blockquote>
<div><p>Figure 15.35 InitialNode example</p>
</div></blockquote>
<p>Activity の実行の開始時点において、InitialNode は <code class="docutils literal notranslate"><span class="pre">Receive</span> <span class="pre">Order</span></code>
ExecutableNode に制御を渡す。</p>
</section>
<section id="id9">
<h4><a class="toc-backref" href="#id68" role="doc-backlink">15.3.5.2 Fork and Join Nodes</a><a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h4>
<p>棒ノード二種。</p>
<blockquote>
<div><p>Figure 15.36 ForkNode example</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Fill</span> <span class="pre">Order</span></code> が完了したときに、ForkNode は <code class="docutils literal notranslate"><span class="pre">Ship</span> <span class="pre">Order</span></code> と <code class="docutils literal notranslate"><span class="pre">Send</span> <span class="pre">Invoice</span></code>
の両方に制御を渡す。</p>
<blockquote>
<div><p>Figure 15.37 JoinNode example</p>
</div></blockquote>
<p>JoinNode は <code class="docutils literal notranslate"><span class="pre">Ship</span> <span class="pre">Order</span></code> と <code class="docutils literal notranslate"><span class="pre">Send</span> <span class="pre">Invoice</span></code> の処理を同期するのに使われる。両方が完了したときに <code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Order</span></code> に制御を引き渡す。</p>
<blockquote>
<div><p>Figure 15.38 <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> example</p>
</div></blockquote>
<p>自動販売機の制御が <code class="docutils literal notranslate"><span class="pre">Dispense</span> <span class="pre">Drink</span></code> に引き渡されるには、この <code class="docutils literal notranslate"><span class="pre">joinSpec</span></code> にある条件が満たされる必要がある：</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{joinSpec =
 A and B
 and the total coin value
 inserted is &gt;= drink price}
</pre></div>
</div>
</div></blockquote>
</section>
<section id="merge-and-decision-nodes">
<h4><a class="toc-backref" href="#id69" role="doc-backlink">15.3.5.3 Merge and Decision Nodes</a><a class="headerlink" href="#merge-and-decision-nodes" title="Permalink to this heading">¶</a></h4>
<p>菱形ノード二種。</p>
<blockquote>
<div><p>Figure 15.39 MergeNode example</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Buy</span> <span class="pre">Item</span></code> と <code class="docutils literal notranslate"><span class="pre">Make</span> <span class="pre">Item</span></code> のどちらか一方または両方共が実行されたのかもしれない。</p>
<p>場合によっては <code class="docutils literal notranslate"><span class="pre">Ship</span> <span class="pre">Item</span></code> が二度実行される：</p>
<blockquote>
<div><p>As <em>each</em> completes, control is passed to Ship Item. That is, if only one of
Buy Item or Make Item completes, then Ship Item is executed only once; if
both complete, Ship Item is executed twice</p>
<p>Figure 15.40 DecisionNode example</p>
</div></blockquote>
<p>角括弧を用いることで分岐条件を柔軟に表現できる。</p>
<blockquote>
<div><p>Figure 15.41 DecisionNode example with <code class="docutils literal notranslate"><span class="pre">decisionInput</span></code></p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">decisionInput</span></code> の註釈に分岐条件を書き下している。</p>
<blockquote>
<div><p>As the item has been removed from inventory, the reorder level should also be
checked; and if the actual level falls below a pre-specified reorder point,
more of the same type of item should be reordered.</p>
</div></blockquote>
</section>
<section id="id10">
<h4><a class="toc-backref" href="#id70" role="doc-backlink">15.3.5.4 Final Nodes</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h4>
<p>目玉とマルバツノード。</p>
<blockquote>
<div><p>Figure 15.42 ActivityFinalNode example</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Order</span></code> 完了時に FinalNode に至る。Activity は停止する。</p>
<blockquote>
<div><p>Figure 15.43 ActivityFinalNode example</p>
</div></blockquote>
<p>開始直後の ForkNode で二つの concurrent flows が始まる。</p>
<blockquote>
<div><p>The first one to reach the ActivityFinalNode aborts the other.</p>
</div></blockquote>
<p>とにかくどちらの流れを経ても FinalNode に至る。</p>
<blockquote>
<div><p>Figure 15.44 ActivityFinalNode example</p>
</div></blockquote>
<ul>
<li><p>FinalNode を一つにまとめても図の意味は変わらない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Notify</span> <span class="pre">of</span> <span class="pre">Modification</span></code> からは FinalNode に至らないことに注意（なぜか）。</p>
<blockquote>
<div><p>Figure 15.45 FlowFinalNode example</p>
</div></blockquote>
</li>
</ul>
<p>これは <code class="docutils literal notranslate"><span class="pre">Build</span></code> Component が反復的に実行すると解釈する。それと同時？に
<code class="docutils literal notranslate"><span class="pre">Install</span></code> Component が実行していることに注意。</p>
<blockquote>
<div><p>Figure 15.46 FlowFinalNode and ActivityFinalNode example</p>
</div></blockquote>
<ul class="simple">
<li><p>JoinNode は <code class="docutils literal notranslate"><span class="pre">Ship</span> <span class="pre">Order</span></code> と <code class="docutils literal notranslate"><span class="pre">Accept</span> <span class="pre">Payment</span></code> の両方が完了したときに
MergeNode に制御が渡されることを示す。</p></li>
<li><p>注文が拒否されるたびに、制御は <code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Order</span></code> に渡される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Order</span></code> が完了すると、制御は ActivityFinalNode に渡される。</p></li>
</ul>
<p>ActivityFinalNode に至るとすると、左側のループはもはや実行中ではないはず？</p>
</section>
<section id="various-control-nodes">
<h4><a class="toc-backref" href="#id71" role="doc-backlink">15.3.5.5 Various Control Nodes</a><a class="headerlink" href="#various-control-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.47 ControlNode examples (with accompanying actions and control
flows)</p>
</div></blockquote>
<p>この Activity には既視感がある。</p>
</section>
</section>
</section>
<section id="object-nodes">
<h2><a class="toc-backref" href="#id72" role="doc-backlink">15.4 Object Nodes</a><a class="headerlink" href="#object-nodes" title="Permalink to this heading">¶</a></h2>
<section id="id11">
<h3><a class="toc-backref" href="#id73" role="doc-backlink">15.4.1 Summary</a><a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>An ObjectNode is a kind of ActivityNode (see sub clause 15.2.2) used to hold
value-containing object tokens during the course of the execution of an
Activity.</p>
</div></blockquote>
<p>本節ではその具象型三種 ActivityParameterNodes, CentralBufferNodes,
DataStoreNodes ばかりでなく、ObjectNode 一般の話を述べる。</p>
<p>ObjectNode の四番目の種類である Pins は、常に Actions に関連付けられる。
<a class="reference internal" href="ch16-actions.html"><span class="doc">16 Actions</span></a> で述べられる。</p>
</section>
<section id="id12">
<h3><a class="toc-backref" href="#id74" role="doc-backlink">15.4.2 Abstract Syntax</a><a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 15.48 Object Nodes</p>
</div></blockquote>
<p>ObjectNode と関連する要素の役割を理解したい。</p>
</section>
<section id="id13">
<h3><a class="toc-backref" href="#id75" role="doc-backlink">15.4.3 Semantics</a><a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h3>
<section id="id14">
<h4><a class="toc-backref" href="#id76" role="doc-backlink">15.4.3.1 Object Nodes</a><a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h4>
<p>ObjectNode は Activity の実行中にオブジェクトトークンを保持する。</p>
<ul class="simple">
<li><p>ObjectNode が保持するトークンは <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdges から到着する。</p></li>
<li><p>ObjectNode が保持するトークンは <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges を出発することが許される。</p></li>
<li><p>トークンは <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺の一つしか通過していくことが許されない。</p></li>
</ul>
<p>ObjectNode は値が同じオブジェクトトークンを複数含められる。そのようなトークンは通常は結合しない。</p>
<blockquote>
<div><p>ObjectNodes are TypedElements (see sub clause 7.3).</p>
</div></blockquote>
<ul class="simple">
<li><p>ObjectNode に <code class="docutils literal notranslate"><span class="pre">type</span></code> が指定されている場合、ObjectNode が保持するオブジェクトトークンはどれも ObjectNode の <code class="docutils literal notranslate"><span class="pre">type</span></code> に適合する値でなければならない。</p></li>
<li><p>指定されていない場合、値はどんな <code class="docutils literal notranslate"><span class="pre">type</span></code> の値であってもよい。</p></li>
<li><p>空トークンは任意の型であるとみなせる。</p></li>
</ul>
<p>ObjectNodes は States の <code class="docutils literal notranslate"><span class="pre">inState</span></code> 集合を指定することも許される。</p>
<blockquote>
<div><p>If such a set is specified, then any object token held by the ObjectNode
shall have a value with a <code class="docutils literal notranslate"><span class="pre">type</span></code> that has or inherits a StateMachine as its
<code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code> that has all of the states in the <code class="docutils literal notranslate"><span class="pre">inState</span></code> set, and
whose instance for the given value shall be in a state configuration
containing all of the States specified in the <code class="docutils literal notranslate"><span class="pre">inState</span></code> set</p>
</div></blockquote>
<p>ObjectNode はその <code class="docutils literal notranslate"><span class="pre">upperBound</span></code> で指定されている場合、それを超える個数のトークンを含むことは許されない。また、この ValueSpecification は UnlimitedNatural 値に評価されるものとする。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">upperBound</span></code> は、トークンが ObjectNode に供給されるたび、または ObjectNode
から削除されるたびに評価される。ObjectNode がすでに保持しているトークンの数が評価された <code class="docutils literal notranslate"><span class="pre">upperBound</span></code> 以上である場合、ObjectNode は保持しているトークンのいくつかが削除されるまで、それ以上のトークンを受理しないものとする。一つ以上のトークンが削除された結果、保持しているトークンの数が評価された <code class="docutils literal notranslate"><span class="pre">upperBound</span></code>
値以下になった場合、ObjectNode は <code class="docutils literal notranslate"><span class="pre">upperBound</span></code> の限界まで保留中の供給を受理することが許される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">upperBound</span></code> が <code class="docutils literal notranslate"><span class="pre">*</span></code> と評価された場合、ObjectNode が保持できるトークン数に制限はない。</p></li>
</ul>
<p>ObjectNode の <code class="docutils literal notranslate"><span class="pre">ordering</span></code> は、この節点が保持するトークンを <code class="docutils literal notranslate"><span class="pre">outgoing</span></code>
ActivityEdges に供給する順序を指定する。この特性には次の値の一つをとる：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unordered</span></code></dt><dd><p>順序を定義しない。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIFO</span></code></dt><dd><p>ObjectNode が受理した順番で <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺に与える。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">LIFO</span></code></dt><dd><p>ObjectNode が受理したのと逆の順番で <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺に与える。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ordered</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior を用いた設計者定義による順序とする。</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">selection</span></code> の仕様：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ordering</span> <span class="pre">==</span> <span class="pre">ordered</span></code> であるとき、かつそのときに限って、ObjectNode には
<code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior があるものとする。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">selection</span></code> は入力 Parameter と出力 Parameter を一つずつ持つものとする。</p>
<ul>
<li><p>この入力 Parameter は多重度 <code class="docutils literal notranslate"><span class="pre">0..*</span></code>, unordered, non-unique である必要がある。</p></li>
<li><p>この出力 Parameter は多重度が <code class="docutils literal notranslate"><span class="pre">1..1</span></code> である必要がある。</p></li>
</ul>
</li>
<li><p>ObjectNode が型付けられていない場合、これらの Parameters も片付けられていないものとする。そうでない場合、入力 Parameter と出力 Parameter はそれぞれ
ObjectNode と同じ <code class="docutils literal notranslate"><span class="pre">type</span></code> か上位型を持つものとする。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">selection</span></code> の実行：</p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior of an ObjectNode is executed whenever a token is
to be offered to the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edges of the node. The values contained in
all the object tokens held by the Object Node are passed as input to the
Behavior invocation.</p>
</div></blockquote>
<p>この Behavior はこれらの値のいずれかを選択して返す。この値を含むオブジェクトトークンが ObjectNode の <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> 辺に供給される。</p>
<p>ObjectNode の <code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior はその <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ObjectFlows の
<code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior によって上書きされる (15.2.3)。</p>
<p>トークンの追い越しに関する記述があるが、よくわからないので省略。</p>
<p>ControlFlow はある性質の ObjectNode に出入りする：</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">isControlType</span></code> = true for an ObjectNode, ControlFlows may be
<code class="docutils literal notranslate"><span class="pre">incoming</span></code> to and <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> from the ObjectNode, objects tokens can come
into or go out of the ObjectNode along ControlFlows, and these tokens can
flow along ControlFlows reached downstream of the ObjectNode.</p>
</div></blockquote>
</section>
<section id="activity-parameter-nodes">
<h4><a class="toc-backref" href="#id77" role="doc-backlink">15.4.3.2 Activity Parameter Nodes</a><a class="headerlink" href="#activity-parameter-nodes" title="Permalink to this heading">¶</a></h4>
<p>Activity は Behavior の一種なので (13.2) Parameters があることがある。</p>
<blockquote>
<div><p>When the Activity is invoked, values may be passed into the Activity
execution on input Parameters (i.e., those with direction in or inout) and
values may be passed out of the Activity execution on output Parameters
(i.e., those with direction inout, out or return).</p>
</div></blockquote>
<p>Activity ではその入出力は ActivityParameterNodes を用いて処理される。</p>
<ul class="simple">
<li><p>ActivityParameterNode それぞれはその節点を所有する Activity の Parameter 一つに関連付けられる。</p></li>
<li><p>ActivityParameterNode の <code class="docutils literal notranslate"><span class="pre">type</span></code> は関連付けられた Parameter の <code class="docutils literal notranslate"><span class="pre">type</span></code> と同じであるものとする。</p></li>
</ul>
<p>ActivityParameterNode はすべてが <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ActivityEdges であるか、すべてが
<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges であるかのどちらかであるものとする。</p>
<blockquote>
<div><p>An ActivityParameterNode with <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> edges is an input
ActivityParameterNode, while an ActivityParameterNode with <code class="docutils literal notranslate"><span class="pre">incoming</span></code> edges
is an output ActivityParameterNode.</p>
</div></blockquote>
<p>Activity が持つ ActivityParameterNodes の内訳：</p>
<blockquote>
<div><p>An Activity shall have one ActivityParameterNode corresponding to each in,
out, or return Parameter and two ActivityParameterNodes for each inout
Parameter.</p>
</div></blockquote>
<ul class="simple">
<li><p>入力 Parameter は 出力 ActivityParameterNode に関連付けてはならない。</p></li>
<li><p>出力または戻り Parameter は入力 ActivityParameterNode に関連付けてはならない（辺が接続されていない ActivityParameterNode に関連付けることは許される）。</p></li>
<li><p>出力 Parameter は高々一つの入力 ActivityParameterNode と高々一つの出力
ActivityParameterNode に関連付けられなければならない。</p></li>
</ul>
<p>オブジェクトトークンが出力 ActivityParameterNode に流れ込むことが考えられる：</p>
<blockquote>
<div><p>An output ActivityParameterNode accepts all tokens offered to it, which are
then placed onto the node. If an output ActivityParameterNode is associated
with a non-streaming Parameter, then, when the execution of the containing
Activity completes, the values contained in the object tokens held by the
ActivityParameterNode are passed out of the execution on the Parameter.</p>
</div></blockquote>
<p>この Parameter に順序が付けられている場合、その値は ActivityParameterNode のトークン順序に対応して順序が付けられる。</p>
<p>Parameter が streaming の場合はどうか。入力 ActivityParameterNode の場合は：</p>
<blockquote>
<div><p>If an input ActivityParameterNode is associated with a streaming Parameter,
then, whenever a new value is posted to the Parameter, that value is wrapped
in an object token, placed on the ActivityParameterNode and offered to all
outgoing edges.</p>
</div></blockquote>
<p>出力 ActivityParameterNode の場合は上記の反対の工程が起こる。</p>
</section>
<section id="central-buffer-nodes">
<h4><a class="toc-backref" href="#id78" role="doc-backlink">15.4.3.3 Central Buffer Nodes</a><a class="headerlink" href="#central-buffer-nodes" title="Permalink to this heading">¶</a></h4>
<p>CentralBufferNode は <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ObjectFlows と <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ObjectFlows の間の緩衝材として機能する。オブジェクトトークンを溜めこんでおく場所だ。</p>
</section>
<section id="data-store-nodes">
<h4><a class="toc-backref" href="#id79" role="doc-backlink">15.4.3.4 Data Store Nodes</a><a class="headerlink" href="#data-store-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A DataStoreNode is a CentralBufferNode that holds its object tokens
persistently while its activity is executing.</p>
</div></blockquote>
<p>DataStoreNode が保持するオブジェクトトークンは下流の ObjectNode が受理すると、そのトークンはまず通常の CentralBufferNode の意味で DataStoreNode から取り除かれる。そのとき、オブジェクトトークンはコピーされてすぐにこの DataStoreNode に戻される。</p>
<blockquote>
<div><p>Thus, the values held by a DataStoreNode appear to persist for the duration
of each execution of its containing activity, even as tokens move downstream
from the node.</p>
</div></blockquote>
<p>DataStoreNode がオブジェクトトークンを受理するとき、そのトークンがすでにその節点が保持するトークンに含まれるオブジェクトと同一の ID を有するオブジェクトを含む場合、重複するオブジェクトトークンが DataStoreNode 上に配置されないものとする。正規の CentralBufferNode とは異なり、DataStoreNode はオブジェクト群を一意に含む。</p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">selection</span></code> and <code class="docutils literal notranslate"><span class="pre">transformation</span></code> Behaviors on <code class="docutils literal notranslate"><span class="pre">outgoing</span></code>
ObjectFlows can be used to get information out of a DataStoreNode as if a
query were being performed.</p>
</div></blockquote>
<p>例えば、<code class="docutils literal notranslate"><span class="pre">selection</span></code> は取得するオブジェクトを特定し、<code class="docutils literal notranslate"><span class="pre">transformation</span></code> はそのオブジェクトの属性値を取得可能だ。</p>
</section>
</section>
<section id="id15">
<h3><a class="toc-backref" href="#id80" role="doc-backlink">15.4.4 Notation</a><a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<section id="id16">
<h4><a class="toc-backref" href="#id81" role="doc-backlink">15.4.4.1 Object Nodes</a><a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.49 ObjectNode notations</p>
</div></blockquote>
<ul class="simple">
<li><p>ObjectNodes は矩形で示す。</p></li>
<li><p>節点をラベル付ける名前を記号の内側に置き、名前は ObjectNode の <code class="docutils literal notranslate"><span class="pre">type</span></code> を示すか、<code class="docutils literal notranslate"><span class="pre">name:type</span></code> の形式で節点の <code class="docutils literal notranslate"><span class="pre">name</span></code> と <code class="docutils literal notranslate"><span class="pre">type</span></code> を示す。</p></li>
<li><p>その型がコレクションを表現する ObjectNode はそのようにラベルすることが許される。</p></li>
<li><p>型として Signal を持つ ObjectNode は矩形ではなく、初心者マークみたいな多角形で示す。左が凹で右が凸。</p></li>
</ul>
<blockquote>
<div><p>Figure 15.50 ObjectNode annotations</p>
</div></blockquote>
<p>ObjectNode に States の <code class="docutils literal notranslate"><span class="pre">inState</span></code> 集合がある場合、この集合にある States の名前は付きカンマ区切りリストとして ObjectNode の名前の下の中括弧内に記述される。</p>
<blockquote>
<div><p>Values for <code class="docutils literal notranslate"><span class="pre">upperBound</span></code>, <code class="docutils literal notranslate"><span class="pre">ordering</span></code> and <code class="docutils literal notranslate"><span class="pre">isControlType</span></code> are notated by
placing an annotation with the following form beneath the ObjectNode symbol
(as shown in Figure 15.50):</p>
</div></blockquote>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nc">object-node-annotation</span><span class="p">&gt;</span> <span class="o">::=</span> ‘{’ <span class="p">&lt;</span><span class="nc">object-node-property</span><span class="p">&gt;</span> ( ‘,’ <span class="p">&lt;</span><span class="nc">object-node-property</span><span class="p">&gt;</span> )* ‘}’
<span class="p">&lt;</span><span class="nc">object-node-property</span><span class="p">&gt;</span> <span class="o">::=</span> ‘upperBound’ ‘=’ <span class="p">&lt;</span><span class="nc">value-specification</span><span class="p">&gt;</span> |
                           ‘ordering’ ‘=’ <span class="p">&lt;</span><span class="nc">object-node-ordering-kind</span><span class="p">&gt;</span> |
                           ‘controlType’
<span class="p">&lt;</span><span class="nc">object-node-ordering-kind</span><span class="p">&gt;</span> <span class="o">::=</span> ‘unordered’ | ‘ordered’ | ‘FIFO’ | ‘LIFO’
</pre></div>
</div>
<blockquote>
<div><p>Figure 15.51 Specifying selection behavior on an ObjectNode</p>
</div></blockquote>
<p>ObjectNode の <code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior は ObjectNode 記号に付属するキーワード
<code class="docutils literal notranslate"><span class="pre">«selection»</span></code> を持つ註釈記号の中で指定される。</p>
</section>
<section id="id17">
<h4><a class="toc-backref" href="#id82" role="doc-backlink">15.4.4.2 Activity Parameter Nodes</a><a class="headerlink" href="#id17" title="Permalink to this heading">¶</a></h4>
<p>ActivityParameterNode は ObjectNode として記されるが、付随する Parameter の完全テキスト仕様が普通の名前・型ラベルの代わりに ActivityParameterNode をラベル付けするのに用いられる。</p>
<blockquote>
<div><p>Figure 15.52 Notation for stream and exception parameters</p>
</div></blockquote>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">streaming</span></code> Parameter に関連する ActivityParameterNode の記法は、文字列
<code class="docutils literal notranslate"><span class="pre">{stream}</span></code> を節点記号の近くに記すものとする。</p></li>
<li><p>例外 Parameter に関連する ActivityParameterNode の記法は、小さな三角を節点記号の近くに記すものとする。</p>
<blockquote>
<div><p>Figure 15.53 Presentation option for flows between pins and parameter nodes</p>
</div></blockquote>
</li>
<li><p>Activity の上側の表現と下側の表現は等価だ。</p></li>
<li><p>Parameters は Activity の境界でやり取りする。</p></li>
</ul>
</section>
<section id="central-buffer-and-data-store-nodes">
<h4><a class="toc-backref" href="#id83" role="doc-backlink">15.4.4.3 Central Buffer and Data Store Nodes</a><a class="headerlink" href="#central-buffer-and-data-store-nodes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.54 Optional CentralBufferNode notation</p>
</div></blockquote>
<p>CentralBufferNode 記号はキーワード <code class="docutils literal notranslate"><span class="pre">«centralBuffer»</span></code> を含んでもよい。</p>
<blockquote>
<div><p>Figure 15.55 DataStoreNode notation</p>
</div></blockquote>
<p>DataStoreNode はキーワード <code class="docutils literal notranslate"><span class="pre">«datastore»</span></code> が付いた ObjectNode として記す。</p>
</section>
</section>
<section id="id18">
<h3><a class="toc-backref" href="#id84" role="doc-backlink">15.4.5 Examples</a><a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h3>
<section id="id19">
<h4><a class="toc-backref" href="#id85" role="doc-backlink">15.4.5.1 Activity Parameter Nodes</a><a class="headerlink" href="#id19" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.56 Example of ActivityParameterNodes for regular and exception
Parameters</p>
</div></blockquote>
<p>ここで見るべきは境界上の節点のみ。<code class="docutils literal notranslate"><span class="pre">Rejected</span> <span class="pre">Computer</span></code> に三角が付いているので、この節点が例外だ。</p>
<blockquote>
<div><p>Figure 15.57 Example of ActivityParameterNodes for streaming Parameters</p>
</div></blockquote>
<p>Fig. 15.55 と似ているが右側が異なる。</p>
<ul class="simple">
<li><p>入出力どちらの ActivityParameterNodes でも <code class="docutils literal notranslate"><span class="pre">streaming</span></code> たり得る。</p></li>
<li><p>ちなみに <code class="docutils literal notranslate"><span class="pre">streaming</span></code> であることと例外であることは両立してはならない。</p></li>
</ul>
</section>
<section id="id20">
<h4><a class="toc-backref" href="#id86" role="doc-backlink">15.4.5.2 Central Buffer and Data Store Nodes</a><a class="headerlink" href="#id20" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.58 CentralBufferNode example</p>
</div></blockquote>
<p>予備部品と採用部品の区別法を示していないことに注意。</p>
<blockquote>
<div><p>All the parts that are not used will be packed as spares, and vice versa,
because each token can only be drawn from the CentralBufferNode by one
outgoing edge. The choice in this example is non-deterministic.</p>
<p>Figure 15.59 DataStoreNode example</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">selection</span></code> Behavior の説明が欲しい。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Once</span> <span class="pre">a</span> <span class="pre">year</span></code> という記号があるが、これは Timer の類だろう。</p></li>
</ul>
<p>AcceptEventAction がその年次制御トークンを生成すると、JoinNode の結合条件が満たされ、<code class="docutils literal notranslate"><span class="pre">Personnel</span> <span class="pre">Database</span></code> からの出発辺が <code class="docutils literal notranslate"><span class="pre">{weight=*}</span></code> であるため、シリアライズされたすべての従業員レコードのオブジェクトトークンが <code class="docutils literal notranslate"><span class="pre">Review</span> <span class="pre">Employee</span></code> に流れることが可能だ。</p>
</section>
</section>
</section>
<section id="executable-nodes">
<h2><a class="toc-backref" href="#id87" role="doc-backlink">15.5 Executable Nodes</a><a class="headerlink" href="#executable-nodes" title="Permalink to this heading">¶</a></h2>
<section id="id21">
<h3><a class="toc-backref" href="#id88" role="doc-backlink">15.5.1 Summary</a><a class="headerlink" href="#id21" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>An ExecutableNode is a kind of ActivityNode that may be executed as a step in
the overall desired behavior of the containing Activity.</p>
</div></blockquote>
<p>一般的に、Activity 内の ControlNodes と ObjectNodes は、シーケンスの制御と
Activity 内の ExecutableNodes 間のデータの流れを管理するために主に存在する。</p>
<p>ExecutableNodes の具象型はすべてが Actions (<a class="reference internal" href="ch16-actions.html"><span class="doc">16 Actions</span></a>) だ。本節では
Activity 内の ExecutableNodes の一般的な意味と、ExecutableNode に
ExceptionHandler を付属させる能力について述べられる。</p>
</section>
<section id="id22">
<h3><a class="toc-backref" href="#id89" role="doc-backlink">15.5.2 Abstract Syntax</a><a class="headerlink" href="#id22" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 15.60 Executable Nodes</p>
</div></blockquote>
<ul class="simple">
<li><p>ExecutableNode は一つの ObjectNode に関連する ExceptionHandlers を所有する。</p></li>
<li><p>ExceptionHandler は Classifiers を例外の型として関連付ける。</p></li>
</ul>
</section>
<section id="id23">
<h3><a class="toc-backref" href="#id90" role="doc-backlink">15.5.3 Semantics</a><a class="headerlink" href="#id23" title="Permalink to this heading">¶</a></h3>
<section id="id24">
<h4><a class="toc-backref" href="#id91" role="doc-backlink">15.5.3.1 Executable Nodes</a><a class="headerlink" href="#id24" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>An ExecutableNode is an ActivityNode that carries out a substantive
behavioral step of the Activity that contains it.</p>
</div></blockquote>
<p>ExecutableNode の <code class="docutils literal notranslate"><span class="pre">incoming</span></code> と <code class="docutils literal notranslate"><span class="pre">outcoming</span></code> はすべて ControlFlow でなければならない。</p>
<p>ExecutableNode はデータを消費したり生産したりすることがあるが、そうするには関連する ObjectNodes を通じたうえでなければならない。</p>
<blockquote>
<div><p>An ExecutableNode shall not execute until all <code class="docutils literal notranslate"><span class="pre">incoming</span></code> ControlFlows (if
any) are offering tokens. That is, there is an implicit join on the
<code class="docutils literal notranslate"><span class="pre">incoming</span></code> Control Flows.</p>
</div></blockquote>
<p>ExecutableNode は実行を開始する前に、<code class="docutils literal notranslate"><span class="pre">incoming</span></code> ControlFlows から供給されるトークンすべてを受理する。複数のトークンが供給されている場合、すべて消費する。</p>
<blockquote>
<div><p>While the ExecutableNode is executing, it is considered to hold a single
control indicating it is execution.</p>
</div></blockquote>
<p>場合によっては ExecutableNode 一つの複数同時実行が一斉に進行することがある
(16.2)。この場合 ExecutableNode は同時実行それぞれに対して制御トークンを一つ保持する。</p>
<p>制御トークンの行方：</p>
<blockquote>
<div><p>When an ExecutableNode completes an execution, the control token representing
that execution is removed from the ExecutableNode and control tokens are
offered on all <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ControlFlows of the ExecutableNode.</p>
</div></blockquote>
<p>つまり、ExecutableNode から <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ControlFlows への制御の流れの暗黙の分岐が存在する。</p>
</section>
<section id="exceptions-and-exception-handlers">
<h4><a class="toc-backref" href="#id92" role="doc-backlink">15.5.3.2 Exceptions and Exception Handlers</a><a class="headerlink" href="#exceptions-and-exception-handlers" title="Permalink to this heading">¶</a></h4>
<p>例外は実行の完了様式が正常ではないことを識別するために用いられる値だ。
ExecutableNode の実行中に例外が発生し、この実行内で処理されない場合、実行は停止され、この例外が当 ExecutableNode の外部へと伝わる。</p>
<p>ExecutableNode は例外処理機能を有することがある：</p>
<blockquote>
<div><p>An ExecutableNode may have one or more ExceptionHandlers that are used to
deal with exceptions that may be propagated out of the ExecutableNode, which
is the <code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> of those <code class="docutils literal notranslate"><span class="pre">handlers</span></code>.</p>
</div></blockquote>
<p>例外が <code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> から伝わると、この <code class="docutils literal notranslate"><span class="pre">handlers</span></code> 集合は例外に合致する処理者を探す。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">handler</span></code> は例外の <code class="docutils literal notranslate"><span class="pre">type</span></code> がその <code class="docutils literal notranslate"><span class="pre">exceptionTypes</span></code> の一つと同じか、またはその派生型である場合に合致する。</p></li>
<li><p>合致する場合、<code class="docutils literal notranslate"><span class="pre">handler</span></code> は例外を捕捉する。</p></li>
<li><p>複数の合致がある場合、厳密に一つの <code class="docutils literal notranslate"><span class="pre">handler</span></code> が捕捉するが、どれであるのかは定義されない。</p></li>
</ul>
<p>例外を捕捉すると何が起こるか：</p>
<blockquote>
<div><p>If an ExceptionHandler catches an exception, the exception is wrapped in an
object token that is placed on the <code class="docutils literal notranslate"><span class="pre">exceptionInput</span></code> ObjectNode for the
handler. The <code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> of the ExceptionHandler is then executed.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> の実行は <code class="docutils literal notranslate"><span class="pre">exceptionInput</span></code> を介して捕捉した例外を入手することが許される。</p>
<p>例外が処理されると次のようにして制御トークンが供給される：</p>
<blockquote>
<div><p>When the <code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> of an ExceptionHandler completes execution after an
exception is caught, control tokens are offered on the <code class="docutils literal notranslate"><span class="pre">outgoing</span></code>
ControlFlows of the <code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> of the ExceptionHandler, in exactly the
same way as if the <code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> completed normally.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> が OutputPins を持つ Action (16.2) である場合、<code class="docutils literal notranslate"><span class="pre">handlerBody</span></code>
も合致する OutputPins を持つ Action でなければならず、<code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> の
OutputPins に置かれたトークンはすべて <code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> の OutputPins に転送される。</p>
<p><code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> は孤立点のようなものだ：</p>
<blockquote>
<div><p>A <code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> shall have no <code class="docutils literal notranslate"><span class="pre">incoming</span></code> or <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> ActivityEdges.
An ExecutableNode acting as a <code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> is not enabled to execute in
any case other than in response to an exception being caught by its handler.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> に対する所有権：</p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> of an ExceptionHandler shall have the same owner as the
<code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> of the ExceptionHandler and shall own the
<code class="docutils literal notranslate"><span class="pre">exceptionInput</span></code> of the ExceptionHandler.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">exceptionInput</span></code> の型は</p>
<ul class="simple">
<li><p>型付けられていないか、</p></li>
<li><p>ExceptionHandler の <code class="docutils literal notranslate"><span class="pre">exceptionTypes</span></code> すべてと同じ型か、</p></li>
<li><p>ExceptionHandler の <code class="docutils literal notranslate"><span class="pre">exceptionTypes</span></code> すべての汎化型だ。</p></li>
</ul>
<blockquote>
<div><p>Typically, the <code class="docutils literal notranslate"><span class="pre">handlerBody</span></code> will be a StructuredActivityNode and the
<code class="docutils literal notranslate"><span class="pre">exceptionInput</span></code> will be an InputPin for it (see sub clause 16.11 on
StructuredActivityNodes).</p>
</div></blockquote>
<p>例外を処理しないとようにするとこうなる：</p>
<blockquote>
<div><p>If an ExecutableNode propagates an exception and the node either has no
<code class="docutils literal notranslate"><span class="pre">handlers</span></code>, or no <code class="docutils literal notranslate"><span class="pre">handler</span></code> matches the propagated exception, then the
exception continues to propagate outward. If the exception is not caught at
all within the execution of the containing Activity, then the Activity
execution terminates and the exception is propagated out of the Activity.</p>
</div></blockquote>
<p>Activity が同期的に呼び出された場合、例外は呼び出し元に伝わる。非同期的に呼び出された場合、例外は失われる。</p>
</section>
</section>
<section id="id25">
<h3><a class="toc-backref" href="#id93" role="doc-backlink">15.5.4 Notation</a><a class="headerlink" href="#id25" title="Permalink to this heading">¶</a></h3>
<section id="id26">
<h4><a class="toc-backref" href="#id94" role="doc-backlink">15.5.4.1 Executable Nodes</a><a class="headerlink" href="#id26" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.61 ExecutableNode notation</p>
</div></blockquote>
<p>ExecutableNode は一般的には丸い角の矩形として描かれる。</p>
<p>Actions のさまざまな種類に対するより特殊な記法は <a class="reference internal" href="ch16-actions.html"><span class="doc">16 Actions</span></a> で述べられる。</p>
</section>
<section id="exception-handlers">
<h4><a class="toc-backref" href="#id95" role="doc-backlink">15.5.4.2 Exception Handlers</a><a class="headerlink" href="#exception-handlers" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.62 ExceptionHandler notation</p>
</div></blockquote>
<p>ExceptionHandler は稲妻記号で描かれる。</p>
<ul>
<li><p>矢印の始点は <code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> だ。</p></li>
<li><p>稲妻の隣に <code class="docutils literal notranslate"><span class="pre">exceptionType</span></code> の名前を記す。</p></li>
<li><p>矢印の終点 <code class="docutils literal notranslate"><span class="pre">exceptionInput</span></code> 節点は小さい正方形で示す。</p></li>
<li><p>複数の ExceptionHandlers を同じ <code class="docutils literal notranslate"><span class="pre">protectedNode</span></code> に取り付けてもかまわない。</p>
<blockquote>
<div><p>Figure 15.63 Alternative ExceptionHandler notation</p>
</div></blockquote>
</li>
</ul>
<p>矢印自体を稲妻にする代わりに、ジグザグマークを普通の矢印に添えて ExceptionHandle
を表記としてもよい。</p>
</section>
</section>
<section id="id27">
<h3><a class="toc-backref" href="#id96" role="doc-backlink">15.5.5 Examples</a><a class="headerlink" href="#id27" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 15.64 ExceptionHandler example</p>
</div></blockquote>
<p>まず逆行列を求め、それからベクトルを乗じることで別のベクトルを得る。</p>
<p>行列が非正則ならば、逆行列演算は失敗するはずで <code class="docutils literal notranslate"><span class="pre">SingularMatrix</span></code> 例外が送出される。この例外は <code class="docutils literal notranslate"><span class="pre">exceptionType</span></code> <code class="docutils literal notranslate"><span class="pre">SingularMatrix</span></code> に対する ExceptionHandler により処理されるが、それは <code class="docutils literal notranslate"><span class="pre">Substitute</span> <span class="pre">Vector1</span> <span class="pre">Action</span></code> を含む領域を実行する。</p>
<p>逆行列演算またはベクトル乗算のどちらかの処理中に <code class="docutils literal notranslate"><span class="pre">Overflow</span></code> 例外が発生すると
<code class="docutils literal notranslate"><span class="pre">Substitute</span> <span class="pre">Vector1</span> <span class="pre">Action</span></code> を含む領域が実行される。</p>
<p>行列演算が例外なしで完了するか、ExceptionHandlers のうちの一つが引き起こしたかに関わらず、次に動作 <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">Results</span></code> が実行される。</p>
</section>
</section>
<section id="activity-groups">
<h2><a class="toc-backref" href="#id97" role="doc-backlink">15.6 Activity Groups</a><a class="headerlink" href="#activity-groups" title="Permalink to this heading">¶</a></h2>
<section id="id28">
<h3><a class="toc-backref" href="#id98" role="doc-backlink">15.6.1 Summary</a><a class="headerlink" href="#id28" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>ActivityGoups are a grouping constructs for ActivityNodes and ActivityEdges.</p>
</div></blockquote>
<p>節点と辺は複数の集団に所属することが可能だ。</p>
<p>本節では ActivityGroup の二つの具象型、 ActivityPartitions と
InterruptibleActivityRegions について述べる。</p>
<p>StructuredActivityNode は ActivityGroup の第三の種類だが、Actions でもある。
<a class="reference internal" href="ch16-actions.html"><span class="doc">16 Actions</span></a> で議論する。</p>
</section>
<section id="id29">
<h3><a class="toc-backref" href="#id99" role="doc-backlink">15.6.2 Abstract Syntax</a><a class="headerlink" href="#id29" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 15.65 ActivityGroups</p>
</div></blockquote>
<ul class="simple">
<li><p>ActivityGroup の特殊型として ActivityPartition と InterruptibleActivityRegion
がある。</p></li>
<li><p>ActivityGroup は <code class="docutils literal notranslate"><span class="pre">subgraph</span></code> を表現するためのものだろう。</p></li>
</ul>
</section>
<section id="id30">
<h3><a class="toc-backref" href="#id100" role="doc-backlink">15.6.3 Semantics</a><a class="headerlink" href="#id30" title="Permalink to this heading">¶</a></h3>
<section id="activity-partitions">
<h4><a class="toc-backref" href="#id101" role="doc-backlink">15.6.3.1 Activity Partitions</a><a class="headerlink" href="#activity-partitions" title="Permalink to this heading">¶</a></h4>
<p>ActivityPartition の定義：</p>
<blockquote>
<div><p>An ActivityPartition is a kind of ActivityGroup for identifying ActivityNodes
that have some characteristics in common. ActivityPartitions can share
contents.</p>
</div></blockquote>
<ul class="simple">
<li><p>多くの場合、業務モデルにおける組織単位に相当する。</p></li>
<li><p>Activity の節点間で特性や資源を割り当てるために用いられることがある。</p></li>
</ul>
<p>ActivityPartitions はモデルのトークン流通に影響を及ぼさない。役目としては：</p>
<blockquote>
<div><p>They constrain and provide a view on the Behaviors invoked due to the
execution of the <code class="docutils literal notranslate"><span class="pre">containedNodes</span></code> and <code class="docutils literal notranslate"><span class="pre">containedEdges</span></code> of the partition,
including Operation calls and Signal sends. This may be due not only to the
execution of explicit InvocationActions (see sub clause 16.3) but also the
implicit invocation of, e.g., <code class="docutils literal notranslate"><span class="pre">transformation</span></code> and <code class="docutils literal notranslate"><span class="pre">specification</span></code>
Behaviors.</p>
</div></blockquote>
<p>この制約は次にあるように、仕切り <code class="docutils literal notranslate"><span class="pre">represents</span></code> 要素の種類によって異なる：</p>
<dl>
<dt>Classifier</dt><dd><p>呼び出し先 Behaviors は <code class="docutils literal notranslate"><span class="pre">represents</span></code> の Classifier のオブジェクトが担う。</p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">context</span></code> of all invoked Behaviors shall be the Classifier.
Operation calls and Signal sends within the partition shall target objects
at runtime that are instances of the Classifier.</p>
</div></blockquote>
</dd>
<dt>InstanceSpecification</dt><dd><p>呼び出し先 Behaviors は <code class="docutils literal notranslate"><span class="pre">represents</span></code> の InstanceSpecification によりモデル化されるオブジェクトが担う。</p>
<ul class="simple">
<li><p>呼び出し先 Behaviors すべての <code class="docutils literal notranslate"><span class="pre">context</span></code> はこの InstanceSpecification の
Classifier であるものとする。</p></li>
<li><p>仕切り内の Operation 呼び出しと Signal 送信は InstanceSpecification によってモデル化されたオブジェクトを対象とするものとする。</p></li>
</ul>
</dd>
<dt>Property</dt><dd><p>呼び出し先 Behaviors は <code class="docutils literal notranslate"><span class="pre">represents</span></code> の Property が保持するオブジェクトが担う。</p>
<ul class="simple">
<li><p>仕切り内の Operation 呼び出しと Signal 送信は実行時にこの Property が保持するオブジェクトを対象とする。</p></li>
<li><p>呼び出しは各値に対して同時に行われたものとして扱われ、そのオブジェクトすべてが完了するまで呼び出しは完了しない。</p></li>
</ul>
</dd>
</dl>
<p>ActivityPartition は上に挙げた以外の他の種類の Elements を表現してもよいが、当仕様書はそれらの意味を定義しない。</p>
<p>ActivityPartition は入れ子になり得る：</p>
<blockquote>
<div><p>An ActivityPartition may have <code class="docutils literal notranslate"><span class="pre">subpartitions</span></code>. If an ActivityPartition has
<code class="docutils literal notranslate"><span class="pre">isDimension</span></code> = true, then it is a dimension partition for its
<code class="docutils literal notranslate"><span class="pre">subpartitions</span></code>.</p>
</div></blockquote>
<p>寸法仕切りは他の ActivityPartitions に含まれてはいけない。</p>
<p>ActivityPartition が Property を表現し、その <code class="docutils literal notranslate"><span class="pre">subpartitions</span></code> が
InstanceSpecifications を表現する場合、この InstanceSpecifications はその
Property が保持する値をモデル化するものとする。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">subpartitions</span></code> で呼び出される Behaviors は、この <code class="docutils literal notranslate"><span class="pre">subpartitions</span></code> の
InstanceSpecification と包含元 ActivityPartition の両方に対して要求される制約と合致しなければならない。例えば</p>
<ul>
<li><p>仕切りは呼び出された Behavior が実行される場所を表す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">subpartitions</span></code> はこの Property に関する <code class="docutils literal notranslate"><span class="pre">Chicago</span></code> のような特定の値を表す。場所 Property は Activity を包含する <code class="docutils literal notranslate"><span class="pre">context</span></code> BehavioredClassifier の
<code class="docutils literal notranslate"><span class="pre">attribute</span></code> であったり、この Activity 自体の <code class="docutils literal notranslate"><span class="pre">attribute</span></code> であったりする。</p></li>
</ul>
</li>
</ul>
<p>ActivityPartition が Classifier の <code class="docutils literal notranslate"><span class="pre">attribute</span></code> である Property を表現し、別の仕切りがこの Property を含むならば、その <code class="docutils literal notranslate"><span class="pre">superPartition</span></code> はその Classifier またはその Classifier を <code class="docutils literal notranslate"><span class="pre">type</span></code> とする Property を表現するものとする。また、
<code class="docutils literal notranslate"><span class="pre">superPartition</span></code> の外部でない <code class="docutils literal notranslate"><span class="pre">subpartitions</span></code> はすべて Classifier の
<code class="docutils literal notranslate"><span class="pre">attributes</span></code> を表すものとする。</p>
<ul class="simple">
<li><p>実行時において、<code class="docutils literal notranslate"><span class="pre">subpatitions</span></code> にある Behaviors の呼び出しの対象は、
<code class="docutils literal notranslate"><span class="pre">superPartition</span></code> が表す Classifier のオブジェクトと同じ <code class="docutils literal notranslate"><span class="pre">attribute</span></code> の値でなければならない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">superPartition</span></code> がこの Classifier を <code class="docutils literal notranslate"><span class="pre">context</span></code> とする包含 Activitity の
<code class="docutils literal notranslate"><span class="pre">partition</span></code> である場合、実行時の実行 Activity の context object はこの
<code class="docutils literal notranslate"><span class="pre">superPartition</span></code> が表す Classifier と同じオブジェクトであるものとする。</p></li>
</ul>
<p>非外部 ActivityPartition が Classifier を表現し、別の仕切りに含まれている場合、その <code class="docutils literal notranslate"><span class="pre">superPartition</span></code> もまた Classifier を表現するものとし、その
<code class="docutils literal notranslate"><span class="pre">subpartition</span></code> の Classifier は次のどちらかでなければならない：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">superPartition</span></code> が表現する Classifier の</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">nestedClassifier</span></code> または</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ownedBehavior</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">superPartition</span></code> が表現する Classifier に関連付けられた複合 Association の端子</p></li>
</ul>
<blockquote>
<div><p>If the latter, then, at runtime, the target for invocations of Behaviors in
the <code class="docutils literal notranslate"><span class="pre">subpartition</span></code>, including Operation calls and Signal sends, shall be
considered to be an instance of the Classifier represented by the
<code class="docutils literal notranslate"><span class="pre">subpartition</span></code> that is linked to an instance of the Classifier represented
by the <code class="docutils literal notranslate"><span class="pre">superPartition</span></code> by the composition Association.</p>
</div></blockquote>
<p>外部 ActivityPartition とは <code class="docutils literal notranslate"><span class="pre">isExternal</span></code> が真であるものだ。これは仕切りの構造の規則に対する作為的な例外だ。</p>
<blockquote>
<div><p>For example, a dimension partition may have partitions showing the parts of a
StructuredClassifier. It can then have an external partition that does not
represent one of the parts, but a completely separate Classifier.</p>
</div></blockquote>
<p>業務モデリングでは外部仕切りを使用して業務外部の実体を模倣できる。</p>
<blockquote>
<div><p>ActivityPartitions may be used in a way that provides enough information for
review by high-level modelers, though not enough for execution. For example,
if a partition represents a Classifier, then Behaviors invoked in that
partition are the responsibility of instances of the Classifier, but the
model may or may not say which instance in particular.</p>
</div></blockquote>
<p>モデルがどれが特定のオブジェクトであるかを名言しないというのがミソだ。Operation
の呼び出しはその Classifier 上の Operation に限定されるが、この呼び出しへの入力
ObjectFlow は稼働中にどのオブジェクトを対象にするべきかを示すのには指定されないかもしれない。</p>
<blockquote>
<div><p>Another option would be to use ActivationPartitions that represent <code class="docutils literal notranslate"><span class="pre">parts</span></code>.
Then, when the Activity executes in the context of a particular object, the
parts of that object at runtime will be used as targets for the Operation
calls and Signal sends, as described above.</p>
</div></blockquote>
</section>
<section id="interruptible-activity-regions">
<h4><a class="toc-backref" href="#id102" role="doc-backlink">15.6.3.2 Interruptible Activity Regions</a><a class="headerlink" href="#interruptible-activity-regions" title="Permalink to this heading">¶</a></h4>
<p>InterruptibleActivityRegion とは Activity の一部分の停止を支援する ActivityGroup
だ。</p>
<ul class="simple">
<li><p>InterruptibleActivityRegion は ActivityNodes しか含まない。</p></li>
<li><p>InterruptibleActivityRegion はその <code class="docutils literal notranslate"><span class="pre">source</span></code> が領域内にあり、その <code class="docutils literal notranslate"><span class="pre">target</span></code>
が領域外にある特定の ActivityEdges を <code class="docutils literal notranslate"><span class="pre">interruptingEdge</span></code> として識別する。</p></li>
</ul>
<blockquote>
<div><p>When a token offered along an interruptingEdge is accepted and traverses that
edge, then the execution of all <code class="docutils literal notranslate"><span class="pre">containedNodes</span></code> of the region is
terminated and all tokens are removed from them.</p>
</div></blockquote>
<p>しかし、<code class="docutils literal notranslate"><span class="pre">interruptingEdge</span></code> を流れるトークンは依然としてその <code class="docutils literal notranslate"><span class="pre">target</span></code> に到着し、さらに領域内の <code class="docutils literal notranslate"><span class="pre">source</span></code> から領域外の <code class="docutils literal notranslate"><span class="pre">target</span></code> へ非割り込み辺を流れる供給トークンも、たとえ流れる間に割り込みが起こっても、依然として``target``に到着する。</p>
<blockquote>
<div><p>AcceptEventActions in the region that do not have <code class="docutils literal notranslate"><span class="pre">incoming</span></code> edges are
enabled only when a token enters the region, even if the token is not
directed at the AcceptEventAction.</p>
<p>Do not use an InterruptibleActivityRegion if it is not desired to abort all
flows in the region in some cases.</p>
</div></blockquote>
<p>例えば <code class="docutils literal notranslate"><span class="pre">isSingleExecution</span></code> が真である Activity において、トークンの流れの複数が同じ Activity を流れることになる。この場合、トークンの一つが領域から離れるからといって、領域内の流れのすべてを中止することはまず望ましくない。</p>
<blockquote>
<div><p>Arrange for separate invocations of the Activity to use separate executions
of the Activity (i.e., <code class="docutils literal notranslate"><span class="pre">isSingleExecution</span></code> = false) when employing
InterruptibleActivityRegions, so tokens from different invocations will not
affect each other.</p>
</div></blockquote>
</section>
</section>
<section id="id31">
<h3><a class="toc-backref" href="#id103" role="doc-backlink">15.6.4 Notation</a><a class="headerlink" href="#id31" title="Permalink to this heading">¶</a></h3>
<section id="id32">
<h4><a class="toc-backref" href="#id104" role="doc-backlink">15.6.4.1 Activity Partitions</a><a class="headerlink" href="#id32" title="Permalink to this heading">¶</a></h4>
<p>ActivityPartition は、通常、水平または垂直の二本の平行線で表記され、一方の端の箱には仕切りを示す名前を記す。</p>
<blockquote>
<div><p>Figure 15.66 ActivityPartition notations</p>
</div></blockquote>
<p>これらの線に挟まれて置かれる ActivityNodes と ActivityEdges のいずれもがその仕切りの中に含まれるとみなされる。この ActivityPartition の表記法は swimlane と俗に言われる (a)。</p>
<p><code class="docutils literal notranslate"><span class="pre">superPartition</span></code> のさらなる仕切りとして <code class="docutils literal notranslate"><span class="pre">subpartitions</span></code> を表現することで階層的な仕切りを表現することができる (b)。</p>
<p>図式は多次元に分割することも可能で、各 swim cell は複数の仕切りの交差となる
(c)。</p>
<blockquote>
<div><p>The partitions within each dimension may be grouped into an enclosing
activity partition with <code class="docutils literal notranslate"><span class="pre">isDimension</span></code> = true, whose name is the dimension
name.</p>
</div></blockquote>
<p>状況によっては、罫線による ActivityPartitions の図式化は現実的ではないことがある。その場合には次に示す代替記法を検討する。</p>
<blockquote>
<div><p>Figure 15.67 ActivityPartition notations</p>
</div></blockquote>
<ol class="loweralpha simple">
<li><p>仕切りの名前を括弧付きで ActivityNode の名前の上に置く。</p></li>
<li><p>外側の仕切りはキーワード <code class="docutils literal notranslate"><span class="pre">«external»</span></code> を付けてラベルする。</p></li>
</ol>
<blockquote>
<div><p>When ActivityPartition swimlane notation is combined with the frame notation
for Activity (see sub clause 15.2.4), the outside edges of the top level
partition swimlanes can be merged with the Activity frame.</p>
</div></blockquote>
</section>
<section id="id33">
<h4><a class="toc-backref" href="#id105" role="doc-backlink">15.6.4.2 Interruptible Activity Regions</a><a class="headerlink" href="#id33" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.68 InterruptableActivityRegion</p>
</div></blockquote>
<ul>
<li><p>InterruptableActivityRegion はその領域に含まれる節点の周囲に描かれる破線丸角矩形で記される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interruptingEdge</span></code> は稲妻 ActivityEdge で表記される。</p>
<blockquote>
<div><p>Figure 15.69 InterruptableActivityRegion alternative notation</p>
</div></blockquote>
</li>
</ul>
<p>先述の通り <code class="docutils literal notranslate"><span class="pre">interruptingEdge</span></code> の矢印を真っ直ぐにしてジグザグマークを添えてもよい。</p>
</section>
</section>
<section id="id34">
<h3><a class="toc-backref" href="#id106" role="doc-backlink">15.6.5 Examples</a><a class="headerlink" href="#id34" title="Permalink to this heading">¶</a></h3>
<section id="id35">
<h4><a class="toc-backref" href="#id107" role="doc-backlink">15.6.5.1 Activity Partitions</a><a class="headerlink" href="#id35" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.70 ActivityPartitions using swimlane notation</p>
</div></blockquote>
<p>いつもの例題に swimlanes を明記したもの。上段が <code class="docutils literal notranslate"><span class="pre">Order</span> <span class="pre">Department</span></code> の担当する
Activity の部分を含む。中段が <code class="docutils literal notranslate"><span class="pre">Account</span> <span class="pre">Department</span></code> で、下段が <code class="docutils literal notranslate"><span class="pre">Customer</span></code>
だ。</p>
<p>仕切りをまたぐ ActivityEdges は、どの <code class="docutils literal notranslate"><span class="pre">subpartitions</span></code> にも含まれない。</p>
<blockquote>
<div><p>Figure 15.71 ActivityPartitions using annotation</p>
</div></blockquote>
<p>先の見本から swimlane を外したもの。</p>
<p>丸括弧とキーワード <code class="docutils literal notranslate"><span class="pre">«external»</span></code> で所属する ActivityPartition がわかる。</p>
<blockquote>
<div><p>Figure 15.72 ActivityPartitions using multidimensional swimlane notation</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Make</span> <span class="pre">Payment</span></code> は <code class="docutils literal notranslate"><span class="pre">Seattle/Accounting</span> <span class="pre">Clerk</span></code> swim cell に含まれているが、その実行者と場所は指定されていない。キーワード <code class="docutils literal notranslate"><span class="pre">«external»</span></code> が付いている。</p>
</section>
<section id="id36">
<h4><a class="toc-backref" href="#id108" role="doc-backlink">15.6.5.2 Interruptible Activity Regions</a><a class="headerlink" href="#id36" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 15.73 InterruptableActivityRegion example</p>
</div></blockquote>
<p>InterruptableActivityRegion と凹五角形記号の組み合わせは使い易そうだ。</p>
<p>受注、記入、出荷の間に注文取消しが起こると、その流れは停止されて <code class="docutils literal notranslate"><span class="pre">Cancel</span>
<span class="pre">Order</span></code> が実行される。</p>
<blockquote>
<div><p>NOTE. If this happens after Fill Order is finished, invoicing might have
already been initiated (due to the ForkNode after Fill Order).</p>
</div></blockquote>
<p>このフローは InterruptibleActivityRegion の外側にあるため、<code class="docutils literal notranslate"><span class="pre">Ship</span> <span class="pre">Order</span></code> が終了しても <code class="docutils literal notranslate"><span class="pre">Cancel</span> <span class="pre">Order</span></code> 要求によって終了することはない。</p>
</section>
</section>
</section>
<section id="classifier-descriptions">
<h2><a class="toc-backref" href="#id109" role="doc-backlink">15.7 Classifier Descriptions</a><a class="headerlink" href="#classifier-descriptions" title="Permalink to this heading">¶</a></h2>
<p>機械生成による節。</p>
</section>
<section id="association-descriptions">
<h2><a class="toc-backref" href="#id110" role="doc-backlink">15.8 Association Descriptions</a><a class="headerlink" href="#association-descriptions" title="Permalink to this heading">¶</a></h2>
<p>機械生成による節。</p>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="ch14-statemachines.html" title="Previous document">14 StateMachines</a>
        </li>
        <li>
          <a href="ch16-actions.html" title="Next document">16 Actions</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">図書・教科書・仕様書ノート</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ou23/index.html">Modern C++ Tutorial: C++ 11/14/17/20 On the Fly 読書ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ノートにまとまっていない書籍類一覧</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">シェルノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v5.html">What’s New In Bash 5 ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">C++ ノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python ノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../youtube-dl.html">youtube-dl 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ソフトウェア・ツール・パッケージ・ライブラリーノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../google-ime.html">Google 日本語入力利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wslg.html">Windows Subsystem for Linux GUI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oh-my-posh.html">Oh My Posh 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ffmpeg/index.html">FFmpeg 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zoom.html">Zoom Cloud Meetings 利用ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">その他</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">テーマ別</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../javascript.html">JavaScript 総合</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Unified Modeling Language 2.5 読書ノート</a><ul>
      <li>Previous: <a href="ch14-statemachines.html" title="previous chapter">14 StateMachines</a></li>
      <li>Next: <a href="ch16-actions.html" title="next chapter">16 Actions</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2023, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>