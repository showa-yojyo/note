
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>13 Common Behavior &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/prefab.css" />
    
    <script src="../_static/mathjax-v3.js"></script>
    <script src="../_static/mermaid.js"></script>
    
    <link rel="next" title="14 StateMachines" href="statemachines.html" />
    <link rel="prev" title="12 Packages" href="packages.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="statemachines.html" title="14 StateMachines"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="packages.html" title="12 Packages"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Unified Modeling Language 2.5 読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">13 Common Behavior</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="common-behavior">
<h1><a class="toc-backref" href="#id11">13 Common Behavior</a><a class="headerlink" href="#common-behavior" title="Permalink to this heading">¶</a></h1>
<p>UML 2.5 pp. 283-302 に関するノート。ノートにあまり時間をかけたくないが、面倒なので見えているテキストを訳す場合がある。</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>誤訳や変な解釈がいかにもありそうなので、発覚次第修正する。</p>
</div>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>個人的に訳すのが厳しい、訳したくない、訳に納得していない英単語集。</p>
<ul class="simple">
<li><p>automaton (n.) ここはそのままカタカナで。「状態機械」は state machine に使いたい。原文では複数形の automata で記されていたとしてもここでは「オートマトン」と書くかもしれない。</p></li>
<li><p>behavior (n.) 「振る舞い」「挙動」「行動」を気まぐれに使い分ける。字数を費やしたくない都合上、「挙動」を多用する。</p></li>
<li><p>context (n.)「文脈」を避けたい場合は「前後」「状況」「背景」「脈絡」など？</p></li>
<li><p>emergent (adj.) 「不意に起こる」ぐらいの意味のはず。</p></li>
<li><p>event (n.) ふつうは「イベント」とするが、当ノートでは実験的に「事象」で統一してみる。イベントプールが事象プールになるが、気にしない。</p></li>
<li><p>invoke (v.), etc. 「発動する」とした。「呼び出す」で十分伝わるかもしれない。</p></li>
<li><p>occurrence(s) (n.) これは instance(s) の Event 版と言える。「出来事」か「発生」か気分次第。</p></li>
<li><p>streaming (n.) これはどうしよう。</p></li>
<li><p>trigger (v.) 何かの引き金になる、何かのきっかけになる、何かを誘発する、等々。</p></li>
</ul>
</div>
<div class="contents topic" id="id3">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#common-behavior" id="id11">13 Common Behavior</a></p>
<ul>
<li><p><a class="reference internal" href="#summary" id="id12">13.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#behaviors" id="id13">13.2 Behaviors</a></p></li>
<li><p><a class="reference internal" href="#events" id="id14">13.3 Events</a></p></li>
<li><p><a class="reference internal" href="#classifier-descriptions" id="id15">13.4 Classifier Descriptions</a></p></li>
<li><p><a class="reference internal" href="#association-descriptions" id="id16">13.5 Association Descriptions</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="summary">
<h2><a class="toc-backref" href="#id12">13.1 Summary</a><a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>この章では UML にある挙動のモデリング全ての根底にある核心の概念を指定する。</p></li>
<li><p>UML は
Behavior, Event そして Trigger という構成要素を与えることで、対応する挙動のモデリングの基礎概念をモデル化する。</p></li>
<li><p>Behavior は動的な変化をモデリングするための根本的な概念である。</p>
<ul>
<li><p>Behavior は直接の発動によってか、挙動を務める (hosts) アクティブオブジェクトの生成によって実行してよい。</p></li>
<li><p>Behavior はまた突発的であってもよく、それら自身が特有の個々の挙動を実施して、ひとつまたはそれを超える関与オブジェクトの相互作用から生じるものである。</p></li>
</ul>
</li>
<li><p>動的な挙動は、特定の時点で起こる興味のある事象に帰着する。</p>
<ul>
<li><p>そういう事象は暗黙でよく、ある値またはある時間の範囲の経過の変化の際に発生する。</p></li>
<li><p>それらは明示的でもよく、操作が呼ばれたり、非同期信号が受信されたりすると発生する。</p></li>
</ul>
</li>
<li><p>事象の発生は新しい挙動のきっかけになることができ、または、もう実行しているの挙動の経路を変えてよい。</p>
<ul>
<li><p>明示的な事象は挙動間の連絡にとっての根本的な仕組みをこうして与えて、そこでは、例えば操作を呼び出すことや信号を送ることのような、ある挙動で実行に移される行動が、別の挙動での応答のきっかけとなり得る。</p></li>
</ul>
</li>
<li><p>この章の残りは Behaviors, Events そして Triggers の基本的 UML モデリングの仕組みのさらなる詳細を述べる。これらの仕組みは後続の章で仕様化される UML の挙動のモデリング構成要素全部の屋台骨を用意する。</p></li>
</ul>
</section>
<section id="behaviors">
<h2><a class="toc-backref" href="#id13">13.2 Behaviors</a><a class="headerlink" href="#behaviors" title="Permalink to this heading">¶</a></h2>
<section id="id4">
<h3>13.2.1 Summary<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>本節では UML での挙動をモデリングするための屋台骨を導入する。
Behavior の具象下位型（後続の章で述べる）は、さまざまな仕組みを用意することで挙動を指定する。</p></li>
<li><p>UML はいろいろな挙動の仕様の仕組みを支援している：</p>
<ul>
<li><p>有限オートマトンをモデル化する StateMachines: <a class="reference internal" href="statemachines.html"><span class="doc">14 StateMachines</span></a></p></li>
<li><p>Petri ネット的グラフを用いて定義される Activities: <a class="reference internal" href="activities.html"><span class="doc">15 Activities</span></a></p></li>
<li><p>事象発生の半順序連続列をモデル化する Interactions: <a class="reference internal" href="interactions.html"><span class="doc">17 Interactions</span></a></p></li>
</ul>
</li>
<li><p>これらの挙動の仕様の仕組みはそれらの表現力および適用性の領域の点で異なる。</p></li>
</ul>
</section>
<section id="abstract-syntax">
<h3>13.2.2 Abstract Syntax<a class="headerlink" href="#abstract-syntax" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Figure 13.1 Behaviors</p>
<ul>
<li><p>Behavior を中心に据えたクラス図。新登場するクラスにはその他に OpaqueBehavior と FunctionBehavior がある。</p></li>
</ul>
</li>
</ul>
<dl class="simple">
<dt>A_classifierBehavior_behavioredClassifier</dt><dd><ul class="simple">
<li><p>BehavioredClassifier から Behavior への関連（単方向）。</p></li>
</ul>
</dd>
<dt>A_method_specification</dt><dd><ul class="simple">
<li><p>BehavioralFeature から Behavior への関連（両方向）。</p></li>
</ul>
</dd>
<dt>A_precondition_behavior</dt><dd><ul class="simple">
<li><p>Behavior から Constraint への composite 関連（単方向）。</p></li>
<li><p>A_ownedRule_context を subsets する。</p></li>
</ul>
</dd>
<dt>A_postcondition_behavior</dt><dd><ul class="simple">
<li><p>Behavior から Constraint への composite 関連（単方向）。</p></li>
<li><p>A_ownedRule_context を subsets する。</p></li>
</ul>
</dd>
<dt>A_ownedParameterSet_behavior</dt><dd><ul class="simple">
<li><p>Behavior から Parameter への関連 composite 関連（単方向）。</p>
<ul>
<li><p>Behavior が非同期的に発動されたならば、挙動の実行が完了するときにはどんな結果値も失われる。</p></li>
</ul>
</li>
<li><p>A_ownedMember_namespace を subsets する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ownedParameter</span></code> は ordered である。</p></li>
</ul>
</dd>
<dt>A_ownedParameterSet_behavior</dt><dd><ul class="simple">
<li><p>Behavior から ParameterSet への関連 composite 関連（単方向）。</p></li>
<li><p>入力 ParameterSets を伴う Behavior は一実行当たり、ひとつの集合の Parameters から入力を受け入れられるだけ。</p></li>
<li><p>出力 ParameterSets を伴う Behavior は一実行当たり、ひとつの集合の Parameters に出力を与えられるだけ。</p></li>
<li><p>A_ownedMember_namespace を subsets する。</p></li>
</ul>
</dd>
<dt>A_ownedBehavior_behavioredClassifier</dt><dd><ul class="simple">
<li><p>BehavioredClassifier から Behavior への composite 関連（単方向）。</p></li>
</ul>
</dd>
<dt>A_context_behavior</dt><dd><ul class="simple">
<li><p>Behavior から BehavioredClassifier への関連（単方向）。</p></li>
</ul>
</dd>
</dl>
</section>
<section id="semantics">
<h3>13.2.3 Semantics<a class="headerlink" href="#semantics" title="Permalink to this heading">¶</a></h3>
<section id="id5">
<h4>13.2.3.1 Behaviors<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>Behavior とは長い時間に亘って動的に発生してよい事象の詳細である。</p>
<ul>
<li><p>Behavior はそれが <code class="docutils literal notranslate"><span class="pre">method</span></code> としてか、それが BehavioredClassifier の <code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code> として実装する BehaviorFeature で直接発動してよい。</p></li>
</ul>
</li>
<li><p>各発動で、発動のため続いて起こる実際の事象の発生列は、
Behavior の詳細に整合性を保っているが、
Behavior についての execution trace と呼ばれる。</p>
<ul>
<li><p>Behavior は正常に完了してよいか、例外の送出を結果として完了してよい。この場合は、Behavior が同期的に起動されたならば、例外は呼び出し側に伝えられる。</p></li>
</ul>
</li>
<li><p>UML では Behaviors は Classes の一種であり、それは Behaviors をオブジェクト化してよいということを意味する。
Behavior のオブジェクトは挙動の実行 (behavior execution) として知られる。</p>
<ul>
<li><p>Behavior を発動することはその Behavior をオブジェクト化することに相当し、
Behavior 実行それぞれに対応する固有の execution trace がある。</p></li>
</ul>
</li>
<li><p>Behavior は Class であるがゆえに、それを特殊化してよいし、自身が StructuralFeatures や BehavioralFeatures を所有してもよい。</p></li>
<li><p>Behavioral を複数回発動してよい。再入可能な (reentrant) Behavior は、その直前の発動が完了するよりも先にもう一度発動されてよい。再入可能でない Behavior は、先の発動が完了していなければ再度発動してはならないものとする。</p></li>
<li><p>Behavior を同期的に、または非同期的に発動してよい。</p></li>
<li><p>Behavior に対する <code class="docutils literal notranslate"><span class="pre">preconditions</span></code> は Behavior が発動される際に
true であるものとする条件を定義する。
<code class="docutils literal notranslate"><span class="pre">precondition</span></code> が成り立たないときの Behavior の発動の意味は意図的に未定義である。</p></li>
<li><p>Behavior に対する <code class="docutils literal notranslate"><span class="pre">postconditions</span></code> は
<code class="docutils literal notranslate"><span class="pre">preconditions</span></code> が成り立っていたという仮定で、
Behavior の発動が成功に完了すると true となるはずの条件を定義する。</p></li>
</ul>
</section>
<section id="behavior-parameters">
<h4>13.2.3.2 Behavior Parameters<a class="headerlink" href="#behavior-parameters" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>Behavior には実行に値を引き渡すのと、実行から値を受け取る能力のある Parameters があってよい。</p></li>
<li><p>Behavior が発動されると、入力方向または入出力方向がそれらの多重度によって強制された
Parameters に対応している実引数の値が与えられる。</p></li>
<li><p>Behavior の実行が完了すると、入出力、出力、そして戻り値方向がそれらの多重度によって強制された
Parameters に対応している結果の値をもたらしてよい。</p></li>
<li><p>Parameters はストリーミングとして特徴付けてよい（すなわち <code class="docutils literal notranslate"><span class="pre">isStreaming</span></code> 特性が true である）。そのような Parameters は発動時と完了時以外にも、
Behavior の実行途中の任意の時点で値を入出力することができる。</p></li>
<li><p>発動者がストリーミング出力 Parameters から値を得ることを可能にするためには、ストリーム出力が発動者で非同期的な応答のきっかけになる可能性があるときでさえ、発動された Behavior は同期的に発動される必要がある。</p></li>
<li><p>再入可能な Behavior にはストリーミング Parameters がないものとする。複数の実行が同時に進む可能性があり、どの実行がストリーム値を受領したり提示したりしようとするのかがあいまいになろうとするためである。</p></li>
<li><p>Behavior には
<code class="docutils literal notranslate"><span class="pre">isException</span></code> が true である出力 Parameters をひとつまたはそれを超える個数分あってよい。</p></li>
<li><p>入力 ParameterSets のある Behavior は実行ごとに集合のうちのひとつの
Parameters からの入力を受け付けるしかできない。</p></li>
</ul>
</section>
<section id="opaque-and-function-behaviors">
<h4>13.2.3.3 Opaque and Function Behaviors<a class="headerlink" href="#opaque-and-function-behaviors" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>OpaqueBehavior とはその詳細が UML 以外のテキスト言語で与えられる Behavior である。</p></li>
<li><p>OpaqueBehavior には要求される挙動を記述する別の手段を表すテキスト Strings の列からなる
<code class="docutils literal notranslate"><span class="pre">body</span></code> がある。</p></li>
<li><p>言語を指定する必要はない。</p></li>
<li><p>OpaqueBehavior にひとつを超える <code class="docutils literal notranslate"><span class="pre">body</span></code> String があれば、
<code class="docutils literal notranslate"><span class="pre">bodies</span></code> の任意のひとつが OpaqueBehavior の挙動を決定付けるのに使うことができる。</p></li>
<li><p>FunctionBehavior とはどんなオブジェクトや他の外部データをも、アクセスしたり変更したりしない
OpaqueBehavior である。</p>
<ul>
<li><p>FunctionBehavior の実行中は、何であれ外部にある物を伴う通信や相互作用は禁止である。</p></li>
<li><p>計算時間量は定義されない。</p></li>
<li><p>ある入力値に対しては FunctionBehavior は例外を送出してよい。その場合、計算内容は放棄される。</p></li>
</ul>
</li>
<li><p>FunctionBehaviors はこのように入力実引数の集合を出力結果値の集合に変換するような関数を表現する。</p>
<ul>
<li><p>FunctionBehaviors の実行はその実引数にのみ依存して、結果の値を計算すること以外の効果はない。</p></li>
<li><p>FunctionBehaviors としてモデル化されるかもしれない関数の例として、初等的算術、論理値、文字列関数がある。</p></li>
</ul>
</li>
</ul>
</section>
<section id="behaviored-classifiers">
<h4>13.2.3.4 Behaviored Classifiers<a class="headerlink" href="#behaviored-classifiers" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>BehavioredClassifier とは <code class="docutils literal notranslate"><span class="pre">ownedBehaviors</span></code> があってよい Classifier であり、そのうちの高々ひとつが BehavioredClassifier 自身の挙動を指定するのに考慮されるものである。</p></li>
<li><p>BehavioredClassifier の直接の <code class="docutils literal notranslate"><span class="pre">ownedBehavior</span></code> ではない Behavior にはそれでもなお <code class="docutils literal notranslate"><span class="pre">context</span></code> がある。</p></li>
<li><p>Class により
<code class="docutils literal notranslate"><span class="pre">ownedBehavior</span></code> としてではなく、
<code class="docutils literal notranslate"><span class="pre">nestedClassifier</span></code> として直接所有される Behavior には、それの <code class="docutils literal notranslate"><span class="pre">context</span></code> としては Class がない。</p></li>
<li><p>Behavior に <code class="docutils literal notranslate"><span class="pre">context</span></code> があれば、
Behavior の実行には
<code class="docutils literal notranslate"><span class="pre">context</span></code> BehavioredClassifier のオブジェクトである関連脈絡オブジェクトがいつでもある。</p></li>
<li><p>BehavioredClassifier には、それの <code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code> と呼ばれる目立った <code class="docutils literal notranslate"><span class="pre">ownedBehavior</span></code> があってよい。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code> の正確な意味はそれを所有する BehavioredClassifier の種類に依存する。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">isActive</span></code> が false である Class には
<code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code> がないものとする。</p></li>
</ul>
</li>
</ul>
</section>
<section id="behavioral-features-and-methods">
<h4>13.2.3.5 Behavioral Features and Methods<a class="headerlink" href="#behavioral-features-and-methods" title="Permalink to this heading">¶</a></h4>
<ul>
<li><p>BehavioralFeatures には二種類、つまり Operations および Receptions がある。</p></li>
<li><p>Class の BehavioralFeature をひとつまたはそれを超える <code class="docutils literal notranslate"><span class="pre">method</span></code> Behaviors
が実装してよい。</p></li>
<li><p>受領オブジェクトは発動された <code class="docutils literal notranslate"><span class="pre">method</span></code> のいずれの実行の間においても脈絡オブジェクトになる。</p></li>
<li><p>Reception の <code class="docutils literal notranslate"><span class="pre">methods</span></code> はいつでも非同期的に発動され、それに対して Operation の <code class="docutils literal notranslate"><span class="pre">method</span></code> は同期的にも非同期的にもどちらにも発動されてよいが、Operation がどう呼び出されたかに依存する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code> の解決手順は要求されている BehavioralFeature と、要求を受信するオブジェクトと、そして要求に結び付いたデータの値のどれでもとに基くものとする。</p></li>
<li><p>次のものは高々ひとつの <code class="docutils literal notranslate"><span class="pre">method</span></code> が識別されているように常になる CallEvent に対する簡単なオブジェクト指向な解決手順である：</p>
<blockquote>
<div><p>受信オブジェクトの Class が CallEvent で識別された Operation について
<code class="docutils literal notranslate"><span class="pre">method</span></code> を所有するならば、その <code class="docutils literal notranslate"><span class="pre">method</span></code> は解決の結果である。そうでなければ、受信オブジェクトの Class の基底クラスを Operation についての <code class="docutils literal notranslate"><span class="pre">method</span></code> であるか調べ、
<code class="docutils literal notranslate"><span class="pre">method</span></code> が見つかるか、階層の根に到達するまではこのようにして一般化の階層を上がっていく。</p>
</div></blockquote>
</li>
<li><p>Operation の <code class="docutils literal notranslate"><span class="pre">method</span></code> には Operation の Parameters に対応する Parameters があるものとする。</p></li>
<li><p>しかしながら、
<code class="docutils literal notranslate"><span class="pre">method</span></code> の Parameters を
BehavioralFeature の Parameters に一致することについて特定の扱い方は定義されていない。</p>
<ul class="simple">
<li><p>厳密一致。対応する Parameters の <code class="docutils literal notranslate"><span class="pre">type</span></code> が順序正しく同じである必要がある。</p></li>
<li><p>共変一致。<code class="docutils literal notranslate"><span class="pre">method</span></code> の Parameter の <code class="docutils literal notranslate"><span class="pre">type</span></code> が
BehavioralFeature の Parameter の <code class="docutils literal notranslate"><span class="pre">type</span></code> の派生型でよい。</p></li>
<li><p>反変一致。<code class="docutils literal notranslate"><span class="pre">method</span></code> の Parameter の <code class="docutils literal notranslate"><span class="pre">type</span></code> が
BehavioralFeature の Parameter の <code class="docutils literal notranslate"><span class="pre">type</span></code> の基底型でよい。</p></li>
<li><p>またはそれについての組み合わせ。</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="notation">
<h3>13.2.4 Notation<a class="headerlink" href="#notation" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Behavior の各種サブクラスの記法は後続の章で定義する。</p></li>
<li><p>Signals と Receptions の記法は <a class="reference internal" href="simple-classifiers.html"><span class="doc">10 Simple Classifiers</span></a> で取り扱った。</p></li>
<li><p>アクティブ Class の記法は <a class="reference internal" href="structured-classifiers.html"><span class="doc">11 Structured Classifiers</span></a> で取り扱った。</p></li>
</ul>
</section>
<section id="examples">
<h3>13.2.5 Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h3>
<p>なし。</p>
</section>
</section>
<section id="events">
<h2><a class="toc-backref" href="#id14">13.3 Events</a><a class="headerlink" href="#events" title="Permalink to this heading">¶</a></h2>
<section id="id6">
<h3>13.3.1 Summary<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Event とは、ある特定の瞬間に起こり得る何かである。ひとつの Event にはたくさんの発生があってよく、それらは相異なる時刻において起こってよい。この道理だと、
Events は実際には UML の Classifiers ではないが、
Event をそれの発生の分類項目であるとみなすことができる。</p></li>
<li><p>とりわけ重要なのは Behavior の内側で応答のきっかけになる Events である。
UML で明示的にモデル化してよいそのような Events は次を含む：</p>
<ul>
<li><p>TimeEvents: 特定の時刻または期間の後に起こる。</p></li>
<li><p>ChangeEvents: 特定のブーリアン値が true になると起こる。</p></li>
<li><p>MessageEvents: メッセージの受信で起こる。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id7">
<h3>13.3.2 Abstract Syntax<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Figure 13.2 Events</p>
<ul>
<li><p>Trigger と Event 系のクラス図。
Event には直接のサブクラスが先述した 3 種あり、そのうちひとつの MessageEvent にだけはさらに直接のサブクラスがやはり 3 種ある。</p></li>
</ul>
</li>
</ul>
<dl class="simple">
<dt>A_event_trigger</dt><dd><ul class="simple">
<li><p>Trigger から Event への関連（単方向）。</p></li>
<li><p>単一の Event をいくつかの異なる Triggers で用いてよい。</p></li>
</ul>
</dd>
<dt>A_port_trigger</dt><dd><ul class="simple">
<li><p>Trigger から Port への関連（単方向）。</p></li>
<li><p>その事象が MessageEvent である必要がある場合に、
Trigger はひとつ以上の Ports を指定してよいこの場合は Trigger は指定 Ports のひとつを通じて受信したメッセージのための事象の出来事に単に match する。</p></li>
</ul>
</dd>
<dt>A_operation_callEvent</dt><dd><ul class="simple">
<li><p>CallEvent から Operation への関連（単方向）。</p></li>
<li><p>メッセージは <code class="docutils literal notranslate"><span class="pre">operation</span></code> の呼び出しを要求する。</p></li>
</ul>
</dd>
<dt>A_signal_signalEvent</dt><dd><ul class="simple">
<li><p>SignalEvent から Signal への関連（単方向）。</p></li>
<li><p>メッセージは <code class="docutils literal notranslate"><span class="pre">signal</span></code> オブジェクトの受信を要求する。</p></li>
</ul>
</dd>
<dt>A_changeExpression_changeEvent</dt><dd><ul class="simple">
<li><p>ChangeEvent から ValueSpecification への composite 関連（単方向）。</p></li>
<li><p>ChangeEvent は式 changeExpression の値が
false から true になるときに起こるものである。</p></li>
<li><p>A_ownedElement_owner を subsets する。</p></li>
</ul>
</dd>
<dt>A_when_timeEvent</dt><dd><ul class="simple">
<li><p>TimeEvent から TimeExpression への composite 関連（単方向）。</p></li>
<li><p>TimeEvent の起こる瞬間を指定する TimeExpression である。</p></li>
<li><p>A_ownedElement_owner を subsets する。</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id8">
<h3>13.3.3 Semantics<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<section id="event-dispatching">
<h4>13.3.3.1 Event Dispatching<a class="headerlink" href="#event-dispatching" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>Event とは、潜在的に挙動の結果のきっかけとなってよいある出来事の詳細である。</p>
<ul>
<li><p>Event は PackageableElement であり、
Events がその利用と独立してモデル化されることを可能にする。</p></li>
<li><p>しかし Trigger は常にある大きな挙動の仕様の一部として現れる。</p></li>
<li><p>単一の Event はいくつかの異なる Triggers で用いてよい。</p></li>
</ul>
</li>
<li><p>13.2.3 節で論じたように、
Behavior の実行にはいつでも関連脈絡オブジェクト（実行それ自身であってよい）がある。</p>
<ul>
<li><p>脈絡オブジェクトはそれの関連した Behavior 実行の全てについて
Event 発生の処理を仲介する。</p></li>
<li><p>ある脈絡オブジェクトが Event 発生を認めると、それは即時効果があるか、それは遅れたきっかけとなった効果のために保存されてよい。</p></li>
<li><p>即時効果は
BehavioralFeature の <code class="docutils literal notranslate"><span class="pre">method</span></code> の発動のような、
Behavior の直接発動により、
Event により決定付けられるものとして表明される。</p></li>
<li><p>きっかけとなった効果は、オブジェクトの事象プールにある出来事の保管場と、プールの出来事に対応する Event と一致する Trigger に到達する進行中の Behavior 実行による出来事の遅れた消費とによって表明される。</p></li>
</ul>
</li>
<li><p>一般に、Trigger が続行することを必要とする待機点に Behavior 実行が着くと、それの脈絡オブジェクトの事象プールで残っている Trigger(s) を満足する事象があるか調べられる。</p>
<ul>
<li><p>プールが Triggers の中のひとつを満足する事象の出来事を含んでいると、その出来事はプールから取り除かれて Behavior に送達され、指定されたようにそれの実行を続行する。</p></li>
</ul>
</li>
<li><p>同じ脈絡オブジェクトを使う Behaviors はすべてがそのオブジェクトの事象プールを共有するが、ひとつの Behavior しかそのプールにある Event の出来事のどれでもを消費することができない。</p></li>
<li><p>事象プールにある Event の出来事が調べられるか送達されるかという特別の順序についての要件はない。</p>
<ul>
<li><p>事象プールが待機点にある Triggers を何も満足させない出来事を含むならば、
BehavioredClassifiers の一般的な意味は何がそれに対して起こるかを指定しない。</p></li>
</ul>
</li>
</ul>
</section>
<section id="message-events">
<h4>13.3.3.2 Message Events<a class="headerlink" href="#message-events" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>メッセージとは、送信者が Operation 呼び出しか受信者による Signal 受信のどちらかを要求する通信である。</p>
<ul>
<li><p>この通信はふたつの事象を伴う。すなわち、メッセージを送信する事象とメッセージを受信する事象である。</p></li>
<li><p>しかしながら、事象を送信することは、それらが暗に InvaocationActions の実行中にあり、そのような事象の出来事が Interactions でモデル化されることが可能ではあるが、
UML にある明示的なモデル要素としてモデル化されていない。その一方で MessageEvent はメッセージの受信の明示的なモデルであり、その事象の出来事に応答する Trigger を指定することを可能にするためのものである。</p></li>
</ul>
</li>
<li><p>メッセージは次のものを含む：</p>
<ul>
<li><p>要求に結び付くデータ（Operation 引数に対しては実引数、Signal 属性に対しては値）</p></li>
<li><p>依頼の性質の情報（つまり発動された BehavioralFeature である）</p></li>
<li><p>同期的な発動に対しては、発動された Behavior からの返信の復帰を可能にさせるのに十分な情報</p></li>
</ul>
</li>
<li><p>各メッセージが正確にひとつの受信オブジェクトから対象とされて、正確にひとつの送信オブジェクトによって引き起こされる限りは、送信事象の出来事は発生されているメッセージをいくらか生じてよい。</p>
<ul>
<li><p>メッセージの受信者は送信者と同じでよく、それが局所的でもよく、遠隔的でもよい。</p></li>
<li><p>メッセージの伝送の方法、メッセージを伝送するのに必要な時間量、伝送 (pl.) がそれらの受信オブジェクトに到着する順序、および受信オブジェクトに到着するための経路は未定義とする。</p></li>
</ul>
</li>
<li><p>メッセージの受信は MessageEvent の出来事として表明される。</p>
<ul>
<li><p>CallEvent とは、特定の Operation が呼び出されることを要求するメッセージのための
MessageEvent である。</p></li>
<li><p>SignalEvent とは、特定の Signal のオブジェクトの受信を要求するメッセージのための
MessageEvent である。</p></li>
<li><p>AnyReceiveEvent とは、他の関係 Trigger のどれによっても明示的に処理されることのないメッセージのどれもに対する MessageEvent である。</p></li>
</ul>
</li>
<li><p>Operation に対する CallEvent
または受信者の Reception に一致する Signal に対する SignalEvent の場合、その Operation なり Reception なりにひとつまたはそれを超える <code class="docutils literal notranslate"><span class="pre">methods</span></code> があれば、
13.2.3 節で述べた <code class="docutils literal notranslate"><span class="pre">method</span></code> 解決処理が
MessageEvent の出来事を処理するのに用いられる <code class="docutils literal notranslate"><span class="pre">method</span></code> を決定付けるのに実施されるものとする。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code> がそうして特定されると、それがメッセージ要求に応答するために発動される。さもなくば、MessageEvent の出来事が受信オブジェクトの事象プールに保存される。</p></li>
<li><p>MessageEvent の出来事が事象プールから発送されて、受信者についての Behavior の仕様で定義された Trigger に一致すると、その Behavior の内部での応答の実行を引き起こす。</p></li>
</ul>
</li>
<li><p>AnyReceiveEvent に対する Trigger は、メッセージのどんな受信がきっかけになってもよい。ただし、メッセージに明示的に一致する適切な SignalEvent または CallEvent Trigger がある場合には、
AnyReceiveEvent の Trigger はそのメッセージによって誘発されない。</p></li>
<li><p>Trigger はひとつまたはそれを超える Ports を指定してもよく、その場合には Trigger の事象は MessageEvent であるものとする。この場合、Trigger は指定された Ports のひとつを通じて受信したメッセージに対する事象の出来事にしか一致しない。</p></li>
</ul>
</section>
<section id="change-events">
<h4>13.3.3.3 Change Events<a class="headerlink" href="#change-events" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>ChangeEvent はブーリアン式 <code class="docutils literal notranslate"><span class="pre">changeExpression</span></code> が true になると発生する。例えば、これはある Attribute の変化や、ある Association に対応するリンクが参照する値の変化で生じるものである可能性がある。</p>
<ul>
<li><p>ChangeEvent は暗黙的に起こるものであり、明示的な作用のどれによる結果でもない。</p></li>
</ul>
</li>
<li><p>ある出来事は
<code class="docutils literal notranslate"><span class="pre">changeExpression</span></code> の値が false から true に変化するどんなときにも発生されるものとみなされる。</p></li>
</ul>
</section>
<section id="time-events">
<h4>13.3.3.4 Time Events<a class="headerlink" href="#time-events" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>TimeEvent はそれが発生する時間の瞬間を指定する。その瞬間は TimeExpression を使って指定される。</p></li>
<li><p>13.3.3.1 節で論じたように、事象の出来事が送達されてよいところで利用可能な、ひとつまたはそれを超える Triggers を有する待機点に
Behavior は到達してよい。</p>
<ul>
<li><p>もしそのような未済 Trigger に相対 TimeEvent があれば、その TimeEvent についての開始時刻は Behavior が待機点に到達した時刻である。</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="id9">
<h3>13.3.4 Notation<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Triggers での使用の脈絡外での Events に対する表記法はない。
Trigger は Event の種類に基いてテキストで記される。</p></li>
<li><p>CallEvent はきっかけとする Operation の名前で記し、オプションで代入仕様を続ける。</p></li>
<li><p>SignalEvent はきっかけとする Signal の名前で記し、オプションで代入仕様を続ける。</p></li>
<li><p>AnyReceiveEvent はいずれも <code class="docutils literal notranslate"><span class="pre">all</span></code> と記す。</p></li>
<li><p>ChangeEvent は <code class="docutils literal notranslate"><span class="pre">when</span></code> を記し、
Boolean ValueSpecification を続ける。
<a class="reference internal" href="values.html"><span class="doc">8 Values</span></a> 参照。</p></li>
<li><p>相対 TimeEvent は <code class="docutils literal notranslate"><span class="pre">after</span></code> を記し、“after 5 seconds” のような TimeExpression を続ける。絶対 TimeEvent は <code class="docutils literal notranslate"><span class="pre">at</span></code> を記し、“at Jan. 1, 2000, Noon” のような TimeExpression を続けることで指定する。</p></li>
</ul>
</section>
<section id="id10">
<h3>13.3.5 Examples<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<p>なし。</p>
</section>
</section>
<section id="classifier-descriptions">
<h2><a class="toc-backref" href="#id15">13.4 Classifier Descriptions</a><a class="headerlink" href="#classifier-descriptions" title="Permalink to this heading">¶</a></h2>
<p>機械生成による節。</p>
</section>
<section id="association-descriptions">
<h2><a class="toc-backref" href="#id16">13.5 Association Descriptions</a><a class="headerlink" href="#association-descriptions" title="Permalink to this heading">¶</a></h2>
<p>機械生成による節。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="statemachines.html" title="14 StateMachines"
             >next</a></li>
        <li class="right" >
          <a href="packages.html" title="12 Packages"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Unified Modeling Language 2.5 読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">13 Common Behavior</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>