
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>9 Classification &#8212; 読書ノート v1.4</title>
    <link rel="stylesheet" href="../_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/mathjaxconf.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="next" title="10 Simple Classifiers" href="simple-classifiers.html" />
    <link rel="prev" title="8 Values" href="values.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="simple-classifiers.html" title="10 Simple Classifiers"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="values.html" title="8 Values"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Unified Modeling Language 2.5 読書ノート</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="classification">
<h1><a class="toc-backref" href="#id36">9 Classification</a><a class="headerlink" href="#classification" title="Permalink to this headline">¶</a></h1>
<p>UML 2.5 pp. 97-164 に関するノート。</p>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#classification" id="id36">9 Classification</a><ul>
<li><a class="reference internal" href="#summary" id="id37">9.1 Summary</a></li>
<li><a class="reference internal" href="#classifiers" id="id38">9.2 Classifiers</a></li>
<li><a class="reference internal" href="#classifier-templates" id="id39">9.3 Classifier Templates</a></li>
<li><a class="reference internal" href="#features" id="id40">9.4 Features</a></li>
<li><a class="reference internal" href="#properties" id="id41">9.5 Properties</a></li>
<li><a class="reference internal" href="#operations" id="id42">9.6 Operations</a></li>
<li><a class="reference internal" href="#generalization-sets" id="id43">9.7 Generalization Sets</a></li>
<li><a class="reference internal" href="#instances" id="id44">9.8 Instances</a></li>
<li><a class="reference internal" href="#classifier-descriptions" id="id45">9.9 Classifier Descriptions</a></li>
<li><a class="reference internal" href="#association-descriptions" id="id46">9.10 Association Descriptions</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id37">9.1 Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>分類は組織化をするのに重要な技法である。この章では分類に関する概念を指定する。核となる概念とは Classifier すなわちその具象サブクラスが値のさまざまな型を分類するのに用いられる抽象メタクラスである。</li>
<li>この章にあるその他のメタクラスは Classifiers の構成要素、
Classifiers が InstanceSpecifications を使ってオブジェクト化されるモデル、そしてこれらの概念すべての間にあるさまざまな関係を表現する。</li>
</ul>
</div>
<div class="section" id="classifiers">
<h2><a class="toc-backref" href="#id38">9.2 Classifiers</a><a class="headerlink" href="#classifiers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>9.2.1 Summary<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Classifier はその Features に応じたオブジェクトの分類（項目）を表現する。</li>
<li>Classifiers は Generalizations によって階層的構造に組織化されている。</li>
<li>RedefinableElements は Generalization の階層を背景として再定義されてよい。</li>
</ul>
</div>
<div class="section" id="abstract-syntax">
<h3>9.2.2 Abstract Syntax<a class="headerlink" href="#abstract-syntax" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.1 Classifiers<ul>
<li>Classifier を中心とした図式だが、大量の関連が記されている。</li>
<li>文字が潰れていて PDF ビューワーでズーム率を上げないと読めない。</li>
</ul>
</li>
</ul>
<dl class="docutils">
<dt>A_inheritedMember_inheritingClassifier</dt>
<dd><ul class="first last simple">
<li>Classifier から NamedElement への関連（単方向）。</li>
<li>継承されたメンバーの集合のことをその <code class="docutils literal notranslate"><span class="pre">inheritedMember</span></code> と呼ぶ。特に断りのない限り、private な可視性ではない <code class="docutils literal notranslate"><span class="pre">member</span></code> である。</li>
<li>関連 A_member_memberNamespace を subsets する。<ul>
<li>関連端 <code class="docutils literal notranslate"><span class="pre">inheritedMember</span></code> は制約 <code class="docutils literal notranslate"><span class="pre">{readOnly}</span></code> がある。</li>
</ul>
</li>
</ul>
</dd>
<dt>A_redefinedElement_redefinableElement</dt>
<dd><ul class="first simple">
<li>RedefinableElement から RedefinableElement への関連（単方向）。</li>
<li>両関連端とも <code class="docutils literal notranslate"><span class="pre">{readOnly,</span> <span class="pre">union}</span></code> であり、多重度は <code class="docutils literal notranslate"><span class="pre">*</span></code> である。</li>
</ul>
<dl class="last docutils">
<dt>A_redefinedClassifier_classifier</dt>
<dd><ul class="first last simple">
<li>Classifier から Classifier への関連（単方向）。</li>
<li>上記関連を subsets する。</li>
</ul>
</dd>
</dl>
</dd>
<dt>A_redefinitionContext_redefinableElement</dt>
<dd><ul class="first last simple">
<li>RedefinableElement から Classifier への単方向関連。</li>
<li>関連端 <code class="docutils literal notranslate"><span class="pre">redefinitionContext</span></code> は「メンバーがそこから再定義されてもよいような Classifier」を表す。</li>
<li>両関連端とも <code class="docutils literal notranslate"><span class="pre">{readOnly,</span> <span class="pre">union}</span></code> であり、多重度は <code class="docutils literal notranslate"><span class="pre">*</span></code> である。<ul>
<li>とは言え、UML の仕様書では <code class="docutils literal notranslate"><span class="pre">redefinitionContext</span></code> が一つを超える事例はない。</li>
</ul>
</li>
</ul>
</dd>
<dt>A_feature_featuringClassifier</dt>
<dd><ul class="first simple">
<li>Classifier と Feature との間の関連（双方向）。</li>
<li>Classifier は Features の集合、そのうちのいくつかはその Classifier の attributes と呼ばれる Properties である。下記関連のコメント参照。</li>
<li>A_member_memberNamespace を subsets する。<ul>
<li>両関連端にはさらに <code class="docutils literal notranslate"><span class="pre">{readOnly,</span> <span class="pre">union}</span></code> も付く。</li>
</ul>
</li>
</ul>
<dl class="last docutils">
<dt>A_attribute_classifier</dt>
<dd><ul class="first last simple">
<li>Classifier から Property への関連（単方向）。</li>
<li>上記の関連と A_redefinitionContext_redefinableElement を subsets する。<ul>
<li>両関連端にはさらに readOnly と union も付く。</li>
<li>関連端 <code class="docutils literal notranslate"><span class="pre">attribute</span></code> のほうにはさらに <code class="docutils literal notranslate"><span class="pre">{ordered}</span></code> が加わっている。</li>
</ul>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>A_collaborationUse_classifier</dt>
<dd><ul class="first simple">
<li>Classifier から CollaborationUse への composite 関連。</li>
<li>Classifier は、それを Collaborations に関係させる CollaborationUses を所有してもよい。その Collaborations はこの Classifier の外観を描写する。
<a class="reference internal" href="structured-classifiers.html"><span class="doc">11 Structured Classifiers</span></a> で述べる。</li>
<li>A_ownedElement_owner を subsets する。</li>
</ul>
<dl class="last docutils">
<dt>A_representation_classifier</dt>
<dd><ul class="first last simple">
<li>Classifier から CollaborationUse への関連（単方向）。</li>
<li>上記関連を subsets する。</li>
<li>関連端 <code class="docutils literal notranslate"><span class="pre">representation</span></code> の多重度は <code class="docutils literal notranslate"><span class="pre">0..1</span></code> である。</li>
</ul>
</dd>
</dl>
</dd>
<dt>A_ownedUseCase_classifier</dt>
<dd><ul class="first last simple">
<li>Classifier から UseCase への composite 関連（単方向）。</li>
<li>Classifier は UseCases を所有してもよい。
<a class="reference internal" href="usecases.html"><span class="doc">18 UseCases</span></a> で述べる。</li>
<li>A_ownedMember_namespace を subsets する。</li>
</ul>
</dd>
<dt>A_generalization_specific</dt>
<dd><ul class="first last simple">
<li>Generalization から Classifier への composite 関連（両方向）。</li>
<li>各 Generalization は <code class="docutils literal notranslate"><span class="pre">specific</span></code> を <code class="docutils literal notranslate"><span class="pre">general</span></code> と関係させる。</li>
<li>与えられた Classifier に対し、その <code class="docutils literal notranslate"><span class="pre">specific</span></code> の推移閉包（グラフ論等で頻用する用語）をその specializations と呼ぶ。</li>
<li>A_ownedElement_owner と A_source_directedRelationship を subsets する。</li>
</ul>
</dd>
<dt>A_general_generalization</dt>
<dd><ul class="first last simple">
<li>Generalization から Classifier への関連（単方向）。</li>
<li>与えられた Classifier に対し、その <code class="docutils literal notranslate"><span class="pre">general</span></code> の推移閉包をその <code class="docutils literal notranslate"><span class="pre">generalizations</span></code> と呼ぶ。特に直接の <code class="docutils literal notranslate"><span class="pre">generalizations</span></code> はその親と呼ばれる。もっと言えば Classifier が Class のときには <code class="docutils literal notranslate"><span class="pre">superClasses</span></code> となる。</li>
<li>A_target_directedRelationship を subsets する。</li>
</ul>
</dd>
<dt>A_general_classifier</dt>
<dd><ul class="first last simple">
<li>Classifier から Classifier への関連（単方向）。</li>
<li>説明が見当たらないが、子クラスは親クラスに依存する、くらいの意味か。</li>
</ul>
</dd>
<dt>A_generalizationSet_generalization</dt>
<dd>後述。</dd>
<dt>A_contract_substitution</dt>
<dd><ul class="first last simple">
<li>Substitution から Classifier への関連（単方向）。</li>
<li>意味は上述の Substitution のノートを参照。</li>
<li>関連 A_supplier_supplierDependency を subsets する。</li>
</ul>
</dd>
<dt>A_substitution_substitutingClassifier</dt>
<dd><ul class="first last simple">
<li>Classifier から Substitution への composite 関連（両方向）。</li>
<li>意味は上述の Substitution のノートを参照。</li>
<li><code class="docutils literal notranslate"><span class="pre">contract</span></code> が実装する Interfaces は上記関連の substitutingClassifier もまた実装する必要があるか、あるいは substitutingClassifier がより特殊な Interface 型を実装する必要がある。</li>
<li><code class="docutils literal notranslate"><span class="pre">contract</span></code> が所有するどんな Port も上記関連の substitutingClassifier が所有するある Port に match することが必要である。</li>
<li>関連 A_clientDependency_client と A_ownedElement_owner を subsets する。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="semantics">
<h3>9.2.3 Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id3">
<h4>9.2.3.1 Classifiers<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Classifier には Features の集合があり、それらのいくつかは Classifier の <code class="docutils literal notranslate"><span class="pre">attributes</span></code> と呼ばれる Properties である。
Features のそれぞれは Classifier の <code class="docutils literal notranslate"><span class="pre">member</span></code> である（<a class="reference internal" href="common-structure.html"><span class="doc">7 Common Structure</span></a> を参照）。</li>
<li>Classifier によって分類される値をその Classifier のインスタンスと呼ぶ。<ul>
<li>以降、私のノートでは英単語 instance を訳すときは一律オブジェクトとする。</li>
</ul>
</li>
<li>Classifier を再定義することが許される（後述）。</li>
<li>Classifier は、
Classifier を Collaborations に結びつける CollaborationUses を所有してよい。
Collaborations はこの Classifier の様子を記述する。
<a class="reference internal" href="structured-classifiers.html"><span class="doc">11 Structured Classifiers</span></a> 参照。</li>
<li>Classifier は UseCases を所有してよい。
<a class="reference internal" href="usecases.html"><span class="doc">18 UseCases</span></a> 参照。</li>
</ul>
</div>
<div class="section" id="generalization">
<h4>9.2.3.2 Generalization<a class="headerlink" href="#generalization" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Generalizations は
Classifiers 間の generalization/specialization を定義する。
Generalization それぞれは <code class="docutils literal notranslate"><span class="pre">specific</span></code> な Classifier をより <code class="docutils literal notranslate"><span class="pre">general</span></code> な Classifier に結びつける。</li>
<li>Classifier のオブジェクトは、その一般化のそれぞれの（間接的な）オブジェクトでもある。</li>
<li>Classifier が一般化されるときには、それの一般化のあるメンバーは継承される。つまり継承する Classifier 自身で定義されたかのように振る舞う。</li>
<li>継承されたメンバーの集合は <code class="docutils literal notranslate"><span class="pre">inheritedMembers</span></code> と呼ばれる。</li>
<li>型の適合とは、ある型が別のものに適合するならば、最初の型のオブジェクトのいずれもその <code class="docutils literal notranslate"><span class="pre">type</span></code> が二番目の型であると宣言されている
TypedElement の値として用いられてよいことを意味する。</li>
<li>Classifier の <code class="docutils literal notranslate"><span class="pre">isAbstract</span></code> 特性は、true のとき、
Classifier が抽象、すなわち、直接オブジェクトがないことを指定する。言い換えると、抽象 Classifier のオブジェクトはどれもがその特殊化のひとつのオブジェクトであるものとする。</li>
<li>ある Classifier が別のものを一般化するならば、可能な限りの状況のもとで、子のオブジェクトは親のオブジェクトに置き換えられる場合とは必ずしも限らない。<ul>
<li>例えば、Circle を Ellipse の特殊化として定義してよく、そのオブジェクトは Ellipse の特性にアクセスすることを伴う環境のすべてで置換可能となるかもしれない。だが、もし Ellipse がその長軸の長さしか変更しない挙動を定義しようものなら、
Circle オブジェクトはそのような挙動を実装することはどうしても不可能だろう。</li>
<li><code class="docutils literal notranslate"><span class="pre">isSubstitutable</span></code> 特性を、特殊な Classifier が一般の Classifier が用いられる環境すべてで用いられるかどうかを示すのに用いてよい。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="redefinition">
<h4>9.2.3.3 Redefinition<a class="headerlink" href="#redefinition" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>特殊化する Classifier の一般化の <code class="docutils literal notranslate"><span class="pre">member</span></code> のどれでもが継承される代わりに再定義されることが許される。</li>
<li>メンバーが再定義されてよい Classifier は <code class="docutils literal notranslate"><span class="pre">redefinitionContext</span></code> と呼ばれる。</li>
<li>再定義する要素は、それが再定義する RedefinableElement に対する整合性があるものとするが、
<code class="docutils literal notranslate"><span class="pre">general</span></code> な状況での制約に矛盾しない、特殊化する <code class="docutils literal notranslate"><span class="pre">redefinitionContext</span></code> のオブジェクトに特有の固有の制約や他の詳細を追加してよい。</li>
<li>再定義する要素ひとつが RedefinableElements を複数再定義してよい。</li>
<li><code class="docutils literal notranslate"><span class="pre">isLeaf</span></code> 特性が true のとき、その RedefinableElement には再定義を何もあってはならないものとすることを指定する。</li>
<li>再定義の詳細な意味は RedefinableElement の特殊化のそれぞれについて異なる。</li>
<li>Classifier 自身は RedefinableElement である。
Classifier が Class または Interface で入れ子になるときにこれが働いて、
Classifier は <code class="docutils literal notranslate"><span class="pre">redefinitionContext</span></code> になる。</li>
</ul>
</div>
<div class="section" id="substitution">
<h4>9.2.3.4 Substitution<a class="headerlink" href="#substitution" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Substitution とは、
<code class="docutils literal notranslate"><span class="pre">substitutingClassifier</span></code> が <code class="docutils literal notranslate"><span class="pre">contract</span></code> Classifier に指定される契約に従うことを知らせる、ふたつの Classifiers の間の関係である。これは
<code class="docutils literal notranslate"><span class="pre">contact</span></code> Classifier のオブジェクトが期待されるところでは
<code class="docutils literal notranslate"><span class="pre">substitutingClassifier</span></code> のオブジェクトが実行時に置換可能であることを含意する。</li>
</ul>
</div>
</div>
<div class="section" id="notation">
<h3>9.2.4 Notation<a class="headerlink" href="#notation" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id4">
<h4>9.2.4.1 Classifiers<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Classifier は抽象メタクラスである。それでもやはり、
Classifier の具象サブクラスのどれにとっても利用可能な既定の表記法を一箇所で定義することは都合が良い。</li>
<li>Classifier の既定の表記法は、
Classifier の <code class="docutils literal notranslate"><span class="pre">name</span></code> を含む実線矩形であり、
<code class="docutils literal notranslate"><span class="pre">name</span></code> の下部にある水平線により分離された区画がある。</li>
<li>Classifier に対して既定の表記法を用いるならば、
Classifier のメタクラスに対応するキーワードを
<code class="docutils literal notranslate"><span class="pre">name</span></code> の上部に guillemets で括って示すものとする。<ul>
<li>キーワードについては <a class="reference internal" href="keywords.html"><span class="doc">Annex C: Keywords</span></a> 参照。</li>
</ul>
</li>
<li>キーワード（ステレオタイプ名を含む）は Classifier <code class="docutils literal notranslate"><span class="pre">name</span></code> の上部に
guillemets で括られ、プレーンな字面で中央寄せとするべきでもある。</li>
<li>抽象 Classifier の <code class="docutils literal notranslate"><span class="pre">name</span></code> は利用フォントが許す限りイタリック体で示す。あるいは <code class="docutils literal notranslate"><span class="pre">name</span></code> の後か下に <code class="docutils literal notranslate"><span class="pre">{abstract}</span></code> と示すことも認められる。</li>
<li>Classifier 形状にある区画のいくらかは必須であり、具象構文適合を展示するツールにより支援されるものとする。</li>
<li>どの区画も非表示にしてよい。</li>
<li>attributes と名付けられた区画はその <code class="docutils literal notranslate"><span class="pre">attribute</span></code> 特性を介して到達される Properties を示す表記法を含む。この区画は必須かつ非表示でなければ常に他の区画の上部に現れる。</li>
<li>operations と名付けられた区画は Operations を示す表記法を含む。</li>
<li>receptions と名付けられた区画は Receptions を示す表記法を含む。</li>
<li>Features を示す表記法を含む区画はどれもそれらの Features を
public, private, protected の下にグループ分けされて示してよい。</li>
<li>準拠ツールは Features を示す表記法を含む区画の個々の Features を非表示にするオプションを与えることが許される。</li>
<li>準拠ツールは区画の命名を任意に支援してよい。</li>
<li>Classifier に Classifiers である <code class="docutils literal notranslate"><span class="pre">ownedMembers</span></code> があれば、準拠ツールは所有される Classifiers とその間の関係を所有する Classifier の矩形の区画の別々の内部に入れ子にして図式的に示すためのオプションを提供してよい。</li>
<li>Classifier が Constraints を所有するならば、準拠ツールは所有する Classifier の矩形の区画の別々の内部にリストされた所有される Constraints を示す区画を実装してよい。</li>
</ul>
</div>
<div class="section" id="other-elements">
<h4>9.2.4.2 Other elements<a class="headerlink" href="#other-elements" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Generalization は関わり合う Classifiers を表現する記号の間を結ぶ白い矢先の矢印として示される。</li>
<li>同一の <code class="docutils literal notranslate"><span class="pre">general</span></code> Classifier を参照する複数の Generalizations を表すのに、それらの矢印を分離しても共有して示してもよい。</li>
<li>RedefinableElement を表す一般的な表記法はない。</li>
<li>Substitution は Dependency の記法を用いる。キーワードは «substitute» とする。</li>
<li>Classifier が継承した <code class="docutils literal notranslate"><span class="pre">members</span></code> を仮に <code class="docutils literal notranslate"><span class="pre">member</span></code> が継承されていなかったら示されたであろうテキスト的表現に対して先頭にキャレット記号を付けることで
Classifier の図式上に示してよい。</li>
<li>類似の表記法を Classifier の <code class="docutils literal notranslate"><span class="pre">inheritedMembers</span></code> である
NamedElements のすべてに対して、それらが継承されたものであることを示すのに用いてよい。</li>
<li>継承された <code class="docutils literal notranslate"><span class="pre">members</span></code> を非継承 <code class="docutils literal notranslate"><span class="pre">members</span></code> と区別しやすくするように明るい色で示してもよい。</li>
</ul>
</div>
</div>
<div class="section" id="examples">
<h3>9.2.5 Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>いずれも矢印の向きとスタイルの規約を了解するだけで十分だ。</p>
<ul class="simple">
<li>Figure 9.2 Generalization notation showing different target styles<ul>
<li>よくあるクラス継承図。個人的には shared target style の方が好みだ。</li>
</ul>
</li>
<li>Figure 9.3 Example of Substitution notation<ul>
<li>Substitution の記法例。</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="classifier-templates">
<h2><a class="toc-backref" href="#id39">9.3 Classifier Templates</a><a class="headerlink" href="#classifier-templates" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3>9.3.1 Summary<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Classifier は引数として扱えることを知らせる TemplateableElement の一種である。</li>
</ul>
</div>
<div class="section" id="id6">
<h3>9.3.2 Abstract Syntax<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.4 Classifier Templates<ul>
<li>字が潰れて読みにくい。閲覧にはズームを 150% にはしたい。</li>
<li>この図では Classifier が間接的に ParameterableElement の一種であることがすぐに思い出せない。</li>
</ul>
</li>
</ul>
<dl class="docutils">
<dt>A_ownedTemplateSignature_classifier</dt>
<dd><ul class="first last simple">
<li>Classifier から RedefinableTemplateSignature への composite 関連（両方向）。</li>
<li>A_redefinitionContext_redefinableElement を subsets する。</li>
<li>さらに A_ownedTemplateSignature_template を redefines する。</li>
</ul>
</dd>
<dt>A_extendedSignature_redefinableTemplateSignature</dt>
<dd><ul class="first last simple">
<li>RedefinableTemplateSignature 間の関連（単方向）。</li>
<li>RedefinableTemplateSignature はテンプレートである親 Classifier 全ての
RedefinableTemplateSignature を再定義する。</li>
<li>A_redefinedElement_redefinableElement を subsets する。</li>
</ul>
</dd>
<dt>A_inheritedParameter_redefinableTemplateSignature</dt>
<dd><ul class="first last simple">
<li>RedefinableTemplateSignature から TemplateParameter への関連（単方向）。</li>
<li>A_parameter_templateSignature を subsets する。</li>
<li>関連端 <code class="docutils literal notranslate"><span class="pre">inheritedMember</span></code> は <code class="docutils literal notranslate"><span class="pre">{readOnly}</span></code> である。</li>
</ul>
</dd>
<dt>A_parameteredElement_templateParameter</dt>
<dd><ul class="first last simple">
<li>ClassifierTemplateParameter と Classifier との間の関連（両方向）。</li>
<li>先述の ClassifierTemplateParameter のノート参照。<ul>
<li><code class="docutils literal notranslate"><span class="pre">parameteredElement</span></code> が存在して抽象でなければ、引数として用いられる Classifier は抽象であってはならない。</li>
</ul>
</li>
<li>これは既存の同名の関連を redefines する。</li>
</ul>
</dd>
<dt>A_constrainingClassifier_classifierTemplateParameter</dt>
<dd><ul class="first last simple">
<li>ClassifierTemplateParameter から Classifier への関連（単方向）。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h3>9.3.3 Semantics<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<div class="section" id="template-and-bound-classifiers">
<h4>9.3.3.1 Template and Bound Classifiers<a class="headerlink" href="#template-and-bound-classifiers" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>テンプレートと被束縛要素の用語の意味は <a class="reference internal" href="common-structure.html"><span class="doc">7 Common Structure</span></a> で定義されている。</li>
<li>RedefinableTemplateSignature を使って引数化された Classifier はテンプレート Classifier と呼ばれる。一方、ひとつまたはそれを超える TemplateBindings がある Classifier は被束縛 Classifier と呼ばれる。</li>
<li>テンプレートの一般的な意味は <a class="reference internal" href="common-structure.html"><span class="doc">7 Common Structure</span></a> で定義されているとおりである。</li>
<li>拡張被束縛 Classifier のメンバーを束縛において実引数として用いてよい。</li>
<li>被束縛 Classifier には束縛の結果生じるものに加えて中身があってよい。</li>
<li>テンプレート Classifier の引数は TemplateParameter のどんな種類の可能性もある。</li>
<li>引数が Classifier のときには、ClassifierTemplateParameter で表現され、意味と表記法はこの章で定義される。</li>
<li>引数が LiteralSpecification のときには、意味と表記法は
<a class="reference internal" href="common-structure.html"><span class="doc">7 Common Structure</span></a> で定義されているとおりである。</li>
<li>引数が Operation であるときには、意味と表記法は 9.6 にあるとおりである。</li>
<li>引数が Property であるときには、意味と表記法は 9.5 にあるとおりである。</li>
</ul>
</div>
<div class="section" id="template-classifier-specialization">
<h4>9.3.3.2 Template Classifier specialization<a class="headerlink" href="#template-classifier-specialization" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>RedefinableTemplateSignature は特殊化するテンプレート Classifier の状況で新たな仮 TemplateParameters の追加を許すために
RedefinableElement と TemplateSignature の両方を特殊化する。</li>
<li>RedefinableTemplateSignature はテンプレートである親 Classifiers のすべての RedefinableTemplateSignatures を再定義する。</li>
</ul>
</div>
<div class="section" id="classifier-template-parameters">
<h4>9.3.3.3 Classifier Template Parameters<a class="headerlink" href="#classifier-template-parameters" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>ClassifierTemplateParameter とは、
<code class="docutils literal notranslate"><span class="pre">parameteredElement</span></code> が
ParameterableElement の一種であるという能力で Classifier である
TemplateParameter の一種である。</li>
<li>Class, Collaboration, Component, DataType, Interface, Signal, UseCase などの
Classifier のサブクラスはすべて引数として、束縛して、TemplateParameters として用いてもよい。同様のことが Class のサブクラスとしての Behavior に対しても成り立ち、それにより Activity, Interaction, StateMachine などの
Behavior のサブクラスすべてもそのようにしてよい。</li>
<li>ClassifierTemplateParameter の <code class="docutils literal notranslate"><span class="pre">constrainingClassifier</span></code> 特性は引数として用いることが可能な実引数を制約する
Classifiers の集合を指定する。この集合に何か Classifiers があれば、実引数はそれらのすべてと互換性が次の意味であるものとする：<ul>
<li><code class="docutils literal notranslate"><span class="pre">allowSubstitutable</span></code> が true ならば、互換性は <code class="docutils literal notranslate"><span class="pre">contract</span></code> が <code class="docutils literal notranslate"><span class="pre">constrainingClassifier</span></code> である
Substitution をさらに許す。</li>
<li><code class="docutils literal notranslate"><span class="pre">allowSubstitutable</span></code> が false ならば、互換性とはその集合のすべてと同じであることか、
<code class="docutils literal notranslate"><span class="pre">constrainingClassifiers</span></code> のすべての特殊化であることを意味する。</li>
</ul>
</li>
<li>なお、
<code class="docutils literal notranslate"><span class="pre">constrainingClassifiers</span></code> があれば、
<code class="docutils literal notranslate"><span class="pre">parameteredElement</span></code> は次のように制約が付くものとする：<ul>
<li><code class="docutils literal notranslate"><span class="pre">allowSubstitutable</span></code> が true ならば、互換性は <code class="docutils literal notranslate"><span class="pre">contract</span></code> が <code class="docutils literal notranslate"><span class="pre">constrainingClassifier</span></code> である
Substitution をさらに許す。</li>
<li><code class="docutils literal notranslate"><span class="pre">allowSubstitutable</span></code> が false ならば、互換性とはその集合のすべてと同じであることか、
<code class="docutils literal notranslate"><span class="pre">constrainingClassifiers</span></code> のすべての直接的特殊化であることを意味し、さらなる機能はない。</li>
</ul>
</li>
<li>すべての場合で、
<code class="docutils literal notranslate"><span class="pre">parameteredElement</span></code> が抽象的でなければ、実引数として用いられる Classifier は抽象的ではないものとする。</li>
</ul>
</div>
</div>
<div class="section" id="id8">
<h3>9.3.4 Notation<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>これは <a class="reference internal" href="common-structure.html"><span class="doc">7 Common Structure</span></a> の Templates の記法の焼き直しのようだ。</p>
<ul class="simple">
<li>ClassifierTemplateParameter は
TemplateParameter が選択自由な型制約を含むように表記法を拡張する。</li>
<li>錯覚かもしれないが p. 103 の BNF と p. 104 の例題とで
<code class="docutils literal notranslate"><span class="pre">&lt;constraint&gt;</span></code> の prefix が異なる気がする。</li>
</ul>
</div>
<div class="section" id="id9">
<h3>9.3.5 Examples<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.5 Template Class and Bound Class<ul>
<li>クラステンプレート FArray の図式か。</li>
<li>T, k がそれぞれ TemplateParameter である。</li>
<li>T は制約なしクラスの、k は LiteralInteger の TemplateParameter である。</li>
<li>k の方にはデフォルト値の指定が付いている。</li>
<li>AddressList は bound Class である。</li>
</ul>
</li>
<li>Figure 9.6 Anonymous Bound Class<ul>
<li>無名被束縛 Class の見本。C++ 風に書くと <code class="docutils literal notranslate"><span class="pre">FArray&lt;Point&gt;</span></code> を表現する図。</li>
</ul>
</li>
<li>Figure 9.7 Template Class with constrained Class parameter<ul>
<li>クラステンプレート Car の図式。</li>
<li>CarEngine と n が TemplateParameter である。</li>
<li>CarEngine には制約が指定されている。読み方は「Engine と呼ばれる Class に適合する」である。</li>
<li>n は「LiteralInteger である」という制約が指定されている。</li>
</ul>
</li>
<li>Figure 9.8 Bound Class<ul>
<li>これは被束縛 Class の記法の見本。</li>
<li>被束縛 Class の名前は DieselCar である。</li>
<li>TemplateParameter である CarEngine と n に対して
DieselEngine と 2 をそれぞれ束縛している。</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="features">
<h2><a class="toc-backref" href="#id40">9.4 Features</a><a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id10">
<h3>9.4.1 Summary<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Features は Classifiers の構造的特徴と挙動の特徴を表現する。</li>
</ul>
</div>
<div class="section" id="id11">
<h3>9.4.2 Abstract Syntax<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.9 Features<ul>
<li>クラスの他に列挙体がある。</li>
</ul>
</li>
</ul>
<dl class="docutils">
<dt>A_feature_featuringClassifier</dt>
<dd>先述の通り。</dd>
<dt>A_raisedException_behavioralFeature</dt>
<dd><ul class="first last simple">
<li>BehavioralFeature から Type への関連（単方向）。</li>
<li>BehavioralFeature はその呼出期間中に例外を送出してもよい。この関連はその例外の型を指定する。</li>
</ul>
</dd>
<dt>A_method_specification</dt>
<dd><ul class="first last simple">
<li>BehavioralFeature と Behavior の間の関連（両方向）。</li>
<li>多重度は <code class="docutils literal notranslate"><span class="pre">specification</span></code> <code class="docutils literal notranslate"><span class="pre">0..1</span></code> に対して <code class="docutils literal notranslate"><span class="pre">method</span></code> <code class="docutils literal notranslate"><span class="pre">*</span></code> である。</li>
<li>BehavioralFeature の挙動の応答を定義する一つの方法は、それを実装するような Behavior を一つまたは複数指定することである。この関連はその指定を示す。</li>
</ul>
</dd>
<dt>A_ownedParameter_ownerFormalParam</dt>
<dd><ul class="first last simple">
<li>BehavioralFeature から Parameter への composite 関連（単方向）。</li>
<li>関連端 <code class="docutils literal notranslate"><span class="pre">ownedParameter</span></code> はその BehavioralFeature が呼び出されるときに与えられる引数の順序、型、入出力方向の特徴を述べるものである。<ul>
<li>それゆえ <code class="docutils literal notranslate"><span class="pre">ownedParameter</span></code> は <code class="docutils literal notranslate"><span class="pre">{ordered}</span></code> である。</li>
</ul>
</li>
<li>A_ownedMember_namespace を subsets する。</li>
</ul>
</dd>
<dt>A_ownedParameterSet_behavioralFeature</dt>
<dd><ul class="first last simple">
<li>BehavioralFeature から ParameterSet への composite 関連（単方向）。</li>
<li>上述関連の代替？</li>
<li>A_ownedMember_namespace を subsets する。</li>
</ul>
</dd>
<dt>A_defaultValue_owningParameter</dt>
<dd><ul class="first last simple">
<li>Parameter から ValueSpecification への composite 関連（単方向）。</li>
<li>defaultValue が指定されていれば、その BehavioralFeature の呼び出し時に実引数が与えらていない場合に限り、この Parameter として評価されて用いられる。</li>
<li>A_ownedElement_owner を subsets する。</li>
<li>多重度は両端ともに <code class="docutils literal notranslate"><span class="pre">0..1</span></code> である。</li>
</ul>
</dd>
<dt>A_parameterSet_parameter</dt>
<dd><ul class="first last simple">
<li>Parameter と ParameterSet の間の関連（両方向）。</li>
<li>多重度は <code class="docutils literal notranslate"><span class="pre">parameter</span></code> <code class="docutils literal notranslate"><span class="pre">1..*</span></code> に対して
<code class="docutils literal notranslate"><span class="pre">parameterSet</span></code> <code class="docutils literal notranslate"><span class="pre">*</span></code> である。</li>
</ul>
</dd>
<dt>A_condition_parameterSet</dt>
<dd><ul class="first last simple">
<li>ParameterSet から Constraint への composite 関連（単方向）。</li>
<li>関連端 condition の意味は、入力 ParameterSet のそれが Operation における <code class="docutils literal notranslate"><span class="pre">preconditions</span></code> と、出力 ParameterSet のそれが Operation における <code class="docutils literal notranslate"><span class="pre">postconditions</span></code> とそれぞれ同じである。</li>
<li>A_ownedElement_owner を subsets する。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id12">
<h3>9.4.3 Semantics<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id13">
<h4>9.4.3.1 Features<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Feature それぞれは、それの <code class="docutils literal notranslate"><span class="pre">featuringClassifier</span></code> と呼ばれる Classifier と関連付けられている。
Feature は
<code class="docutils literal notranslate"><span class="pre">qualifiers</span></code> として振る舞う Properties を除いて、それの <code class="docutils literal notranslate"><span class="pre">featuringClassifier</span></code> を表すある構造的または挙動的特徴を表現する。</li>
<li><code class="docutils literal notranslate"><span class="pre">isStatic</span></code> 特性はその特徴が Classifier 自身に関係する (true) のか、
Classifier のオブジェクトそれぞれに関係するのかを指定する。</li>
</ul>
</div>
<div class="section" id="structural-features">
<h4>9.4.3.2 Structural Features<a class="headerlink" href="#structural-features" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>StructuralFeature とは Classifier のオブジェクトの構造を指定する
Classifier の型の付いた Feature である。</li>
<li>Properties である Classifier の StructuralFeature は
Classifier の <code class="docutils literal notranslate"><span class="pre">attributes</span></code> と呼ばれる。
UML では Property は StructuralFeature の唯一の種類であるので、
Classifier の StructuralFeatures の全部は Properties,
したがって <code class="docutils literal notranslate"><span class="pre">attributes</span></code> である。</li>
<li>Classifier のオブジェクトごとに直接または継承した非静的な Classifier の <code class="docutils literal notranslate"><span class="pre">attribute</span></code> に対する値または値の集まりがある。<ul>
<li><code class="docutils literal notranslate"><span class="pre">attribute</span></code> の多重度が <code class="docutils literal notranslate"><span class="pre">0..1</span></code> であれば、値がひとつもないか、
Type が <code class="docutils literal notranslate"><span class="pre">attribute</span></code> の Type に適合する単一の値のどちらかがあるものとする。</li>
<li><code class="docutils literal notranslate"><span class="pre">attribute</span></code> の多重度が <code class="docutils literal notranslate"><span class="pre">1..1</span></code> であれば、
Type が <code class="docutils literal notranslate"><span class="pre">attribute</span></code> の Type に適合する単一の値があるものとする。</li>
<li><code class="docutils literal notranslate"><span class="pre">attribute</span></code> の多重度が <code class="docutils literal notranslate"><span class="pre">j..k</span></code> であれば、
Types のそれぞれが <code class="docutils literal notranslate"><span class="pre">attribute</span></code> の Type に適合する
j 個以上 k 個以下の値の集まりがあるものとする。</li>
<li><code class="docutils literal notranslate"><span class="pre">attribute</span></code> の多重度が <code class="docutils literal notranslate"><span class="pre">0</span></code> であれば、値がないものとする。</li>
</ul>
</li>
<li>StructuralFeature に <code class="docutils literal notranslate"><span class="pre">isStatic</span></code> が true であると、上記の点はオブジェクトの個々に対してではなく、ある実行スコープの範囲内にある見分けられる個体とみなされる
Classifier 自身に関係する。</li>
<li>意味論的に準拠しているツールで、継承した静的 StructuralFeature それぞれは二者択一の意味のうちひとつがあるものとする：<ol class="arabic">
<li>実行スコープ内では
StructuralFeature の値または値の集まりは、継承する Classifier のどれに対しても、所有する Classifier の値または値の集まりといつも同じである。これらの意味は Java や C# での静的メンバーに対応する。</li>
<li>実行スコープ内では所有する Classifier とそれを継承する Classifier それぞれに、
StructuralFeature には別々かつ独立した値または値の集まりがある。これらの意味は Ruby や Smalltalk でのクラスインスタンス変数に対応する。</li>
</ol>
</li>
<li>StructuralFeature に <code class="docutils literal notranslate"><span class="pre">isReadOnly</span></code> が true であるならば、いったんそれが初期値を割り当てられると、更新されてはならない。</li>
</ul>
</div>
<div class="section" id="behavioral-features">
<h4>9.4.3.3 Behavioral Features<a class="headerlink" href="#behavioral-features" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>非静的 BehavioralFeature はそれの  <code class="docutils literal notranslate"><span class="pre">featuringClassifier</span></code> のオブジェクトが、固有の挙動の応答を実施することによって、
BehavioralFeature の発動 (invocation) に反応することを指定する。</li>
<li><code class="docutils literal notranslate"><span class="pre">ownedParameters</span></code> のリストは、
BehavioralFeature が発動されるときに与えられ得る、または発動が完了するときに出力されたり返されたりする引数の順序、型、方向を記述する。</li>
<li>方向が in または inout である <code class="docutils literal notranslate"><span class="pre">ownedParameters</span></code> は、引数は BehavioralFeature を発動するときに与えられるものとすることを定義する。</li>
<li>BehavioralFeature はその発動の間に例外を送出することが許される。</li>
<li>BehavioralFeature の挙動の応答を定義する方法のひとつは、
BehavioralFeature を実装する <code class="docutils literal notranslate"><span class="pre">methods</span></code> として、ひとつまたはそれを超える Behaviors を指定することである。<ul>
<li><code class="docutils literal notranslate"><span class="pre">isAbstract</span></code> 特性が true のときには、
BehavioralFeature にはそれを実装する <code class="docutils literal notranslate"><span class="pre">methods</span></code> が何もないことを指定する。</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">concurrency</span></code> 特性は同一オブジェクトに対する同時に起こる呼び出しの意味を指定する。その型とは CallConcurrencyKind という列挙体で、次のリテラル値をとる。<ul>
<li>sequential: 並行性を管理する仕組みはひとつも BehavioralFeature に関連しない。</li>
<li>guarderd: 時間的に重なり合う BehavioralFeature の複数発動がひとつのオブジェクトに対して起こることが許されるが、ひとつしか開始することを許されない。残りは現在実行中の BehavioralFeature が完了するまでブロックされる。</li>
<li>concurrent: 時間的に重なり合う BehavioralFeature の複数発動がひとつのオブジェクトに対して起こることが許されて、それらのすべてを同時に進行することが許される。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="parameters">
<h4>9.4.3.4 Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Parameter は情報を BehavioralFeature の発動に引き渡したり、発動から受け取ったりするのに使われる引数の仕様である。</li>
<li>Parameter に <code class="docutils literal notranslate"><span class="pre">defaultValue</span></code> が指定されているならば、
BehavioralFeature の発動時に実引数が何も渡されないときに限り、それは発動時に評価され、この Parameter の実引数として使われる。</li>
<li>Parameter に <code class="docutils literal notranslate"><span class="pre">name</span></code> を与えることが許されており、そのときには同じ BehavioralFeature の Parameters の中から
Parameter を一意に特定する。<ul>
<li>Parameter に <code class="docutils literal notranslate"><span class="pre">name</span></code> がない場合、引数リストの位置で識別される。</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">direction</span></code> 特性は所有する BehavioralFeature に対して値が入力なのか出力なのかその両方なのかを指定する。その型は ParameterDirectionKind という列挙体で、次のリテラル値からなる。<ul>
<li>in</li>
<li>inout</li>
<li>out</li>
<li>return</li>
</ul>
</li>
<li>BehavioralFeature は、ひとつを超える Parameter に対して、その方向を return にセットするという手段により、
return Parameter と特徴づけることは許されない。</li>
<li><code class="docutils literal notranslate"><span class="pre">effect</span></code> 特性は、
Parameter に入出力されたオブジェクトに何を起こすかを指定するのに用いてよい。型は ParameterEffectKind という列挙体であり、次のリテラル値からなる。<ul>
<li>create: out, inut, return な Parameter 限定。</li>
<li>read</li>
<li>update</li>
<li>delete: in または input な Parameter 限定。</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">isException</span></code> 特性は出力 Parameters に適用する。</li>
<li><code class="docutils literal notranslate"><span class="pre">isStream</span></code> 特性は、true であるときに、ストリーミング Parameter を示す。ストリーミング Parameter はこの機能を実装する Behavior のどれもが、この Parameter 上でストリーミングな挙動を呈するという期待を表す。
<a class="reference internal" href="common-behavior.html"><span class="doc">13 Common Behavior</span></a> で述べる。</li>
<li>BehavioralFeature が所有する ParameterSet とは、その BehavioralFeature を実装する Behaviors が使ってよい入力または出力の代用の集合を与える要素である。<ul>
<li>ParameterSet にある Parameters はすべてが同じ BehavioralFeature の入力であるか、すべてが同じ BehavioralFeature の出力であるものとする。</li>
<li>すべてが入力の ParameterSet は入力 ParameterSet と呼ばれ、すべてが出力の ParameterSet は出力 ParameterSet と呼ばれる。</li>
</ul>
</li>
<li>ParameterSets のより詳細な意味と見本は <a class="reference internal" href="actions.html"><span class="doc">16 Actions</span></a> で見つけられる。</li>
</ul>
</div>
</div>
<div class="section" id="id14">
<h3>9.4.4 Notation<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Feature に対する一般的な表記法はない。サブクラスはそれらに特有の表記法を定義する。</li>
<li>静的 Features は下線を付ける。</li>
<li>Features がリストで示されるところでは、
Features のリストの最終要素として省略記号 <code class="docutils literal notranslate"><span class="pre">(...)</span></code> をさらなる Features が存在するがそのリストには示されていないことを示すのに用いてよい。</li>
<li>読み取り専用 StructuralFeature はその StructuralFeature の表記法の一部として <code class="docutils literal notranslate"><span class="pre">{readOnly}</span></code> を使って示す。</li>
<li>Feature 再定義は
Feature 上に <code class="docutils literal notranslate"><span class="pre">{redefines</span> <span class="pre">&lt;x&gt;}</span></code> 特性文字列を使用して明示的に表記するか、別の Feature と isDistinguishableFrom() を使っても区別できない Feature を所有 Classifier のより一般な Classifiers のうちのひとつにあることをもって暗に示すかのどちらかでよい。</li>
<li>Parameter は p. 108 の BNF の形式のテキスト文字列として示す。<ul>
<li>目を引くのは &lt;perm-propery&gt; だ。付加的な情報を示すのに用いる。値は ordered, unordered, unique, nonunique, seq の文字列から任意個選べる。</li>
</ul>
</li>
<li>Activity 図の ParameterSets の表記法は <a class="reference internal" href="actions.html"><span class="doc">16 Actions</span></a> で見つけられる。他の図式での ParameterSets の表記法はない。</li>
</ul>
</div>
</div>
<div class="section" id="properties">
<h2><a class="toc-backref" href="#id41">9.5 Properties</a><a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id15">
<h3>9.5.1 Summary<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Property は次のものを表現する StructuralFeature である。<ul>
<li>Classifier::<code class="docutils literal notranslate"><span class="pre">attributes</span></code></li>
<li>Association::<code class="docutils literal notranslate"><span class="pre">memberEnds</span></code></li>
<li>StructuralFeature::<code class="docutils literal notranslate"><span class="pre">parts</span></code></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id16">
<h3>9.5.2 Abstract Syntax<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.10 Properties<ul>
<li>Property を中心とした図式である。</li>
</ul>
</li>
</ul>
<dl class="docutils">
<dt>A_ownedAttribute_interface, A_ownedAttribute_datatype, A_ownedAttribute_class</dt>
<dd><ul class="first last simple">
<li>それぞれ Interface, DataType, Class から Property への composite 関連（両方向）。</li>
<li>関連端 ownedAttribute は Classifier の <code class="docutils literal notranslate"><span class="pre">attribute</span></code> であるということを表している。</li>
<li>A_attribute_classifier と A_ownedMember_namespace を subsets する。さらに Class 版関連だけはまだ説明されていない関連を subsets または redefines する。</li>
</ul>
</dd>
<dt>A_memberEnd_association</dt>
<dd><ul class="first last simple">
<li>Association と Property 間の関連（両方向）。</li>
<li>関連端 <code class="docutils literal notranslate"><span class="pre">memberEnd</span></code> は Association の一方の関連端であることを表す。<ul>
<li>二項関連においては、Property は同時に <code class="docutils literal notranslate"><span class="pre">ownedAttribute</span></code> と <code class="docutils literal notranslate"><span class="pre">memberEnd</span></code> であってもよい。どちらか一方の場合、生成されたときに Property は関連の位数に従った個数の Classifier のオブジェクトに関連したある値・値の集まりを表現する。この Classifiers の集まりをその Property の <code class="docutils literal notranslate"><span class="pre">context</span></code> と呼ぶ。</li>
</ul>
</li>
<li>A_member_memberNamespace を subsets する。</li>
</ul>
</dd>
<dt>A_ownedEnd_owningAssociation</dt>
<dd>これは <a class="reference internal" href="structured-classifiers.html"><span class="doc">11 Structured Classifiers</span></a> で説明する。</dd>
<dt>A_qualifier_associationEnd</dt>
<dd><ul class="first last simple">
<li>Property から Property への composite 関連（両方向）。</li>
<li>上述の関連端 <code class="docutils literal notranslate"><span class="pre">memberEnd</span></code> な Property にはそれ自身が
<code class="docutils literal notranslate"><span class="pre">qualifiers</span></code> として働くような他の Properties があってもよい。</li>
<li>関連端 <code class="docutils literal notranslate"><span class="pre">qualifier</span></code> は <code class="docutils literal notranslate"><span class="pre">{ordered}</span></code> である。</li>
<li>A_ownedElement_owner を subsets する。</li>
</ul>
</dd>
<dt>A_defaultValue_owningProperty</dt>
<dd><ul class="first last simple">
<li>Propery から ValueSpecification への composite 関連（単方向）。</li>
<li>関連 A_ownedElement_owner を subsets する。</li>
<li>多重度は両端ともに <code class="docutils literal notranslate"><span class="pre">0..1</span></code> である。</li>
</ul>
</dd>
<dt>A_opposite_property</dt>
<dd><ul class="first last simple">
<li>Property から Property への関連（単方向）。</li>
<li>説明なし。</li>
<li>多重度は両端ともに <code class="docutils literal notranslate"><span class="pre">0..1</span></code> である。</li>
</ul>
</dd>
<dt>A_subsettedProperty_property</dt>
<dd><ul class="first last simple">
<li>Property から Property への関連（単方向）。</li>
<li>これは Property が集約であるときに、
<code class="docutils literal notranslate"><span class="pre">subsetttedProperty</span></code> が <code class="docutils literal notranslate"><span class="pre">property</span></code> から重複構成要素を除外した集合であることを表す。</li>
</ul>
</dd>
<dt>A_redefinedProperty_property</dt>
<dd><ul class="first last simple">
<li>Property から Property への関連（単方向）。</li>
<li>説明なし。</li>
<li>A_redefinedElement_redefinableElement を subsets する。</li>
<li>多重度は両端ともに <code class="docutils literal notranslate"><span class="pre">*</span></code> である。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id17">
<h3>9.5.3 Semantics<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Property は Classifier の <code class="docutils literal notranslate"><span class="pre">attribute</span></code> か、
Association::<code class="docutils literal notranslate"><span class="pre">memberEnd</span></code> か、場合によっては両者を同時に表現することが許される。</p>
</li>
<li><p class="first">一般的なモデリングのシナリオで便利な慣習は、型が Class の一種の Property が Association 端であることで、それに対して型が DataType の一種の Property はそうではない。</p>
</li>
<li><p class="first">Property はひとつまたはそれを超えるオブジェクトの宣言された状態を、値への名前のついた関係に関して表現する。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">memberEnd</span></code> である Property にはそれ自身が
<code class="docutils literal notranslate"><span class="pre">qualifiers</span></code> の役に立つ他の Property があってよい。</p>
</li>
<li><p class="first">Property が <code class="docutils literal notranslate"><span class="pre">ownedAttribute</span></code> を介して
Association 以外の Classifier によって所有されるときに、それは Classifier の <code class="docutils literal notranslate"><span class="pre">attribute</span></code> を表す。</p>
</li>
<li><p class="first">Property に <code class="docutils literal notranslate"><span class="pre">defaultValue</span></code> が指定されていると、
Property に対して特定の設定が不在であるか、
Property に特定の値であることを要求する制約がモデルにあれば、
Property のオブジェクトが生成されるときにこの既定値が評価される。</p>
</li>
<li><p class="first">Property の <code class="docutils literal notranslate"><span class="pre">isDerived</span></code> が true であると、それは派生されたものであり、その値は他の情報から計算されてもよい。</p>
</li>
<li><p class="first">Property は間接的に RedefinableElement の一種であるので、
Properties を再定義してよい。</p>
</li>
<li><p class="first">派生された Property は派生されていないものを再定義してよい。</p>
</li>
<li><p class="first">Property に指定された既定値があり、
Property が別の Property を指定された既定値で再定義するならば、再定義された Property から得られるより一般的な既定値の代わりに再定義する Property の既定値が使われる。</p>
</li>
<li><p class="first">時々 Property はあるオブジェクトがオブジェクトの集合をグループ化するのに使われる情況をモデル化するのに用いられる。これは集約 (aggregation) と呼ばれる。</p>
<ul class="simple">
<li>AggregationKind は次のリテラル値からなる列挙型である。<ul>
<li>none: Property には集約の意味はない。</li>
<li>shared: Property の集約の意味は「共有」である。共有集約の正確な意味は応用領域と設計者によって異なる。</li>
<li>composite: Property が複合的に集約されている。これは集約の強い形であり、全体・部分の関係を表現していると解釈する。</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">合成集約とは、
<code class="docutils literal notranslate"><span class="pre">part</span></code> オブジェクトが高々ひとつの合成オブジェクトに同時に含まれることを必要とする集約の強い形式である。合成オブジェクトが削除されれば、その <code class="docutils literal notranslate"><span class="pre">part</span></code> オブジェクトのすべてが一緒に削除される。</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">原文は instance と object を明らかに使い分けている。私は両者のニュアンスの差を全く理解していない。</p>
</div>
</li>
<li><p class="first">合成は推移的削除性の有向非循環グラフにつなげてよい。つまり、グラフの部品であるオブジェクトをひとつ削除すると、その結果そのオブジェクト下のサブグラフのオブジェクトすべての削除をも生じる。</p>
</li>
<li><p class="first">Property は別の <code class="docutils literal notranslate"><span class="pre">subsetttedProperty</span></code> の部分集合として特徴づけてよい。</p>
</li>
<li><p class="first">Property は
<code class="docutils literal notranslate"><span class="pre">isDerivedUnion</span></code> を true に設定することで導出和集合 (derived union) であると特徴づけてよい。</p>
<ul class="simple">
<li>ある Property が、そのすべての <code class="docutils literal notranslate"><span class="pre">{subsets}</span></code> である Properties の和集合と一致するとき、その Property は導出和集合であると呼ぶのだろう。</li>
</ul>
</li>
<li><p class="first">導出和集合として特徴付けられた属性が <code class="docutils literal notranslate"><span class="pre">isOrded</span></code> が true であり、特定の状況においてそれの部分集合である特性のすべてが順序付けられているか、上限が 1 であると特徴づけられていて、
Classifier::allAttributes() 操作のその状況での値が
well-defined な順序付けを与えるときには、和集合の順序は部分集合の特性を
allAttributes() の結果に出現する順序により評価することと、結果を連結することで定義される。</p>
</li>
<li><p class="first">Property は <code class="docutils literal notranslate"><span class="pre">isID</span></code> 特性を通じて、それが <code class="docutils literal notranslate"><span class="pre">member</span></code> である Classifiers を見分ける識別子である（または部分である）と特徴づけてよい。</p>
</li>
<li><p class="first">Property は ParameterableElement を特殊化して、
Property が仮の ConnectableElementTemplateParameter とて露出されてよいことと、テンプレートの束縛で実引数として与えられてよいことを指定する。</p>
</li>
</ul>
</div>
<div class="section" id="id18">
<h3>9.5.4 Notation<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Property の一般的な記法が BNF 記法で仕様化されている。<ul>
<li>個人的には prop-modifier がいつも気になっている。</li>
</ul>
</li>
<li>限定子 (qualifiers) を表す表記法は <a class="reference internal" href="structured-classifiers.html"><span class="doc">11 Structured Classifiers</span></a> で定義する。</li>
<li>Property の集約を表す表記法は <a class="reference internal" href="structured-classifiers.html"><span class="doc">11 Structured Classifiers</span></a> で定義する。</li>
<li>Classifier では、型、可視性、既定値、多重度、特性文字列を、モデルに存在するときであっても、表示しないようにしてよい。</li>
<li>Classifier では、属性の個々の特性を連続的な文字列としてではなく、列で示してよい。</li>
<li>Classifier では、属性は関連の表記法を使って示してもよいが、そこには集約の修飾物（白または黒塗りダイヤモンド）しか矢印の末尾に示してはいけない。</li>
<li>Property によるテンプレート Classifier を引数化するのに用いられる
ConnectableElementTemplateParameter を表す表記法は p. 112 末端の
BNF 記法が指定するもので与えられる。</li>
</ul>
</div>
<div class="section" id="id19">
<h3>9.5.5 Examples<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.11 Examples of attributes<ul>
<li>スラッシュの使い方が複数ある？</li>
</ul>
</li>
<li>Figure 9.12 Association-like notation for attributes<ul>
<li>属性が関連の記法でどう示されるのかを示す。</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="operations">
<h2><a class="toc-backref" href="#id42">9.6 Operations</a><a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id20">
<h3>9.6.1 Summary<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Operation とは、Interface, DataType, または Class が所有することが許される BehavioralFeature である。
Operations はテンプレート化することもテンプレート引数として使うことも許される。</li>
</ul>
</div>
<div class="section" id="id21">
<h3>9.6.2 Abstract Syntax<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.13 Operations<ul>
<li>Operation を中心とした図式。</li>
<li>左側は Property の図式とそっくり。</li>
</ul>
</li>
</ul>
<dl class="docutils">
<dt>A_ownedOperation_interface, A_ownedOperation_datatype, A_ownedOperation_class</dt>
<dd><ul class="first last simple">
<li>Interface, DataType, Class いずれかから Operation への composite 関連（双方向）。</li>
<li>各 Classifier が Operation(s) を所有してもよいという意味。</li>
<li><code class="docutils literal notranslate"><span class="pre">ownedOperation</span></code> は <code class="docutils literal notranslate"><span class="pre">{ordered}</span></code> である。</li>
<li>A_feature_featuringClassifier を subsets する。</li>
<li>A_redefinitionContext_redefinableElement を subsets する。</li>
<li>A_ownedMember_namespace を subsets する。</li>
</ul>
</dd>
<dt>A_ownedParameter_operation</dt>
<dd><ul class="first last simple">
<li>Operation から Parameter への composite 関連（双方向）。</li>
<li>Parameter は Operation の構成要素の一つである。</li>
<li>A_ownedParameter_ownerFormalParam を subsets する。<ul>
<li>ownedParameter の方は <code class="docutils literal notranslate"><span class="pre">{ordered,</span> <span class="pre">redefines</span> <span class="pre">ownedParameter}</span></code> となっている。</li>
</ul>
</li>
</ul>
</dd>
<dt>A_precondition_preContext, A_postcondition_postContext, A_bodyCondition_bodyContext</dt>
<dd><ul class="first last simple">
<li>Operation から Constraint への composite 関連（単方向）。</li>
<li><code class="docutils literal notranslate"><span class="pre">precondition</span></code> と <code class="docutils literal notranslate"><span class="pre">postcondition</span></code> は Operation の呼び出しに関する事前条件と事後条件をそれぞれ意味する。</li>
<li><code class="docutils literal notranslate"><span class="pre">bodyCondition</span></code> は Operation の戻す結果をその仕様が計算する値によって縛りをかける。</li>
<li>A_ownedRule_context を subsets する。</li>
</ul>
</dd>
<dt>A_raisedException_operation</dt>
<dd><ul class="first last simple">
<li>Operation から Type への関連（単方向）。</li>
<li>Operation はその呼出期間中に例外を送出してもよい。そういう場合は上述の <code class="docutils literal notranslate"><span class="pre">postcondition</span></code> や <code class="docutils literal notranslate"><span class="pre">bodyCondition</span></code> は成立していると仮定するべきではない。</li>
<li>A_raisedException_behavioralFeature を subsets する。<ul>
<li>図では <code class="docutils literal notranslate"><span class="pre">operation</span></code> が <code class="docutils literal notranslate"><span class="pre">{subsets}</span></code> で
<code class="docutils literal notranslate"><span class="pre">raisedException</span></code> が <code class="docutils literal notranslate"><span class="pre">{redefines}</span></code> になっている？</li>
</ul>
</li>
</ul>
</dd>
<dt>A_redefinedOperation_operation</dt>
<dd><ul class="first last simple">
<li>Operation から Operation への関連（単方向）。</li>
<li>Operation を継承クラスで再定義することを示す関連だろうか。</li>
<li>A_redefinedElement_redefinableElement を subsets する。</li>
</ul>
</dd>
<dt>A_parameteredElement_templateParameter</dt>
<dd><ul class="first last simple">
<li>OperationTemplateParameter と Operation の間の関連（双方向）。</li>
<li>同名関連の redefines である。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id22">
<h3>9.6.3 Semantics<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id23">
<h4>9.6.3.1 Operations<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Operation は Interface, DataType, または Class の BehavioralFeature である。</li>
<li>戻り値があれば、Operation の型はこの Parameter の方と同じである。そうでなければ Operation には型がない。</li>
<li>Operation の <code class="docutils literal notranslate"><span class="pre">precondition</span></code> は Operation が発動されるときに
true であるとする条件を定義する。</li>
<li>Operation の <code class="docutils literal notranslate"><span class="pre">postcondition</span></code> は Operation の発動が成功裡に完了するときに
true である条件を定義する。</li>
<li>Operation の <code class="docutils literal notranslate"><span class="pre">bodyCondition</span></code> は
<code class="docutils literal notranslate"><span class="pre">bodyCondition</span></code> の仕様により計算される値に対し返る結果を抑制する。</li>
<li>Operation は発動の間に例外を送出してよい。</li>
<li>Operation は <code class="docutils literal notranslate"><span class="pre">featuringClassifier</span></code> の特殊化で再定義してよい。</li>
<li>Operation が特殊化で再定義されるときに、異なる型適合システムは、引数と結果の型がどのように変わってよいのかを決める、異なる概略を採用する。<ul>
<li>型が異なってはならないときは、それは不変性 (invariance) と呼ばれる。</li>
<li>引数型が特殊型に特殊化されてよいときは、それは共変性 (covariance) と呼ばれる。</li>
<li>引数型が特殊型で一般化されてよいときは、それは反変性 (contravariance) と呼ばれる。</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">isQuery</span></code> 特性が true であると、
Operation の発動はオブジェクトまたはモデル内の他のどんな要素の状態を修正しないものとする。<ul>
<li>C++ で言うところの const メンバー関数のような概念だろう。それより条件が強いように見える。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="template-operations">
<h4>9.6.3.2 Template Operations<a class="headerlink" href="#template-operations" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Operation はテンプレート Operations と被束縛 Operations の特殊化を支援するために
TemplateableElement を特殊化する。</li>
</ul>
</div>
<div class="section" id="operation-template-parameters">
<h4>9.6.3.3 Operation Template Parameters<a class="headerlink" href="#operation-template-parameters" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Operation はテンプレートによって
OperationTemplateParameter を通じて、仮テンプレート引数として露出してよい。</li>
<li>OperationTemplateParameter のための既定値は露出された Operation と同じ引数型、方向、多重度である
Operation でなければならない。</li>
</ul>
</div>
</div>
<div class="section" id="id24">
<h3>9.6.4 Notation<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Operation のテキストによる表現形式を BNF 記法で仕様化している。ザッと見た感じでは Parameter の記法に準じているように見受けられる。</li>
<li>次に template Operation の TemplateParameter の記法を仕様化している。
Operation の名前と Parameters の間に山括弧でリストするというものだ。</li>
<li>さらに OperationTemplateParameter の記法を仕様化している。これは TemplateParameter の記法を拡張することでなされる。</li>
<li>例外とストリーミング Parameters およびストリーミング Operations のクラス図における表記法には、特性文字列にキーワード <code class="docutils literal notranslate"><span class="pre">execption</span></code> および <code class="docutils literal notranslate"><span class="pre">stream</span></code> がある。</li>
</ul>
</div>
<div class="section" id="id25">
<h3>9.6.5 Examples<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>テンプレートが絡む記法は山括弧がダブって読みにくくなる。まるで C++ のコード。</li>
</ul>
</div>
</div>
<div class="section" id="generalization-sets">
<h2><a class="toc-backref" href="#id43">9.7 Generalization Sets</a><a class="headerlink" href="#generalization-sets" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id26">
<h3>9.7.1 Summary<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>GeneralizationSet は Generalizations を直交する寸法にグループ分けする手段を与える。
GeneralizationSet はその <code class="docutils literal notranslate"><span class="pre">powertype</span></code> と呼ばれる Classifier と結びつけてよい。これらの技法は分類階層を組織化にさらなる表現力を与える。</li>
</ul>
</div>
<div class="section" id="id27">
<h3>9.7.2 Abstract Syntax<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.14 Generalization Sets<ul>
<li>Figure 9.1 の一部を詳細にしたもの。</li>
</ul>
</li>
</ul>
<dl class="docutils">
<dt>A_generalizationSet_generalization</dt>
<dd><ul class="first last simple">
<li>Generalization と GeneralizationSet の間の関連（両方向）。</li>
<li>Generalization がどの GeneralizationSet に所属するのかを示す。</li>
<li>両関連端は多重度 <code class="docutils literal notranslate"><span class="pre">*</span></code> である。</li>
</ul>
</dd>
<dt>A_powertypeExtent_powertype</dt>
<dd><ul class="first last simple">
<li>Classifier と GeneralizationSet との間の関連（両方向）。</li>
<li>この関連が意味するのは、
GeneralizationSet の各 Generalization に対して、特殊化 Classifier が <code class="docutils literal notranslate"><span class="pre">powertype</span></code> のオブジェクトに一意に関連している、ということだ。<ul>
<li>すなわち <code class="docutils literal notranslate"><span class="pre">powertype</span></code> オブジェクトと対応する Classifiers が意味的に等価であると扱われる。</li>
</ul>
</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id28">
<h3>9.7.3 Semantics<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Generalizations は一般化の直交寸法を表現するのにグループ化されてよい。グループのそれぞれは GeneralizationSet により表現される。</li>
<li>GeneralizationSet の <code class="docutils literal notranslate"><span class="pre">isCovering</span></code> 特性は、その集合にある Generalizations の特定の Classifiers が完全であるかどうかを示す。つまり、Classifier の任意の派生型オブジェクトは、ここにある Classifiers の少なくとも一つのもののそれであることが常に成り立つ。</li>
<li><code class="docutils literal notranslate"><span class="pre">isDisjoint</span></code> 特性はその集合にある Generalizations の特定の Classifiers に部分的に重なりがある (false) かどうかを指定する。</li>
<li>GeneralizationSet は任意で <code class="docutils literal notranslate"><span class="pre">powertype</span></code> と呼ばれる Classifier と結びつけてよい。</li>
</ul>
</div>
<div class="section" id="id29">
<h3>9.7.4 Notation<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Generalization 関係の線分に名前があるとき、その名前は Generalization が所属する GeneralizationSet を指名する。</li>
<li>Figure 9.15 GeneralizationSets designated by name<ul>
<li>Generalization の名前をいつもの矢印のラベルに記している。</li>
</ul>
</li>
<li>Figure 9.16 GeneralizationSets designated by shared target<ul>
<li>以前にも見た shared target style による記法。</li>
</ul>
</li>
<li>Figure 9.17 GeneralizationSet designated by dashed line spanning Generalization arrows<ul>
<li>破線を矢印群に交差させることで GeneralizationSet を示す。</li>
<li>ラベルを省略しても GeneralizationSet の存在を示唆できるというささやかな利点がある。</li>
</ul>
</li>
<li>Table 9.1 GeneralizationSet constraints<ul>
<li><code class="docutils literal notranslate"><span class="pre">isCovering</span></code> と <code class="docutils literal notranslate"><span class="pre">isDisjoint</span></code> の記法は制約の記法に準じる。</li>
</ul>
</li>
<li>Figure 9.18 GeneralizationSet constraint notation with shared target style</li>
<li>Figure 9.19 GeneralizationSet constraint notation with dashed line style<ul>
<li>制約はラベル内に記す。</li>
</ul>
</li>
<li>Figure 9.20 Power type notation with shared target style</li>
<li>Figure 9.21 Power type notation with dashed line style<ul>
<li><code class="docutils literal notranslate"><span class="pre">powertype</span></code> の記法は GeneralizationSet のそれに準じる。名前の前にコロンを付す。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id30">
<h3>9.7.5 Examples<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p>ここの見本が分かりやすいので、GeneralizationSet の概念を誤解しにくくなっている。</p>
<ul class="simple">
<li>Figure 9.22 GeneralizationSet notation options<ul>
<li>抽象クラス Person が Woman および Man に特殊化されている。独立して、Employee に特殊化されている。
Woman と Man への特殊化が GeneralizationSet をひとつ、
Employee への特殊化が別の GeneralizationSet を構成している。この見本はさまざまな表記法形式を使って (employs) いる。</li>
<li>抽象型 Person を異なる基準で特殊化していることがよくわかる。</li>
</ul>
</li>
<li>Figure 9.23 GeneralizationSets and constraints<ul>
<li>男か女かにしか分類できないし、これらは互いに排他的な概念なので、ラベルに <code class="docutils literal notranslate"><span class="pre">{complete,</span> <span class="pre">disjoint}</span></code> と記してよい。</li>
</ul>
</li>
<li>Figure 9.24 Power type example<ul>
<li><code class="docutils literal notranslate"><span class="pre">powertype</span></code> TreeSpecies による Tree の派生モデル。</li>
</ul>
</li>
<li>Figure 9.25 More power type examples<ul>
<li><code class="docutils literal notranslate"><span class="pre">powertype</span></code> いろいろ。</li>
<li>GeneralizationSet でコロンで始まる名前は
<code class="docutils literal notranslate"><span class="pre">powertype</span></code> であることを示す。</li>
</ul>
</li>
<li>Figure 9.26 More than one powertype<ul>
<li><code class="docutils literal notranslate"><span class="pre">powertype</span></code> が複数存在するときには、
<code class="docutils literal notranslate"><span class="pre">powertypes</span></code> と共にサブタイプの集まりにラベルを付けることがますます重要になってくる。</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="instances">
<h2><a class="toc-backref" href="#id44">9.8 Instances</a><a class="headerlink" href="#instances" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id31">
<h3>9.8.1 Summary<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>InstanceSpecifications はモデル化されたシステムで
Classifiers のオブジェクトを表現する。</li>
</ul>
</div>
<div class="section" id="id32">
<h3>9.8.2 Abstract Syntax<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.27 Instances<ul>
<li>InstanceSpecification, Slot, InstanceValue をやる。</li>
</ul>
</li>
</ul>
<dl class="docutils">
<dt>A_slot_owningInstance</dt>
<dd><ul class="first last simple">
<li>InstanceSpecification から Slot への composite 関連。</li>
</ul>
</dd>
<dt>A_classifier_instanceSpecification</dt>
<dd><ul class="first last simple">
<li>InstanceSpecification から Classifier への関連（単方向）。</li>
<li>InstanceSpecification のオブジェクトの種類として参照する。</li>
<li>例えば <code class="docutils literal notranslate"><span class="pre">classifier</span></code> が<ul>
<li>Class ならばその Class のオブジェクトの特徴を述べ、</li>
<li>Association ならばその Association のリンクの特徴を述べ、</li>
<li>空ならば表現されているオブジェクトの種類を強制しない。</li>
</ul>
</li>
</ul>
</dd>
<dt>A_definingFeature_slot</dt>
<dd><ul class="first last simple">
<li>Slot から StructuralFeature への関連（単方向）。</li>
</ul>
</dd>
<dt>A_value_owningSlot</dt>
<dd><ul class="first last simple">
<li>Slot から ValueSpecification への composite 関連（単方向）。</li>
<li>関連 A_ownedElement_owner を subsets する。</li>
<li>value は <code class="docutils literal notranslate"><span class="pre">{ordered}</span></code> である。</li>
<li>value は型、多重度、等々において前述の definingFeature と適合する必要がある。</li>
</ul>
</dd>
<dt>A_specification_owningInstanceSpec</dt>
<dd><ul class="first last simple">
<li>InstanceSpecification から ValueSpecification への composite 関連（単方向）。</li>
<li>もし specification があれば、InstanceSpecification の値を与えるために
ValueSpecification が評価される。</li>
<li>もし InstanceSpecification の参照する classifiers が一つ以上ある場合、
ValueSpecification の型は少なくとも classifiers の一つには適合する必要がある。</li>
</ul>
</dd>
<dt>A_instance_instanceValue</dt>
<dd><ul class="first last simple">
<li>InstanceValue から InstanceSpecification への関連（単方向）。</li>
<li>InstanceValue は参照する InstanceSpecification を所有しない。複数の InstanceValues が同じ InstanceSpecification を参照してもよい。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id33">
<h3>9.8.3 Semantics<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>InstanceSpecification はモデル化されたシステムであり得るまたはオブジェクトの現実の存在を表し、それらのオブジェクトを完全にまたは部分的に記述する。</li>
<li>Slot は InstanceSpecification により模されるオブジェクトが特定の StructuralFeature のために値であることを指定する。それは
<code class="docutils literal notranslate"><span class="pre">classifier</span></code> が再定義された StructuralFeatures を除いた Association であるならば、直接の属性、継承された属性、一般化において private な属性、または <code class="docutils literal notranslate"><span class="pre">memberEnd</span></code> であるということにより
Slot を所有する InstanceSpecification の
<code class="docutils literal notranslate"><span class="pre">classifier</span></code> に関する StructuralFeature であるものとする。</li>
<li>InstanceSpecification は次のものを表現してよい。<ul>
<li>一つまたはそれを超える Classifiers によるオブジェクトの分類。いずれも抽象でよい。</li>
<li>それの <code class="docutils literal notranslate"><span class="pre">classifiers</span></code> に基づくオブジェクトの種類。</li>
<li>オブジェクトの StructuralFeatures の値の仕様。値は Slots に含まれる。</li>
<li>ValueSpecification による、オブジェクトの計算方法、導出方法、構築方法の選択自由の仕様。</li>
</ul>
</li>
<li>InstanceSpecification はある時点におけるオブジェクト、スナップショットを表してよい。</li>
<li>InstanceSpecification はモデル要素であって、モデル化しているオブジェクトと混同するべきではないということを留意することは重要である。</li>
<li>InstanceValue とは、値が InstanceSpecification を用いて指定される
ValueSpecification の一種である。</li>
<li>InstanceValue はそれが参照する InstanceSpecification を所有しない。それに対して InstanceValues は同じ InstanceSpecification を参照してよい。</li>
</ul>
</div>
<div class="section" id="id34">
<h3>9.8.4 Notation<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>InstanceSpecification はその <code class="docutils literal notranslate"><span class="pre">classifiers</span></code> と似た記法を用いて描かれるが、
Classifier の名前が現れる代わりに、もしあればオブジェクト名、コロン、Classifier の名前（たち）を連結し、下線を引く。</li>
<li>InstanceSpecification の <code class="docutils literal notranslate"><span class="pre">classifier</span></code> が Association であるものはリンクを表現し、Association の同じ記法を用いて示すが、実線のパスは Classifiers ではなく InstanceSpecifications を接続する。</li>
<li>Classifiers と InstanceSpecifications では名前はオプションである。</li>
<li>無名 (unnamed) Classifier の無名 (anonymous) InstanceSpecification 標準表記は下線のついたコロンである。</li>
<li>Slots は対応する StructuralFeatures のそれに似た記法を用いて示す。</li>
<li>InstanceValue はテキストによる記法または図表的な表記法を用いて現れてよい。</li>
<li>InstanceValue である Slot 値は代わりにリンクのそれに似た図式的表記法を用いて示してよい。</li>
<li>StructuredClassifier により分類される InstanceSpecification では、それはその役目を演じるオブジェクトを表す、入れ子の矩形を含んでよい。</li>
<li>InstanceSpecification の名前にオブジェクトが演じる役目の名前を続けてよい。</li>
<li>InstanceSpecification が Slot 値と役目を描写する入れ子の矩形の両方を含むところでは、それは属性に類する区画と対応する StructuredClassifier の内部構造区画に分割される。</li>
</ul>
</div>
<div class="section" id="id35">
<h3>9.8.5 Examples<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Figure 9.28 Specification of an Instance of String<ul>
<li>String 型オブジェクト streetName の図式に見える。</li>
<li>これが InstanceSpecification の記法の一つの見本となる。</li>
<li>識別子の下にある引用符で括られた文字列が値である。</li>
</ul>
</li>
<li>Figure 9.29 Slots with values<ul>
<li>Slots 付き InstanceSpecification の記法例。</li>
</ul>
</li>
<li>Figure 9.30 InstanceSpecifications representing two objects connected by a link<ul>
<li>リンク付き InstanceSpecifications の記法例。</li>
</ul>
</li>
<li>Figure 9.31 InstanceValue represented textually<ul>
<li>InstanceValue の記法例。Slot から参照して欲しいようだ。</li>
</ul>
</li>
<li>Figure 9.32 InstanceValue represented graphically<ul>
<li>上記例題を関連の記法？で書き直した。</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="classifier-descriptions">
<h2><a class="toc-backref" href="#id45">9.9 Classifier Descriptions</a><a class="headerlink" href="#classifier-descriptions" title="Permalink to this headline">¶</a></h2>
<p>機械生成による節。</p>
</div>
<div class="section" id="association-descriptions">
<h2><a class="toc-backref" href="#id46">9.10 Association Descriptions</a><a class="headerlink" href="#association-descriptions" title="Permalink to this headline">¶</a></h2>
<p>機械生成による節。</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="simple-classifiers.html" title="10 Simple Classifiers"
             >next</a></li>
        <li class="right" >
          <a href="values.html" title="8 Values"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Unified Modeling Language 2.5 読書ノート</a> &#187;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2018, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>