<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>12 Packages &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="13 Common Behavior" href="ch13-common-behavior.html" />
    <link rel="prev" title="11 Structured Classifiers" href="ch11-structured-classifiers.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="ch11-structured-classifiers.html" title="Previous document">11 Structured Classifiers</a>
        </li>
        <li>
          <a href="ch13-common-behavior.html" title="Next document">13 Common Behavior</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="packages">
<h1><a class="toc-backref" href="#id9" role="doc-backlink">12 Packages</a><a class="headerlink" href="#packages" title="Permalink to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#packages" id="id9">12 Packages</a></p>
<ul>
<li><p><a class="reference internal" href="#summary" id="id10">12.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id11">12.2 Packages</a></p></li>
<li><p><a class="reference internal" href="#profiles" id="id12">12.3 Profiles</a></p></li>
<li><p><a class="reference internal" href="#classifier-descriptions" id="id13">12.4 Classifier Descriptions</a></p></li>
<li><p><a class="reference internal" href="#association-descriptions" id="id14">12.5 Association Descriptions</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="summary">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">12.1 Summary</a><a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p>Packages provide the main generic structuring and organizing capability of
UML. There are specializations for Models and for Profiles which organize
extensions to UML.</p>
</div></blockquote>
</section>
<section id="id1">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">12.2 Packages</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<section id="id2">
<h3>12.2.1 Summary<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>This sub clause provides the specification for Packages and Models.</p>
</div></blockquote>
</section>
<section id="abstract-syntax">
<h3>12.2.2 Abstract Syntax<a class="headerlink" href="#abstract-syntax" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 12.1 Packages</p>
</div></blockquote>
<ul class="simple">
<li><p>Package, Model, PackageMerge が新しく現れた。</p></li>
<li><p>Type も PackageableElement の一種であることが図では省略してある。</p></li>
</ul>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">A_packagedElement_owningPackage</span></code></dt><dd><p>Package から PackageableElement への複合関連（単方向）。</p>
<ul class="simple">
<li><p>Package は Namespace であり、所有要素を関連端 <code class="docutils literal notranslate"><span class="pre">packagedElement</span></code> で表現する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_ownedMember_namespace</span></code> を subsets する。</p></li>
</ul>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">A_ownedType_package</span></code></dt><dd><p>Package から Type への複合関連（双方向）。</p>
<ul class="simple">
<li><p>Type である内容物への参照を表現する関連。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_packagedElement_owningPackage</span></code> を subsets する。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_nestedPackage_nestingPackage</span></code></dt><dd><p>Package から Package への複合関連（双方向）。</p>
<ul class="simple">
<li><p>Package である内容物への参照を表現する関連。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_packagedElement_owningPackage</span></code> を subsets する。</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_packageMerge_receivingPackage</span></code></dt><dd><p>Package から PackageMerge への複合関連（双方向）。</p>
<ul class="simple">
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">receivingPackage</span></code> 側の Package が合併前後で構成要素が増える方を指す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_ownedElement_owner</span></code> と <code class="docutils literal notranslate"><span class="pre">A_source_directedRelationship</span></code> を subsets する。</p></li>
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">receivingPackage</span></code> の多重度はちょうど 1 だ。</p></li>
<li><p>cf. <code class="docutils literal notranslate"><span class="pre">A_mergedPackage_packageMerge</span></code></p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_mergedPackage_packageMerge</span></code></dt><dd><p>PackageMerge から Package への関連（単方向）。</p>
<ul class="simple">
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">mergedPackage</span></code> は合併前後でその構成内容物が変わらない方を指す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_target_directedRelationship</span></code> を subsets する。</p></li>
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">mergedPackage</span></code> の多重度はちょうど 1 だ。</p></li>
<li><p>cf. <code class="docutils literal notranslate"><span class="pre">A_packageMerge_receivingPackage</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="semantics">
<h3>12.2.3 Semantics<a class="headerlink" href="#semantics" title="Permalink to this heading">¶</a></h3>
<section id="package">
<h4>12.2.3.1 Package<a class="headerlink" href="#package" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A Package is a namespace for its <code class="docutils literal notranslate"><span class="pre">members</span></code>, which comprise those elements
associated via packagedElement (which are said to be <em>owned</em> or <em>contained</em>),
and those <em>imported</em>.</p>
</div></blockquote>
<p>Package 定義は含まれる要素を併合することで他の Package の内容を拡張することが可能だ。</p>
<blockquote>
<div><p>A Package may be defined as a template and bound to other templates: see sub
clause 7.3, Templates, for further information.</p>
<p>The URI can be specified to provide a unique identifier for a Package.</p>
</div></blockquote>
<p>UML の内側では、プロファイル (12.3.3) を除いて、これに対する決められた使い方はない。例えば、モデル管理機能がモデルの識別のために使用することがある。</p>
<ul class="simple">
<li><p>URI はなるべく一意であり、一度割り当てられたらなるべく変更されない。</p></li>
<li><p>URI が再参照可能である必要はない（当然これは許容される）。</p></li>
</ul>
</section>
<section id="packagemerge">
<h4>12.2.3.2 PackageMerge<a class="headerlink" href="#packagemerge" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A PackageMerge is a directed relationship between two Packages that indicates
that the contents of the target <code class="docutils literal notranslate"><span class="pre">mergedPackage</span></code> are combined into the
source <code class="docutils literal notranslate"><span class="pre">receivingPackage</span></code> according to a set of rules defined below.</p>
</div></blockquote>
<ul>
<li><p>元要素が対象要素の特徴を自身のそれに概念的に追加し、その結果として双方の特徴を兼ね合わせた要素になるという意味で Generalization に似ている。</p></li>
<li><p>サブクラスが継承された特徴で通常は叙述されないのと同じように、受信 Package はその <code class="docutils literal notranslate"><span class="pre">mergedPackage</span></code> から併合した要素で叙述されることは通常ない。</p></li>
<li><p>モデルの意味論上、明示的な PackageMerges を持つモデルと、すべての併合が実行されたモデルに違いはない。</p>
<blockquote>
<div><p>Also, as with Generalization, a Package may not merge itself (directly or
indirectly).</p>
</div></blockquote>
</li>
</ul>
<p>PackageMerge の能力は、異なる Package で定義された要素が同じ <code class="docutils literal notranslate"><span class="pre">name</span></code> を持ち、同じ概念を表すことを意図している場合に使用されるように設計されている。</p>
<blockquote>
<div><p>A given base concept may be merged for different purposes, with each purpose
defined in a separate receiving Package. By selecting different receiving
packages, it is possible to obtain a custom definition of a concept for a
specific end.</p>
</div></blockquote>
<p>ある基本概念は、異なる目的のために併合されることがあり、各目的は別々の受信
Package で定義される。</p>
<p>受信 Package に含まれるモデル要素への言及は、その Package に含まれる増分ではなく、併合結果への言及を意味する。これを図示しているのが Figure 12.2 だ。</p>
<blockquote>
<div><p>Figure 12.2 Illustration of the Meaning of Package Merge</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">P2::A</span></code> は <code class="docutils literal notranslate"><span class="pre">P1::A</span></code> の増分を定義する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P3::SubA</span></code> は <code class="docutils literal notranslate"><span class="pre">P2::A</span></code> のサブクラスの定義だ。<code class="docutils literal notranslate"><span class="pre">P3</span></code> から見ると、
<code class="docutils literal notranslate"><span class="pre">P2::A</span></code> は <code class="docutils literal notranslate"><span class="pre">P1</span></code> と <code class="docutils literal notranslate"><span class="pre">P2</span></code> の間のマージ結果の <code class="docutils literal notranslate"><span class="pre">A</span></code> を表現していると解釈する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P1</span></code>: <code class="docutils literal notranslate"><span class="pre">mergedPackage</span></code> (<code class="docutils literal notranslate"><span class="pre">target</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P2</span></code>: <code class="docutils literal notranslate"><span class="pre">receivingPackage</span></code> (<code class="docutils literal notranslate"><span class="pre">source</span></code>, <code class="docutils literal notranslate"><span class="pre">owner</span></code>) であると同時に
<code class="docutils literal notranslate"><span class="pre">resultingPackage</span></code></p></li>
</ul>
<p>マージの <code class="docutils literal notranslate"><span class="pre">before</span></code>/<code class="docutils literal notranslate"><span class="pre">after</span></code> で同じところにあるものの呼び方が変わる
(<code class="docutils literal notranslate"><span class="pre">receiving</span></code>/<code class="docutils literal notranslate"><span class="pre">resulting</span></code>) ことがわかればとりあえず読める。</p>
<p>PackageMerge は併合される Package の内容が受け取る Package の内容と結合される操作（それ自体が変換の集合である）という見方が可能だ。Packages 二つのある要素が（定義された規則に従って）合致する場合、それらの内容は以下に指定された
PackageMerge の公式規則に従って一つの結果の要素に（概念上）併合される。</p>
<blockquote>
<div><p>This operation is akin to “copying down” the features of superclasses into a
subclass: the fully expanded subclass is the equivalent to the resulting
package.</p>
</div></blockquote>
<p>PackageMerge の規則を理解するには、三種の異なる実体を明確に区別する必要がある：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mergedPackage</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">P1</span></code> in Fig. 12.2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">receivingPackage</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">P2</span></code>)</p></li>
<li><p>合併変換の結果 (also <code class="docutils literal notranslate"><span class="pre">P2</span></code>)</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">receivingPackage</span></code> は <code class="docutils literal notranslate"><span class="pre">resultingPackage</span></code> の役割も果たす。同じモデル要素にこのような二重の解釈があると混乱するので、理解を助けるために以下の術語を導入する：</p>
<dl>
<dt>併合されたパッケージ (merged package)</dt><dd><p>受領パッケージに併合されるパッケージ（図式中の矢印の目標側パッケージ）。</p>
</dd>
<dt>受領パッケージ (receiving package)</dt><dd><p>概念上は、併合の結果を含むパッケージ（図式中の矢印の起点側パッケージ）であるのだが、この用語は併合変換が実施される前のパッケージおよびその中身を指すのに用いる。</p>
</dd>
<dt>結果パッケージ (resulting package)</dt><dd><p>概念上は、併合の結果を含むパッケージだ。モデルでは当然ながらこれは受領パッケージと同じパッケージだが、この特定の用語は併合変換が実施された後のパッケージおよびその中身を指すのに用いる。</p>
</dd>
<dt>併合された要素 (merged element)</dt><dd><p>併合されたパッケージに存在するモデル要素を指す。</p>
</dd>
<dt>受領要素 (receiving element)</dt><dd><p>受領パッケージにあるモデル要素。</p>
</dd>
<dt>結果要素 (resulting element)</dt><dd><p>併合が実施された後の結果パッケージにあるモデル要素。は、受信パッケージのモデル要素です。その要素に合致する（以下に定義する）併合された要素がある場合、その二つが結合されて結果要素が生成される（後述）。この用語は、併合が実行される前の要素を指すために用いる（「結果」と言っているが「実行される前の」だ）。</p>
</dd>
<dt>要素型 (element type)</dt><dd><p>Parameter や StructuralFeature の <code class="docutils literal notranslate"><span class="pre">type</span></code> のような、TypedElement のあらゆる種類の <code class="docutils literal notranslate"><span class="pre">type</span></code> を指す。</p>
</dd>
<dt>要素メタタイプ (element metatype)</dt><dd><p>モデル要素の <abbr>MOF</abbr> 型だ。例えば Classifier, Association, Feature だ。</p>
<blockquote>
<div><p>Figure 12.3 Conceptual View of the Package Merge Semantics</p>
</div></blockquote>
</dd>
</dl>
<ul class="simple">
<li><p>図の右側は UML の図式ではない。</p></li>
<li><p>この <code class="docutils literal notranslate"><span class="pre">B</span></code> ダッシュを意識することがコツだと言っている。</p></li>
</ul>
<p>PackageMerge の意味は制約と変換の集合で定義される。制約は有効な PackageMerge にに対する事前条件を指定し、一方、変換はその意味上の効果（事後条件）を記述する。制約がいくつか違反していれば PackageMerge は ill-formed であり、それを含むモデルは無効だ。</p>
<blockquote>
<div><p>Different element metatypes have different semantics, but the general
principle is always the same</p>
</div></blockquote>
<p>結果の要素は併合する前よりも能力が低下することはない。例えば、PackageMerge の結果として、受け取るモデル要素の回航可能性、多重度、可視性等々が低下することはないことを意味する。</p>
<blockquote>
<div><p>One of the key consequences of this is that model elements in the resulting
Package are compatible extensions of the corresponding elements in the
(unmerged) receiving package.</p>
</div></blockquote>
<p>本仕様では、明示的な合併変換は一定の一般的メタモデル (Packages, Classes,
Associations, Properties, etc.) に対してしか定義していない。他の種類の要素メタタイプ（例えば状態機械や相互作用）の意味が複雑かつ領域固有であるので、このような変換はできない。</p>
<blockquote>
<div><p>Elements of all other kinds of metatypes are transformed according to the
<em>default rule</em>: they are simply deep copied into the resulting package. (This
rule can be superseded for specific metatypes through profiles or other kinds
of language extensions.)</p>
</div></blockquote>
</section>
<section id="general-package-merge-rules">
<h4>12.2.3.3 General Package Merge Rules<a class="headerlink" href="#general-package-merge-rules" title="Permalink to this heading">¶</a></h4>
<p>併合される要素と受領要素が合致する (to match) とは、以下の規則群を満たすことを言う。</p>
<dl>
<dt>CONSTRAINTS</dt><dd><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">«merge»</span></code> 有向グラフに閉路があることは不可能だ。</p></li>
<li><p>Package は（直接または間接的に <code class="docutils literal notranslate"><span class="pre">owningPackage</span></code> を介して）その Package を含む Package を併合することは不可能だ。</p></li>
<li><p>Package はそれが含む Package を（直接または間接的に <code class="docutils literal notranslate"><span class="pre">packagedElement</span></code> を介して）併合することは不可能だ。</p></li>
<li><p>メタタイプが Package, Class, DataType, Property, Association, Operation,
Constraint, Enumeration, EnumerationLiteral の一種ではないような併合された要素には、その受領要素が併合された要素の厳密な複製ではない限りは、同じ名前とメタタイプを持つ受領要素を持つことは不可能だ。</p></li>
<li><p>PackageMerge は併合を実施するのに要求される制約のすべて（この一覧）が成り立つとき、かつそのときに限り有効だ。</p></li>
<li><p>合致する型付けられた要素 (e.g., Properties, Parameters) は、適合する型である必要がある。Classes またはDataTypes 型の場合、適合型とは同一型あるいは共通上位型のいずれかだ。それ以外の場合では、適合とは型が同一でなければならないことを意味する。</p></li>
<li><p>受領要素は併合された要素へのどれに対しても明示的な参照があることは不可能だ。</p></li>
<li><p>合致する RedefinableElements に関連する再定義は、いずれも矛盾してはならない。</p></li>
</ol>
</dd>
<dt>TRANSFORATIONS</dt><dd><ol class="arabic">
<li><p>（既定の規則）合致する要素のない合併された要素または受領要素は結果の
Package の中に deep copy される。</p></li>
<li><p>名前とメタタイプが合致し、互いに完全な複製である二つの要素を合併した結果が受領要素だ。</p></li>
<li><p>合致した要素はそれらのメタタイプに固有の変換規則に従って結合され、結果は生じる Package に含まれる。</p></li>
<li><p>結果パッケージに行き着く型付き要素に対する型参照のすべては、対応する結果
TypedElements への参照に変換される。それぞれの増分への参照ではない。</p></li>
<li><p>合致する要素全てに対して：</p>
<p>合致する要素の両方とも private <code class="docutils literal notranslate"><span class="pre">visibility</span></code> である場合、結果要素の
<code class="docutils literal notranslate"><span class="pre">visibility</span></code> は private だ。それ以外の場合には、結果要素の <code class="docutils literal notranslate"><span class="pre">visibility</span></code>
は public ということになる。</p>
</li>
<li><p>合致する Classifier 要素全てについて：</p>
<p>合致する要素が両方とも <code class="docutils literal notranslate"><span class="pre">isAbstract</span></code> が真の場合、結果要素は <code class="docutils literal notranslate"><span class="pre">isAbstract</span></code>
が真だ。それ以外の場合には、結果要素は <code class="docutils literal notranslate"><span class="pre">isAbstract</span></code> が偽だ。</p>
</li>
<li><p>合致する要素全てについて：</p>
<p>合致する要素が両方とも <code class="docutils literal notranslate"><span class="pre">isFinalSpecialization</span></code> が真である場合、結果要素は
<code class="docutils literal notranslate"><span class="pre">isFinalSpecialization</span></code> が真だ。それ以外の場合には、結果要素は
<code class="docutils literal notranslate"><span class="pre">isFinalSpecialization</span></code> が偽だ。</p>
</li>
<li><p>合致する要素全てについて：</p>
<p>合致する要素の両方とも導出されない場合、結果要素もまた導出されない。そうでなければ、結果要素は導出される。</p>
</li>
<li><p>合致する MultiplicityElements 全てに対して：</p>
<p>結果要素の境界 <code class="docutils literal notranslate"><span class="pre">lower</span></code> は合致する要素の境界 <code class="docutils literal notranslate"><span class="pre">lower</span></code> のうち、小さいほうだ。</p>
</li>
<li><p>合致する MultiplicityElements 全てに対して：</p>
<p>結果要素の境界 <code class="docutils literal notranslate"><span class="pre">upper</span></code> は合致する要素の境界 <code class="docutils literal notranslate"><span class="pre">upper</span></code> のうち、大きいほうだ。</p>
</li>
<li><p>併合される要素か受領要素の一方のモデル要素に適用されるステレオタイプは、どれも対応する結果要素にも適用される。</p></li>
<li><p>合致する RedefinableElements の場合：</p>
<p>合致する RedefinableElements の異なる再定義は、すべて結果要素に適用される。</p>
</li>
<li><p>合致する RedefinableElements の場合：</p>
<p>合致する要素の両方とも <code class="docutils literal notranslate"><span class="pre">isLeaf</span></code> が真の場合、結果要素も <code class="docutils literal notranslate"><span class="pre">isLeaf</span></code> が真だ。それ以外の場合には結果要素は <code class="docutils literal notranslate"><span class="pre">isLeaf</span></code> が偽だ。</p>
</li>
</ol>
</dd>
</dl>
</section>
<section id="package-rules">
<h4>12.2.3.4 Package Rules<a class="headerlink" href="#package-rules" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Elements that are kinds of Package match by <code class="docutils literal notranslate"><span class="pre">name</span></code> and metatype.</p>
</div></blockquote>
<dl class="simple">
<dt>CONSTRAINTS</dt><dd><ol class="arabic simple">
<li><p>併合された Package にある Classifiers のすべては、空でない <code class="docutils literal notranslate"><span class="pre">qualifiedName</span></code>
がある必要があり、合併された Package で <code class="docutils literal notranslate"><span class="pre">isDistinguishableFrom()</span></code> の値が真である必要がある。</p></li>
<li><p>受領 Package にある Classifiers すべては、空でない <code class="docutils literal notranslate"><span class="pre">qualifiedName</span></code> がある必要があり、受領 Package で <code class="docutils literal notranslate"><span class="pre">isDistinguishableFrom()</span></code> の値が真である必要がある。</p></li>
</ol>
</dd>
<dt>TRANSFORATIONS</dt><dd><ol class="arabic simple">
<li><p>併合された Package の <code class="docutils literal notranslate"><span class="pre">nestedPackage</span></code> は受領 Package が合致する
<code class="docutils literal notranslate"><span class="pre">nestedPackage</span></code> をすでに含んでいない限り、結果 Package で同じ <code class="docutils literal notranslate"><span class="pre">name</span></code> と同じ内容を持つ <code class="docutils literal notranslate"><span class="pre">nestedPackage</span></code> に変換される。</p></li>
<li><p>受領 Package の <code class="docutils literal notranslate"><span class="pre">elementImport</span></code> である ElementImport は、結果 Package において対応する ElementImport に変換される。（インポートされた要素を所有する
Package への PackageMerge が存在しない限り）インポートされた要素は併合されない。</p></li>
</ol>
</dd>
</dl>
</section>
<section id="class-and-datatype-rules">
<h4>12.2.3.5 Class and DataType Rules<a class="headerlink" href="#class-and-datatype-rules" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Elements that are kinds of Class or DataType match by <code class="docutils literal notranslate"><span class="pre">name</span></code> and metatype.</p>
</div></blockquote>
<dl class="simple">
<dt>TRANSFORATIONS</dt><dd><ol class="arabic simple">
<li><p>併合された Classifier の <code class="docutils literal notranslate"><span class="pre">ownedAttributes</span></code> である Properties はすべて、下に規定する Property 変換規則に従って、受領 Classifier に併合されて、結果
Classifier を生成する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nestedClassifiers</span></code> は同じ規則に従って再帰的に併合される。</p></li>
</ol>
</dd>
</dl>
</section>
<section id="property-rules">
<h4>12.2.3.6 Property Rules<a class="headerlink" href="#property-rules" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Elements that are kinds of Property match by <code class="docutils literal notranslate"><span class="pre">name</span></code> and metatype.</p>
</div></blockquote>
<dl>
<dt>CONSTRAINTS</dt><dd><ol class="arabic simple">
<li><p>合致する Properties の <code class="docutils literal notranslate"><span class="pre">isStatic</span></code> の値が同じである必要がある。</p></li>
<li><p>合致する Properties の <code class="docutils literal notranslate"><span class="pre">isUnique</span></code> の値が同じである必要がある。</p></li>
<li><p>合致する Properties に関連する Constraints のいずれも競合していない必要がある。</p></li>
</ol>
</dd>
<dt>TRANSFORATIONS</dt><dd><ol class="arabic">
<li><p>合致する受領 Property のない併合された Properties の場合は、結果 Property
は併合された Property と同じ結果 Classifier の Property となる。</p></li>
<li><p>合致する受領 Property を有する併合された Properties の場合は、結果 Property
は同じ名前と特徴がある Property だ。これらの特徴が異なる場合、結果 Property
の特徴は適切な変換規則の適用により決定される。</p></li>
<li><p>合致 Properties について：</p>
<p>両方の Property で <code class="docutils literal notranslate"><span class="pre">isReadOnly</span></code> が真である場合、結果 Property でも
<code class="docutils literal notranslate"><span class="pre">isReadOnly</span></code> が真だ。そうでない場合は結果 Property では <code class="docutils literal notranslate"><span class="pre">isReadOnly</span></code> が偽だ。</p>
</li>
<li><p>合致 Properties について：</p>
<p>両方の Property で <code class="docutils literal notranslate"><span class="pre">isOrdered</span></code> が偽である場合、結果 Property でも
<code class="docutils literal notranslate"><span class="pre">isOrdered</span></code> が偽だ。そうでない場合は結果 Property では <code class="docutils literal notranslate"><span class="pre">isOrdered</span></code> が真だ。</p>
</li>
<li><p>合致 Properties について：</p>
<p>どの Property もある導出和集合の部分集合として指定されていない場合、結果
Property はその導出和集合の部分集合として指定されない。</p>
</li>
<li><p>合致 Properties について：</p>
<p>合致 Properties の異なる制約が、結果 Property にすべて適用される。</p>
</li>
<li><p>合致 Properties について：</p>
<p>併合された要素と受領要素の両方またはどちらか一方で <code class="docutils literal notranslate"><span class="pre">isUnique</span></code> が偽である場合、結果要素は <code class="docutils literal notranslate"><span class="pre">isUnique</span></code> が偽であり、そうでなければ結果要素は
<code class="docutils literal notranslate"><span class="pre">isUnique</span></code> が真だ。</p>
</li>
<li><p>結果 Property に対する <code class="docutils literal notranslate"><span class="pre">type</span></code> の値は、結果 Package の対応する <code class="docutils literal notranslate"><span class="pre">type</span></code> を参照するよう変換される。</p></li>
</ol>
</dd>
</dl>
</section>
<section id="association-rules">
<h4>12.2.3.7 Association Rules<a class="headerlink" href="#association-rules" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Elements that are kinds of Association match by <code class="docutils literal notranslate"><span class="pre">name</span></code> and metatype.</p>
</div></blockquote>
<dl>
<dt>CONSTRAINTS</dt><dd><ol class="arabic simple">
<li><p>これらの規則は二項 Association にしか適用しない。一般の多項 Association の併合には既定規則を適用する。</p></li>
<li><p>合致する併合された関連端の <code class="docutils literal notranslate"><span class="pre">aggregation</span></code> が composite であると、受領関連端でも <code class="docutils literal notranslate"><span class="pre">aggregation</span></code> が composite である必要がある。</p></li>
<li><p>合致する併合された関連端が Association により所有されている場合、受領関連端はその Association がり所有する必要がある。</p></li>
</ol>
</dd>
<dt>TRANSFORATIONS</dt><dd><ol class="arabic">
<li><p>合致する Associations の併合は、Classifiers についての規則に従いAssociation
classifiers を併合し、対応する <code class="docutils literal notranslate"><span class="pre">ownedEnd</span></code> Properties を、Propertyes の規則と Association 端子の次の規則に従い併合することで達成される。</p></li>
<li><p>合致する関連端の場合：</p>
<p>どの関連端も <code class="docutils literal notranslate"><span class="pre">ownedNavigableEnd</span></code> にない場合、結果関連端も
<code class="docutils literal notranslate"><span class="pre">ownedNavigableEnd</span></code> にはない。それ以外の場合には、結果関連端は
<code class="docutils literal notranslate"><span class="pre">ownedNavigableEnd</span></code> に含まれる。</p>
</li>
</ol>
</dd>
</dl>
</section>
<section id="operation-rules">
<h4>12.2.3.8 Operation Rules<a class="headerlink" href="#operation-rules" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Elements that are kinds of Operation match by <code class="docutils literal notranslate"><span class="pre">name</span></code>, Parameter order, and
Parameter types, not including any return type.</p>
</div></blockquote>
<dl class="simple">
<dt>CONSTRAINTS</dt><dd><ol class="arabic simple">
<li><p>Operation Parameters とその型は、Properties の定義と同じ型の多重度に対する規則に従う必要がある。</p></li>
<li><p>合致する合併された Operation の <code class="docutils literal notranslate"><span class="pre">isQuery</span></code> が真の場合、受領 Operation は
<code class="docutils literal notranslate"><span class="pre">isQuery</span></code> が真である必要がある。</p></li>
</ol>
</dd>
<dt>TRANSFORATIONS</dt><dd><ol class="arabic simple">
<li><p>合致する受領 Operation のない併合された Operations の場合は、結果 Operation
は結果 classifier において同じ名前と同じ署名である Operation だ。</p></li>
<li><p>合致する受領 Operation のある併合された Operations の場合は、結果 Operation
は合致する併合された Operations と受領 Operations の併合結果であり、
Parameter 変換は上で定義された Property 変換に従って実施される。</p></li>
</ol>
</dd>
</dl>
</section>
<section id="enumeration-rules">
<h4>12.2.3.9 Enumeration Rules<a class="headerlink" href="#enumeration-rules" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Elements that are kinds of EnumerationLiteral match by owning Enumeration and
Literal <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</div></blockquote>
<dl class="simple">
<dt>CONSTRAINTS</dt><dd><ol class="arabic simple">
<li><p>合致する EnumerationLiterals は同じ順序である必要がある。</p></li>
</ol>
</dd>
<dt>TRANSFORATIONS</dt><dd><ol class="arabic simple">
<li><p>併合された Enumeration 由来の非合致 EnumerationLiterals は受領 Enumeration
に含まれる。</p></li>
</ol>
</dd>
</dl>
</section>
<section id="constraint-rules">
<h4>12.2.3.10 Constraint Rules<a class="headerlink" href="#constraint-rules" title="Permalink to this heading">¶</a></h4>
<dl class="simple">
<dt>CONSTRAINTS</dt><dd><ol class="arabic simple">
<li><p>Constraints は互いに矛盾があってはならない。</p></li>
</ol>
</dd>
<dt>TRANSFORATIONS</dt><dd><ol class="arabic simple">
<li><p>併合されたモデル要素の Constraints はすべて受領モデル要素の Constraints に加わる。</p></li>
</ol>
</dd>
</dl>
</section>
<section id="model">
<h4>12.2.3.11 Model<a class="headerlink" href="#model" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A Model is a description of a system, where ‘system’ is meant in the broadest
sense and may include not only software and hardware but organizations and
processes.</p>
</div></blockquote>
<ul>
<li><p>Model は特定の関係者 (certain category of <em>stakeholders</em>) のために、ある視点から、ある抽象度で記述される。</p></li>
<li><p>Model は目的に関連する側面だけが表現されているが、システム全体を網羅しているという意味で完全だ。</p>
<blockquote>
<div><p>As a Package, a Model has a set of <code class="docutils literal notranslate"><span class="pre">members</span></code> that together describe the
system being modeled. The organization of these elements varies by the
modeling method being used.</p>
</div></blockquote>
</li>
</ul>
<p>Model にはシステムの環境の関連部分を記述する要素を含むことがある。</p>
<blockquote>
<div><p>The environment is typically modeled by Actors and their Interfaces. As these
are external to the system, they reside outside the Package/Component
hierarchy. They may be collected in a separate Package, or owned directly by
the Model as <code class="docutils literal notranslate"><span class="pre">packagedElements</span></code>.</p>
</div></blockquote>
<p>同じシステムに対して種々の Models を定義することが可能であり、典型的にはこの
Models は相補的であり、種々のシステム利害関係者の観点から定義される。</p>
<blockquote>
<div><p>With composition of Models, a container model represents a comprehensive view
of the system given by the different views defined by the contained Models.</p>
<p>Models can have Abstraction Dependencies between them: refinement
(stereotyped by <code class="docutils literal notranslate"><span class="pre">«Refine»</span></code> from the Standard Profile) or mapping (for
example stereotyped by <code class="docutils literal notranslate"><span class="pre">«Trace»</span></code> from the Standard Profile).</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">refinement</span></code> （標準プロファイル <code class="docutils literal notranslate"><span class="pre">«Refine»</span></code> でステレオタイプされる）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mapping</span></code> （例えば標準プロファイル <code class="docutils literal notranslate"><span class="pre">«Trace»</span></code> でステレオタイプされる）</p></li>
</ul>
<p>これらは、通常、Model に含まれる要素間の Dependencies によってより詳細に表現される。Model それぞれが完全であることを意図しているため、異なる Models の要素間の
Relationships は通常、Models の内容に直接的な影響を与えない。しかし、改良をなぞったり、モデル間の相互参照を追跡したりするのに便利だ。</p>
</section>
</section>
<section id="notation">
<h3>12.2.4 Notation<a class="headerlink" href="#notation" title="Permalink to this heading">¶</a></h3>
<p>Package は大きい矩形であって、その左上に小さい矩形（タブ）を付けた形状で示す。</p>
<ul class="simple">
<li><p>Package の <code class="docutils literal notranslate"><span class="pre">members</span></code> を大きい矩形の内部に示すことがある。また、Package の外部に描かれた <code class="docutils literal notranslate"><span class="pre">member</span></code> への分岐線で示すこともある。</p></li>
<li><p>Package に付属する端子には円内にプラス記号 <code class="docutils literal notranslate"><span class="pre">+</span></code> が描かれる。</p></li>
</ul>
<blockquote>
<div><p>Conformant tools may restrict the use of these notations to
<code class="docutils literal notranslate"><span class="pre">packagedElements</span></code>. Optionally, elements that become available for use in
an importing Package through a PackageImport or an ElementImport may have a
distinct color or be dimmed to indicate that they are not
<code class="docutils literal notranslate"><span class="pre">packagedElements</span></code>.</p>
</div></blockquote>
<ul>
<li><p>Package の <code class="docutils literal notranslate"><span class="pre">members</span></code> が大きな矩形の中に表示されていない場合、Package の
<code class="docutils literal notranslate"><span class="pre">name</span></code> を大きな矩形の中に入れる必要がある。</p></li>
<li><p>Package の <code class="docutils literal notranslate"><span class="pre">members</span></code> が大きな矩形の中に表示されている場合、Package の
<code class="docutils literal notranslate"><span class="pre">name</span></code> はタブに入れる必要がる。</p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">visibility</span></code> of a <code class="docutils literal notranslate"><span class="pre">packagedElement</span></code> may be indicated by preceding the
<code class="docutils literal notranslate"><span class="pre">name</span></code> by a visibility symbol (<code class="docutils literal notranslate"><span class="pre">+</span></code> for public and <code class="docutils literal notranslate"><span class="pre">-</span></code> for private).</p>
</div></blockquote>
</li>
</ul>
<p>Packages の可視性が protected や package であることは許されない。</p>
<blockquote>
<div><p>A tool may show visibility by a graphic marker, such as color or font. A tool
may also show <code class="docutils literal notranslate"><span class="pre">visibility</span></code> by selectively displaying those elements that
meet a given visibility level (e.g., only public elements). A diagram showing
a Package with <code class="docutils literal notranslate"><span class="pre">members</span></code> need not necessarily show all its <code class="docutils literal notranslate"><span class="pre">members</span></code>; it
may show a subset of the <code class="docutils literal notranslate"><span class="pre">members</span></code> according to some criterion.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">URI</span></code> for a Package may be indicated with the text <code class="docutils literal notranslate"><span class="pre">{uri</span> <span class="pre">=</span> <span class="pre">&lt;uri&gt;}</span></code>
following the Package <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</div></blockquote>
<p>PackageMerge は開いた鏃の破線矢印を用いて示す (Figure 12.4)。</p>
<blockquote>
<div><ul class="simple">
<li><p>矢印の向きは <code class="docutils literal notranslate"><span class="pre">receivingPackage</span></code> から <code class="docutils literal notranslate"><span class="pre">mergedPackage</span></code> だ。</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">«merge»</span></code> を破線のそばに示す。</p></li>
</ul>
</div></blockquote>
<p>Model は通常の Package シンボルに小さな三角を大矩形の右上隅に描いたもので記す。</p>
<p>特に Model の <code class="docutils literal notranslate"><span class="pre">members</span></code> が大矩形の中に表示されている場合、タブ内の Model
<code class="docutils literal notranslate"><span class="pre">name</span></code> の右側に三角形を描いてもよい。</p>
<p>A Model may also be notated as a Package, using the ordinary Package symbol with
the keyword <code class="docutils literal notranslate"><span class="pre">«model»</span></code> placed above the <code class="docutils literal notranslate"><span class="pre">name</span></code> of the Model.</p>
</section>
<section id="examples">
<h3>12.2.5 Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 12.5 Examples of a Package with Members</p>
</div></blockquote>
<ul class="simple">
<li><p>左側のものはただ Package を表示している。</p></li>
<li><p>中央のものは Package の矩形の境界内にある <code class="docutils literal notranslate"><span class="pre">members</span></code> の一部を示している。ついでに <cite>URI`</cite> も表示。</p></li>
<li><p>右のものは代替の所有権表記を使用して <code class="docutils literal notranslate"><span class="pre">members</span></code> の一部を示している。</p></li>
</ul>
<p>どの図式でも Package の内容物がすべて記されているとは限らないようだ。マルプラスの見本によると、線のスタイルは実線。</p>
<blockquote>
<div><p>Figure 12.6 Simple Example of Package Merge</p>
</div></blockquote>
<p>もっとも基本的な見本と思われる。P と Q は R によって併合され、S は Q のみを併合している。</p>
<blockquote>
<div><p>Figure 12.7 Simple Example of Transformed Packages Following the Merges</p>
</div></blockquote>
<p>上述の結果、各パッケージがどういう構成になるかを模式化したもの。</p>
<ul>
<li><p>角括弧内の式（説明目的の記号であって UML ではない）は最終結果を生成するためにどの要素が併合されたかを示す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;</span></code> は演算子としての概念的併合変換を示す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X&#64;Y</span></code> は受領要素 <code class="docutils literal notranslate"><span class="pre">X</span></code> と併合された要素 <code class="docutils literal notranslate"><span class="pre">Y</span></code> の合致に適用される併合変換からの結果要素を表す。</p>
<blockquote>
<div><p>Figure 12.8 Introducing Additional Package Merges</p>
</div></blockquote>
</li>
</ul>
<p>それ自身の <code class="docutils literal notranslate"><span class="pre">packagedElements</span></code> を所有しない Package <code class="docutils literal notranslate"><span class="pre">T</span></code> が、先に定義された
Package <code class="docutils literal notranslate"><span class="pre">R</span></code> と <code class="docutils literal notranslate"><span class="pre">S</span></code> を併合することで、追加的 PackageMerge が導入される。</p>
<blockquote>
<div><p>Figure 12.9 Result of the Additional Package Merges</p>
</div></blockquote>
<p>上述の <code class="docutils literal notranslate"><span class="pre">T</span></code> のマージ状態を模式化したもの。</p>
<p>この Package では <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code> の定義はすべて一緒にされた。
Package <code class="docutils literal notranslate"><span class="pre">Q</span></code> と <code class="docutils literal notranslate"><span class="pre">S</span></code> に元々あった Associations の末端の型は、Package <code class="docutils literal notranslate"><span class="pre">T</span></code> の適切な要素を参照するようにすべて更新された。</p>
<blockquote>
<div><p>Figure 12.10 Three Models Representing Parts of a System</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Client</span></code>, <code class="docutils literal notranslate"><span class="pre">Business</span></code>, <code class="docutils literal notranslate"><span class="pre">Data</span></code> からなる三層構造システムの Models の図式。</p>
<blockquote>
<div><p>Figure 12.11 Two Views of One System Collected in a Container Model</p>
</div></blockquote>
<p>Models-in-Model な図式。同一図式内にあえて異なる記法（キーワード or 小三角）を併用している。</p>
</section>
</section>
<section id="profiles">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">12.3 Profiles</a><a class="headerlink" href="#profiles" title="Permalink to this heading">¶</a></h2>
<section id="id3">
<h3>12.3.1 Summary<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>The Profiles clause describes capabilities that allow metaclasses to be
extended to adapt them for different purposes.</p>
</div></blockquote>
<p>これは J2EE や .NET 等のさまざまなプラットフォームや領域（リアルタイムまたはサービス志向様式）に UML メタモデルを合わせる能力も含む。</p>
<p>この節 (12.3) は OMG <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> に対する整合性がある。</p>
<section id="positioning-profiles-versus-metamodels-mof-and-uml">
<h4>12.3.1.1 Positioning Profiles versus Metamodels, MOF and UML<a class="headerlink" href="#positioning-profiles-versus-metamodels-mof-and-uml" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>UML is reused at several meta-levels in various OMG specifications that deal
with modeling.</p>
</div></blockquote>
<p><a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> に匹敵する use cases を他の上部構造仕様よりもワンランク上の水準であるメタメタレベルで扱う。これを可能にするため、参照メタモデルを <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> を用いた定義に対応する UML のオブジェクトとして定義する必要がある。したがって、UML プロファイル を定義する場合、プロファイルのステレオタイプは <a class="reference internal" href="ane-serialization.html"><span class="doc">Annex E: XMI Serialization and Schema</span></a> で定義される。XMI シリアライズが参照されている UML メタモデルの規範版の UML クラスを拡張するように。</p>
<blockquote>
<div><p>Profiles are not a first-class extension capability (i.e., it does not allow
for creating new metamodels). Rather, the intention of Profiles is to give a
straightforward mechanism for adapting an existing metamodel with constructs
that are specific to a particular domain, platform, or method.</p>
</div></blockquote>
<ul>
<li><p>そのような adapting それぞれは Profile にまとめられる。</p></li>
<li><p>Profile を使用して UML に適用される Constraints を削除することは不可能だが、
Profile に固有の新しい Constraints を追加することは可能だ。他の制限はこの
Profiles 節に固有のものしかなく、メタモデルをカスタマイズする方法を制限することを意図したものは他にない。</p>
<blockquote>
<div><p>First-class extensibility is handled through <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a>, where there are no
restrictions at the metamodel level: it is possible to add subclasses and
associations as necessary.</p>
</div></blockquote>
</li>
</ul>
<p>UML を拡張したくなる理由：</p>
<ul class="simple">
<li><p>特定のプラットフォームやドメインに適合した用語法 (a terminology) を与える。</p></li>
<li><p>記法のない諸構成概念 (e.g. Action) に構文を与える。</p></li>
<li><p>既存の諸記号に別の記法を与える。例えばネットワーク内の計算機を表すのに、いつもの Node 記号に代わり計算機の絵を使えるようにするなど。</p></li>
<li><p>UML や特定のメタクラスに対してさらなる意味を追加する。</p></li>
<li><p>UML に存在しない型を追加する。例えば連続時間など。</p></li>
<li><p>UML の諸構成概念の用途を制限する Constraints を追加する。例えば多重継承を禁じるなど。</p></li>
<li><p>モデルを別のモデルやコードに変換する際に用いることが可能な情報を追加する。例えばモデルと Java コードの間の写像規則の定義など。</p></li>
</ul>
<p>いつ新しいメタモデルを作成するべきか、いつプロファイルを作成するべきか、あるいはいつ両者を（一方は UML ツール用、もう一方は <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> ベースのツール用に）作成するべきかという問いに対して、簡単な答えはない。</p>
</section>
</section>
<section id="id4">
<h3>12.3.2 Abstract Syntax<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 12.12 Profiles</p>
</div></blockquote>
<p>一見するとグラフの構造がいつもより込み入っている。</p>
<p>新クラスは Profile, ProfileApplication, Stereotype, Image, Extension,
ExtensionEnd と、いつもより多く登場する。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">A_metaclassReference_profile</span></code></dt><dd><p>Profile から PackageImport への複合関連（単方向）。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A_packageImport_importingNamespace</span></code> を subsets する。</p></li>
<li><p>cf. <code class="docutils literal notranslate"><span class="pre">A_metamodelReference_profile</span></code></p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_metamodelReference_profile</span></code></dt><dd><p>Profile から ElementImport への複合関連（単方向）。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A_elementImport_importingNamespace</span></code> を subsets する。</p></li>
<li><p>cf. <code class="docutils literal notranslate"><span class="pre">A_metaclassReference_profile</span></code></p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_appliedProfile_profileApplication</span></code></dt><dd><p>ProfileApplication から Profile への関連（単方向）。</p>
<ul class="simple">
<li><p>Package に適用されている Profile を参照する関連だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_target_directedRelationship</span></code> を subsets する。</p></li>
<li><p>cf. <code class="docutils literal notranslate"><span class="pre">A_profileApplication_applyingPackage</span></code></p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_profileApplication_applyingPackage</span></code></dt><dd><p>Package から ProfileApplication への複合関連（双方向）。</p>
<ul class="simple">
<li><p>Package が Profile 適用情報を所有する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_source_directedRelationship</span></code> と <code class="docutils literal notranslate"><span class="pre">A_ownedElement_owner</span></code> を subsets する。</p></li>
<li><p>cf. <code class="docutils literal notranslate"><span class="pre">A_appliedProfile_profileApplication</span></code></p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_profile_stereotype</span></code></dt><dd><p>Stereotype から Profile への関連（単方向）。</p>
<ul class="simple">
<li><p>自らを直接的にまたは間接的に含む Profile への参照を示す。</p></li>
<li><p>関連端 profile は <code class="docutils literal notranslate"><span class="pre">{readOnly}</span></code> だ。</p></li>
<li><p>関連端 profile の多重度は 1 だ。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_icon_stereotype</span></code></dt><dd><p>Stereotype から Image への複合関連（単方向）。</p>
<ul class="simple">
<li><p>Stereotype を図式内でアイコンイメージを用いて表示する際、その中身の場所を参照する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_ownedElement_owner</span></code> を subsets する。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_ownedStereotype_owningPackage</span></code></dt><dd><p>Package から Stereotype への複合関連（単方向）。</p>
<ul class="simple">
<li><p>ある適用済み Profile が直接る Stereotype を所有するという意味か。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_packagedElement_owningPackage</span></code> を subsets/redefines する。</p></li>
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">ownedStereotype</span></code> は <code class="docutils literal notranslate"><span class="pre">{readOnly}</span></code> だ。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_ownedEnd_extension</span></code></dt><dd><p>Extension から ExtensionEnd への複合関連（単方向）。</p>
<ul class="simple">
<li><p>拡張されているメタクラスへの参照する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_ownedEnd_owningAssociation</span></code> を redefines/subsets する。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_extension_metaclass</span></code></dt><dd><p>Class から Extension への関連（双方向）。</p>
<ul class="simple">
<li><p>メタクラスを拡張する Stereotype を参照する関連端を所有する。</p></li>
<li><p>関連端は両方とも <code class="docutils literal notranslate"><span class="pre">{readOnly}</span></code> だ。</p></li>
<li><p>関連端の多重度は <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> が 1 に対して <code class="docutils literal notranslate"><span class="pre">extension</span></code> が <code class="docutils literal notranslate"><span class="pre">*</span></code> だ。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_type_extensionEnd</span></code></dt><dd><p>ExtensionEnd から Stereotype への関連（単方向）。</p>
<ul class="simple">
<li><p>メタクラスを拡張する Stereotype を参照する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_type_typedElement</span></code> を redefines/subsets する。</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id5">
<h3>12.3.3 Semantics<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<section id="id6">
<h4>12.3.3.1 Profiles<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A Profile is a restricted form of metamodel that can be used to extend UML,
as described below.</p>
</div></blockquote>
<p>主な拡張構成要素は Stereotype だ。</p>
<section id="restricting-availability-of-uml-elements">
<h5>12.3.3.1.1 Restricting Availability of UML Elements<a class="headerlink" href="#restricting-availability-of-uml-elements" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> ElementImports and <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code>
PackageImports may be used to specify the Profile’s filtering rules. The
filtering rules determine which UML elements are <em>available</em> when the Profile
is applied and which ones are <em>hidden</em>.</p>
</div></blockquote>
<p>注意：あるモデルに Profile を適用しても、そのモデルは何ら変更されない。Profile
は根底にあるモデルのビューを単に定義するだけだ。</p>
<p>メタクラスが隠される（利用不能となる）ことの影響は次のとおり：</p>
<ul class="simple">
<li><p>当該メタクラス（またはそのサブクラス）のオブジェクトを新たに生成することは不能になる。</p></li>
<li><p>当該メタクラス（またはそのサブクラス）の既存のオブジェクトを、図式上で表示したり、ブラウザー枠内を含む、リストで選択したりが不能になる。</p></li>
<li><p>当該メタクラス（またはそのサブクラス）の既存のオブジェクトに関する
Relationships は図式上で表示したり、ブラウザー枠内を含むリストで選択したりが不能になる。</p></li>
</ul>
<p>上記で言う「隠す」をどのように実装するかはツールによって異なる場合がある。</p>
<p>Profile の選別規則（後述）を作動させるには、Profile を厳格モードで適用する必要がある：</p>
<blockquote>
<div><p>specifically the <code class="docutils literal notranslate"><span class="pre">isStrict</span></code> attribute on the ProfileApplication must be set
to true; otherwise the filtering rules are ignored for this profile
application.</p>
</div></blockquote>
<p>最も一般的な事例は、Profile が <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> を使って UML 自身をインポートする場合だ。</p>
<blockquote>
<div><p>A conformant tool may provide this as built-in behavior when the user creates
a Profile. In that case, every UML metaclass is available.</p>
</div></blockquote>
<ul class="simple">
<li><p>あるいは、特定のメタクラスを <code class="docutils literal notranslate"><span class="pre">metaclassReferences</span></code> を通して参照することもできる。その場合、それらだけが利用可能だ。</p></li>
<li><p>さらなる選択肢は、UML メタクラスの部分集合の ElementImport を含む Package(s)
への一つ以上のメタモデル参照を使うことだ。</p></li>
</ul>
<p>ElementImports の <code class="docutils literal notranslate"><span class="pre">visibility</span></code> および <code class="docutils literal notranslate"><span class="pre">alias</span></code> 特性は <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code>
として用いられるときには無視される。</p>
<p><code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> と <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> の両方が Profile に存在する場合、後者は無視されて特定のメタクラスだけが使用可能になる。</p>
<p>詳しくは、Profile が厳格モードで適用された後に、モデル要素が利用可能かどうかを決定するのに次の規則が使われる。メタクラスおよびそのオブジェクトが利用可能であるのは、</p>
<ol class="arabic simple">
<li><p>明示的な <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> により参照されるか、</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> がない場合、明示的な <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> により参照される Package の直接的または推移的な <code class="docutils literal notranslate"><span class="pre">members</span></code> であるか、</p></li>
<li><p>（拡張されたメタクラスが利用できない場合であっても、）適用される Profile の
<code class="docutils literal notranslate"><span class="pre">member</span></code> である Stereotype によって拡張されているときだ。</p></li>
</ol>
<blockquote>
<div><p>All other model elements are <em>hidden</em> (not available) when the Profile is
applied in Strict mode.</p>
</div></blockquote>
<p>このため、利用可能なメタクラスの重複しない集合を指定する適用プロファイルの組み合わせは無効となる。</p>
<p>Profile <code class="docutils literal notranslate"><span class="pre">P1</span></code> が別の Profile <code class="docutils literal notranslate"><span class="pre">P2</span></code> をインポートすると、<code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code>
と <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> の関連すべてが <code class="docutils literal notranslate"><span class="pre">P1</span></code> の水準で結合され、選別規則がこの和集合に適用する。</p>
<blockquote>
<div><p>Stereotypes imported from another Profile using ElementImport or
PackageImport are added to the namespace members of the importing
profile.Profile Contents.</p>
</div></blockquote>
<p>Profile は Stereotypes ばかりでなく Classes, Associations, DataTypes,
PrimitiveTypes, Enumerations を定義またはインポートすることができる。</p>
<blockquote>
<div><p>More precisely all the constraints of a CMOF-compliant metamodel apply to a
UML Profile. These are defined in detail in Section 14.4 of the <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> Core
Specification. The effect of these constraints is that, except for
Stereotypes and Extensions, all other Types defined or imported in a Profile
must be exactly one of the Types explicitly mentioned in the above subset and
that no specialization outside this subset is allowed.</p>
</div></blockquote>
<p>Profile-defined Type という用語は、Profile で定義またはインポートされた CMOF 準拠の Class, Association, DataType, PrimitiveType, Enumeration に相当する。</p>
<blockquote>
<div><p>Profile-defined Types can only be used as the type of Properties in that
Profile or as a general classifier of another Profile-defined Type.</p>
</div></blockquote>
<p>これらは TypedElement の型、InstanceSpecification の classifier, Generalization
関係の一般または特殊 classifier など、Profile が適用されるモデルの Types として使用することは不可能だ。しかし、これらの型を別の Packageで定義し、Profile とモデル Package の両方で必要に応じてインポートすることで、両方の目的で使用することは可能だ。</p>
<blockquote>
<div><p>Stereotypes can participate only in binary Associations. The opposite class
can be another Stereotype, a non-Stereotype Class that is a
<code class="docutils literal notranslate"><span class="pre">packagedElement</span></code> of a Profile (directly or indirectly), or a UML
metaclass.</p>
</div></blockquote>
<p>これらの Associations には、反対側のクラスによって型付けられる <code class="docutils literal notranslate"><span class="pre">ownAttribute</span></code>
特性必要だ。反対側のクラスがステレオタイプでない場合、反対側の特性は他のクラス・メタクラスではなく、Association 自体の <code class="docutils literal notranslate"><span class="pre">ownMember</span></code> でなければならない。</p>
<ul class="simple">
<li><p>これらの規則の効果として、Profile 内の Associations は Stereotype を含む必要はないが、その両端を所有してはならない。</p></li>
<li><p>Profile-defined 二項 Association は <code class="docutils literal notranslate"><span class="pre">aggregation</span> <span class="pre">=</span>
<span class="pre">AggregationKind::composite</span></code> を持つ端子を高々一つ持つことができ、他方の端子は
<code class="docutils literal notranslate"><span class="pre">aggregation</span> <span class="pre">=</span> <span class="pre">AggregationKind::none</span></code> でなければならない。</p></li>
<li><p>さらに、Stereotype または Profile-defined Class の Property は、その型が
Profile-defined Class である場合かつその場合に限り、複合集約を持つことが可能であり、Stereotype または Profile-defined Class または DataType の Property は、その型が Profile-defined DataType, PrimitiveType, Enumeration のいずれかである場合、<code class="docutils literal notranslate"><span class="pre">aggregation</span> <span class="pre">=</span> <span class="pre">AggregationKind::none</span></code> を持つ必要がある。</p></li>
</ul>
<blockquote>
<div><p>The most direct implementation of the Profile capability that a tool can
provide is by having a metamodel based implementation, similar to the Profile
metamodel. However, this is not a requirement of the current standard, which
requires only the support of the specification, and the standard XMI based
interchange capacities.</p>
</div></blockquote>
<p>Profile 機能はメタモデルベースの実装を持たないツールでも実装可能なように設計されている。</p>
<p>新しい値をモデル要素に取り付けるために用いられる実質的にあらゆる仕組みが、有効なプロファイル実装として機能することが可能だ。</p>
<p>しかし、そのような値を作成するには、Profile-defined Class や DataTypes のオブジェクトを作成し、その Class や DataTypes が型付ける Properties の値として参照し、また Profile-defined Association のリンクオブジェクトを作成するために
Profile-defined Class のオブジェクトを参照する、メタモデルとしての限定された機能が必要となる。</p>
</section>
<section id="integrating-and-extending-profiles">
<h5>12.3.3.1.2 Integrating and Extending Profiles<a class="headerlink" href="#integrating-and-extending-profiles" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>There is a number of ways to create, extend, and integrate Profiles.</p>
</div></blockquote>
<p>Profile 統合の最も単純な形式は、複数 Profiles を同じ Package に適用するだけだ。</p>
<blockquote>
<div><p>It is also possible for one Profile to reuse all of or parts of another, and
to extend other Profiles.</p>
</div></blockquote>
<ul class="simple">
<li><p>他の Class と同様に、Stereotypes も Packages や Profiles で定義することができ、再利用のために共通要素を括ることが可能だ。これらの Stereotypes は他の
Profiles で参照されたり特殊化されたりすることで、直接再利用することが可能だ。</p></li>
<li><p>被参照 Stereotype が拡張 Profile の利用者に見えるかどうかについては通常の規則が適用される：拡張 Profile を適用した後に他の Profiles の Stereotype が見えるようにするには public import が必要だ。</p></li>
</ul>
<p>例えば、<em>Unified Profile for DoDAF and MODAF</em> (UPDM) Profile は、SysML Profileと統合して、Requirement や ViewPoint などの Stereotypes を再利用することも可能だろう。UPDM は SysML と意味的に整合する方法で ViewPoint を使用するように設計することも可能だろう。しかし、UPDM はその目的のために特性や関連を追加して ViewPoint を拡張することも可能だろう。</p>
<blockquote>
<div><p>The UPDM specification could note to users that ViewPoint is a stereotype in
UPDM that represents a “placeholder” to ViewPoint in SysML. Users could then
apply UPDM to a model, and get UPDM’s ViewPoint capabilities without any
coupling with, or need for SysML. UPDM could then provide another compliance
point that merges with the SysML profile resulting in stereotypes Requirement
and ViewPoint having the capabilities of both profiles. The SysML::ViewPoint
would be merged with the UPDM::ViewPoint allowing the shared semantics to be
supported without making any changes to the existing model.</p>
</div></blockquote>
<p>SysML を含む UPDM を希望する利用者は、この併合された Profile を適用することになるだろう。</p>
</section>
<section id="mof-equivalent-semantics">
<h5>12.3.3.1.3 MOF-Equivalent Semantics<a class="headerlink" href="#mof-equivalent-semantics" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>This sub clause specifies the semantics of Stereotypes and their instances
using <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a>.</p>
</div></blockquote>
<p><a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> を使用しない実装では、観測可能なすべての方法で、<a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> の実装であるかのように動作するように、舞台裏で必要なことを行わなければならないことの意味にとること。</p>
<blockquote>
<div><p>The same mapping to <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> is used to determine how to serialize applied
profiles using XMI. A Profile is an instance of the UML2 metamodel, not a
CMOF metamodel. Therefore the MOF to XMI mapping rules do not directly apply
for instances of a Profile.</p>
</div></blockquote>
<p>Figure 12.15 は、UML2 Profile と同等の CMOF モデルとの間の写像の例だ。この写像は Profile が XMI としてシリアライズされ、交換される方法を説明し、正式に指定する手段として使用される。</p>
<p>以下の Profile to CMOF 写像規則を使用すると、XMI 仕様を使用して、Profile および
Profile を適用したモデルが XMI でどのように表現されるかを決定することができる。写像の中では：</p>
<ul>
<li><p>Profile は CMOF Package に写る。</p></li>
<li><p>Stereotype は、同じ名前と特性を持つ CMOF クラスに写る。</p></li>
<li><p>Metaclass はすでに CMOF クラスなので、それ自身に写る。</p></li>
<li><p>Extension は Association に写る。Extensions 節の Semantics 参照。</p></li>
<li><p>Profile に含まれるその他の要素 (Stereotype 以外の Classes, DataTypes,
PrimitiveTypes, Enumerations, Associations) は <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> 要素として扱われる。</p></li>
<li><p>Stereotype のオブジェクトは Stereotype を表現する CMOF クラスのオブジェクトに写る。</p>
<blockquote>
<div><p>This stereotype instance is compositionally associated with the Element to
which it applies using a Link that is an instance of the composite
Association to which the Extension is mapped.</p>
</div></blockquote>
</li>
</ul>
<p>Profile の場合、<code class="docutils literal notranslate"><span class="pre">URI</span></code> Property は XMI で Profile のオブジェクトを識別するのに用いられる <code class="docutils literal notranslate"><span class="pre">nsURI</span></code> を決定するために用いられる。</p>
<blockquote>
<div><p>NOTE. By default the <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute of the Profile is used for the
nsPrefix in XMI but this can be overridden by the CMOF tag
org.omg.xmi.nsPrefix.</p>
</div></blockquote>
<p>UML Standard Profile のような OMG 標準 Profile は、URI の OMG 標準命名法に従っている。</p>
<blockquote>
<div><p>For non-standard profiles a recommended convention is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>nsUri = http://&lt;profileParentQualifiedName&gt;/&lt;version&gt;/&lt;profileName&gt;.xmi
nsPrefix = &lt;profileName&gt;
</pre></div>
</div>
</div></blockquote>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;profileParentQualifiedName&gt;</span></code> は Profile を含む Package の修飾名で（もしあれば）、<code class="docutils literal notranslate"><span class="pre">/</span></code> は <code class="docutils literal notranslate"><span class="pre">::</span></code> に置き換えられ，他のすべての不正な XML QName 文字は削除される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;version&gt;</span></code> はバージョン識別子だ。</p>
<p>OMG 標準プロファイルの場合、これは YYYYMMnn の形式の日付であり、XMI に影響を与えずに再発行されるかもしれない仕様ではなく、プロファイル XMI のバージョンを表す。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;profileName&gt;</span></code> はプロファイルの <code class="docutils literal notranslate"><span class="pre">name</span></code> だ。</p></li>
</ul>
<p>Profile は他のモデルと同様に XMI ファイルとして交換可能であり、Profile が適用されたモデルもまた相互に交換可能だ。</p>
<p>Figure 12.19 は UML2 のメタクラスである Interface を拡張した <code class="docutils literal notranslate"><span class="pre">Home</span></code> という名前の Stereotype だ。Figure 12.15 はその例の <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> 対応を示すもので、基本的には
<code class="docutils literal notranslate"><span class="pre">Home</span></code> <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> クラスから Interface <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> クラスへの Association を導入している。説明目的で <code class="docutils literal notranslate"><span class="pre">Home</span></code> Stereotype に Property <code class="docutils literal notranslate"><span class="pre">magic:String</span></code> を加えている。</p>
<p>以下の最初のシリアライズは、Figure 12.19 のモデル（UML2 メタモデルを拡張したプロファイルの定義）がどのように交換されるかを示している。</p>
<blockquote>
<div><p>Figure 12.13 Using the HomeExample Profile to Extend a Model</p>
</div></blockquote>
<p>ステレオタイプ <code class="docutils literal notranslate"><span class="pre">Home</span></code> で拡張された Interface のオブジェクトを含むモデル。</p>
<div class="admonition- admonition">
<p class="admonition-title">読書ノート</p>
<p>シリアライズの記述が節の終わりまで続くのを割愛。</p>
</div>
</section>
</section>
<section id="defining-profiles-for-non-uml-metamodels">
<h4>12.3.3.2 Defining Profiles for Non-UML Metamodels<a class="headerlink" href="#defining-profiles-for-non-uml-metamodels" title="Permalink to this heading">¶</a></h4>
<p>Profiles 機能を使用して UML 以外のメタモデルの拡張を定義することが理論上可能だ。そのメタモデルを実装するツールは、何らかのプロファイル適用機構を対処する必要があるだろう（本仕様の範囲外）。Profile 定義機構をこのやり方で利用する方法が以下に述べられる。</p>
<blockquote>
<div><p>In addition to UML, a Profile may be related to another <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a>-compliant
<em>reference metamodel</em>. In general a reference metamodel typically consists of
metaclasses that are either imported or locally owned. All metaclasses that
are extended by a profile have to be members (directly or indirectly) of the
same reference metamodel. The <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> ElementImports and
<code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> PackageImports serve two purposes:</p>
</div></blockquote>
<ol class="arabic simple">
<li><p>プロファイルによってインポートされる参照メタモデル要素を識別し、</p></li>
<li><p>Profile の選別規則を指定する。選別規則は Profile が適用されたときにメタモデルのどの要素が利用可能 (available) で、どの要素が隠匿 (hidden) されるかを決定する。</p></li>
</ol>
<blockquote>
<div><p>NOTE. Applying a Profile does not change the underlying model in any way; it
merely defines a view of the underlying model.</p>
</div></blockquote>
<p>先にもこれを記した気がする。</p>
<blockquote>
<div><p>In general, only model elements that are instances of imported reference
metaclasses will be visible when the profile is applied. Instances of all
other metaclasses will be hidden and further instances may not be created.</p>
</div></blockquote>
<p>何もしなければメタクラスが参照メタモデルによって所有されているモデル要素が目に見える。これはパッケージインポートの既定規則に従って、参照メタモデルのあらゆる部分パッケージに推移的に適用される。</p>
<blockquote>
<div><p>If any metaclass is imported using a <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> ElementImport,
then model elements whose metaclasses are the same as that metaclass are
available. However, a <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> blocks a <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code>
whenever an element or Package of the referenced metamodel is also referenced
by a metaclass reference. In such cases, only the elements that are
explicitly referenced by the metaclassReference will be visible, while all
other elements of the metamodel Package will be hidden.</p>
</div></blockquote>
<p>このような場合、<code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> によって明示的に参照されている要素しか目に見えず、メタモデル Package の他の全ての要素は隠匿される。</p>
<blockquote>
<div><p>The following rules are used to determine whether a model element is
available or hidden after a Profile has been applied. Model elements are
<em>available</em> if they are instances of metaclasses that are:</p>
</div></blockquote>
<ol class="arabic simple">
<li><p>明示的な <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> により参照されるか、</p></li>
<li><p>明示的な <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> により参照される Package に（直接的または推移的に）含まれるか、</p></li>
<li><p>適用された Profile が所有する Stereotype により拡張されている（拡張されたメタクラス自体が見えない場合であっても）。</p></li>
</ol>
<blockquote>
<div><p>All other model elements are hidden (not available) when the Profile is
applied.</p>
</div></blockquote>
<p>最も一般的な場合は、Profile が <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> を使用してメタモデル全体をインポートする場合だ。この場合、メタモデル内のメタクラスをオブジェクト化するすべての要素が見える。</p>
<blockquote>
<div><p>Figure 12.14 Specification of an Available Metaclass</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MyMetamodel</span></code> は二つのメタクラス <code class="docutils literal notranslate"><span class="pre">Metaclass1</span></code> と <code class="docutils literal notranslate"><span class="pre">Metaclass2</span></code> を含むメタモデルだ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MyProfile</span></code> は <code class="docutils literal notranslate"><span class="pre">MyMetamodel</span></code> と <code class="docutils literal notranslate"><span class="pre">Metaclass2</span></code> を参照する Profile だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Metaclass2</span></code> に対する明示的なメタクラス参照もある。これはメタモデル参照を上書きする。</p></li>
<li><p>ただし、Metaclass2 への明示的なメタクラス参照もあり、これはメタモデル参照をオーバーライドします。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MyProfile</span></code> を <code class="docutils literal notranslate"><span class="pre">MyMetamodel</span></code> に基づく何らかのモデルに適用すると、<code class="docutils literal notranslate"><span class="pre">Metaclass2</span></code> のオブジェクトが表示される。<code class="docutils literal notranslate"><span class="pre">Metaclass2</span></code> は明示的なメタクラス参照によって参照されているからだ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Metaclass1</span></code> のオブジェクトのうち、<code class="docutils literal notranslate"><span class="pre">MyStereotype</span></code> のオブジェクトによって拡張されたオブジェクトも見えることになる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MyStereotype</span></code> によって拡張されていない <code class="docutils literal notranslate"><span class="pre">Metaclass1</span></code> のオブジェクトは隠匿されたままだ。</p></li>
</ul>
<blockquote>
<div><p>If a Profile P1 imports another Profile P2, then all <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code>
and <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> associations will be combined at the P2 level, and
the filtering rules apply to this union.</p>
</div></blockquote>
<p>Profile 水準で定義される選別規則はプロファイルがモデルに適用されるときに何をするのかをモデリングツールに提案するものに過ぎない。</p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">isStrict</span></code> attribute on a ProfileApplication specifies that the
filtering rules have to be applied strictly.</p>
</div></blockquote>
<p>ProfileApplication の <code class="docutils literal notranslate"><span class="pre">isStrict</span></code> が真である場合、Profile がモデルに適用されたときに、プロファイルによって定義されたアクセス可能メタクラス以外のメタクラスにはアクセスできないものとする。異なるアクセス可能メタクラスを指定する適用されたプロファイルを組み合わせることを禁止するのだ。</p>
</section>
<section id="profileapplication">
<h4>12.3.3.3 ProfileApplication<a class="headerlink" href="#profileapplication" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A ProfileApplication is used to record which Profiles have been applied to a
Package.</p>
<p>One or more Profiles that extend UML may be applied at will to a model
Package. Applying a Profile means that it is possible to apply the
Stereotypes that are defined as part of the Profile.</p>
</div></blockquote>
<ul class="simple">
<li><p>複数 Profiles を一つの Package に適用することが可能だ、矛盾する Constraints を持つ場合、Package を無効にしてしまう可能性がある。</p></li>
<li><p>Profileを適用することは、その入れ子 Profile やインポートされた Profile をすべて再帰的に適用することを意味する。</p></li>
<li><p>Profile の public <code class="docutils literal notranslate"><span class="pre">members</span></code> である Stereotypes は、その Profile が適用された
Package の該当するモデル要素に適用してもよい。</p></li>
</ul>
<p>Profile が適用されると、ExtensionEnds が <code class="docutils literal notranslate"><span class="pre">isRequired</span></code> が真であるメタクラスのオブジェクトである要素に対して、適当な Stereotypes のオブジェクトを生成する必要がある。これらのオブジェクトがないモデルは well-formed ではない。</p>
<blockquote>
<div><p>Once a Profile has been applied to a Package, it is allowed to remove the
applied Profile at will. Removing a Profile implies that all elements that
are instances of Stereotypes defined in the Profile are deleted including the
instances of Profile-defined Classes they compositionally aggregate and the
instances of Profile-defined composite Associations linking them.</p>
</div></blockquote>
<p>複合集約でない他のオブジェクトも、その定義型が同じモデルに適用された他の
Profile からアクセスできなくなった場合、削除されなければならない。</p>
<p>適用された Profile を削除しても、参照されるメタモデル由来の要素のオブジェクトはそのまま残る。削除されるのは、Profile に含まれる要素のオブジェクトだけだ。このことが意味するのは、例えば、プロファイル化 UML モデルは、プロファイル対応をしていない他のツールといつでも交換することが可能であり、純粋な UML モデルとして解釈されることだ。</p>
<blockquote>
<div><p>A Profile which is a <code class="docutils literal notranslate"><span class="pre">packagedElement</span></code> of another Profile can be applied
individually.</p>
</div></blockquote>
<p>ただし、入れ子になった Profile は、Stereotypes を含む場合には必要メタクラスとメタモデル参照両方またはどちらか一方を指定しなければならず、PackageImport を使用して、共同適用される他の Profile を指示することが可能だ。メタクラスとメタモデル参照の両方またはどちらか一方は、包含 Profile からは継承されない。</p>
</section>
<section id="stereotypes">
<h4>12.3.3.4 Stereotypes<a class="headerlink" href="#stereotypes" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A Stereotype defines an extension for one or more metaclasses, and enables
the use of specific terminology or notation in place of, or in addition to,
the ones used for the extended metaclasses.</p>
</div></blockquote>
<p>Stereotype が複数のメタクラスを拡張する場合、どの時点においても、メタクラスのうち正確に一つのオブジェクトにしか適用不可能だ。ただし、あるメタクラスのオブジェクトから Stereotype を切り離して、別のメタクラスのオブジェクトに付け替えることは可能だ。</p>
<blockquote>
<div><p>A Stereotype is a limited kind of metaclass that cannot be used by itself,
but must always be used in conjunction with one of the metaclasses it
extends. Each Stereotype may extend one or more metaclasses through
association (Extension) rather than generalization/specialization. Similarly,
a metaclass may be extended by one or more Stereotypes.</p>
</div></blockquote>
<p>Stereotype のオブジェクト S を、UML のメタクラス C に「拡張」（これは特定の種類の Association である）を使って関連付けることは、型 C のモデル要素を S のオブジェクトによって拡張することが許されることを意味する。モデル水準では S のオブジェクトは、リンク (S から C への Association/Extension) によって C モデル要素（C のオブジェクト）に関連付けられる。</p>
<blockquote>
<div><p>Any metaclass referenced by a <code class="docutils literal notranslate"><span class="pre">metaclassReference</span></code> or contained in a
Package referenced by <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> of the closest Profile directly
or indirectly containing a Stereotype can be extended by the Stereotype.</p>
</div></blockquote>
<p>例えば、States, Transitions, Activities, Use Cases, Components, Properties,
Dependencies, etc. はその <code class="docutils literal notranslate"><span class="pre">metamodelReference</span></code> が UML ならば、すべて
Stereotypes で拡張が可能だ。</p>
<p>Stereotype は Package に含まれることもある。その場合、拡張可能なメタクラスは
Package を含む最も近い親 Profile により参照されるものだ。</p>
<blockquote>
<div><p>Just like a Class, a Stereotype may have Properties, which have traditionally
been referred to as Tag Definitions. When a Stereotype is applied to a model
element, the values of the Properties have traditionally been referred to as
<em>tagged values</em>. Stereotype specializes Class and its Properties have the
same meaning in Stereotypes as they do in Class.</p>
</div></blockquote>
<p>Stereotype Property は複合集約を持つことが可能だ。Stereotype 上の複合集約
Property の値は、その Stereotype のオブジェクトにより所有される。</p>
<p>プロファイルは、元々適用されていたモデルを変更することなく適用解除が可能であるため、モデル内のメタクラスのオブジェクトは、Stereotype オブジェクトやその特性の値を参照することは不可能だ。</p>
<p>複合集約 Stereotype Property の型は Stereotype またはメタクラスではあり得ない。</p>
<ul class="simple">
<li><p>ツール売人は被所有操作・動作を含む拡張性を対応することを選択してもよいが、そうすることを要求されてはいない。</p></li>
<li><p>ツールは Stereotype <code class="docutils literal notranslate"><span class="pre">ownAttributes</span></code> を対応しなければならない。</p></li>
</ul>
<blockquote>
<div><p>Its Profile or Package defines the namespace for the Stereotype.</p>
</div></blockquote>
<p>Profiles が Package に適用されている場合、利用可能な Stereotypes は適用された
Profiles により定義され、異なる Profiles や Packages にある同じ <code class="docutils literal notranslate"><span class="pre">name</span></code> である
Stereotypes を区別するために、必要ならば完全修飾名を使ってこれらの Stereotypes
を表示することが可能だ。</p>
<p>PackageImport と ElementImport を使って、修飾されていない <code class="docutils literal notranslate"><span class="pre">names</span></code> の使用を許すことができる。</p>
<p>適用された Profile (<code class="docutils literal notranslate"><span class="pre">ownedStereotype</span></code>) が直接所有する Stereotypes を修飾名なしで用いてよい。</p>
</section>
<section id="images">
<h4>12.3.3.5 Images<a class="headerlink" href="#images" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>The Image class provides the necessary information to display an Image in a
diagram. Icons are typically handled through the Image class.</p>
<p>Information such as physical placement or format is provided by the Image
class.</p>
</div></blockquote>
<ul class="simple">
<li><p>Image クラスは、さまざまな形式の画像を表現するための汎用的な方法を用意する。</p></li>
<li><p>利便性と相互運用性のために、<code class="docutils literal notranslate"><span class="pre">format</span></code> には定義済みの値がいくつ規定されているが、<code class="docutils literal notranslate"><span class="pre">format</span></code> のとり得る集合は限界がない。</p></li>
</ul>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">format</span></code> property indicates the format of the <code class="docutils literal notranslate"><span class="pre">content</span></code>, which is how
the string content should be interpreted.</p>
</div></blockquote>
<ul class="simple">
<li><p>値 <abbr>SVG</abbr>, <abbr>GIF</abbr>, <abbr>PNG</abbr>, etc. が予約されている。</p></li>
<li><p>加えて接頭辞 <code class="docutils literal notranslate"><span class="pre">MINE:</span></code> も予約済み。これは RFC 3023 で定義された有効 MIME 型が続かなければならない。この選択肢は上記の予約値を表現するための代替手段として用いることが可能だ。例えば <code class="docutils literal notranslate"><span class="pre">MIME:</span> <span class="pre">image/svg+xml</span></code> で <abbr>SVG</abbr> を表現することも可能だ。</p></li>
</ul>
</section>
<section id="extensions">
<h4>12.3.3.6 Extensions<a class="headerlink" href="#extensions" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>An Extension is used to indicate that the properties of a metaclass are
extended through a Stereotype, and gives the ability to flexibly add (and
later remove) stereotypes to classes.</p>
<p>Extension is a kind of Association. One end of the Extension is an ordinary
Property and the other end is an ExtensionEnd.</p>
</div></blockquote>
<p>前者は Extension と Class に結び付け、対して後者は Extension とその Class を拡張する Stereotype に結びつける。</p>
<p>A required Extension (isRequired = true) means that an instance of this
Stereotype must be linked to each instance of the extended metaclass in the
model to which the containing Profile has been applied (otherwise the model is
not well-formed). If the extending Stereotype has subclasses, then at most one
instance of the Stereotype or one of its subclasses is required.</p>
<ul>
<li><p>必要 Extension (<code class="docutils literal notranslate"><span class="pre">isRequired</span> <span class="pre">==</span> <span class="pre">true</span></code>) とは、この Stereotype のオブジェクトが、その Profile が適用されたモデル内の拡張メタクラスのオブジェクトそれぞれにリンクされていなければならないことを意味する。</p></li>
<li><p>不要 Extension (<code class="docutils literal notranslate"><span class="pre">isRequired</span> <span class="pre">==</span> <span class="pre">false</span></code>) とは、この Stereotype のオブジェクトが、拡張メタクラスのオブジェクトに自由にリンクし、また後で自由に削除されることが許されることを意味する。</p>
<ul class="simple">
<li><p>ただし、同じ Stereotype またはその部分型を同じ要素に二度適用することは不可能だ。</p></li>
<li><p>Stereotype のオブジェクトは拡張メタクラスのオブジェクトが削除されるか、Stereotype を定義する Profile が Package の <code class="docutils literal notranslate"><span class="pre">appliedProfiles</span></code> から削除されると削除される。</p></li>
</ul>
<blockquote>
<div><p>Figure 12.15 MOF Model Equivalent to Extending “Interface” by the “Home”
Stereotype</p>
</div></blockquote>
</li>
</ul>
<p>単一メタクラス拡張について同値な MOF 構成を示す図。</p>
<ul class="simple">
<li><p>Figure 12.19 で示した Home という Stereotype が Interface メタクラスを拡張する場合を図示している。</p></li>
<li><p>Interface は UML のメタクラスのオブジェクトであり、Home は Stereotype のオブジェクトだ。</p></li>
<li><p>Extension と等価な <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> 概念的要素は拡張メタクラスから拡張 Stereotype への合成だ。後者は拡張メタクラスが所有する。</p></li>
<li><p>Extension が必要な場合、拡張 Stereotype によって型付けされた Property の多重度は 1 だ。</p></li>
</ul>
<blockquote>
<div><p>The name of the Property typed by the extended metaclass is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>‘base_’ extendedMetaclassName
</pre></div>
</div>
<p>The name of the Property typed by the extension Stereotype (the ExtensionEnd)
is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>‘extension_’ stereotypeName
</pre></div>
</div>
</div></blockquote>
<p>Stereotype に Constraints が追加されることはよくある。上記の Property は OCL の回航を表現するために使用してもよい。例えば、次の OCL 式は <code class="docutils literal notranslate"><span class="pre">Home</span></code> Interface
に属性を持たせてはならないことを述べている：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">self</span><span class="p">.</span><span class="n">base_Interface</span><span class="p">.</span><span class="n">ownedAttributes</span><span class="o">-&gt;</span><span class="n">isEmpty</span><span class="p">()</span>
</pre></div>
</div>
<blockquote>
<div><p>Figure 12.16 Example of Multiple Metaclass Extension</p>
</div></blockquote>
<p>複数のメタクラスを拡張する例。Stereotype <code class="docutils literal notranslate"><span class="pre">TestCase</span></code> はメタクラス Operation と
Behavior の両方を拡張している。</p>
<blockquote>
<div><p>Figure 12.17 MOF Model Equivalent to Multiple Metaclass Extension</p>
</div></blockquote>
<p>複数メタクラス拡張に対する <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> 構成に対応する等価性を図示している。</p>
</section>
<section id="extensionend">
<h4>12.3.3.7 ExtensionEnd<a class="headerlink" href="#extensionend" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>An ExtensionEnd is used to tie an Extension to a Stereotype when extending a
metaclass: it is a <code class="docutils literal notranslate"><span class="pre">navigableOwnedEnd</span></code> of the Extension, avoiding an extra
<code class="docutils literal notranslate"><span class="pre">ownedAttribute</span></code> on the extended Class. It is always typed by a Stereotype
and must always have <code class="docutils literal notranslate"><span class="pre">isComposite</span></code> = true.</p>
</div></blockquote>
<p>ExtensionEnd の既定の多重度は <code class="docutils literal notranslate"><span class="pre">0..1</span></code> だ。Stereotype が必要な場合は <code class="docutils literal notranslate"><span class="pre">1..1</span></code> になることもあるが、上限値がこれを超えることはない。</p>
</section>
</section>
<section id="id7">
<h3>12.3.4 Notation<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<p>Extension の記法は矢印だ。</p>
<blockquote>
<div><p>Figure 12.18 The Notation for an Extension</p>
</div></blockquote>
<ul class="simple">
<li><p>鏃は黒塗の三角。</p></li>
<li><p>向きは Stereotype から拡張 Class とする。</p></li>
<li><p>Association と同じ修飾をしてもよいが、通常は省略し、回航可能性の矢印は描かない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isRequired</span></code> が真ならば ExtensionEnd の近くに <code class="docutils literal notranslate"><span class="pre">{required}</span></code> と記す。
ExtensionEnd の多重度 <code class="docutils literal notranslate"><span class="pre">0..1</span></code> または <code class="docutils literal notranslate"><span class="pre">1</span></code> を、装飾 <code class="docutils literal notranslate"><span class="pre">{required}</span></code> の代わりとして使用することが可能だ。<code class="docutils literal notranslate"><span class="pre">isRequired</span></code> がどのように導出されるかによって、多重度 <code class="docutils literal notranslate"><span class="pre">0..1</span></code> は <code class="docutils literal notranslate"><span class="pre">isRequired</span></code> が偽であることに対応する。</p></li>
</ul>
<p>Profile は Package と同じ記法を用いる。ただし名前の前または上にキーワード
<code class="docutils literal notranslate"><span class="pre">«profile»</span></code> をつける。</p>
<p><code class="docutils literal notranslate"><span class="pre">Profile::metaclassReference</span></code>, <code class="docutils literal notranslate"><span class="pre">Profile::metamodelReference</span></code> は
<code class="docutils literal notranslate"><span class="pre">Package::elementImport</span></code>, <code class="docutils literal notranslate"><span class="pre">Package::packageImport</span></code> とそれぞれ同じ記法プラスキーワード <code class="docutils literal notranslate"><span class="pre">«reference»</span></code> を付ける。</p>
<p>ProfileApplication は破線矢印で示す。</p>
<ul class="simple">
<li><p>鏃は開く。</p></li>
<li><p>向きは Package から適用される各 <code class="docutils literal notranslate"><span class="pre">appliedProfile</span></code> に向かう。</p></li>
<li><p>矢印の近辺にキーワード <code class="docutils literal notranslate"><span class="pre">«apply»</span></code> か、<code class="docutils literal notranslate"><span class="pre">isStrict</span></code> が真ならばキーワード
<code class="docutils literal notranslate"><span class="pre">«strict»</span></code> を示す。</p></li>
</ul>
<blockquote>
<div><p>If multiple <code class="docutils literal notranslate"><span class="pre">appliedProfiles</span></code> have Stereotypes with the same name, it may
be necessary to qualify the name of the Stereotype (with the profile name).</p>
</div></blockquote>
<p>Stereotype は Class と同じ記法を用いる。ただし名前の前または上にキーワード
<code class="docutils literal notranslate"><span class="pre">«stereotype»</span></code> をつける。</p>
<p>Stereotype がモデル要素に適用される場合、Stereotype の名前はモデル要素の名前の上か前、または名前が省略されるか表示されない場合に名前が現れる場所に <code class="docutils literal notranslate"><span class="pre">«...»</span></code> の中に表示される。</p>
<p>NamedElement ではないが図表的表現があるモデル要素では、他に特別な記述がない限り、Stereotype は図表的表現の右上隅にある <code class="docutils literal notranslate"><span class="pre">«...»</span></code> の中に表示することが可能だ。</p>
<p>複数の Stereotypes が適用されているならば、それらの名前を <code class="docutils literal notranslate"><span class="pre">«...»</span></code> 内に CSV として示す。</p>
<p>拡張モデル要素にキーワードがある場合、ステレオタイプ名はそのキーワードの近くに、または個別の <code class="docutils literal notranslate"><span class="pre">«...»</span></code> で示される。例：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">«interface»</span> <span class="pre">«Clock»</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">«Clock,</span> <span class="pre">interface»</span></code></p></li>
</ul>
<p>Stereotype の <code class="docutils literal notranslate"><span class="pre">name</span></code> はクラスの命名規約に従い大文字で始めるのが普通。しかし
Profiles は異なる規約を用いてよい。</p>
<p>ツールは Stereotypes を表示するのかしないのかを選ぶことができる。</p>
<blockquote>
<div><p>A tool can choose whether it will display Stereotypes or not. In particular,
tools can choose not to display <em>required</em> stereotypes, but to display only
the values of their <code class="docutils literal notranslate"><span class="pre">ownedAttributes</span></code> if any.</p>
</div></blockquote>
<p>モデル要素に適用される Stereotype またはその一般化の <code class="docutils literal notranslate"><span class="pre">ownedAttributes</span></code> の値は次の三者の方法のうちの一つで示すことが可能だ：</p>
<ol class="arabic simple">
<li><p>モデル要素を表す図表ノードに接続された註釈記号の部分として</p></li>
<li><p>モデル要素を表す図表ノードの別々の区画で</p></li>
<li><p>図表ノードで <code class="docutils literal notranslate"><span class="pre">name</span></code> 文字列の上か、それ以外の場合は名前文字列の前に</p></li>
</ol>
<p>区画または註釈記号を用いる場合、区画や註釈に含まれるだけでなく、<code class="docutils literal notranslate"><span class="pre">name</span></code> 文字列の前に <code class="docutils literal notranslate"><span class="pre">«...»</span></code> でステレオタイプ名を示してよい。</p>
<blockquote>
<div><p>The values are displayed as name-value pairs:</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nc">namestring</span><span class="p">&gt;</span> ‘=’ <span class="p">&lt;</span><span class="nc">valuestring</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>If a Stereotype Property is multi-valued, then the <code class="docutils literal notranslate"><span class="pre">&lt;valuestring&gt;</span></code> is
displayed as a comma-separated list:</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nc">valuestring</span><span class="p">&gt;</span> <span class="o">::=</span> <span class="p">&lt;</span><span class="nc">value</span><span class="p">&gt;</span> [‘,’ <span class="p">&lt;</span><span class="nc">value</span><span class="p">&gt;</span>]*
</pre></div>
</div>
</div></blockquote>
<p>特定の値には特別な表示規則がある：</p>
<ul class="simple">
<li><p>真偽型 Properties の値を表示する場合、<code class="docutils literal notranslate"><span class="pre">&lt;namestring&gt;</span></code> が表示されている場合の値は真であり、そうでない場合、値は偽であるという規約を用いてもよい。</p></li>
<li><p>値が NamedElement の <code class="docutils literal notranslate"><span class="pre">name</span></code> の場合、その要素の <code class="docutils literal notranslate"><span class="pre">qualifiedName</span></code> を表示しても可としてよい。</p></li>
</ul>
<p>Stereotype Property の値を表示するのに区画を使う場合、Property 値を表示する適用された Stereotype それぞれに対して区画を追加する必要がある。このような区画の先頭には、適用される Stereotype の名称が <code class="docutils literal notranslate"><span class="pre">«...»</span></code> で表示される。このような区画は、一般的に区画を使用することができる要素、特に Classifiers と State にしか適用されることがない。</p>
<p>註釈記号中やモデル要素の <code class="docutils literal notranslate"><span class="pre">name</span></code> の前か上に表示される場合、特定の Stereotype の
Property の値の前に、適用される Stereotype の名前を <code class="docutils literal notranslate"><span class="pre">«...»</span></code> で表示することが許される。</p>
<blockquote>
<div><p>When displayed in compartments or in a comment symbol, at most one
namestring-valuestring pair can appear on a single line. When displayed above
or before a model element’s <code class="docutils literal notranslate"><span class="pre">name</span></code>, the name-value pairs are separated by
semicolons and all pairs for a given stereotype are enclosed in braces.</p>
</div></blockquote>
<section id="icon-presentation">
<h4>12.3.4.1 Icon presentation<a class="headerlink" href="#icon-presentation" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>It is possible to attach Images to a Stereotype that can be used in lieu of,
or in addition to, the normal notation of a model element to which the
Stereotype is applied.</p>
</div></blockquote>
<p>Stereotype に <code class="docutils literal notranslate"><span class="pre">icon</span></code> 値があると、その Stereotype が適用されたモデル要素に参照される Image を図表的に添えることが可能だ。</p>
<p>図表的表現を有するすべてのモデル要素がアイコンを付けることが可能。モデル要素が図表的に表現されている場合、</p>
<ul>
<li><p>箱：箱が Image に取って代わられ、モデル要素の <code class="docutils literal notranslate"><span class="pre">name</span></code> が Image の下に現れる。この表現方法は、モデル要素に単一の Stereotype が適用されており、モデル要素の
Properties (e.g. <code class="docutils literal notranslate"><span class="pre">ownedAttributes</span></code>, <code class="docutils literal notranslate"><span class="pre">ownedOperations</span></code>) がない場合だけ可能。</p>
<p>また別の選択として、モデル要素を表現する箱の内側や上部に Image の縮小版を表示してもよい。複数の Stereotypes が適用されている場合、複数の Images を箱の中に表示してよい。</p>
</li>
<li><p>線：線の近くに Image を配置してよい。</p></li>
<li><p>テキスト記法：テキスト表記の左に Image を表示してよい。</p></li>
</ul>
<blockquote>
<div><p>Several Images may be referenced by a Stereotype’s icon Property.</p>
</div></blockquote>
<p>ツールによっては、箱を置き換えるアイコン、箱内の縮小アイコン、ツリーブラウザー内のアイコンなど、異なる目的で異なる画像を使用することができる。あるいは一つの画像を異なる大きさに拡大縮小することを選択することがある。</p>
<p>モデル要素には既定の表現をするためのアイコンをすでに使うものもある。典型的な例には Actor モデル要素があり、「棒人間」のアイコンを用いる。</p>
<blockquote>
<div><p>When a Stereotype with an icon is applied to such a model element, the
Stereotype’s <code class="docutils literal notranslate"><span class="pre">icon</span></code> replaces the default presentation icon within diagrams.</p>
</div></blockquote>
</section>
</section>
<section id="id8">
<h3>12.3.5 Examples<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 12.19 Example of Using an Extension</p>
</div></blockquote>
<p>ここで <code class="docutils literal notranslate"><span class="pre">Home</span></code> はメタクラス Interface を拡張するステレオタイプだ。</p>
<p>ステレオタイプ <code class="docutils literal notranslate"><span class="pre">Home</span></code> のオブジェクトはクラス Interface のオブジェクトに自由に追加・除去することが可能であり、Profile に固有の情報を Package に動的に追加・除去する柔軟なやり方を呈している。</p>
<blockquote>
<div><p>Figure 12.20 Example of a Required Extension</p>
</div></blockquote>
<p>Profile が適用されるモデル内のメタクラス Component のオブジェクトそれぞれは、Extension の <code class="docutils literal notranslate"><span class="pre">isRequired</span></code> が真であるので、ステレオタイプ <code class="docutils literal notranslate"><span class="pre">Bean</span></code> のオブジェクトを適用しなければならない。</p>
<p>モデルはそのような Stereotype が適用されなければ well-formed でない。</p>
<blockquote>
<div><p>Figure 12.21 Defining a Simple EJB Profile</p>
</div></blockquote>
<p>ある EJB Profile の簡単な見本。</p>
<p><code class="docutils literal notranslate"><span class="pre">Bean</span></code> がメタクラス Component に適用されていることを必要とする。<code class="docutils literal notranslate"><span class="pre">Bean</span></code> は抽象的なので、具象サブクラスである <code class="docutils literal notranslate"><span class="pre">Entity</span></code> か <code class="docutils literal notranslate"><span class="pre">Session</span></code> のどちらかのオブジェクトが Component の各オブジェクトにリンクされていなければならないことを意味する。</p>
<p>Profile の部分である Constraints は、Profile が Package に適用されたときに評価され、モデルが well-formed であるためにはこれらの Constraints が満たされている必要がある。</p>
<blockquote>
<div><p>Figure 12.22 Importing a Package from a Profile</p>
<p>In Figure 12.22, the Package named <code class="docutils literal notranslate"><span class="pre">Types</span></code> is imported by the Profile named
<code class="docutils literal notranslate"><span class="pre">Manufacturer</span></code>. The Enumeration named <code class="docutils literal notranslate"><span class="pre">Color</span></code> and the Class named
<code class="docutils literal notranslate"><span class="pre">JavaInteger</span></code> are then used as the type of Properties of the Stereotype
named Device as well as the standard PrimitiveType <code class="docutils literal notranslate"><span class="pre">String</span></code>.</p>
</div></blockquote>
<p>Profile <code class="docutils literal notranslate"><span class="pre">Manufacturer</span></code> が後で Package に適用される場合、<code class="docutils literal notranslate"><span class="pre">Types</span></code> 由来の型は
Profile が適用される Package では（明示的にパッケージ <code class="docutils literal notranslate"><span class="pre">Types</span></code> をインポートしない限りは）利用不可能だ。</p>
<p>Package <code class="docutils literal notranslate"><span class="pre">Factory</span></code> が Package <code class="docutils literal notranslate"><span class="pre">Types</span></code> をインポートしない限り、クラス
<code class="docutils literal notranslate"><span class="pre">JavaInteger</span></code> は Stereotype Property の型として使用可能だが、通常の Property
としては使用不可（この例ではインポートしているので使用可能）。</p>
<p>Stereotype <code class="docutils literal notranslate"><span class="pre">Device</span></code> が Clas <code class="docutils literal notranslate"><span class="pre">TV</span></code> に適用されると、Property <code class="docutils literal notranslate"><span class="pre">volume</span></code> の値が表示される。</p>
<blockquote>
<div><p>Figure 12.23 Profiles Applied to a Package</p>
</div></blockquote>
<p>プロファイル Java および EJB を考慮すると、これらが Package <code class="docutils literal notranslate"><span class="pre">WebShopping</span></code> にどのように適用されるかを示す。</p>
<blockquote>
<div><p>Figure 12.24 Defining a Stereotype</p>
</div></blockquote>
<p>簡単なステレオタイプ <code class="docutils literal notranslate"><span class="pre">Clock</span></code> が、自在にメタクラス Class のオブジェクトに対して（動的に）適用可能であるように定義されている。</p>
<blockquote>
<div><p>Figure 12.25 Presentation Options for an Extended Class</p>
</div></blockquote>
<p>上記 <code class="docutils literal notranslate"><span class="pre">Clock</span></code> の数通りの表現例。本文中にはこの見本のための言及がない。</p>
<blockquote>
<div><p>Figure 12.26 An Instance Diagram when Defining a Stereotype</p>
</div></blockquote>
<p>かなり込み入ったオブジェクト図。先ほどの <code class="docutils literal notranslate"><span class="pre">Clock</span></code> の定義を表現している諸オブジェクトを示している。<code class="docutils literal notranslate"><span class="pre">Clock</span></code> から左側の理解が重要。</p>
<blockquote>
<div><p>Figure 12.27 Defining Multiple Stereotypes on Multiple Stereotypes</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Clock</span></code> が Component と Class の両方を拡張することを示す。それとは別に
<code class="docutils literal notranslate"><span class="pre">Creator</span></code> という、Class を拡張する Stereotype を定義している。</p>
<blockquote>
<div><p>Figure 12.28 Using a Stereotype</p>
</div></blockquote>
<p>クラス <code class="docutils literal notranslate"><span class="pre">StopWatch</span></code> に <code class="docutils literal notranslate"><span class="pre">Clock</span></code> を適用した。単に <code class="docutils literal notranslate"><span class="pre">«Clock»</span></code> をクラス名の上に付記するだけで示せる。</p>
<blockquote>
<div><p>Figure 12.29 Showing Values of Stereotypes and a Simple Instance Specification</p>
</div></blockquote>
<p>上記の適用の意味するところを表現する図式。</p>
<p>右側は、オブジェクト図表記を使用して、左側の UML 図の動作と XMI シリアライズを理解するためになるべく使用される <a class="reference external" href="http://www.omg.org/spec/MOF/2.5">MOF</a> 等価なオブジェクトを示す。</p>
<p>Stereotype とメタクラス Class の間の Extension は、Stereotype <code class="docutils literal notranslate"><span class="pre">Clock</span></code> のオブジェクトと <code class="docutils literal notranslate"><span class="pre">Stop</span> <span class="pre">Watch</span></code> という名前の Class の間のリンクをもたらす。</p>
<blockquote>
<div><p>Figure 12.30 Using Stereotypes and Showing Values</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">StopWatch</span></code> に <code class="docutils literal notranslate"><span class="pre">Clock</span></code> と <code class="docutils literal notranslate"><span class="pre">Creator</span></code> を同時に適用する。ここでは各
Stereotype の Property 値を註釈記法で示してある。</p>
<blockquote>
<div><p>Figure 12.31 Other Notational Forms for Depicting Stereotype Values</p>
</div></blockquote>
<p>Stereotype の Property 値を記述する代わりの記法の例。属性区画に <code class="docutils literal notranslate"><span class="pre">«Clock»</span></code> と断ってから値を列挙。</p>
<blockquote>
<div><p>Figure 12.32 Example of a Profile defining Classes and (…)</p>
</div></blockquote>
<p>Profile-defined クラスと二項複合（および非複合）関連を持つ Profile の見本。</p>
<ul>
<li><p>Profile <code class="docutils literal notranslate"><span class="pre">IssuesProfile</span></code> が Profile <code class="docutils literal notranslate"><span class="pre">uml</span></code> をインポートしていることをわざわざ図式内の上部にて断っている。</p></li>
<li><p>本文ではこの図に相当する XMI コード全体を掲載している。</p>
<blockquote>
<div><p>Figure 12.33 Diagram example of applying a profile defining Classes and
Associations and of creating instances of such Classes. Tools can provide a
notation similar to that of object diagrams for instances of Profile-defined
Classes, DataTypes and Associations</p>
</div></blockquote>
</li>
</ul>
<p>上記 <code class="docutils literal notranslate"><span class="pre">IssuesProfile</span></code> の適用例。</p>
<ul class="simple">
<li><p>Profile <code class="docutils literal notranslate"><span class="pre">IssueExample</span></code> は <code class="docutils literal notranslate"><span class="pre">IssuesProfile</span></code> を適用している。</p></li>
<li><p>重要なのは矢印のラベルに現れる <code class="docutils literal notranslate"><span class="pre">«IssueTag»</span></code> の意味だ。</p></li>
</ul>
<p>本文ではこの図のオブジェクト部分を表現する XMI コードを、Profile-defined 関連のリンクオブジェクトの有無で分けて二通り掲載している。</p>
</section>
</section>
<section id="classifier-descriptions">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">12.4 Classifier Descriptions</a><a class="headerlink" href="#classifier-descriptions" title="Permalink to this heading">¶</a></h2>
<p>機械生成による節。</p>
</section>
<section id="association-descriptions">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">12.5 Association Descriptions</a><a class="headerlink" href="#association-descriptions" title="Permalink to this heading">¶</a></h2>
<p>機械生成による節。</p>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="ch11-structured-classifiers.html" title="Previous document">11 Structured Classifiers</a>
        </li>
        <li>
          <a href="ch13-common-behavior.html" title="Next document">13 Common Behavior</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">図書・教科書・仕様書ノート</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ou23/index.html">Modern C++ Tutorial: C++ 11/14/17/20 On the Fly 読書ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ノートにまとまっていない書籍類一覧</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">シェルノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v5.html">What’s New In Bash 5 ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">C++ ノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python ノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../youtube-dl.html">youtube-dl 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ソフトウェア・ツール・パッケージ・ライブラリーノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../google-ime.html">Google 日本語入力利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wslg.html">Windows Subsystem for Linux GUI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oh-my-posh.html">Oh My Posh 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ffmpeg/index.html">FFmpeg 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zoom.html">Zoom Cloud Meetings 利用ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">その他</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">テーマ別</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../javascript.html">JavaScript 総合</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Unified Modeling Language 2.5 読書ノート</a><ul>
      <li>Previous: <a href="ch11-structured-classifiers.html" title="previous chapter">11 Structured Classifiers</a></li>
      <li>Next: <a href="ch13-common-behavior.html" title="next chapter">13 Common Behavior</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2023, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>