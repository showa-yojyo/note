<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>14 StateMachines &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=1a9a5cd9" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=91898170"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="15 Activities" href="ch15-activities.html" />
    <link rel="prev" title="13 Common Behavior" href="ch13-common-behavior.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="ch13-common-behavior.html" title="Previous document">13 Common Behavior</a>
        </li>
        <li>
          <a href="ch15-activities.html" title="Next document">15 Activities</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="statemachines">
<h1><a class="toc-backref" href="#id16" role="doc-backlink">14 StateMachines</a><a class="headerlink" href="#statemachines" title="Permalink to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#statemachines" id="id16">14 StateMachines</a></p>
<ul>
<li><p><a class="reference internal" href="#summary" id="id17">14.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#behavior-statemachines" id="id18">14.2 Behavior StateMachines</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id19">14.2.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#abstract-syntax" id="id20">14.2.2 Abstract Syntax</a></p></li>
<li><p><a class="reference internal" href="#semantics" id="id21">14.2.3 Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#statemachine" id="id22">14.2.3.1 StateMachine</a></p></li>
<li><p><a class="reference internal" href="#regions" id="id23">14.2.3.2 Regions</a></p></li>
<li><p><a class="reference internal" href="#vertices" id="id24">14.2.3.3 Vertices</a></p></li>
<li><p><a class="reference internal" href="#states" id="id25">14.2.3.4 States</a></p></li>
<li><p><a class="reference internal" href="#connectionpointreference" id="id26">14.2.3.5 ConnectionPointReference</a></p></li>
<li><p><a class="reference internal" href="#finalstate" id="id27">14.2.3.6 FinalState</a></p></li>
<li><p><a class="reference internal" href="#pseudostate-and-pseudostatekind" id="id28">14.2.3.7 Pseudostate and PseudostateKind</a></p></li>
<li><p><a class="reference internal" href="#transitions" id="id29">14.2.3.8 Transitions</a></p></li>
<li><p><a class="reference internal" href="#event-processing-for-statemachines" id="id30">14.2.3.9 Event Processing for StateMachines</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#notation" id="id31">14.2.4 Notation</a></p>
<ul>
<li><p><a class="reference internal" href="#statemachine-diagrams" id="id32">14.2.4.1 StateMachine Diagrams</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id33">14.2.4.2 StateMachine</a></p></li>
<li><p><a class="reference internal" href="#region" id="id34">14.2.4.3 Region</a></p></li>
<li><p><a class="reference internal" href="#state" id="id35">14.2.4.4 State</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id36">14.2.4.5 FinalState</a></p></li>
<li><p><a class="reference internal" href="#pseudostate" id="id37">14.2.4.6 Pseudostate</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id38">14.2.4.7 ConnectionPointReference</a></p></li>
<li><p><a class="reference internal" href="#transition" id="id39">14.2.4.8 Transition</a></p></li>
<li><p><a class="reference internal" href="#transitionkind" id="id40">14.2.4.9 TransitionKind</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#examples" id="id41">14.2.5 Examples</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#statemachine-redefinition" id="id42">14.3 StateMachine Redefinition</a></p>
<ul>
<li><p><a class="reference internal" href="#id5" id="id43">14.3.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id44">14.3.2 Abstract Syntax</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id45">14.3.3 Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#statemachine-extension" id="id46">14.3.3.1 StateMachine Extension</a></p></li>
<li><p><a class="reference internal" href="#region-redefinition" id="id47">14.3.3.2 Region Redefinition</a></p></li>
<li><p><a class="reference internal" href="#vertex-redefinition" id="id48">14.3.3.3 Vertex Redefinition</a></p></li>
<li><p><a class="reference internal" href="#transition-redefinition" id="id49">14.3.3.4 Transition Redefinition</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id8" id="id50">14.3.4 Notation</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id51">14.3.5 Examples</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#protocolstatemachines" id="id52">14.4 ProtocolStateMachines</a></p>
<ul>
<li><p><a class="reference internal" href="#id10" id="id53">14.4.1 Summary</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id54">14.4.2 Abstract Syntax</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id55">14.4.3 Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#protocolstatemachine" id="id56">14.4.3.1 ProtocolStateMachine</a></p></li>
<li><p><a class="reference internal" href="#protocoltransition" id="id57">14.4.3.2 ProtocolTransition</a></p></li>
<li><p><a class="reference internal" href="#protocolconformance" id="id58">14.4.3.3 ProtocolConformance</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id13" id="id59">14.4.4 Notation</a></p>
<ul>
<li><p><a class="reference internal" href="#id14" id="id60">14.4.4.1 ProtocolStateMachine</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id61">14.4.4.2 ProtocolTransition</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#classifier-descriptions" id="id62">14.5 Classifier Descriptions</a></p></li>
<li><p><a class="reference internal" href="#association-descriptions" id="id63">14.6 Association Descriptions</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="summary">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">14.1 Summary</a><a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>StateMachine はその関連概念のパッケージだ：</p>
<blockquote>
<div><p>The StateMachines package defines a set of concepts that can be used for
modeling discrete event-driven Behaviors using a finite state-machine
formalism.</p>
</div></blockquote>
<p>プロトコルとはシステムの部分的相互作用の連なりだ：</p>
<blockquote>
<div><p>In addition to expressing the Behavior of parts of a system (e.g., the
Behavior of Classifier instances), state machines can also be used to express
the valid interaction sequences, called <em class="dfn">protocols</em>, for parts of a
system.</p>
</div></blockquote>
<p>ここで二種類の状態機械が現れた。それらに名称を与える：</p>
<blockquote>
<div><p>These two kinds of StateMachines are referred to as <em class="dfn">behavior state
machines</em> and <em class="dfn">protocol state machines</em> respectively.</p>
</div></blockquote>
<p>UML で用いられる有限状態人形は David Harel の statecharts 形式論をオブジェクト指向に変奏したものだ。</p>
</section>
<section id="behavior-statemachines">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">14.2 Behavior StateMachines</a><a class="headerlink" href="#behavior-statemachines" title="Permalink to this heading">¶</a></h2>
<section id="id1">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">14.2.1 Summary</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<p>挙動 StateMachines は次のどれかを明確に記述することが可能だ：</p>
<ul class="simple">
<li><p>能動的 Class の <code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code></p></li>
<li><p>BehavioredClassifier の <code class="docutils literal notranslate"><span class="pre">ownedBehavior</span></code> であって、この BehavioralClassifier
の <code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code> でないもの</p></li>
<li><p>単独 Behavior すなわち対応する BehavioredClassifier のないもの</p></li>
<li><p>BehaviorFeature (Operation or Reception) に対応するメソッド</p></li>
</ul>
</section>
<section id="abstract-syntax">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">14.2.2 Abstract Syntax</a><a class="headerlink" href="#abstract-syntax" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 14.1 Behavior StateMachines</p>
</div></blockquote>
<p>まさに機械の名に相応しい図式だ。あまりに関連が多いため、コネクターが一部交差してしまっている。</p>
<p>新登場クラスが StateMachine, Region, Vertex, Transition, Pseudostate,
ConnectionPointReference, State, FinalState と、とにかく多い。</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">A_region_stateMachine</span></code></dt><dd><p>StateMachine から Region への複合関連（双方向）。StateMachine が直接所有する
Regions だ。</p>
<ul class="simple">
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">region</span></code> の多重度は <code class="docutils literal notranslate"><span class="pre">1..*</span></code> だ。必ず一つは存在する。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_connectionPoint_stateMachine</span></code></dt><dd><p>StateMachine から ConnectionPointReference への複合関連（双方向）。
StateMachine が <code class="docutils literal notranslate"><span class="pre">submachine</span></code> State の一部として用いられているときに定義する。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_submachineState_submachine</span></code></dt><dd><p>StateMachine から State への関連（双方向）。</p>
<p><code class="docutils literal notranslate"><span class="pre">submachine</span></code> State の際に StateMachine が参照する <code class="docutils literal notranslate"><span class="pre">submachine(s)</span></code> だ。複数個を参照する条件は、concurrency が関係してくるらしい。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_subvertex_container</span></code></dt><dd><p>Region と Vertex の間の複合関連（双方向）。Region が Vertices を所有する。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_transition_container</span></code></dt><dd><p>Region と Transition の間の複合関連（双方向）。Region が Transitions を所有する。</p>
<ul class="simple">
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">container</span></code> の多重度が 1 なので、任意の Transition は必ずある
Regionに属する。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_incoming_target</span></code>, <code class="docutils literal notranslate"><span class="pre">A_outgoing_source</span></code></dt><dd><p>Vertex と Transition の間の関連（双方向）。</p>
<ul class="simple">
<li><p>一つの Transition には <code class="docutils literal notranslate"><span class="pre">source</span></code> と <code class="docutils literal notranslate"><span class="pre">target</span></code> という Vertex が一つずつ対応する。</p></li>
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">incoming</span></code> と <code class="docutils literal notranslate"><span class="pre">outgoing</span></code> は <code class="docutils literal notranslate"><span class="pre">readOnly</span></code> だ。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_region_state</span></code></dt><dd><p>State から Region への複合関連（双方向）。</p>
<p>State は StateMachine と同様に Regions を所有する能力がある。ただし関連端
<code class="docutils literal notranslate"><span class="pre">region</span></code> の多重度は <code class="docutils literal notranslate"><span class="pre">*</span></code> だ。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_stateInvariant_owningState</span></code></dt><dd><p>State から Constraint への複合関連（単方向）。</p>
<p>この State が current であるときに常に成り立つ条件、不変条件だ。</p>
<ul class="simple">
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">stateInvariant</span></code> の多重度は <code class="docutils literal notranslate"><span class="pre">0..1</span></code> なので、オプションだ。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_deferrableTrigger_state</span></code></dt><dd><p>State から Trigger への複合関連（双方向）。</p>
<p>State は遅延可能トリガー（後続のある State configuration に到達するまでに処理されていればよいトリガー）を任意個所有する。</p>
<ul class="simple">
<li><p>スラッシュの後に書かれているアレ。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_entry_state</span></code>, <code class="docutils literal notranslate"><span class="pre">A_doActivity_state</span></code>, <code class="docutils literal notranslate"><span class="pre">A_exit_state</span></code></dt><dd><p>State から Behavior への参照。</p>
<ul class="simple">
<li><p>Behavior 側関連端の意味については先ほどのノート参照。</p></li>
<li><p>Behavior 側のいずれの関連端の多重度も <code class="docutils literal notranslate"><span class="pre">0..1</span></code> なので、これらの挙動の定義はオプションだ。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_connection_state</span></code></dt><dd><p>State から ConnectionPointReference への複合関連（双方向）。</p>
<ul class="simple">
<li><p>この <code class="docutils literal notranslate"><span class="pre">submachine</span></code> State と一緒に用いる <code class="docutils literal notranslate"><span class="pre">entry</span></code>/<code class="docutils literal notranslate"><span class="pre">exit</span></code> 接続点（複数形）を所有する。</p></li>
<li><p>cf. <code class="docutils literal notranslate"><span class="pre">A_entry_connectionPointReference</span></code>, <code class="docutils literal notranslate"><span class="pre">A_exit_connectionPointReference</span></code></p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_connectionPoint_state</span></code></dt><dd><p>State から Pseudostate への複合関連（双方向）。</p>
<p>自身が複合 State であるときに限り、その <code class="docutils literal notranslate"><span class="pre">entryPoint</span></code> と <code class="docutils literal notranslate"><span class="pre">exitPoint</span></code> を定義・所有する。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_entry_connectionPointReference</span></code>, <code class="docutils literal notranslate"><span class="pre">A_exit_connectionPointReference</span></code></dt><dd><p>ConnectionPointReference から Pseudostate への関連（単方向）。</p>
<p>対応する <code class="docutils literal notranslate"><span class="pre">entryPoint</span></code>/<code class="docutils literal notranslate"><span class="pre">exitPoint</span></code> への関連を示す。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_trigger_transition</span></code></dt><dd><p>Transition から Trigger への複合関連（単方向）。</p>
<p>この Transition を引き起こして Triggers だ。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_effect_transition</span></code></dt><dd><p>Transition から Behavior への複合関連（単方向）。</p>
<p>関連端 <code class="docutils literal notranslate"><span class="pre">effect</span></code> はこの Transition が起こるときに実施される挙動。多重度が
<code class="docutils literal notranslate"><span class="pre">0..1</span></code> なのでオプション。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_guard_transition</span></code></dt><dd><p>Transition から Constraint への複合関連（単方向）。</p>
<p>ガード条件を表す。この <code class="docutils literal notranslate"><span class="pre">guard</span></code> が <code class="docutils literal notranslate"><span class="pre">true</span></code> になれば Transition は使用可能になる。</p>
<ul class="simple">
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">guard</span></code> の多重度が <code class="docutils literal notranslate"><span class="pre">0..1</span></code> なのでオプション。</p></li>
</ul>
</dd>
</dl>
</section>
<section id="semantics">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">14.2.3 Semantics</a><a class="headerlink" href="#semantics" title="Permalink to this heading">¶</a></h3>
<section id="statemachine">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">14.2.3.1 StateMachine</a><a class="headerlink" href="#statemachine" title="Permalink to this heading">¶</a></h4>
<p>挙動 StateMachine の構造：</p>
<blockquote>
<div><p>A <em>behavior</em> StateMachine comprises one or more Regions, each Region
containing a graph (possibly hierarchical) comprising a set of Vertices
interconnected by arcs representing Transitions.</p>
</div></blockquote>
<p>状態機械の実行は適切な Event の発生により引き起こされる。</p>
<blockquote>
<div><p>A particular execution of a StateMachine is represented by a set of valid
path traversals through one or more Region graphs, triggered by the
dispatching of an Event occurrence that <em>match</em> active Triggers in these
graphs.</p>
</div></blockquote>
<p>経路走査の過程で実行されるのは：</p>
<blockquote>
<div><p>In the course of such a traversal, a StateMachine instance may execute a
potentially complex sequence of Behaviors associated with the particular
elements of the graphs that are being traversed (transition <code class="docutils literal notranslate"><span class="pre">effects</span></code>,
state <code class="docutils literal notranslate"><span class="pre">entry</span></code> and state <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behaviors, etc.)</p>
</div></blockquote>
<p>StateMachine が BehavioredClassifier の context を持つ場合、その Classifier が次を定義する：</p>
<ul class="simple">
<li><p>その StateMachine に適用できる Signal および CallEvent 駆動装置</p></li>
<li><p>その StateMachine が所有する Behaviors が利用できる Features</p></li>
</ul>
<p>Signal と CallEvent 各駆動装置は、それぞれこの Classifier の Receptions と
Operation に従って定義される。Features を利用して StateMachine のメッセージイベント駆動装置を定義することが許される。</p>
<blockquote>
<div><p>If the StateMachine has no BehavioredClassifier context (i.e., it is a
stand-alone Behavior), then its Triggers do not need to be tied to any
Receptions or Operations of some Classifier.</p>
</div></blockquote>
<p>例として、このような StateMachine は駆動装置を TemplateParameters として定義されるかもしれない。TemplateParameters に適切な CallEvent や SignalEvent を束縛することで、異なる <code class="docutils literal notranslate"><span class="pre">context</span></code> Classifiers で再利用することが可能だ。</p>
<blockquote>
<div><p>In situations where a StateMachine specifies the <code class="docutils literal notranslate"><span class="pre">method</span></code> of a
BehavioralFeature (Operation or Reception), the Parameters of the
StateMachine shall match the Parameters of the BehavioralFeature (see sub
clause 13.2.3).</p>
</div></blockquote>
<p>これは StateMachine の実行が BehaviorFeature の Parameter を入手するための手段だ。それ以外の場合、実行中の StateMachine オブジェクトが発送された Event 発生とその関連データを入手する方法は定義されていない (<a class="reference internal" href="ch13-common-behavior.html"><span class="doc">13 Common Behavior</span></a>)。</p>
<blockquote>
<div><p>By definition, invocations of StateMachine executions result in triggered
effects (see sub clause 13.3.3) and, hence, there is an associated event pool
with such an execution.</p>
</div></blockquote>
<p>StateMachine 実行に対するイベントプールが所属するのは次のどちらかだ：</p>
<ul class="simple">
<li><p>その <code class="docutils literal notranslate"><span class="pre">context</span></code> の Classifier オブジェクト</p></li>
<li><p>この StateMachine が BehavioralFeature の <code class="docutils literal notranslate"><span class="pre">method</span></code> を定義する場合には、この挙動機能を所有する Classifier のオブジェクト</p></li>
</ul>
<blockquote>
<div><p>Due to its event-driven nature, a StateMachine execution is either <em>in
transit</em> or <em>in state</em>, alternating between the two.</p>
</div></blockquote>
<p>関連する Triggers の少なくとも一つに合致するイベントが発送されるときが遷移中 (in
transit) だ。この間、その経路に関連する複数の Behaviors を実行することがある。</p>
<blockquote>
<div><p>NOTE. A StateMachine execution may be executing Behaviors even when it has
settled in a stable state configuration, in cases where there are
<code class="docutils literal notranslate"><span class="pre">doActivity</span></code> Behaviors associated with its active state configuration.</p>
</div></blockquote>
</section>
<section id="regions">
<h4><a class="toc-backref" href="#id23" role="doc-backlink">14.2.3.2 Regions</a><a class="headerlink" href="#regions" title="Permalink to this heading">¶</a></h4>
<p>Region の定義：</p>
<blockquote>
<div><p>A Region denotes a behavior fragment that may execute concurrently with its
orthogonal Regions.</p>
</div></blockquote>
<p>Regions が互いに直交するの意味は、次のどちらかが成り立つことを意味する：</p>
<ul class="simple">
<li><p>同一の State が両方の Regions を所有する。</p></li>
<li><p>最上層においては同一の StateMachine が両方の Regions を所有する。</p></li>
</ul>
<p>Region には active であるという概念がある：</p>
<blockquote>
<div><p>A Region becomes <em>active</em> (i.e., it begins executing) either when its owning
State is entered or, if it is directly owned by a StateMachine (i.e., it is a
top level Region), when its owning StateMachine starts executing.</p>
</div></blockquote>
<p>Region それぞれは Vertices と Transitions の集合を所有し、それらはこの Region 内部の挙動の流れを決定する。</p>
<p>Region は特殊な状態を二つ所有することがある：</p>
<blockquote>
<div><p>It may have its own <strong>initial</strong> Pseudostate as well as its own FinalState.</p>
</div></blockquote>
<p>既定作動？の定義：</p>
<blockquote>
<div><p>A <em>default activation</em> of a Region occurs if the Region is entered
implicitly, that is,</p>
</div></blockquote>
<p>State や <strong>history</strong> Pseudostate などの一つを終端とする入方向遷移によって進入するのではなく、以下のどちらかだ：</p>
<ul class="simple">
<li><p>包含 State 上で終了する (<strong>local</strong> または <strong>external</strong>) Transition によってか、</p></li>
<li><p>最上層 Region の場合は StateMachine が実行を開始するとき</p></li>
</ul>
<blockquote>
<div><p><em>Default activation</em> means that execution starts with the Transition
originating from the initial Pseudostate of the Region, if one is defined.</p>
</div></blockquote>
<p>Region 内に存在する <strong>initial</strong> Pseudostate が存在しない場合、特定の approach は定義されていない。モデルが未定義であるとみなすという approach が可能だ。あるいは、Region を含む State は動作中だが、Region は inactive のままとするのも可能だ。</p>
<blockquote>
<div><p>In other words, the containing composite State is treated as a simple (leaf)
State.</p>
</div></blockquote>
<p>明示的作動？の定義：</p>
<blockquote>
<div><p>Conversely, an <em>explicit activation</em> occurs when a Region is entered by a
Transition terminating on one of the Region’s contained Vertices.</p>
</div></blockquote>
<p>直交 Regions の一つが明示的に動作中になると、それらも明示的に進入されない限り、直交する Regions すべてが既定作動中になる。（※複数の直交 Regions は、同じ
<strong>fork</strong> Pseudostate から発生する Transitions によって並行に明示的に進入することが可能）。</p>
</section>
<section id="vertices">
<h4><a class="toc-backref" href="#id24" role="doc-backlink">14.2.3.3 Vertices</a><a class="headerlink" href="#vertices" title="Permalink to this heading">¶</a></h4>
<p>Vertex の定義：</p>
<blockquote>
<div><p>Vertex is an abstract class that captures the common characteristics for a
variety of different concrete kinds of nodes in the StateMachine graph
(States, Pseudostates, or ConnectionPointReferences).</p>
</div></blockquote>
<p>例外もあるが、Vertex は任意の個数の Transitions の <code class="docutils literal notranslate"><span class="pre">source</span></code> または <code class="docutils literal notranslate"><span class="pre">target</span></code>
の両方かどちらか一方であることが可能だ。</p>
<p>一般に、Pseudostates と ConnectionPointReferences は複合遷移の実行が単にそれらを通過し、<code class="docutils literal notranslate"><span class="pre">incoming</span></code> Transition で到着し、<code class="docutils literal notranslate"><span class="pre">outgoing</span></code> Transition で間を置かずに退出するという意味で、推移的 (transitive) である。</p>
<p>しかし、State と FinalState は安定した (stable) Vertices を表し、StateMachine の実行がそこに入ると、別の State に移動する遷移を引き起こすイベントが発生するか、StateMachine が終了するまでその中にとどまる。</p>
</section>
<section id="states">
<h4><a class="toc-backref" href="#id25" role="doc-backlink">14.2.3.4 States</a><a class="headerlink" href="#states" title="Permalink to this heading">¶</a></h4>
<p>State の定義：</p>
<blockquote>
<div><p>A State models a situation in the execution of a StateMachine Behavior during
which some invariant condition holds.</p>
</div></blockquote>
<p>ほとんどの場合、この条件は明示的に定義されていないが、通常は State に関連する名前によって暗示される。例えば Figure 14.36 では、これは電話器の挙動のモデル化であるが、状態 Idle と Active は電話が使用中と未使用中である状況をそれぞれ表す。</p>
<section id="kinds-of-states">
<h5>14.2.3.4.1 Kinds of States<a class="headerlink" href="#kinds-of-states" title="Permalink to this heading">¶</a></h5>
<p>State の種類は次のように三種類に区別される：</p>
<dl>
<dt>単純 State (<code class="docutils literal notranslate"><span class="pre">isSimple</span> <span class="pre">==</span> <span class="pre">true</span></code>)</dt><dd><p>単純 State は Vertices や Transitions が内部にない。</p>
</dd>
<dt>複合 State (<code class="docutils literal notranslate"><span class="pre">isComposite</span> <span class="pre">==</span> <span class="pre">true</span></code>)</dt><dd><p>複合 State は少なくとも一つの Region を含む。</p>
<p>複合 State は Region を一つ持つ単純な複合 State と、Regions を複数有する直交
State のどちらかになる。</p>
</dd>
<dt>部分機械 State (<code class="docutils literal notranslate"><span class="pre">isSubmachineState</span> <span class="pre">==</span> <span class="pre">true</span></code>)</dt><dd><p>部分機械 State は StateMachine 全体を指し、概念的には State の内部に「入れ子」になっているとみなされる。</p>
</dd>
</dl>
<p>部分状態 (substate) の定義と分類：</p>
<dl class="simple">
<dt>部分 State</dt><dd><p>複合 State の Region 内にある State</p>
</dd>
<dt>直接部分 State</dt><dd><p>他のどの State 内にもない部分 State</p>
</dd>
<dt>間接部分 State</dt><dd><p>直接的部分状態でない State</p>
</dd>
</dl>
</section>
<section id="state-configurations">
<h5>14.2.3.4.2 State configurations<a class="headerlink" href="#state-configurations" title="Permalink to this heading">¶</a></h5>
<p>StateMachine は複数 Regions を含み、それぞれが States を含み、そのうちのいずれかは複数 Regions を含む……というように、その構成は一般的には複雑だ。</p>
<blockquote>
<div><p>This complex hierarchy of States is referred to as a <em class="dfn">state
configuration</em> (of a State or a StateMachine).</p>
</div></blockquote>
<p>作動中状態構成の概念：</p>
<blockquote>
<div><p>An executing StateMachine instance can only be in exactly one state
configuration at a time, which is referred to as its <em class="dfn">active state
configuration</em>.</p>
</div></blockquote>
<p>StateMachine の実行は、StateMachine の Triggers に合致するイベントの発生に応答して、ある作動中状態構成から別の構成に遷移することで表現される。</p>
<p>状態が作動中であることを、作動中状態構成との関係で定義する：</p>
<blockquote>
<div><p>A State is said to be active if it is part of the active state configuration.</p>
</div></blockquote>
<p>状態状態構成が安定 (stable) であるとは、次の場合を言う：</p>
<ul class="simple">
<li><p>その状態構成から遷移可能な Transitions がそれ以上なく、かつ</p></li>
<li><p>その状態構成の <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behaviors が（もしあれば）すべてが完了する（ただし
<code class="docutils literal notranslate"><span class="pre">doActivity</span></code> が定義されている場合はその限りでない）。</p></li>
</ul>
<blockquote>
<div><p>After it has been created and completed its initial Transition, a
StateMachine is always “in” some state configuration.</p>
</div></blockquote>
<p>StateMachine のイベントプールで保留中の遅延、完了、またはその他の種類の Event 発生のときでさえ、構成は安定しているとみなされる。</p>
</section>
<section id="state-entry-exit-and-doactivity-behaviors">
<h5>14.2.3.4.3 State <code class="docutils literal notranslate"><span class="pre">entry</span></code>, <code class="docutils literal notranslate"><span class="pre">exit</span></code>, and <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> Behaviors<a class="headerlink" href="#state-entry-exit-and-doactivity-behaviors" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>A State may have an associated <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior.</p>
</div></blockquote>
<p>この Behavior が定義されていれば <strong>external</strong> Transition によって State に進入するときにはいつでも実行される。さらに：</p>
<blockquote>
<div><p>a State may also have an associated <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior, which, if defined, is
executed whenever the State is exited.</p>
<p>A State may also have an associated <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> Behavior.</p>
</div></blockquote>
<p>この Behavior は State に進入した時点で実行を開始し（ただし、State <code class="docutils literal notranslate"><span class="pre">entry</span></code>
Behavior が完了した後に限る）、State に関連する他の Behaviors と同時に、次の時間まで実行する：</p>
<ul class="simple">
<li><p>それが完了する（この場合、完了イベントが生成される）か、</p></li>
<li><p>State から離れるとき。この場合、<code class="docutils literal notranslate"><span class="pre">doActivity</span></code> Behavior の実行が中断される。</p></li>
</ul>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">execution</span></code> of a doActivity Behavior of a State is not affected by the
firing of an internal Transition of that State.</p>
</div></blockquote>
</section>
<section id="state-history">
<h5>14.2.3.4.4 State history<a class="headerlink" href="#state-history" title="Permalink to this heading">¶</a></h5>
<p>State 履歴の概念は複合状態の Regions に関係する有用な概念だ。 Region はそれが最後に終了したときにそれがあった状態構成を追跡する。これにより、次にこの Region が（割り込み処理から復帰したなど）作動中になったとき、またはその履歴に戻る
<strong>Local</strong> Transition がある場合、同じ状態構成を容易に復元することができる。</p>
<p>履歴 Pseudostates には二種類がある：</p>
<dl class="simple">
<dt>深い履歴 (<strong>deepHistory</strong>)</dt><dd><p>包含 Region への最も直近の訪問の完全 (full) 状態構成を表す。</p>
</dd>
<dt>浅い履歴 (<strong>shallowHistory</strong>)</dt><dd><p>既定進入規則を使って進入された、最新の状態構成の最上位部分状態 (topmost
substate) にしか復帰しないことを表す。</p>
</dd>
</dl>
<blockquote>
<div><p>In cases where a Transition terminates on a history Pseudostate when the
State has not been entered before (i.e., no prior history) or it had reached
its FinalState, there is an option to force a transition to a specific
substate, using the <em>default history mechanism</em>.</p>
</div></blockquote>
<ul class="simple">
<li><p>これは、履歴 Pseudostate を起点とし、この Pseudostate を含む Region の特定の
Vertex（これが既定履歴状態だ）で終了する Transition だ。この Transition は実行が履歴 Pseudostate に導かれ、その State がそれまで作動中でなかった場合にのみ実行される。そうでない場合は、その Region への適切な履歴エントリーが実行される（上記）。</p></li>
<li><p>既定履歴遷移が定義されていない場合、後述のように、Regions の標準既定エントリーが実行される。</p></li>
</ul>
<p>遅延 Events:</p>
<blockquote>
<div><p>A State may specify a set of Event types that may be deferred in that State. This means that Event occurrences of those
types will not be dispatched as long as that State remains active.</p>
</div></blockquote>
<p>その代わり、これらの Event 発生はイベントプールに次のいずれかまで残る：</p>
<ul class="simple">
<li><p>これらの Event 型がもはや延期されない状態構成に到達するまで</p></li>
<li><p>延期された Event 型が、延期された状態を起点とする遷移の Trigger において明示的に使用される場合。ある種の上書きオプションだ。</p></li>
</ul>
<blockquote>
<div><p>An Event may be deferred by a composite State or submachine States, in which
case it remains deferred as long as the composite State remains in the active
configuration.</p>
</div></blockquote>
</section>
<section id="entering-a-state">
<h5>14.2.3.4.5 Entering a State<a class="headerlink" href="#entering-a-state" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>The semantics of entering a State depend on the type of State and the manner
in which it is entered.</p>
</div></blockquote>
<p>しかし、どのような場合でも次のことが共通する：</p>
<ul class="simple">
<li><p>State の <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior が（定義されていれば）実行され、その後、到着
Transition に関連した <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior が完了した後に実行される。</p></li>
<li><p>State に <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> Behavior が定義されている場合、この Behavior は</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior が実行された後に即座に実行される。</p></li>
<li><p>同じ複合遷移の一部として進入した部分状態の <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior など、State への進入に関連する後続 Behaviors と同時に (concurrently) 実行される。</p></li>
</ul>
</li>
</ul>
<p>上記の説明で単純 State の場合は完全に網羅している。単一 Region からなる複合
States の場合には、次の選択肢がある：</p>
<dl>
<dt>既定進入 (default entry)</dt><dd><p>この状況は、複合 State が Transition の直接的 <code class="docutils literal notranslate"><span class="pre">target</span></code> である場合に起こる。</p>
<p><code class="docutils literal notranslate"><span class="pre">entry</span></code> を実行し、<code class="docutils literal notranslate"><span class="pre">doActivity</span></code> の実行を分岐した後、<strong>initial</strong> Pseudostate
が定義されていれば、その Vertex から出発 Transition（State の既定 Transition
として知られている）を経由して State 進入を継続する。</p>
<p>初期 Pseudostate が定義されていない場合、単一の approach は定義されていない。</p>
</dd>
<dt>明示的進入 (explicit entry)</dt><dd><p>到着 Transition またはその継続が複合 State の直接含まれる部分状態で終了した場合、その部分状態は作動中となり、その <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior は含んでいる合成
State の <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior の実行後に実行される。</p>
<blockquote>
<div><p>This rule applies recursively if the Transition terminates on an indirect
(deeply nested) substate.</p>
</div></blockquote>
</dd>
<dt>浅い履歴進入 (shallow history entry)</dt><dd><p>到達 Transition が複合 State のある Region の <strong>shallowHistory</strong> Pseudostateで終了する場合、作動中の部分状態は次の項目までこのエントリーの前に直近に作動中だった部分状態になる：</p>
<blockquote>
<div><ul class="simple">
<li><p>the most recently active substate is the FinalState, or</p></li>
<li><p>this is the first entry into this State.</p></li>
<li><p>In the latter two cases, if a default shallow history Transition is
defined originating from the <strong>shallowHistory</strong> Pseudostate, it will be
taken. Otherwise, default State entry is applied.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>深い履歴進入 (deep history entry)</dt><dd><p>この場合の規則は、<code class="docutils literal notranslate"><span class="pre">target</span></code> Pseudostate が <strong>deepHistory</strong> 型であることと、これより下の作動中状態構成の階層すべてに対して規則が再帰的に適用されることを除いて、浅い履歴の場合と同じだ。</p>
</dd>
<dt>入口進入 (entry point entry)</dt><dd><p>Transition が <strong>entryPoint</strong> Pseudostate を経由して複合 State に進入する場合、その入口を起点としてこの State に進入する出発 Transition に関連する <code class="docutils literal notranslate"><span class="pre">effect</span></code>
Behavior だ。</p>
</dd>
</dl>
<blockquote>
<div><p>If the composite State is also an orthogonal State with multiple Regions,
each of its Regions is also entered, either by default or explicitly.</p>
</div></blockquote>
<ul class="simple">
<li><p>Transition が複合 State の端で終了する場合、つまり複合 State に入ることがない場合、Regions のすべてが上記の既定進入規則を用いて進入される。</p></li>
<li><p>Transition が明示的に一つ以上の Regions に進入する場合（分岐の場合）、これらの
Regions は明示的進入をされ、他の Regions は既定進入される。</p></li>
</ul>
<blockquote>
<div><p>Regardless of how a State is entered, the StateMachine is deemed to be “in”
that State even before any <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior or <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior (if
defined) of that State start executing.</p>
</div></blockquote>
</section>
<section id="exiting-a-state">
<h5>14.2.3.4.6 Exiting a State<a class="headerlink" href="#exiting-a-state" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>When exiting a State, regardless of whether it is simple or composite, the
final step involved in the exit, <em>after all other Behaviors associated with
the exit are completed</em>, is the execution of the <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior of that
State.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">exit</span></code> が本当に最後に実行される。</p>
<blockquote>
<div><p>If the State has a <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> Behavior that is still executing when the
State is exited, that Behavior is aborted <em>before</em> the <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior
commences execution.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">doActivity</span></code> があり、かつまだ実行中の場合には abort される。</p>
<blockquote>
<div><p>When exiting from a composite State, <code class="docutils literal notranslate"><span class="pre">exit</span></code> commences with the innermost
State in the active state configuration. This means that <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behaviors
are executed in sequence starting with the innermost active State.</p>
</div></blockquote>
<p><strong>exitPoint</strong> Pseudostate を経由して退出する場合、State の <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior
は、出口点で終了する Transition の <code class="docutils literal notranslate"><span class="pre">effective</span></code> Behavior の後に実行される。</p>
<blockquote>
<div><p>When exiting from an orthogonal State, each of its Regions is exited. After
that, the <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior of the State is executed.</p>
</div></blockquote>
<p>State の終了方法にかかわらず、StateMachine は、その State の <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior
（定義されている場合）の実行が完了した後にのみ、その State から離脱したとみなされる。</p>
<p>カプセル化された複合 States:</p>
<blockquote>
<div><p>In some modeling situations, it is useful to encapsulate a composite State,
by not allowing Transitions to penetrate directly into the State to terminate
on one of its internal Vertices.</p>
</div></blockquote>
<p>用例としては、抽象 Classifier の State の内部が異なる部分型洗練で違ったふうに指定されることが意図されている場合がある。</p>
<blockquote>
<div><p>Despite the encapsulation, it is often necessary to bind the internal
elements of the composite State with incoming and outgoing Transitions.</p>
</div></blockquote>
<p>これは入口点と出口点によって行われ、それらは <strong>entryPoint</strong> と <strong>exitPoint</strong>
Pseudostates によって実現される。</p>
<p>入口点：</p>
<blockquote>
<div><p><em class="dfn">Entry points</em> represent termination points (<code class="docutils literal notranslate"><span class="pre">sources</span></code>) for incoming
Transitions and origination points (<code class="docutils literal notranslate"><span class="pre">targets</span></code>) for Transitions that
terminate on some internal Vertex of the composite State.</p>
</div></blockquote>
<p>後者は事実上、外部からの到着 Transition の継続であり、到着 Transition の
<code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior と出発 Transition の <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior の間に、複合 State
の <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior の実行（定義されている場合）が発生することを条件とする。</p>
<blockquote>
<div><p>If there is no outgoing Transition inside the composite State, then the
incoming Transition simply performs a default State entry.</p>
</div></blockquote>
<p>出口点は入口点の逆のものだ。</p>
<blockquote>
<div><p>That is, Transitions originating from a Vertex within the composite State can
terminate on the exit point.</p>
</div></blockquote>
<p>まともなモデルでは、このような Transition は終了する Transition の継続を表す、同じ出口点から出発する対応する外部 Transition をなるべく持つ。複合 State に
<code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior が定義されている場合、その Behavior は、到着される内部
Transition の <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior の後、かつ出発される外部 Transition の
<code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior の前に実行される。</p>
</section>
<section id="submachine-states-and-submachines">
<h5>14.2.3.4.7 Submachine States and submachines<a class="headerlink" href="#submachine-states-and-submachines" title="Permalink to this heading">¶</a></h5>
<p>Submachine:</p>
<blockquote>
<div><p>Submachines are a means by which a single StateMachine specification can be
reused multiple times. They are similar to encapsulated composite States in
that they need to bind incoming and outgoing Transitions to their internal
Vertices.</p>
</div></blockquote>
<p>部分機械はプログラミング言語におけるマクロのように、相異なる Behavior の仕様であり、それらが使用される context とは異なる context で定義されることがある。より複雑な束縛が必要となる。</p>
<blockquote>
<div><p>This is achieved through the concept of <em>submachine</em> State (i.e., States with
<code class="docutils literal notranslate"><span class="pre">isSubmachineState</span></code> = true), which represent references to corresponding
submachine StateMachines. The concept of ConnectionPointReference is provided
to support binding between the submachine State and the referenced
StateMachine.</p>
</div></blockquote>
<p>ConnectionPointReference:</p>
<blockquote>
<div><p>A ConnectionPointReference represents a point on the submachine State at
which a Transition either terminates or originates.</p>
</div></blockquote>
<ul class="simple">
<li><p>ConnectionPointReference は到着 Transitions に対する部分機械 State への標的であり、出発 Transitions に対する部分機械 State からの出処でもある。</p></li>
<li><p>ConnectionPointReference それぞれは参照される部分機械 StateMachine にある対応入口点または出口点と合致する。</p></li>
</ul>
<p>部分機械とその仕様の間に要する束縛の仕組みは以上だ。</p>
<blockquote>
<div><p>A submachine State implies a macro-like insertion of the specification of the
corresponding submachine StateMachine. It is, therefore, semantically
equivalent to a composite State.</p>
</div></blockquote>
<p>部分機械 StateMachine の Regions は複合 State の Regions だ。その <code class="docutils literal notranslate"><span class="pre">entry</span></code>,
<code class="docutils literal notranslate"><span class="pre">exit</span></code>, <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behaviors および <strong>initial</strong> Transitions を部分機械 State
が含むように定義される。</p>
<blockquote>
<div><p>NOTE. Each submachine State represents a distinct instantiation of a
submachine, even when two or more submachine States reference the same
submachine.</p>
</div></blockquote>
<p>部分機械 StateMachine はその既定 (<strong>initial</strong>) Pseudostate を経るか、その入口点のいずれかを経て進入されることが可能だ。</p>
<blockquote>
<div><p>Entering via the <strong>initial</strong> Pseudostate has the same meaning as for ordinary
composite States. An entry point is equivalent to a <strong>junction</strong> Pseudostate
(fork in cases where the composite State is orthogonal):</p>
</div></blockquote>
<p>入口点を経由して進入することは、複合状態の <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior が実行され、その後に入口点から目標 Vertex への Transition が実行されることを意味する。</p>
<blockquote>
<div><p>Any <code class="docutils literal notranslate"><span class="pre">guards</span></code> associated with these entry point Transitions must evaluate to
true in order for the specification to be well formed.</p>
</div></blockquote>
<p>同様に、部分機械 StateMachine は次の結果として退出可能だ：</p>
<ul class="simple">
<li><p>その FinalState に到達する</p></li>
<li><p>部分機械 State を起点とする集団 Transition の起因</p></li>
<li><p>その出口点のどれかを経由する</p></li>
</ul>
<blockquote>
<div><p>Exiting via a FinalState or by a group Transition has the same meaning as for
ordinary composite States.</p>
</div></blockquote>
</section>
</section>
<section id="connectionpointreference">
<h4><a class="toc-backref" href="#id26" role="doc-backlink">14.2.3.5 ConnectionPointReference</a><a class="headerlink" href="#connectionpointreference" title="Permalink to this heading">¶</a></h4>
<p>接続点参照は部分機械 State によって参照される StateMachine で定義される入口点・出口点の（部分機械 State の一部としての）使用法を表す。部分機械 State の接続点参照は Transitions の出処・目標として使用可能だ。これらは部分機械 State が参照する部分機械 StateMachine への出入りを表す。</p>
<blockquote>
<div><p>Connection point references are sources/targets of Transitions implying exits
out of/entries into the submachine StateMachine referenced by a submachine
State.</p>
</div></blockquote>
<p>Transition の対象としての入口点接続点参照は Transition の <code class="docutils literal notranslate"><span class="pre">target</span></code> が部分機械 State の部分機械で定義された <strong>entryPoint</strong> Pseudostate であることを含意する。</p>
<blockquote>
<div><p>As a result, the Regions of the submachine StateMachine are entered through
the corresponding <strong>entryPoint</strong> Pseudostates.</p>
</div></blockquote>
<p>Transition の出処としての出口点接続点参照は Transition の <code class="docutils literal notranslate"><span class="pre">source</span></code> が部分機械
State の部分機械で定義された出口点 Pseudostate であることを含意する。</p>
<blockquote>
<div><p>When a Region of the submachine StateMachine reaches the corresponding exit
point, the submachine state is exited via this exit point.</p>
</div></blockquote>
</section>
<section id="finalstate">
<h4><a class="toc-backref" href="#id27" role="doc-backlink">14.2.3.6 FinalState</a><a class="headerlink" href="#finalstate" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>FinalState is a special kind of State signifying that the enclosing Region
has completed.</p>
</div></blockquote>
<p>したがって、FinalState への Transition はこの FinalStateを含む Region の挙動の完了を表す。</p>
</section>
<section id="pseudostate-and-pseudostatekind">
<h4><a class="toc-backref" href="#id28" role="doc-backlink">14.2.3.7 Pseudostate and PseudostateKind</a><a class="headerlink" href="#pseudostate-and-pseudostatekind" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A Pseudostate is an abstraction that encompasses different types of transient
Vertices in the StateMachine graph. Pseudostates are generally used to chain
multiple Transitions into more complex <em>compound transitions</em> (see below).</p>
</div></blockquote>
<p>例えば <strong>fork</strong> Pseudostate に進入する Transition と、それから退出する
Transitionsの集合を組み合わせることで、直交 Regions の集合に進入することが可能である混合 Transition を得る。</p>
<p>Pseudostate の具体的意味は Pseudostate の型に依存し、それは型 PseudostateKind の
<code class="docutils literal notranslate"><span class="pre">kind</span></code> 属性により定義される。次に種類とその意味について記す：</p>
<dl>
<dt>initial</dt><dd><p>Region の開始点。</p>
<ul class="simple">
<li><p>Region が既定作動により進入されたときにその中にある Behavior の実行が開始する点。</p></li>
<li><p>高々一つの Transition に対する <code class="docutils literal notranslate"><span class="pre">source</span></code> であり、関連する <code class="docutils literal notranslate"><span class="pre">effect</span></code> を有することはあるが、<code class="docutils literal notranslate"><span class="pre">trigger</span></code> や``guard`` はない。</p></li>
<li><p>Region には高々一つの <strong>initial</strong> Vertex がある。</p></li>
</ul>
</dd>
<dt>deepHistory</dt><dd><p>所有 Region の直近の作動状態構成を表現する変数の一種。</p>
<ul class="simple">
<li><p>ここで停止する Transition はその Region をこの Pseudostate と同じ状態構成に復元することを意味する。</p></li>
<li><p>復元された状態構成にある States すべての <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior は、より外側の
State から適切な順序で実行される。</p></li>
<li><p>複合 State に対してしか定義不可能であり、その Region 一つに含めることが可能である Pseudostate は高々一つだ。</p></li>
</ul>
</dd>
<dt>shallowHistory</dt><dd><p>その包含 Region の最新作動部分状態を表現する変数の一種。ただしその部分状態の部分状態ではない。</p>
<ul>
<li><p>ここで停止する Transition は、State に進入する意味の全てで Region をその部分状態に復元することになる。</p></li>
<li><p>ここからの単一の出発 Transition は複合 State の部分状態で終了するように定義されることがある。</p>
<blockquote>
<div><p>This substate is the <em>default shallow history</em> state of the composite
State.</p>
</div></blockquote>
</li>
<li><p>複合 State に対してしか定義不可能であり、その Region 一つが含むことが可能なのは高々一つだ。</p></li>
</ul>
</dd>
<dt>join</dt><dd><p>異なる直交 Regions 内の Vertices から始まる二つ以上の Transitions の共通の
<code class="docutils literal notranslate"><span class="pre">target</span></code> Vertex として機能する。</p>
<ul class="simple">
<li><p>ここで停止する Transition は <code class="docutils literal notranslate"><span class="pre">guard</span></code> や <code class="docutils literal notranslate"><span class="pre">trigger</span></code> を有することが不可能だ。</p></li>
<li><p>同期機能がある。進入 Transitions すべてが完了しないと、退出 Transition で実行を続行することが不可能だ。</p></li>
</ul>
</dd>
<dt>fork</dt><dd><p>進入 Transitions を複合 State の直交 Regions の Vertices 上で停止する二つ以上の Transitions に分岐する役割がある。</p>
<p>ここから退出する Transitions は <code class="docutils literal notranslate"><span class="pre">guard</span></code> や <code class="docutils literal notranslate"><span class="pre">trigger</span></code> を有することが不可能だ。</p>
</dd>
<dt>junction</dt><dd><p>複数の Transitions を接続して States 間の混合経路をなすのに用いる。</p>
<blockquote>
<div><p>For example, a <strong>junction</strong> Pseudostate can be used to merge multiple
incoming Transitions into a single outgoing Transition representing a
shared continuation path. Or, it can be used to split an incoming
Transition into multiple outgoing Transition segments with different
<code class="docutils literal notranslate"><span class="pre">guard</span></code> Constraints.</p>
</div></blockquote>
<p>このような <code class="docutils literal notranslate"><span class="pre">guard</span></code> Constraints はこの Pseudostate を含む混合遷移が実行される前に評価され、静的条件分岐と呼ばれる。</p>
<blockquote>
<div><p>It may happen that, for a particular compound transition, the configuration
of Transition paths and <code class="docutils literal notranslate"><span class="pre">guard</span></code> values is such that the compound
transition is prevented from reaching a valid state configuration.</p>
</div></blockquote>
<p>このような場合、混合遷移全体が、その Triggers が有効であっても無効になる。</p>
<p>複数の <code class="docutils literal notranslate"><span class="pre">guards</span></code> が真と評価される場合、そのうちの一つが選択される（どう選択されるかは定義されない）。</p>
</dd>
<dt>choice</dt><dd><p>上記 <strong>junction</strong> に似ているが、混合 Transitions 走査がここに到達したときに、出発 Transitions のすべてに対する <code class="docutils literal notranslate"><span class="pre">guard</span></code> Constraints が動的に評価されるという違いがある。</p>
<blockquote>
<div><p>Consequently, <strong>choice</strong> is used to realize a dynamic conditional branch.
It allows splitting of compound transitions into multiple alternative paths
such that the decision on which path to take may depend on the results of
Behavior executions performed in the same compound transition prior to
reaching the choice point.</p>
</div></blockquote>
<ul class="simple">
<li><p>複数の <code class="docutils literal notranslate"><span class="pre">guards</span></code> が真と評価される場合、そのうちの一つが選択される。</p></li>
<li><p>どの <code class="docutils literal notranslate"><span class="pre">guard</span></code> も真と評価されない場合、そのモデルはまともでないとみなされる。すべての <strong>choice</strong> Pseudostate に対して else <code class="docutils literal notranslate"><span class="pre">guard</span></code> を定義しておくと避けられる。</p></li>
</ul>
</dd>
<dt>entryPoint</dt><dd><p>StateMachine または複合 State に対する入口。</p>
<ul class="simple">
<li><p>これらの内部のカプセル化をもたらす。</p></li>
<li><p>これを所有する StateMachine または複合 State の Region では、ここからその
Region 内の Vertex への単一 Transition は高々一つだ。</p></li>
</ul>
<p>所有 State に関連する <code class="docutils literal notranslate"><span class="pre">entry</span></code> Behavior がある場合、この Behavior は出発
Transition に関連する Behavior のどれよりも先に実行される。Regions が複数関与する場合、この入口点は <strong>fork</strong> Pseudostate として動作する。</p>
</dd>
<dt>exitPoint</dt><dd><p>StateMachine または複合 State に対する出口。</p>
<ul class="simple">
<li><p>これらの内部のカプセル化をもたらす。</p></li>
<li><p>複合 State または部分機械 State が参照する StateMachine のいずれかの Region
内の出口点で停止する Transitions は、その状態の停止を意味する。関連する
<code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior の実行を伴う。</p></li>
<li><p>State 内の直交 Region からの Transitions 複数がここで停止する場合、この
Pseudostate は <strong>join</strong> であるかのように動作する。</p></li>
</ul>
</dd>
<dt>terminate</dt><dd><p>ここに進入することは StateMachine の実行が直ちに停止する。</p>
<ul class="simple">
<li><p>StateMachine は States のいずれも退出せず、<code class="docutils literal notranslate"><span class="pre">exit</span></code> Behaviors のいずれも実行しない。</p></li>
<li><p>実行中の <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> は自動的に abort される。</p></li>
<li><p>ここに進入することは DestroyObjectAction を呼び出すことと等価だ。</p></li>
</ul>
</dd>
</dl>
</section>
<section id="transitions">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">14.2.3.8 Transitions</a><a class="headerlink" href="#transitions" title="Permalink to this heading">¶</a></h4>
<p>Transition 定義：</p>
<blockquote>
<div><p>A Transition is a single directed arc originating from a <code class="docutils literal notranslate"><span class="pre">single</span></code> source
Vertex and terminating on a single <code class="docutils literal notranslate"><span class="pre">target</span></code> Vertex (the <code class="docutils literal notranslate"><span class="pre">source</span></code> and
<code class="docutils literal notranslate"><span class="pre">target</span></code> may be the same Vertex), which specifies a valid fragment of a
StateMachine Behavior. It may have an associated <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior, which
is executed when the Transition is traversed (executed).</p>
</div></blockquote>
<p>Transition 走査の期間は未定義だが、ゼロと非ゼロ時間の両方を含む異なる意味上の解釈を認める。</p>
<p>Transition はより複雑な混合遷移 (compound transition) の一部として実行され、
StateMachine の実行をある安定状態構成から別のものへと移行させる。混合遷移の意味を以下に述べる。</p>
<p>実行の途中では、Transition オブジェクトは次のどれかであると言う：</p>
<dl class="simple">
<dt>到達した (reached)</dt><dd><p>その StateMachine の実行がその <code class="docutils literal notranslate"><span class="pre">source</span></code> Vertex に到達した（つまりその
<code class="docutils literal notranslate"><span class="pre">source</span></code> State が作動中態構成にある）ときに。</p>
</dd>
<dt>走査した (traversed)</dt><dd><p>それが（関連する <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior と一緒に）目下実行されているときに。</p>
</dd>
<dt>完了した (completed)</dt><dd><p>それが <code class="docutils literal notranslate"><span class="pre">target</span></code> Vertex に到達した後に。</p>
</dd>
</dl>
<p>Transition は Triggers の集合を所有することがあり、それぞれはそれの発生が発送されたときに Transition の走査を引き起こすことがある Event を指定する。</p>
<blockquote>
<div><p>A Transition <code class="docutils literal notranslate"><span class="pre">trigger</span></code> is said to be <em>enabled</em> if the dispatched Event
occurrence matches its Event type.</p>
</div></blockquote>
<p>Transition に Triggers が複数定義されている場合、それらは論理和のようなものだ：</p>
<blockquote>
<div><p>that is, if <em>any</em> of them are enabled, the Transition will be triggered.</p>
</div></blockquote>
<section id="transition-kinds-relative-to-source">
<h5>14.2.3.8.1 Transition kinds relative to source<a class="headerlink" href="#transition-kinds-relative-to-source" title="Permalink to this heading">¶</a></h5>
<p>Transition の意味はその <code class="docutils literal notranslate"><span class="pre">source</span></code> Vertex との関係に依存して決まる。Transition
の属性 <code class="docutils literal notranslate"><span class="pre">kind</span></code> の値によって異なる可能性三つが定義される：</p>
<dl>
<dt>external</dt><dd><p>Transition はその <code class="docutils literal notranslate"><span class="pre">source</span></code> から退出する、の意。</p>
<blockquote>
<div><p>If the Vertex is a State, then executing this Transition will result in the
execution of any associated exit Behavior of that State.</p>
</div></blockquote>
</dd>
<dt>local</dt><dd><p><strong>external</strong> の反対であり、Transition はそれを含む State から退出しない、の意。</p>
<ul class="simple">
<li><p>したがって包含 State の <code class="docutils literal notranslate"><span class="pre">exit</span></code> は実行されない。</p></li>
<li><p>ただし <strong>local</strong> Transitions では <code class="docutils literal notranslate"><span class="pre">target</span></code> は <code class="docutils literal notranslate"><span class="pre">source</span></code> と異なる必要がある。</p></li>
<li><p>この種の Transition は複合 State 内にしか存在不能だ。</p></li>
</ul>
</dd>
<dt>internal</dt><dd><p><strong>local</strong> Transition の特別な場合であり、自己遷移をする。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code> と <code class="docutils literal notranslate"><span class="pre">target</span></code> が同じ。</p></li>
<li><p>State に退出されない。再入不能。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code> が State の場合に限り定義される。</p></li>
</ul>
</dd>
</dl>
</section>
<section id="high-level-group-transitions">
<h5>14.2.3.8.2 High-level (group) Transitions<a class="headerlink" href="#high-level-group-transitions" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>Transitions whose <code class="docutils literal notranslate"><span class="pre">source</span></code> Vertex is a composite States are called
<em class="dfn">high-level</em> or <em class="dfn">group</em> Transitions.</p>
</div></blockquote>
<p>高水準 Transitions が <strong>external</strong> である場合、複合 State の部分状態すべての退出をもたらし、定義された <code class="docutils literal notranslate"><span class="pre">exit</span></code> Behavior を作動中状態構成の最も内側の States から実行する。</p>
<p>高水準 Transitions が <strong>local</strong> である場合、<code class="docutils literal notranslate"><span class="pre">source</span></code> の <code class="docutils literal notranslate"><span class="pre">exit</span></code> と
<code class="docutils literal notranslate"><span class="pre">target</span></code> の <code class="docutils literal notranslate"><span class="pre">entry</span></code> が実行され、包含 State のそれらは実行されない。</p>
</section>
<section id="completion-transitions-and-completion-events">
<h5>14.2.3.8.3 Completion Transitions and completion events<a class="headerlink" href="#completion-transitions-and-completion-events" title="Permalink to this heading">¶</a></h5>
<p>特別な Transition として暗黙の駆動装置がある完了 Transition がある。</p>
<blockquote>
<div><p>The event that enables this trigger is called a <em class="dfn">completion event</em> and
it signifies that all Behaviors associated with the <code class="docutils literal notranslate"><span class="pre">source</span></code> State of the
completion Transition have completed execution.</p>
</div></blockquote>
<p>単純 State の場合、関連する <code class="docutils literal notranslate"><span class="pre">entry</span></code> と <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> の実行が完了すると、完了イベントが生成される。これらの Behaviors が定義されていない場合、完了イベントはこの State に進入する時点で生じる。</p>
<p>複合 State または 部分機械 State の場合、完了イベントは以下の状況で生じる：</p>
<ul class="simple">
<li><p>内部の活動 (e.g. <code class="docutils literal notranslate"><span class="pre">entry</span></code> and <code class="docutils literal notranslate"><span class="pre">doActivity</span></code>) のすべてが実行を完了して、かつ</p></li>
<li><p>State が複合 State であれば、その直交 Regions のすべてが FinalState に到達したか、</p></li>
<li><p>State が部分機械 State であれば、その <code class="docutils literal notranslate"><span class="pre">submachine</span></code> の実行が FinalState に到達した。</p></li>
</ul>
<p>完了イベントは発送優先権がある。つまり、イベントプールにある保留中 Event の発生よりも早くに発送される。</p>
<ul class="simple">
<li><p>複数の直交 Regions に対応する二つ以上の完了イベントが同時に発生した場合、そのような完了の発生が処理される順序は定義されない。</p></li>
<li><p>StateMachine の高水準 Regions すべての完了は StateMachine の Behavior の完了に対応し、停止に至る。</p></li>
</ul>
<p>Transition guards:</p>
<blockquote>
<div><p>A Transition may have an associated <code class="docutils literal notranslate"><span class="pre">guard</span></code> Constraint.</p>
</div></blockquote>
<ul class="simple">
<li><p>偽に評価される <code class="docutils literal notranslate"><span class="pre">guard</span></code> を有する Transitions は無効だ。</p></li>
<li><p>守衛はそれらを含む混合 Transition が有効になる前に評価される。ただし、それが
<strong>choice</strong> Pseudostate から始まる Transition 上にある場合を除く。</p></li>
<li><p>関連する <code class="docutils literal notranslate"><span class="pre">guard</span></code> を有しない Transition は、真である <code class="docutils literal notranslate"><span class="pre">guard</span></code> を有するものとして扱われる。</p></li>
</ul>
<blockquote>
<div><p>NOTE. A completion Transition may also have a <code class="docutils literal notranslate"><span class="pre">guard</span></code>.</p>
</div></blockquote>
<p>テスト：</p>
<blockquote>
<div><p>A <code class="docutils literal notranslate"><span class="pre">guard</span></code> constraint may involve tests of orthogonal States of the current
StateMachine, or explicitly designated States of some reachable object (for
example, “in State1” or “not in State2”).</p>
</div></blockquote>
<p>State 名はそれらを含む入れ子 States および Regions によって完全修飾され、
<code class="docutils literal notranslate"><span class="pre">RegionA::State1::Region1::State2::State3</span></code> という形のパス名をひねり出すことが許される。これは、同じ State 名が異なる複合 State Regions で出現する場合に使用される。</p>
</section>
<section id="compound-transitions">
<h5>14.2.3.8.4 Compound transitions<a class="headerlink" href="#compound-transitions" title="Permalink to this heading">¶</a></h5>
<p>イベント発生が有効な Transition を引き起こすか、StateMachine 実行が作成されると、安定状態構成に到達するまで、接続されて入れ子になった Transitions と Vertices
の集合の走査が開始される。一般的な場合では、混合遷移と呼ばれるこの走査の追跡は、非循環有向グラフで表すことが可能だ。このグラフの根（源）は、以下のいずれかだ：</p>
<ul class="simple">
<li><p>Triggers が一つ以上定義された Transition</p></li>
<li><p>完了 Transition</p></li>
<li><p>共通の <strong>join</strong> Pseudostate に収束する、相異なる直交 Regions を起点とする
Transitions の集合</p></li>
<li><p>最上位 Region つまり StateMachine が所有する Region の <strong>initial</strong> Pseudostate
を起点とする Transition</p></li>
</ul>
<blockquote>
<div><p>Branching in a compound transition execution occurs whenever an executing
Transition performs a default entry into a State with multiple orthogonal
Regions, with a separate branch created for each Region, or when a <strong>fork</strong>
Pseudostate is encountered.</p>
</div></blockquote>
<p>混合遷移の実行結果得られる全体的な挙動は、走査された要素に関連する Behaviors の実行の半順序集合であり、その要素 (Vertices and Transitions) が遭遇した順番によって決まる。</p>
<p>例えば、複合 State に進入する Transition がその State の部分状態で停止する場合、この Transition の <code class="docutils literal notranslate"><span class="pre">effect</span></code> は複合 State の <code class="docutils literal notranslate"><span class="pre">entry</span></code> の実行前に実行され、その後に部分状態の <code class="docutils literal notranslate"><span class="pre">entry</span></code> が実行される。走査中に <strong>fork</strong> Pseudostate に遭遇した場合、少なくとも概念的には、個々の出発枝の <code class="docutils literal notranslate"><span class="pre">effect</span></code> は互いに同時に実行される。</p>
<blockquote>
<div><p>If a <strong>choice</strong> or <strong>join</strong> point is reached with multiple outgoing
Transitions with <code class="docutils literal notranslate"><span class="pre">guards</span></code>, a Transition whose <code class="docutils literal notranslate"><span class="pre">guard</span></code> evaluates to true
will be taken. If more than one <code class="docutils literal notranslate"><span class="pre">guard</span></code> evaluates to true, one of these
Transitions is chosen for continuing the traversal.</p>
</div></blockquote>
<ul class="simple">
<li><p>この選択に対するアルゴリズムは未定義。</p></li>
<li><p><strong>choice</strong> Pseudostate を起点とする Transitions の場合、この Pseudostate に到達したときに真と評価される <code class="docutils literal notranslate"><span class="pre">guards</span></code> がない場合、まともでないモデルが形成される。</p></li>
</ul>
</section>
<section id="transition-ownership">
<h5>14.2.3.8.5 Transition ownership<a class="headerlink" href="#transition-ownership" title="Permalink to this heading">¶</a></h5>
<p>Transition が含まれている Region のほうは直接間接を問わず StateMachine が所有する必要があるが、Transition の所有者は明示的に制限されていない。</p>
<p>Transition の所有者として推奨されるのは、その <code class="docutils literal notranslate"><span class="pre">source</span></code> と <code class="docutils literal notranslate"><span class="pre">target</span></code> の両方を含む Region であって最も内側のものだ。</p>
</section>
</section>
<section id="event-processing-for-statemachines">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">14.2.3.9 Event Processing for StateMachines</a><a class="headerlink" href="#event-processing-for-statemachines" title="Permalink to this heading">¶</a></h4>
<section id="the-run-to-completion-paradigm">
<h5>14.2.3.9.1 The run-to-completion paradigm<a class="headerlink" href="#the-run-to-completion-paradigm" title="Permalink to this heading">¶</a></h5>
<p>StateMachine 実行による Event 発生の処理手順は、<a class="reference internal" href="ch13-common-behavior.html"><span class="doc">13 Common Behavior</span></a> で定義した一般的な意味に従う。</p>
<ul class="simple">
<li><p>StateMachineの、StateMachine は生成時に初期化を実行し、その間に生成によって促された初期混合遷移を実行し、その後、待機点に入る。</p></li>
<li><p>StateMachine Behaviors の場合、待機点は安定状態構成で表される。</p></li>
<li><p>イベントプールに格納されている Event が発送されるまでこの状態が維持される。</p></li>
<li><p>この Event が評価され、StateMachine の有効な Trigger と合致し、その Event 発生によって引き起こすことが可能である有効な Transition が少なくとも一つあれば、単一の StateMachine step が実行される。</p></li>
<li><p>ステップでは混合遷移を実行し、安定状態構成（すなわち次の待機点）で停止する。</p></li>
</ul>
<p>この循環は StateMachine が Behavior を完了するか、外部の取次者が非同期で停止するまで反復する。</p>
<blockquote>
<div><p>StateMachines can respond to any of the Event types described in Clause 13
<em>as well as to completion events</em></p>
</div></blockquote>
<p>※先述したが、完了イベントに優先権があり、イベントプール内の保留 Event 発生よりも早く発送される。</p>
<blockquote>
<div><p>Event occurrences are detected, dispatched, and processed by the StateMachine
execution, <em>one at a time</em>.</p>
</div></blockquote>
<p>※イベントの発送順序は、様々なスケジューリングアルゴリズムに対応できるように、未定義のままにしてある。</p>
<blockquote>
<div><p>This cycle is referred to as the <em class="dfn">run-to-completion paradigm</em>, and the
corresponding StateMachine step is called a <em class="dfn">run-to-completion step</em>.</p>
</div></blockquote>
<p>Run-to-Completion とは、例外や、context Classifier オブジェクトや StateMachine実行の非同期破棄がない場合、保留中の Event 発生が発送されるのは、直前の発生の処理が完了し、安定状態構成に到達した後であるということだ。</p>
<blockquote>
<div><p>When an Event occurrence is detected and dispatched, it may result in one or
more Transitions being <em>enabled</em> for firing.</p>
</div></blockquote>
<p>Transition が有効にならず、対応する Event 型が作動中状態構成の
<code class="docutils literal notranslate"><span class="pre">deferrableTriggers</span></code> 一覧のいずれにもない場合、発送された Event 発生は破棄され、この run-to-completion step は完了する。</p>
<blockquote>
<div><p>Due to the presence of orthogonal Regions, it is possible that multiple
Transitions (in different Regions) can be triggered by the same Event
occurrence.</p>
</div></blockquote>
<ul class="simple">
<li><p>これらの Transitions が実行される順番は未定義のままとする。</p></li>
<li><p>動作中状態構成の各直交 Region で、入れ子になった直交 Region を含まないもの（最下層）は、現在の Event 発生の結果として、高々一つの Transition を引き起こすことが可能だ。</p></li>
<li><p>直交 Regions すべてがこの Transition を実行し終わると、現在の Event 発生は完全に消費され、run-to-completion step は完了する。</p></li>
</ul>
<p>Region にある複数の互いに排他的な Transitions が同じ Event 発生によって有効になることがある。そのような場合、ただ一つが選択されて実行される。その選択アルゴリズムについては後述。</p>
<p>Transition 中には複数の行動 Behaviors が実行されることがある。</p>
<blockquote>
<div><p>If such a Behavior includes a synchronous invocation call on another object
executing a StateMachine, then the Transition step is not completed until the
invoked object method completes its run-to-completion step.</p>
</div></blockquote>
<p>Run-to-completion をさまざまな手段で実装してよい。</p>
<blockquote>
<div><p>For active Classes, it may be realized by an event-loop running in its own
thread, and that reads event occurrences from a pool. For passive Classes it
may be implemented using a monitor.</p>
</div></blockquote>
</section>
<section id="enabled-transitions">
<h5>14.2.3.9.2 Enabled Transitions<a class="headerlink" href="#enabled-transitions" title="Permalink to this heading">¶</a></h5>
<p>Transition が有効であるのは、次の場合、かつその場合に限る：</p>
<ul>
<li><p>その <code class="docutils literal notranslate"><span class="pre">source</span></code> States のすべてが作動中状態構成にある。</p></li>
<li><p>Transition の <code class="docutils literal notranslate"><span class="pre">triggers</span></code> の少なくとも一つは、送配された Event 発生の Event
型により合致する Event がある。</p>
<blockquote>
<div><p>In case of Signal Events, any occurrence of the same or compatible type as
specified in the Trigger will match. If one of the Triggers is for an
AnyReceiveEvent, then either a Signal or CallEvent satisfies this Trigger,
provided that there is no other Signal or CallEvent Trigger for the same
Transition or any other Transition having the same source Vertex as the
Transition with the AnyReceiveEvent trigger (see also 13.3.1).</p>
</div></blockquote>
</li>
<li><p>起源状態構成から目標状態構成または <code class="docutils literal notranslate"><span class="pre">guards</span></code> 条件すべてが真である動的
<strong>choice</strong> Pseudostate への少なくとも一つの完全経路が存在する場合。</p>
<blockquote>
<div><p>(Transitions without <code class="docutils literal notranslate"><span class="pre">guards</span></code> are treated as if their <code class="docutils literal notranslate"><span class="pre">guards</span></code> are
always true).</p>
</div></blockquote>
</li>
</ul>
<p>同じ Event 発生によって複数の Transition が有効になる可能性があるため、有効になることは Transition を引き起こすのに必要ではあるが十分ではない。</p>
</section>
<section id="conflicting-transitions">
<h5>14.2.3.9.3 Conflicting Transitions<a class="headerlink" href="#conflicting-transitions" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>It is possible for more than one Transition to be enabled within a
StateMachine. If that happens, then such Transitions may be <em>in conflict</em>
with each other.</p>
</div></blockquote>
<p>例えば、同じ State を起点とする Transitions 二つが、同じイベントによって引き起こされ、異なる <code class="docutils literal notranslate"><span class="pre">guards</span></code> を持つ場合を考える。このイベントが発生し、双方の
<code class="docutils literal notranslate"><span class="pre">guard</span></code> 条件が真である場合、ある run-to-completion step で起こる Transition は高々一つだ。</p>
<blockquote>
<div><p>Two Transitions are said to conflict if they both exit the same State, or,
more precisely, that the intersection of the set of States they exit is
non-empty.</p>
</div></blockquote>
<p>互いに直交する Regions で発生する Transitions のみが同時に引き起こされてよい。</p>
<p>この制約により、Transitions の集合を実行した結果得られる新しい作動中状態構成がうまく形成されることが保証される。</p>
</section>
<section id="firing-priorities">
<h5>14.2.3.9.4 Firing priorities<a class="headerlink" href="#firing-priorities" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>In situations where there are conflicting Transitions, the selection of which
Transitions will fire is based in part on an implicit priority.</p>
</div></blockquote>
<p>競合 Transitions の優先順位は、状態階層における相対的な位置に基づく。定義によれば、部分状態を起点とする Transition は、この部分状態の包含 States を起点とする競合 Transitions よりも優先度が高い。</p>
<p>Transition の優先順位はその <code class="docutils literal notranslate"><span class="pre">source</span></code> State に基いて定義される。</p>
<p>混合遷移内で連鎖する Transitions の優先順位は、最も深く入れ子になった <code class="docutils literal notranslate"><span class="pre">source</span></code>
State を持つ Transition の優先順位に基づく。</p>
<blockquote>
<div><p>In general, if t1 is a Transition whose source State is s1, and t2 has source
s2, then:</p>
<ul class="simple">
<li><p>If s1 is a direct or indirectly nested substate of s2, then t1 has higher
priority than t2.</p></li>
<li><p>If s1 and s2 are not in the same state configuration, then there is no
priority difference between t1 and t2.</p></li>
</ul>
</div></blockquote>
</section>
<section id="transition-selection-algorithm">
<h5>14.2.3.9.5 Transition selection algorithm<a class="headerlink" href="#transition-selection-algorithm" title="Permalink to this heading">¶</a></h5>
<p>射出する Transitions の集合は、現在の状態構成の Regions にある Transitions であって次の諸条件を満たすものだ：</p>
<ul class="simple">
<li><p>集合にある Transitions すべてが有効だ。</p></li>
<li><p>集合に衝突 Transitions がない。</p></li>
<li><p>集合外の Transition で、集合内の Transition より優先度の高いものはない。</p></li>
</ul>
<p>これは強欲な選択計算法により実装することが可能で、作動中状態構成を走査するというものだ。</p>
<blockquote>
<div><p>States in the active state configuration are traversed starting with the
innermost nested simple States and working outwards. For each State at a
given level, all originating Transitions are evaluated to determine if they
are enabled. This traversal guarantees that the priority principle is not
violated.</p>
</div></blockquote>
<p>唯一の非自明な問題は、全水準で直交 States 間の Transition 競合を解消することだ。これは、各直交 State において、そのコンポーネントのいずれかの中の Transition が射出したら探索を停止することでなされる。</p>
</section>
<section id="transition-execution-sequence">
<h5>14.2.3.9.6 Transition execution sequence<a class="headerlink" href="#transition-execution-sequence" title="Permalink to this heading">¶</a></h5>
<p><strong>internal</strong> および <strong>local</strong> Transitions を除くどの Transition も <code class="docutils literal notranslate"><span class="pre">source</span></code>
State から退出し <code class="docutils literal notranslate"><span class="pre">target</span></code> State へ進入する。これら二つの States は、複合でもかまわず、Transition の主始点と主終点としてそれぞれ指定される。</p>
<blockquote>
<div><p>The <em class="dfn">main source</em> is a direct substate of the Region that contains the
<code class="docutils literal notranslate"><span class="pre">source</span></code> States, and the <em class="dfn">main target</em> is the substate of the Region
that contains the <code class="docutils literal notranslate"><span class="pre">target</span></code> States.</p>
</div></blockquote>
<p>ある Region から別の Region への Transition は、同じ直後の複合 State では許されない。</p>
<p>Transition が有効になり、射出するために選択されると、次の段階が順に行われる：</p>
<ol class="arabic">
<li><p>主始点 State から開始して、その主始点 State を含む States が先に述べた
State 退出規則に則って退出される。</p></li>
<li><p>一連の State 退出は、主始点と主終点の両方を直接または間接的に含む最初の
Region に到達するまで続行する。</p>
<blockquote>
<div><p>The Region that contains both the main source and main target states is
called their <em class="dfn">least common ancestor</em>.</p>
</div></blockquote>
<p>その時点で <code class="docutils literal notranslate"><span class="pre">source</span></code> States の部分構成と <code class="docutils literal notranslate"><span class="pre">target</span></code> States の部分構成を接続する Transition の <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior が実行される（ここでの部分構成とは、
least common ancestor の先祖 Region に含まれる完全状態構成の部分集合を指す）。</p>
</li>
<li><p>主終点 State を含む States の構成は、主終点 State を含む least common
ancestor Region の最も外側の State から進入される。Behaviors の実行は State
進入または複合 State 進入の規則に従う。</p></li>
</ol>
<p>この遷移実行法は Figure 14.2 の StateMachine 見本が図解する。</p>
<blockquote>
<div><p>Figure 14.2 Compound transition example</p>
</div></blockquote>
<p>この場合、StateMachine が State <code class="docutils literal notranslate"><span class="pre">S11</span></code> にある間、イベント <code class="docutils literal notranslate"><span class="pre">sig</span></code> が発送されて、次の一連の動作が実行される：</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>xS11; t1; xS1; t2; eT1; eT11; t3; eT111
</pre></div>
</div>
</div></blockquote>
<p>入れ子になっている States と Transitions の遷移順序が外側からなのか内側からなのかが始点に近いか終点に近いかで決まるということが要点のようだ。</p>
</section>
</section>
</section>
<section id="notation">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">14.2.4 Notation</a><a class="headerlink" href="#notation" title="Permalink to this heading">¶</a></h3>
<section id="statemachine-diagrams">
<h4><a class="toc-backref" href="#id32" role="doc-backlink">14.2.4.1 StateMachine Diagrams</a><a class="headerlink" href="#statemachine-diagrams" title="Permalink to this heading">¶</a></h4>
<p>StateMachine をどのように図式化するかを規定する節だ。</p>
<blockquote>
<div><p>A StateMachine diagram is a graph that represents a StateMachine. States and
various other types of Vertices in the StateMachine graph are rendered by
appropriate State and Pseudostate symbols, while Transitions are generally
rendered by directed arcs that connect them, or by control symbols
representing the actions of the Behavior on the Transition.</p>
</div></blockquote>
<p>StateMachine 図は States/Vertices/Pseudostates と Transitions をそれぞれ頂点、辺とする有向グラフの一種であると考えられる。</p>
</section>
<section id="id2">
<h4><a class="toc-backref" href="#id33" role="doc-backlink">14.2.4.2 StateMachine</a><a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h4>
<p>StateMachine 再定義をクラス図で描写する場合、Classifier に対する既定矩形記法を用いることができ、キーワード <code class="docutils literal notranslate"><span class="pre">«statemachine»</span></code> が StateMachine の名前の上または前にある名前区画の中に収める。</p>
<p>StateMachine とその <code class="docutils literal notranslate"><span class="pre">context</span></code> Classifier または BehavioralFeatures の間の関連には特別な図表的表現がない。</p>
</section>
<section id="region">
<h4><a class="toc-backref" href="#id34" role="doc-backlink">14.2.4.3 Region</a><a class="headerlink" href="#region" title="Permalink to this heading">¶</a></h4>
<p>Regions を有する複合 State や StateMachine を図示するには、それらのグラフ Region
を破線を引いて tiling して Regions に分割する (Fig. 14.3)。</p>
<ul class="simple">
<li><p>各 Region は任意の名前を持つことが許され、入れ子になった非交和 State とその間の Transitions を含む。</p></li>
<li><p>State 全体のテキスト区画は実線により直交 Regions から区切られる。</p></li>
</ul>
<blockquote>
<div><p>Figure 14.3 Notation for a composite State with Regions</p>
</div></blockquote>
<p>Regions が二つある複合 State を示す。</p>
</section>
<section id="state">
<h4><a class="toc-backref" href="#id35" role="doc-backlink">14.2.4.4 State</a><a class="headerlink" href="#state" title="Permalink to this heading">¶</a></h4>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>UML 2.5 と 2.5.1 の仕様書で、この辺りの文書構造に変化があるようだが、旧版ではおそらく余分な節が挿入されていて、節番号にズレが生じていた。</p>
</div>
<p>まずは State の記法を二種。</p>
<blockquote>
<div><p>State is shown as a rectangle with rounded corners, with the State name shown
within (Figure 14.4).</p>
<p>Optionally, it may have an attached name tab (Figure 14.5).</p>
</div></blockquote>
<p>後者の記法は通常、直交 Regions を有する複合 State の名称を保持するために用いられるが、他の場合に用いてもかまわない。</p>
<blockquote>
<div><p>A State may be subdivided into multiple compartments separated from each
other by a horizontal line (Figure 14.6).</p>
</div></blockquote>
<p>この図式を観察すると、区画内が Class 記法と若干異なることに気づく。</p>
<dl>
<dt>名前区画</dt><dd><p>この区画では State の名前（オプション）を文字列として保持する。</p>
<p>部分機械 State の場合は、参照される StateMachine の名前を State の名前の後にコロン <code class="docutils literal notranslate"><span class="pre">:</span></code> が続く文字列として示す。</p>
</dd>
<dt>内部 Behaviors 区画</dt><dd><p>この区画では State に付随する内部 Behaviors のリストを保持する。リストの各項目は次の書式だ：</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nc">behavior-type-label</span><span class="p">&gt;</span> [‘/’ <span class="p">&lt;</span><span class="nc">behavior-expression</span><span class="p">&gt;</span>]
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;behavior-type-label&gt;</span></code> は <code class="docutils literal notranslate"><span class="pre">&lt;behavior-expression&gt;</span></code> で指定された Behavior
が呼び出される状況を分類するもので、次のいずれかだ：</p>
<dl class="simple">
<dt>entry</dt><dd><p>対応する式で指定される、当 State への進入時に実行される Behavior <code class="docutils literal notranslate"><span class="pre">entry</span></code>
を識別する。</p>
</dd>
<dt>exit</dt><dd><p>対応する式で指定される、当 State からの退出時に実行される Behavior <code class="docutils literal notranslate"><span class="pre">exit</span></code>
を識別する。</p>
</dd>
<dt>do</dt><dd><p>モデル化された要素が当 State にある限り、または式で指定される計算が完了するまでに実行される進行中 Behavior <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> を識別する。</p>
</dd>
</dl>
<p>オプションの <code class="docutils literal notranslate"><span class="pre">&lt;behavior-expression&gt;</span></code> は、何らかのテキスト表層言語による表現であり、製造者固有の言語でも標準的な言語でもよい (16.1)。</p>
</dd>
<dt>内部 Transitions 区画</dt><dd><p>この区画では <strong>internal</strong> Transitions のリストを含む。各項目は次の構文で表す：</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span>{<span class="p">&lt;</span><span class="nc">trigger</span><span class="p">&gt;</span>}* [‘[’ <span class="p">&lt;</span><span class="nc">guard</span><span class="p">&gt;</span>‘]’] [/<span class="p">&lt;</span><span class="nc">behavior-expression</span><span class="p">&gt;</span>]
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;triger&gt;</span></code> は Triggers に対する記法 (13.3.4)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;guard&gt;</span></code> は真偽式</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;behavior-expression&gt;</span></code> はオプションであり、Event 発生が <strong>internal</strong>
Transition の <code class="docutils literal notranslate"><span class="pre">trigger</span></code> と <code class="docutils literal notranslate"><span class="pre">guard</span></code> に合致する場合に実行される <code class="docutils literal notranslate"><span class="pre">effect</span></code>
Behavior の仕様（上の記述も参照のこと）。</p></li>
</ul>
</dd>
<dt>分解区画</dt><dd><p>複合 State のみこの区画を使える。次の節参照。</p>
</dd>
</dl>
<p>テキストによる挙動式の代わりに、State または <strong>internal</strong> Transition に付随するさまざまな Behaviors を別の図式 (e.g. Activity) で表すことができる。</p>
<section id="composite-state">
<h5>14.2.4.4.1 Composite State<a class="headerlink" href="#composite-state" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>This compartment shows its composition structure in terms of Regions, States,
and Transition. In addition to the (optional) name and internal Transition
compartments, the State may have an additional compartment that contains a
nested diagram.</p>
</div></blockquote>
<p>複合 State の分解を非表示にすることが便利な場合がある。</p>
<blockquote>
<div><p>For example, there may be a large number of States nested inside a composite
State and they may simply not fit in the graphical space available for the
diagram. In that case, the composite State may be represented by a simple
State graphic with a special “composite” icon, usually in the lower
right-hand corner (see Figure 14.8).</p>
</div></blockquote>
<p>このアイコンは水平に配置され接続された二つの States から構成され、当該図式では示されていない分解を持つことを示す、オプションの視覚的な手がかりとなる。その代わりに、複合 States の内容が別の図式に表示される。</p>
<blockquote>
<div><p>NOTE. The “hiding” here is purely a matter of graphical convenience and has
no semantic significance in terms of access restrictions.</p>
</div></blockquote>
<p>複合 State には、その外側の境界に、またはその境界に近接して（内側または外側に）複数の出入口地点を持つことができる。</p>
<blockquote>
<div><p>Figure 14.7 Composite State with two States</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Dialing</span></code> は <code class="docutils literal notranslate"><span class="pre">Start</span></code> と <code class="docutils literal notranslate"><span class="pre">Partial</span></code> <code class="docutils literal notranslate"><span class="pre">Dial</span></code> の二つの States を含む複合
State だ（最初の黒丸と最後の二重丸は今は無視）。</p>
<blockquote>
<div><p>Figure 14.8 Composite State with a hidden decomposition indicator icon</p>
</div></blockquote>
<p>複合 State の分解を非表示にすることは便利だ。メガネのような記号を State 内の右下に記すことでそのことを示す。</p>
<blockquote>
<div><p>Figure 14.9 Composite State with Regions</p>
</div></blockquote>
<p>状態 <code class="docutils literal notranslate"><span class="pre">Studying</span></code> は三個の Regions からなる。</p>
<blockquote>
<div><p>Figure 14.10 Composite State with two Regions and entry, exit, and do Behaviors</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">entry</span></code>: この状態 (<code class="docutils literal notranslate"><span class="pre">LightOn</span></code>) に進入する際に履行される Behavior
(<code class="docutils literal notranslate"><span class="pre">entry</span></code>) だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">do</span></code>: この状態にある間中履行される Behavior (<code class="docutils literal notranslate"><span class="pre">doActivity</span></code>) だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exit</span></code>: この状態から退出する際に履行される Behavior (<code class="docutils literal notranslate"><span class="pre">exit</span></code>) だ。</p></li>
<li><p>文書中に記述がないのでこれは憶測になるが、左の Region がメインの照明、右の
Region がサブの照明を示している。</p></li>
</ul>
</section>
<section id="submachine-state">
<h5>14.2.4.4.2 Submachine State<a class="headerlink" href="#submachine-state" title="Permalink to this heading">¶</a></h5>
<p>部分機械 State は通常の State として描かれる。名前区画の文字列は次の構文だ：</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nc">state-name</span><span class="p">&gt;</span> ‘:’ <span class="p">&lt;</span><span class="nc">name-of-referenced-StateMachine</span><span class="p">&gt;</span>
</pre></div>
</div>
<blockquote>
<div><p>The submachine State symbol may contain the references to one or more
<code class="docutils literal notranslate"><span class="pre">entry</span></code> points and to one or more <code class="docutils literal notranslate"><span class="pre">exit</span></code> points.</p>
</div></blockquote>
<ul class="simple">
<li><p>これらの接続点参照の表記は部分機械 State の境界上の <code class="docutils literal notranslate"><span class="pre">entry</span></code>/<code class="docutils literal notranslate"><span class="pre">exit</span></code>
Pseudostate から構成される。</p></li>
<li><p>名前は参照される StateMachine 内で定義される対応する入口・出口点の名前だ。
ConnectionPointReference 参照。</p></li>
</ul>
<blockquote>
<div><p>If the submachine StateMachine is entered through its default <strong>initial</strong>
Pseudostate or if it is exited as a result of the completion of the
submachine, it is not necessary to use the entry/exit point notation.</p>
</div></blockquote>
<p>同様に、部分機械 State の境界からの明示的なグループ Transition によって退出する場合は、出口点は必要ない。</p>
<blockquote>
<div><p>Submachine States invoking the same submachine may occur multiple times in
the same state diagram with the entry and exit points being part of different
Transitions.</p>
</div></blockquote>
<blockquote>
<div><p>Figure 14.11 Submachine State example</p>
</div></blockquote>
<p>部分機械 State が参照される StateMachine 図の断片だ。実際の部分機械 StateMachine
は、何らかの名前空間で定義される。</p>
<p>Event <code class="docutils literal notranslate"><span class="pre">error1</span></code> が引き起こした Transition は <code class="docutils literal notranslate"><span class="pre">FailureSumbachine</span></code> の入口点
<code class="docutils literal notranslate"><span class="pre">sub1</span></code> にて停止する。Transition <code class="docutils literal notranslate"><span class="pre">error3</span></code> は <code class="docutils literal notranslate"><span class="pre">FailureSumbachine</span></code> の既定
Transition を取ることを示す。</p>
<p>部分機械の出口点 <code class="docutils literal notranslate"><span class="pre">subEnd</span></code> から始まる Transition は <code class="docutils literal notranslate"><span class="pre">HandleFailure</span></code> で実行されるものに加えて、Behavior <code class="docutils literal notranslate"><span class="pre">fixed1</span></code> を実行する。この Transition は当部分機械内で引き起こされなければならない。</p>
<p>当部分機械 State が FinalState に到達したときに生成される完了イベントの結果として、右辺から出ていく Transition が取られる。</p>
<blockquote>
<div><p>NOTE. The same notation would apply to composite States with the exception
that there would be no reference to a StateMachine in the State name.</p>
</div></blockquote>
<blockquote>
<div><p>Figure 14.12 StateMachine with an exit point as part of the StateMachine
graph</p>
</div></blockquote>
<p>二つの出口点が定義された StateMachine の見本。入口点と出口点は状態枠上もしくは状態グラフ内に表示されることがある。この図式はグラフ内に出口点を示した。</p>
<blockquote>
<div><p>Figure 14.13 StateMachine with an exit point on the border</p>
</div></blockquote>
<p>これは先の図式と同じモデルだが、同じ出口点を状態枠上に示したものだ。</p>
<blockquote>
<div><p>Figure 14.14 Submachine Sate that uses an exit point</p>
</div></blockquote>
<p>Figure 14.12 や 14.13 で示した StateMachine が部分機械 State で参照されており、State 記号上に出口点のある表現オプションを示す。</p>
<p>複合 States に対する入口点・出口点の記法例は Fig. 14.23 にある。</p>
</section>
<section id="state-list-notation">
<h5>14.2.4.4.3 State list notation<a class="headerlink" href="#state-list-notation" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>State lists provide a graphical shortcut for certain situations that
sometimes occur in practice.</p>
</div></blockquote>
<p>異なる States を起点とする、同じ Trigger 値を有する <code class="docutils literal notranslate"><span class="pre">effect</span></code> フリーの
Transitions 複数だが、すべてが</p>
<ul class="simple">
<li><p>単一の出発 Transition のある共通 <strong>junction</strong> Vertex を目標 State とするか、</p></li>
<li><p>同じ目標 State で停止するか</p></li>
</ul>
<p>であるものは、State 風図表的要素を起点とする単一 Transition のような辺で表してもよい。辺には起点となる State の名前一覧ラベルが付く。この辺は joint target State
で停止する。</p>
<blockquote>
<div><p>Figure 14.15 State list notation option</p>
</div></blockquote>
<p>どちらの可能性もある。</p>
<blockquote>
<div><p>Figure 14.16 Diagram equivalent to Figure 14.15 without using statelists</p>
</div></blockquote>
<p>状態リストを用いない場合の同値の図式。黒丸が joint target State に相当する。</p>
</section>
</section>
<section id="id3">
<h4><a class="toc-backref" href="#id36" role="doc-backlink">14.2.4.5 FinalState</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h4>
<p>FinalState は小さい黒丸を囲む丸で示す。</p>
<blockquote>
<div><p>Figure 14.17 FinalState notation</p>
</div></blockquote>
<p>FinalState の見本だ。複合 State 内部の States の最も右のもの。</p>
</section>
<section id="pseudostate">
<h4><a class="toc-backref" href="#id37" role="doc-backlink">14.2.4.6 Pseudostate</a><a class="headerlink" href="#pseudostate" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Figure 14.18 initial Pseudostate</p>
</div></blockquote>
<p><strong>initial</strong> Pseudostate は小さい黒丸。</p>
<p>ClassifierBehavior StateMachine の Region では <strong>initial</strong> Pseudostate からの
Transition は、そのオブジェクトを生成する発生の Event 型でラベル付けられていてもよい。そうでない場合、ラベル付けされていなければならない。ラベル付けられていない場合、囲んでいる State からの任意の Transition を表す。</p>
<blockquote>
<div><p>Figure 14.19 shallowHistory Pseudostate</p>
</div></blockquote>
<p><strong>shallowHistory</strong> Pseudostate は <code class="docutils literal notranslate"><span class="pre">H</span></code> を囲む小さい丸で見せる。その Region を直接囲む State Region に適用する。</p>
<blockquote>
<div><p>Figure 14.20 deepHistory Pseudostate</p>
</div></blockquote>
<p><strong>deepHistory</strong> Pseudostate は <code class="docutils literal notranslate"><span class="pre">H*</span></code> を囲む小さい丸で見せる。その Region を直接囲む State Region に適用する。</p>
<blockquote>
<div><p>Figure 14.21 entryPoint Pseudostate</p>
</div></blockquote>
<p>入口点は StateMachine 図または複合 State の枠上に小さい丸として、関連する名前とともに見せる。</p>
<blockquote>
<div><p>Optionally it may be placed both within the StateMachine diagram and outside
the border of the StateMachine diagram or composite State.</p>
</div></blockquote>
<blockquote>
<div><p>Figure 14.22 exitPoint Pseudostate</p>
</div></blockquote>
<p>出口点は StateMachine 図または複合 State の枠上にバツの付いた小さい丸として、関連する名前とともに見せる。</p>
<p>配置位置の選択については入口点と同様。</p>
<blockquote>
<div><p>Figure 14.23 entryPoint and exitPoints on a composite State</p>
</div></blockquote>
<p>複合 States の入口点と出口点を描く場合の表記法を図解する。</p>
<blockquote>
<div><p>Alternatively, the “bracket” notation shown in Figure 14.30 and Figure 14.31
can also be used for the transition-oriented notation.</p>
</div></blockquote>
<blockquote>
<div><p>Figure 14.24 junction Pseudostate with incoming and outgoing Transitions</p>
</div></blockquote>
<p><strong>junction</strong> は黒丸で見せる。</p>
<blockquote>
<div><p>Figure 14.25 choice Pseudostates</p>
</div></blockquote>
<p><strong>choice</strong> Pseudostate は菱形の記号で見せる。NOTE にあるように、場合によっては菱形内部の条件を略記し、Transitions ラベルに移行することが許される。</p>
<blockquote>
<div><p>Figure 14.26 terminate Pseudostate</p>
</div></blockquote>
<p><strong>terminate</strong> Pseudostate はバツで見せる。</p>
<blockquote>
<div><p>Figure 14.27 fork and join Pseudostates</p>
</div></blockquote>
<p><strong>fork</strong> と <strong>join</strong> を表す表記法は太い棒だ。</p>
<blockquote>
<div><p>The bar may have one or more arrows from source States to the bar (when
representing a join). The bar may have one or more arrows from the bar to
States (when representing a fork).</p>
</div></blockquote>
<p>Transition 文字列を棒の近くに示してもよい。</p>
</section>
<section id="id4">
<h4><a class="toc-backref" href="#id38" role="doc-backlink">14.2.4.7 ConnectionPointReference</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A connection point reference to an entry point has the same notation as an
entry Pseudostate. The circle is placed on the border of the State symbol of
a submachine State.</p>
</div></blockquote>
<blockquote>
<div><p>Figure 14.28 Entry point ConnectionPointReference notation</p>
</div></blockquote>
<p>入口点に対する接続点参照は <code class="docutils literal notranslate"><span class="pre">entry</span></code> Pseudostate と同じ表記法だ。</p>
<blockquote>
<div><p>Figure 14.29 Exit point ConnectionPointReference notation</p>
</div></blockquote>
<p>出口点に対する接続点参照は <code class="docutils literal notranslate"><span class="pre">exit</span></code> Pseudostate と同じ表記法だ。</p>
<blockquote>
<div><p>Figure 14.30 Alternative entry point ConnectionPointReference notation</p>
</div></blockquote>
<p>代わりに、入口点に対する接続点参照は「括弧付きの空白」記号を使って見せることもできる。記号内のテキストは <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">via</span> <span class="pre">&lt;name&gt;</span> <span class="pre">)</span></code> とする。ここで <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> は接続点の名前とする。</p>
<blockquote>
<div><p>This notation may only be used if the Transition ending with the connection
point is defined using the graphical Transition notation, such as the one
shown in Figure 14.32.</p>
</div></blockquote>
<p>Fig. 14.30 のことだと思われる。</p>
<blockquote>
<div><p>Figure 14.31 Alternative exit point ConnectionPointReference notation</p>
</div></blockquote>
<p>出口点に対する接続点参照の記法についても、入口点に対するそれの類比で定義される。</p>
</section>
<section id="transition">
<h4><a class="toc-backref" href="#id39" role="doc-backlink">14.2.4.8 Transition</a><a class="headerlink" href="#transition" title="Permalink to this heading">¶</a></h4>
<p>Transition を表すテキスト表記法は既定では：</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span>[<span class="p">&lt;</span><span class="nc">trigger</span><span class="p">&gt;</span> [‘,’ <span class="p">&lt;</span><span class="nc">trigger</span><span class="p">&gt;</span>]* [‘[’ <span class="p">&lt;</span><span class="nc">guard</span><span class="p">&gt;</span>‘]’] [‘/’ <span class="p">&lt;</span><span class="nc">behavior-expression</span><span class="p">&gt;</span>]]
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;trigger&gt;</span></code> は Triggers を表す標準表記法 (13.3.4) だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;guard&gt;</span></code> は <code class="docutils literal notranslate"><span class="pre">guard</span></code> を表す Boolean 式だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;behavior-expression&gt;</span></code> はオプションで、<code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior を指定する式だ。前に述べられているのと同じ。</p></li>
</ul>
<p>代替として、<code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior を制御フローに基づく Actions の配列として記述できる場合、Transitions と混合遷移には Activities に対して使われる表記法と類似するを表す図式的表現がある。</p>
<blockquote>
<div><p>NOTE. Although this alternative notation contains graphical elements
reminiscent of the notation used for Activities, it is a distinct form
applicable only to StateMachines, and its elements map to appropriate
StateMachine concepts.</p>
</div></blockquote>
<p>この表記法は有向グラフの形をしていて、制御フローを表す有向辺で相互接続された一つ以上の図表記号からなる (Fig. 14.32)。</p>
<p><strong>initial</strong> Pseudostate を起点とする Transition 以外の場合、標準的な単純 State
記法の形式である開始記号はこの Transition の <code class="docutils literal notranslate"><span class="pre">source</span></code> State を表現する。この
Transition が Signal に基づく Trigger を持つ場合、この <code class="docutils literal notranslate"><span class="pre">source</span></code> State 記号は特別な Signal 受信記号を表す辺で接続される。この Transition に複数 Triggers がある場合、すべて同じ記号に一覧される。</p>
<p><strong>initial</strong> Pseudostate を起点とする Transition の場合、開始記号は初期記号であり、それは <strong>initial</strong> Pseudostate を表すのに使うものと同じだ。つまり黒塗りの丸だ。この場合、開始記号の直後に Signal 受信記号はない。</p>
<p>経路を停止する終了記号を除いて、次の記号のどれでも、適宜連鎖の中に出現可能だ：</p>
<ul class="simple">
<li><p>動作記号</p></li>
<li><p>選択点記号</p></li>
<li><p>Signal 送信記号</p></li>
<li><p>融合記号</p></li>
</ul>
<p>これらの有向グラフにある停止記号はいつでも、遷移の <code class="docutils literal notranslate"><span class="pre">target</span></code> State を表す State
風記号か最終状態 (FinalState) 記号だ。</p>
<section id="action-symbols">
<h5>14.2.4.8.1 Action symbols<a class="headerlink" href="#action-symbols" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>Each action symbol is represented by a rectangle with an optional textual
specification of the action.</p>
</div></blockquote>
<p>これは OpaqueAction または順次実行される一つ以上の Actions を含む SequenceNode
に写像される（このような Actions は混合遷移の適当な Transition の <code class="docutils literal notranslate"><span class="pre">effect</span></code>
Behavior を指定する Activity の部分だ）。</p>
</section>
<section id="signal-receipt-symbol">
<h5>14.2.4.8.2 Signal receipt symbol<a class="headerlink" href="#signal-receipt-symbol" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>The Signal receipt symbol is shown as a five-pointed polygon that looks like
a rectangle with a triangular notch in one of its sides (either one).</p>
</div></blockquote>
<p>Transition の <code class="docutils literal notranslate"><span class="pre">trigger</span></code> に写像され、<code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior を指定する Activity には写像されない。この Trigger の Signals の名前と <code class="docutils literal notranslate"><span class="pre">guards</span></code> は次の書式で記号内に記述する：</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nc">trigger</span><span class="p">&gt;</span> [‘,’ <span class="p">&lt;</span><span class="nc">trigger</span><span class="p">&gt;</span>]* [‘[’ <span class="p">&lt;</span><span class="nc">guard</span><span class="p">&gt;</span> ‘]’]
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;trigger&gt;</span></code> は 13.3.4 節に記述されているように指定され、Signal と <code class="docutils literal notranslate"><span class="pre">change</span></code>
Event 型のみが許可されるという制約がある。駆動装置記号は常に記号の経路の最初にあり、混合遷移は高々一つの記号しか持つことが不可能だ。</p>
</section>
<section id="signal-send-symbol">
<h5>14.2.4.8.3 Signal send symbol<a class="headerlink" href="#signal-send-symbol" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>This represents the special action of sending a signal and maps directly to a
SendSignalAction that is part of the Activity that describes the <code class="docutils literal notranslate"><span class="pre">effect</span></code>
Behavior of the corresponding Transition.</p>
</div></blockquote>
<p>Signal 送信記号の記法は SendSignalAction (16.3.4) の記法に対応する。</p>
</section>
<section id="choice-point-symbol">
<h5>14.2.4.8.4 Choice point symbol<a class="headerlink" href="#choice-point-symbol" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>This symbol maps directly to a <strong>choice</strong> Pseudostate and uses the same
notation.</p>
</div></blockquote>
<p>これはどの Activity の部分でもない。</p>
</section>
<section id="merge-symbol">
<h5>14.2.4.8.5 Merge symbol<a class="headerlink" href="#merge-symbol" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>A merge symbol is used to join multiple control-flow arcs and maps directly
to a <strong>junction</strong> Pseudostate and uses the same notation. It is not part of
any Activity.</p>
</div></blockquote>
<blockquote>
<div><p>Figure 14.32 Symbols for Signal reception, Sending, and Actions on a
Transition</p>
</div></blockquote>
<p>この図は四つの接続された Transitions からなる混合遷移を示している。</p>
<ul class="simple">
<li><p>Idle から菱形の間</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Req(id)</span></code> が Signal 受信記号。</p></li>
<li><p>菱形が選択点記号。</p></li>
</ul>
</li>
<li><p>菱形から黒丸の間（左右それぞれ）</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Minor(id)</span></code> たちが Signal 送信記号。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MinorReq</span> <span class="pre">:=</span> <span class="pre">id;</span></code> たちがアクション記号。</p></li>
</ul>
</li>
<li><p>黒丸から Busy の間</p>
<ul>
<li><p>黒丸は融合記号。</p></li>
</ul>
</li>
</ul>
</section>
<section id="deferred-triggers">
<h5>14.2.4.8.6 Deferred triggers<a class="headerlink" href="#deferred-triggers" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>A deferrable trigger is shown by listing it within the State followed by a
slash and the label “defer”.</p>
</div></blockquote>
<blockquote>
<div><p>Figure 14.33 Deferred Trigger notation</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Initializing</span></code> と <code class="docutils literal notranslate"><span class="pre">Primed</span></code> のどちらの状態にも <code class="docutils literal notranslate"><span class="pre">request/defer</span></code> とある。イベント <code class="docutils literal notranslate"><span class="pre">request</span></code> 発生の処理はどちらでも延期されるが、<code class="docutils literal notranslate"><span class="pre">Operation</span></code> 状態に到達すれば処理される。</p>
</section>
</section>
<section id="transitionkind">
<h4><a class="toc-backref" href="#id40" role="doc-backlink">14.2.4.9 TransitionKind</a><a class="headerlink" href="#transitionkind" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p>種類が <strong>internal</strong> の Transitions は図式中には明示的に示されない。</p></li>
<li><p>種類が <strong>local</strong> の Transitions は包含複合 State の境界、またはそれの入口点のうちの一つ、または複合 State 内にある Vertex を起点とすることができる。</p>
<ul>
<li><p>代わりに、<strong>local</strong> Transitions は <code class="docutils literal notranslate"><span class="pre">*</span></code> というテキストを含む状態記号から離脱する Transition として示すことも可能だ。</p></li>
<li><p>この種の Transitions は複合 State の境界上またはその出口点の一つまたは複合
State 内にある Vertex でしか停止することが不可能だ。</p></li>
</ul>
</li>
<li><p>種類が <strong>external</strong> の Transitions は <code class="docutils literal notranslate"><span class="pre">source</span></code> Vertex の内部または外部の任意の Vertex を <code class="docutils literal notranslate"><span class="pre">target</span></code> にすることが可能だ。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code> に最も近い <strong>external</strong> Transition の部分は、<code class="docutils literal notranslate"><span class="pre">source</span></code> Vertex の境界の外側に描画されなければならない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code> が State または State 上の出口点である <strong>external</strong> 自己
Transition の場合、State 自体または State 上の入口点を <code class="docutils literal notranslate"><span class="pre">target</span></code> にすることができ、State 境界の完全に外側に描かれる。</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>Figure 14.34 Local Transitions</p>
</div></blockquote>
<p>ここにある Transitions のすべてが <strong>local</strong> だ。</p>
<blockquote>
<div><p>Figure 14.35 External Transitions</p>
</div></blockquote>
<p>ここにある Transitions のすべてが <strong>external</strong> だ。</p>
</section>
</section>
<section id="examples">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">14.2.5 Examples</a><a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 14.36 StateMachine diagram representing a telephone</p>
</div></blockquote>
<p>簡単な電話の StateMachine の図式。</p>
<ul class="simple">
<li><p>Idle の右についている黒丸 (<strong>initial</strong> Pseudostate) と、大きい枠の左上外部にある白丸 (activeEntry) が入口点が見える。</p></li>
<li><p>FinalState に加えて、マルバツ印の aborted なる出口点がある。</p></li>
</ul>
<p>部分機械の例は Fig. 14.12 と Fig. 14.13 に見られる。</p>
</section>
</section>
<section id="statemachine-redefinition">
<h2><a class="toc-backref" href="#id42" role="doc-backlink">14.3 StateMachine Redefinition</a><a class="headerlink" href="#statemachine-redefinition" title="Permalink to this heading">¶</a></h2>
<section id="id5">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">14.3.1 Summary</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>StateMachines are used for the definition of Behavior (for example, Classes
that are generalizable).</p>
</div></blockquote>
<p>Class の特殊化の一環として、それの Behavior 定義を特殊化することが要求されてもよい。これは再定義を用いて一般 Classifier の Behavior の拡張として、特殊化された
Classifier の Behavior を定義することで達せられる。</p>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id44" role="doc-backlink">14.3.2 Abstract Syntax</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 14.37 StateMachine redefinition</p>
</div></blockquote>
<p>現れているクラスはすべて前節ですでに述べられている。</p>
<p>ただし、Region, State, Transition の親クラスが RedefinableElement のみとなっていることが違う。以前見た Figure 14.1 では Namespace のみが親クラスとして示されていた。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">A_extendedStateMachine_stateMachine</span></code>, <code class="docutils literal notranslate"><span class="pre">A_extendedRegion_region</span></code></dt><dd><p>StateMachine/Region から StateMachine/Region への関連（単方向）。これが一つの拡張であるような StateMachine/Region を参照。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_redefinedState_state</span></code>, <code class="docutils literal notranslate"><span class="pre">A_redefinedTransition_transition</span></code></dt><dd><p>State/Transition から State/Transition への関連（単方向）。これがその再定義であるような State/Transition を参照。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_redefinitionContext_region</span></code>, <code class="docutils literal notranslate"><span class="pre">A_redefinitionContext_state</span></code>, <code class="docutils literal notranslate"><span class="pre">A_redefinitionContext_transition</span></code></dt><dd><p>Region/State/Transition から Classifier への関連（単方向）。これが再定義されることが許容される <code class="docutils literal notranslate"><span class="pre">context</span></code> Classifier を参照。</p>
</dd>
</dl>
</section>
<section id="id7">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">14.3.3 Semantics</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<section id="statemachine-extension">
<h4><a class="toc-backref" href="#id46" role="doc-backlink">14.3.3.1 StateMachine Extension</a><a class="headerlink" href="#statemachine-extension" title="Permalink to this heading">¶</a></h4>
<p>StateMachine は一つ以上の他の StateMachine を再定義することが可能であり、その場合、それは再定義された StateMachine の拡張となる。</p>
<blockquote>
<div><p>A <code class="docutils literal notranslate"><span class="pre">region</span></code> of an extension StateMachine can redefine one or more
<code class="docutils literal notranslate"><span class="pre">regions</span></code> of its <code class="docutils literal notranslate"><span class="pre">extendedStateMachines</span></code>.</p>
</div></blockquote>
<p>拡張 StateMachine の basline 動作は、拡張 StateMachine の <code class="docutils literal notranslate"><span class="pre">regions</span></code> と、その <code class="docutils literal notranslate"><span class="pre">extendedStateMachine</span></code> のすべての非再定義 <code class="docutils literal notranslate"><span class="pre">regions</span></code> のすべての和集合を含んでいるかのようなものだ。</p>
<blockquote>
<div><p>An extension StateMachine may also add new <code class="docutils literal notranslate"><span class="pre">connectionPoint</span></code> Pseudostates
or redefine <code class="docutils literal notranslate"><span class="pre">connectionPoints</span></code> from any of its <code class="docutils literal notranslate"><span class="pre">extendedStateMachines</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p>If a StateMachine has a <code class="docutils literal notranslate"><span class="pre">context</span></code> BehavioredClassifier (see sub clause
13.2.3.4), then this BehavioredClassifier is also its <code class="docutils literal notranslate"><span class="pre">redefinitionContext</span></code>
(see sub clause 9.2.3.3).</p>
</div></blockquote>
<ul class="simple">
<li><p>これには一般的な BehavioredClassifer の <code class="docutils literal notranslate"><span class="pre">classifierBehavior</span></code> である
StateMachine や、一般的な BehavioredClassifier の BehavioralFeature の
<code class="docutils literal notranslate"><span class="pre">method</span></code> を指定するための StateMachine の場合も含まれる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code> BehavioredClassifier が特殊化されると、関連するStateMachine は特殊化された BehavioredClassifier の <code class="docutils literal notranslate"><span class="pre">context</span></code> の対応する StateMachine によって拡張される。</p></li>
</ul>
</section>
<section id="region-redefinition">
<h4><a class="toc-backref" href="#id47" role="doc-backlink">14.3.3.2 Region Redefinition</a><a class="headerlink" href="#region-redefinition" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A Region that is a region of an extension StateMachine can redefine a Region
that is a region of an <code class="docutils literal notranslate"><span class="pre">extendedStateMachine</span></code> of that StateMachine. A
Region that is a region of a redefining State in an extension StateMachine
(see sub clause 14.3.3.3) can redefine a Region that is a region of the
redefined State in an <code class="docutils literal notranslate"><span class="pre">extendedStateMachine</span></code> of that StateMachine.</p>
</div></blockquote>
<ul class="simple">
<li><p>どちらの場合でも、再定義 Region は被再定義 Region の拡張と呼ばれる。</p></li>
<li><p>拡張 Region の baseline 動作は、次の和集合のようなものだ：</p>
<ul>
<li><p>拡張 Region に含まれる Vertices と Transitions</p></li>
<li><p>拡張 Region に含まれる非再定義 Vertices と Transitions すべて</p></li>
</ul>
</li>
</ul>
</section>
<section id="vertex-redefinition">
<h4><a class="toc-backref" href="#id48" role="doc-backlink">14.3.3.3 Vertex Redefinition</a><a class="headerlink" href="#vertex-redefinition" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A Vertex defined in an extension Region can redefine a Vertex of the same
kind in the extended Region of the extension Region.</p>
</div></blockquote>
<p>同じ種類。</p>
<blockquote>
<div><p>A State can only be redefined by a State.</p>
</div></blockquote>
<ul class="simple">
<li><p>再定義する State が <code class="docutils literal notranslate"><span class="pre">entry</span></code>, <code class="docutils literal notranslate"><span class="pre">exit</span></code>, <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> の全部または一部を指定する場合、再定義される State が同様の Behavior を指定するかどうかに関わらず、再定義する State に適用されるのは前者の Behavior だ。</p></li>
<li><p>しかし、再定義する State が <code class="docutils literal notranslate"><span class="pre">entry</span></code>, <code class="docutils literal notranslate"><span class="pre">exit</span></code>, <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> の全部または一部を指定しないが、<code class="docutils literal notranslate"><span class="pre">redifned</span></code> State に適用される対応する Behavior がある場合、再定義する State にも <code class="docutils literal notranslate"><span class="pre">redefined</span></code> State の Behavior が適用される。</p></li>
</ul>
<blockquote>
<div><p>Any <code class="docutils literal notranslate"><span class="pre">deferrableTriggers</span></code> applicable to the redefined State also apply to
the redefining State, and the redefining state can also add new
<code class="docutils literal notranslate"><span class="pre">deferrableTriggers</span></code>.</p>
</div></blockquote>
<p>再定義された State が部分機械 State でない場合、再定義 State は次のことが可能だ：</p>
<ul class="simple">
<li><p>再定義された状態の Regions を再定義する（複合 State の場合）</p></li>
<li><p>再定義された状態に Regions を追加する</p></li>
<li><p>再定義された状態の <code class="docutils literal notranslate"><span class="pre">connectionPoint</span></code> Pseudostate を再定義する（複合 State の場合）</p></li>
<li><p>再定義された状態に <code class="docutils literal notranslate"><span class="pre">connectionPoint</span></code> Pseudostate を追加する</p></li>
</ul>
<p>部分機械 State は、その部分機械が再定義された State の部分機械の拡張である部分機械 State によってしか再定義不可能だ。再定義 State は以下のことが可能だ：</p>
<ul class="simple">
<li><p>再定義された State の <code class="docutils literal notranslate"><span class="pre">connection</span></code> ConnectionPointReferences を再定義する。</p></li>
<li><p>再定義された State に <code class="docutils literal notranslate"><span class="pre">connection</span></code> ConnectionPointReferences を追加する。</p></li>
</ul>
<blockquote>
<div><p>A FinalState can only be redefined by a FinalState.</p>
<p>A Pseudostate can only be redefined by a Pseudostate of the same <code class="docutils literal notranslate"><span class="pre">kind</span></code>.</p>
</div></blockquote>
<p>再定義された Pseudostate がある State の <code class="docutils literal notranslate"><span class="pre">connectionPoint</span></code> として所有されている場合、再定義する Pseudostate はその再定義された Pseudostate の所有する State
の再定義の <code class="docutils literal notranslate"><span class="pre">connectionPoint</span></code> でなければならない。</p>
<blockquote>
<div><p>A ConnectionPointReference can only be redefined by a
ConnectionPointReference whose <code class="docutils literal notranslate"><span class="pre">state</span></code> is a redefinition of the state of
the redefined ConnectionPointReference.</p>
</div></blockquote>
</section>
<section id="transition-redefinition">
<h4><a class="toc-backref" href="#id49" role="doc-backlink">14.3.3.4 Transition Redefinition</a><a class="headerlink" href="#transition-redefinition" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>A Transition defined in an extension Region can redefine a Transition defined
in the extended Region of the extension Region.</p>
</div></blockquote>
<ul>
<li><p>再定義する Transition の <code class="docutils literal notranslate"><span class="pre">source</span></code> Vertex は再定義される Transition の
<code class="docutils literal notranslate"><span class="pre">source</span></code> Vertex の再定義でなければならない。</p></li>
<li><p>再定義する Transition の <code class="docutils literal notranslate"><span class="pre">target</span></code> Vertex は再定義される Transition の
<code class="docutils literal notranslate"><span class="pre">target</span></code> Vertex の再定義か、追加された Vertex のどちらかであることが可能だ。</p></li>
<li><p>再定義される Transition に適用される <code class="docutils literal notranslate"><span class="pre">triggers</span></code> は再定義する Transition にも適用され、この再定義 Transition は新しい <code class="docutils literal notranslate"><span class="pre">triggers</span></code> を追加可能だ。</p></li>
<li><p>再定義する Transition が <code class="docutils literal notranslate"><span class="pre">guard</span></code> Constraint と <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior の両方またはどちらか一方を指定する場合、それがこの再定義 Transition に適用される。</p>
<blockquote>
<div><p>However, if the redefining Transition does not specify a <code class="docutils literal notranslate"><span class="pre">guard</span></code>
Constraint and/or <code class="docutils literal notranslate"><span class="pre">effect</span></code> behavior, but there is a <code class="docutils literal notranslate"><span class="pre">guard</span></code> Constraint
and/or <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior that applies to the redefined Transition, then
the <code class="docutils literal notranslate"><span class="pre">guard</span></code> and/or <code class="docutils literal notranslate"><span class="pre">effect</span></code> from the redefined Transition also applies
to the redefining Transition.</p>
</div></blockquote>
</li>
</ul>
</section>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">14.3.4 Notation</a><a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<p>拡張 StateMachine は、その図式の名前の後にキーワード <code class="docutils literal notranslate"><span class="pre">«extended»</span></code> を付けて表示する (Fig. 14.39, 14.40)。</p>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">«extended»</span></code> は拡張 Region, 再定義 Vertex/Transition の名前の後ろに追加可能であってもよい。</p>
<p>再定義 Vertex/Transition は破線または淡い線で描かれる (Fig 14.39)。</p>
<blockquote>
<div><p>Vertices and Transitions from an <code class="docutils literal notranslate"><span class="pre">extendedStateMachine</span></code> that are <em>not</em>
redefined in an extension StateMachine may also be shown on a diagram of the
extension StateMachine drawn with either dashed or light-toned lines.</p>
</div></blockquote>
<p>Region, Vertex, Transition が <code class="docutils literal notranslate"><span class="pre">isLeaf</span></code> 値が真の場合、キーワード <code class="docutils literal notranslate"><span class="pre">«final»</span></code> を要素名の後ろに追加してもよい。</p>
</section>
<section id="id9">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">14.3.5 Examples</a><a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 14.38 A general StateMachine</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">ATM</span></code> StateMachine にある States <code class="docutils literal notranslate"><span class="pre">VerifyCard</span></code>, <code class="docutils literal notranslate"><span class="pre">OutOfService</span></code>,
<code class="docutils literal notranslate"><span class="pre">VerifyTransaction</span></code> が <code class="docutils literal notranslate"><span class="pre">«final»</span></code> として指定されている。それらが <code class="docutils literal notranslate"><span class="pre">ATM</span></code> の特殊化において再定義できないことを意味する。他の States はすべて再定義可能だ。</p>
<p>図式内下方にある Transition もまた <code class="docutils literal notranslate"><span class="pre">«final»</span></code> と指定されている。これも ATM の拡張では再定義不可能だ。</p>
<blockquote>
<div><p>Figure 14.39 An extended StateMachine</p>
</div></blockquote>
<p>上述の図式で示された複合 State <code class="docutils literal notranslate"><span class="pre">ReadAmount</span></code> を再定義し、State <code class="docutils literal notranslate"><span class="pre">EnterAmount</span></code>
を追加した拡張 <code class="docutils literal notranslate"><span class="pre">ATM</span></code> の定義だ。</p>
<p><code class="docutils literal notranslate"><span class="pre">ReadAmount</span></code> からの State <code class="docutils literal notranslate"><span class="pre">SelectedAmount</span></code> と FinalState は、新しい
Transition の <code class="docutils literal notranslate"><span class="pre">source</span></code> または <code class="docutils literal notranslate"><span class="pre">target</span></code> として機能するように再定義される。</p>
<p>State <code class="docutils literal notranslate"><span class="pre">VerifyTransaction</span></code> は新しい State <code class="docutils literal notranslate"><span class="pre">EnterAmount</span></code> を <code class="docutils literal notranslate"><span class="pre">target</span></code> とする新しい Transition の <code class="docutils literal notranslate"><span class="pre">source</span></code> として機能するように再定義される。</p>
<p>継承した状態は破線で描画されていることに注意。</p>
<blockquote>
<div><p>Figure 14.40 Adding Transitions</p>
</div></blockquote>
<p>Fig. 14.39 の StateMachine に Transitions を追加してさらに拡張した見本。</p>
</section>
</section>
<section id="protocolstatemachines">
<h2><a class="toc-backref" href="#id52" role="doc-backlink">14.4 ProtocolStateMachines</a><a class="headerlink" href="#protocolstatemachines" title="Permalink to this heading">¶</a></h2>
<section id="id10">
<h3><a class="toc-backref" href="#id53" role="doc-backlink">14.4.1 Summary</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>ProtocolStateMachines are used to express usage protocols.
ProtocolStateMachines express the legal sequences of Event occurrences to
which the Behaviors of an associated BehavioredClassifier must conform.</p>
</div></blockquote>
<p>ProtocolStateMachines は Classifiers, Interfaces, Ports に関連することが可能。</p>
</section>
<section id="id11">
<h3><a class="toc-backref" href="#id54" role="doc-backlink">14.4.2 Abstract Syntax</a><a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p>Figure 14.41 ProtocolStateMachines</p>
</div></blockquote>
<p>新クラスは ProtocolStateMachine, ProtocolConformance, ProtocolTransition のみ。グラフが分離しているのが不思議。</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">A_conformance_specificMachine</span></code>, <code class="docutils literal notranslate"><span class="pre">A_generalMachine_protocolConformance</span></code></dt><dd><p>前者は ProtocolStateMachine から ProtocolConformance への複合関連（双方向）。後者は ProtocolConformance から ProtocolStateMachine への関連（単方向）。</p>
<ul class="simple">
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">specificMachine</span></code>, <code class="docutils literal notranslate"><span class="pre">generalMachine</span></code> が <code class="docutils literal notranslate"><span class="pre">source</span></code>, <code class="docutils literal notranslate"><span class="pre">target</span></code> をそれぞれ subsets する。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_referred_protocolTransition</span></code></dt><dd><p>ProtocolTransition から Operation への関連（単方向）。</p>
<ul class="simple">
<li><p>Figure 14.42 の <code class="docutils literal notranslate"><span class="pre">m1</span></code> が <code class="docutils literal notranslate"><span class="pre">preCondition</span></code> に相当する。</p></li>
<li><p>関連端 <code class="docutils literal notranslate"><span class="pre">referred</span></code> は readOnly だ。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_preCondition_protocolTransition</span></code></dt><dd><p>ProtocolTransition から Constraint への複合関連（単方向）。</p>
<ul class="simple">
<li><p>Figure 14.42 の <code class="docutils literal notranslate"><span class="pre">C1</span></code> が <code class="docutils literal notranslate"><span class="pre">preCondition</span></code> に相当する。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A_postCondition_owningTransition</span></code></dt><dd><p>ProtocolTransition から Constraint への複合関連（単方向）。</p>
<p><code class="docutils literal notranslate"><span class="pre">A_guard_transition</span></code> の <code class="docutils literal notranslate"><span class="pre">guard</span></code> と <code class="docutils literal notranslate"><span class="pre">transition</span></code> をそれぞれ subsets,
redefines する関連。</p>
<ul class="simple">
<li><p>Figure 14.42 の <code class="docutils literal notranslate"><span class="pre">C2</span></code> が <code class="docutils literal notranslate"><span class="pre">preCondition</span></code> に相当する。</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id12">
<h3><a class="toc-backref" href="#id55" role="doc-backlink">14.4.3 Semantics</a><a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h3>
<section id="protocolstatemachine">
<h4><a class="toc-backref" href="#id56" role="doc-backlink">14.4.3.1 ProtocolStateMachine</a><a class="headerlink" href="#protocolstatemachine" title="Permalink to this heading">¶</a></h4>
<p>ProtocolStateMachine は Classifier の観点で定義される。</p>
<p>ProtocolStateMachine は Classifier のどの BehavioralFeatures を特定の作法状態で、どのような条件で呼び出すことが可能なのかを指定することで、許可される呼び出し手順を規定する。Classifier のオブジェクトの一生の仕様が外部観点から定義される。</p>
<p>ProtocolStateMachines は次を指定することで、Classifier の BehavioralFeatures を呼び出す順序を定義するのに役立つ：</p>
<ul class="simple">
<li><p>有効に呼び出し可能な挙動慣習（どの状態とどの事前条件なのか）</p></li>
<li><p>呼び出しの有効な順序</p></li>
<li><p>呼び出しの期待される効果（事後条件）</p></li>
</ul>
<blockquote>
<div><p>ProtocolStateMachine present an external view of the owning Classifier as
perceived by its collaborators.</p>
</div></blockquote>
<ul class="simple">
<li><p>これは、その遷移の駆動装置が機能呼び出しであり、遷移のガード
(ProtocolTransitions) が呼び出しが有効であるために適用されなければならない事前条件を指定する状態機械仕様によって達成される。</p></li>
<li><p>この状態機械の状態、ProtocolStates は、過去の呼び出し系列の帰結であり、慣習の状態を捉え、事前条件の一形態でもある。</p></li>
</ul>
<p>注：ProtocolStateMachines は Classifier の挙動の “black box” ビューを与えるものなので、その States は内部動作 StateMachines の States と必ずしも対応しなくてもよい。</p>
<p>ProtocolStateMachine の解釈はいろいろある：</p>
<ol class="arabic">
<li><p>宣言的 ProtocolStateMachines</p>
<p>BehavioralFeatures 呼び出す際の合法的な Transitions を指定する。</p>
<ul class="simple">
<li><p>BehaviorFeature 呼び出しの効果は指定されない。</p></li>
<li><p>仕様のこの型は context Classifier の利用者に契約を設けるだけだ。</p></li>
</ul>
</li>
<li><p>実行可能 ProtocolStateMachines</p>
<p>あるオブジェクトが受信かつ処理することある Event 発生すべてと、それらが引き起こす Transitions を指定する。</p>
<ul class="simple">
<li><p>Behavior 呼び出しに合法な Transitions は引き起こされる Transitions と厳密に合致しなければならない。</p></li>
<li><p>この呼び出しの結果、呼び出された BehaviorFeatures に関連するメソッドを実行する。</p></li>
</ul>
</li>
</ol>
<p>両者の解釈とも仕様は同じであり、唯一の違いは後者の解釈が規定する直接の動的な意味合いだ。</p>
<blockquote>
<div><p>The more sophisticated forms of modeling encountered in behavioral
StateMachines such as compound Transitions, submachine StateMachines,
composite States, and concurrent orthogonal Regions, can also be used for
ProtocolStateMachines.</p>
</div></blockquote>
<ul class="simple">
<li><p>例えば同時 Regions はオブジェクトが同時に作動中 States を複数持つことが可能なな作法を表現することを可能にする。</p></li>
<li><p>部分機械 StateMachines と混合遷移を複雑な ProtocolStateMachines の「因数分解」に用いることが可能だ。</p></li>
</ul>
<blockquote>
<div><p>A Classifier may have several ProtocolStateMachines. This can be used, for
example, when a Classifier has multiple parents, each having its own
ProtocolStateMachine, and the protocols are orthogonal.</p>
</div></blockquote>
<p>この代替は、単純に ProtocolStateMachine を一つ持ち、同時 Regions に別々の
StateMachines を持つことだ。</p>
<blockquote>
<div><p>The States of ProtocolStateMachines are exposed to the users of their context
Classifiers.</p>
</div></blockquote>
<p>慣習 State はその context Classifier の exposed 安定状況を表す。つまり
Classifier <code class="docutils literal notranslate"><span class="pre">classifier</span></code> が BehaviorFeature 呼び出しを処理していないとき、このオブジェクトの利用者はその状態構成を知ることが常時可能だ。</p>
<blockquote>
<div><p>The States of a ProtocolStateMachine cannot have defined <code class="docutils literal notranslate"><span class="pre">entry</span></code>, <code class="docutils literal notranslate"><span class="pre">exit</span></code>,
or <code class="docutils literal notranslate"><span class="pre">doActivity</span></code> Behaviors.</p>
</div></blockquote>
</section>
<section id="protocoltransition">
<h4><a class="toc-backref" href="#id57" role="doc-backlink">14.4.3.2 ProtocolTransition</a><a class="headerlink" href="#protocoltransition" title="Permalink to this heading">¶</a></h4>
<p>ProtocolTransition は context Classifier の BehavioralFeature を呼び出すための法定 Transition を指定する。</p>
<blockquote>
<div><p>ProtocolTransitions have the following features:</p>
<ul class="simple">
<li><p>a pre-condition (<code class="docutils literal notranslate"><span class="pre">preCondition</span></code>), which specializes the <code class="docutils literal notranslate"><span class="pre">guard</span></code>
attribute of Transition,</p></li>
<li><p>a trigger,</p></li>
<li><p>a post-condition (<code class="docutils literal notranslate"><span class="pre">postCondition</span></code>).</p></li>
</ul>
</div></blockquote>
<p>慣習 Transition は次のことを指定する：</p>
<ul class="simple">
<li><p>関連（参照）される機能は呼び出し可能であるのは、context Classifier のオブジェクトが``origin`` State であり、ガード条件が成り立つ場合だ。</p></li>
<li><p>Transition が完了すると、そのオブジェクトは事後条件が成り立つ <code class="docutils literal notranslate"><span class="pre">target</span></code> State
になる。</p></li>
</ul>
<blockquote>
<div><p>ProtocolTransitions do not have an associated <code class="docutils literal notranslate"><span class="pre">effect</span></code> Behavior.</p>
</div></blockquote>
<p>BehavioralFeature 呼び出しの結果として実行される ProtocolTransition の結末は暗黙に了解され、呼び出された BehavioralFeature に対応するメソッドの実行だ。</p>
<blockquote>
<div><p>In case of other types of Triggers, the consequences are unspecified except
that a Transition will lead to another State under a specific post-condition,
regardless of any Behaviors associated with this Transition.</p>
</div></blockquote>
<section id="unexpected-trigger-reception">
<h5>14.4.3.2.1 Unexpected trigger reception<a class="headerlink" href="#unexpected-trigger-reception" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>The interpretation of the reception of an Event occurrence that does not
match a valid trigger for the current State, state invariant, or
pre-condition is not defined</p>
</div></blockquote>
<p>定義されていないので、無視、拒否、遅延、例外送出、アプリケーション停止なども可能。</p>
<p>意味論上は事前条件違反に相当し、UML では事前定義された Behavior は定義されていない。</p>
</section>
<section id="unexpected-behavior">
<h5>14.4.3.2.2 Unexpected Behavior<a class="headerlink" href="#unexpected-behavior" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p>The interpretation of an unexpected Behavior, that is an unexpected result of
a Transition (wrong FinalState or FinalState invariant, or post-condition) is
also not defined.</p>
</div></blockquote>
<p>しかし、これを ProtocolStateMachine の実装の誤りとしてなるべく解釈する。</p>
</section>
<section id="equivalences-to-pre-and-post-conditions-of-operations">
<h5>14.4.3.2.3 Equivalences to pre- and post-conditions of operations<a class="headerlink" href="#equivalences-to-pre-and-post-conditions-of-operations" title="Permalink to this heading">¶</a></h5>
<p>ProtocolTransition は付随する操作の事前条件と事後条件で意味上は解釈できる。</p>
<blockquote>
<div><p>Figure 14.42 An example of a ProtocolTransition associated with the operation
“m1”</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">[C1]m1/[c2]</span></code> の読み方を習得すること。状態 <code class="docutils literal notranslate"><span class="pre">S1</span></code> において条件 <code class="docutils literal notranslate"><span class="pre">C1</span></code> が成立しているときに操作 <code class="docutils literal notranslate"><span class="pre">m1</span></code> が呼びだされ、状態 <code class="docutils literal notranslate"><span class="pre">S2</span></code> に到達したときには条件
<code class="docutils literal notranslate"><span class="pre">C2</span></code> が成立している。</p>
<blockquote>
<div><p>Figure 14.43 Example of several ProtocolTransitions (…)</p>
</div></blockquote>
<p>ProtocolStateMachine では複数の Transitions が同じ操作 (e.g. Fig 14.43 <code class="docutils literal notranslate"><span class="pre">m1</span></code>)
を参照することが可能だ。その場合、事前条件と事後条件はすべて以下のように操作の事前条件に組み合わされる：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Operation m1()
Pre:  in state S1 and condition C1
      or
      in state S3 and condition C3
Post: if the initial condition was “in state S1 and condition C1”
          then in S2 and C2
      else
      if the initial condition was “in state S3 and condition C3”
          then in S4 and C4
</pre></div>
</div>
<p>ProtocolStateMachine はその Transitions により参照される BehavioralFeature それぞれに対して法定 ProtocolTransition すべてを指定する。</p>
<p>Unreferred Operations:</p>
<blockquote>
<div><p>If a BehavioralFeature is not referred by any ProtocolTransition, then the
operation can be called for any State of the ProtocolStateMachine, and will
not change the current State or pre- and post-conditions.</p>
</div></blockquote>
</section>
<section id="using-other-types-of-events-in-protocolstatemachines">
<h5>14.4.3.2.4 Using other types of Events in ProtocolStateMachines<a class="headerlink" href="#using-other-types-of-events-in-protocolstatemachines" title="Permalink to this heading">¶</a></h5>
<p>BehavioralFeature の呼び出しとは別に、他の Events は ProtocolStateMachines の挙動を表現することがある。</p>
<p>BehavioralFeature 呼び出しでない Trigger を慣習 Transition に指定することが可能だ。</p>
<blockquote>
<div><p>In that case, this specification is a requirement for the environment
external to the ProtocolStateMachine. That is, it is legal to send an Event
occurrence of this type to an instance of the context Classifier only under
the conditions specified by the ProtocolStateMachine.</p>
</div></blockquote>
<p>正確な意味解釈は定義されていない。</p>
</section>
</section>
<section id="protocolconformance">
<h4><a class="toc-backref" href="#id58" role="doc-backlink">14.4.3.3 ProtocolConformance</a><a class="headerlink" href="#protocolconformance" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>ProtocolStateMachines can be refined into more specific
ProtocolStateMachines. Protocol conformance declares that the specific
ProtocolStateMachine specifies a protocol that conforms to that specified by
the general ProtocolStateMachine.</p>
</div></blockquote>
<p>ProtocolStateMachine は Classifier が所有する。総体的な StateMachine と関連される具体的な StateMachine を所有する Classifiers は、通常、Generalization または
Realization によって接続もされる。</p>
<p>作法適合性は総体的 ProtocolStateMachine に対して指定された規則と制約（状態不変、操作の事前条件、事後条件）のすべてが、その具体的 ProtocolStateMachine に適用されるという宣言を表す。</p>
</section>
</section>
<section id="id13">
<h3><a class="toc-backref" href="#id59" role="doc-backlink">14.4.4 Notation</a><a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h3>
<p>この節は Examples も兼ねているようだ。</p>
<section id="id14">
<h4><a class="toc-backref" href="#id60" role="doc-backlink">14.4.4.1 ProtocolStateMachine</a><a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h4>
<p>ProtocolStateMachine を表す表記法は挙動 StateMachines についてのそれとたいへん似ている。StateMachine の名前の近くに置かれたキーワード <code class="docutils literal notranslate"><span class="pre">«protocol»</span></code> が
ProtocolStateMachine 図を図表的に差別化する。</p>
<blockquote>
<div><p>Figure 14.44 ProtocolStateMachine example</p>
</div></blockquote>
<p>戸外が無人になれば扉は閉められる。</p>
<blockquote>
<div><p>Figure 14.45 Notation for a State with an invariant</p>
</div></blockquote>
<p>ProtocolStateMachine の State に付随する不変式のテキスト表現は、その State の名前の後ろまたは下に配置することで表され、角括弧で括られる。</p>
</section>
<section id="id15">
<h4><a class="toc-backref" href="#id61" role="doc-backlink">14.4.4.2 ProtocolTransition</a><a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h4>
<p>通常の StateMachine 表記法を適用する。違いは ProtocolTransitions について
<code class="docutils literal notranslate"><span class="pre">effect</span></code> Behaviors が指定されていないことと、事後条件が存在可能であることだ。後者はガード条件と同じ構文。Transition 構文の最後に現れる。</p>
<blockquote>
<div><p>Figure 14.46 ProtocolTransition notation</p>
</div></blockquote>
<p>スラッシュの後にガード条件と同じ記法で事後条件を記すことがある。</p>
</section>
</section>
</section>
<section id="classifier-descriptions">
<h2><a class="toc-backref" href="#id62" role="doc-backlink">14.5 Classifier Descriptions</a><a class="headerlink" href="#classifier-descriptions" title="Permalink to this heading">¶</a></h2>
<p>機械生成による節。</p>
</section>
<section id="association-descriptions">
<h2><a class="toc-backref" href="#id63" role="doc-backlink">14.6 Association Descriptions</a><a class="headerlink" href="#association-descriptions" title="Permalink to this heading">¶</a></h2>
<p>機械生成による節。</p>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="ch13-common-behavior.html" title="Previous document">13 Common Behavior</a>
        </li>
        <li>
          <a href="ch15-activities.html" title="Next document">15 Activities</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">図書・教科書・仕様書ノート</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ou23/index.html">Modern C++ Tutorial: C++ 11/14/17/20 On the Fly 読書ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ノートにまとまっていない書籍類一覧</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">シェルノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v5.html">What’s New In Bash 5 ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">C++ ノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python ノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../youtube-dl.html">youtube-dl 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ソフトウェア・ツール・パッケージ・ライブラリーノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../google-ime.html">Google 日本語入力利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wslg.html">Windows Subsystem for Linux GUI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oh-my-posh.html">Oh My Posh 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ffmpeg/index.html">FFmpeg 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zoom.html">Zoom Cloud Meetings 利用ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">その他</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">テーマ別</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../javascript.html">JavaScript 総合</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Unified Modeling Language 2.5 読書ノート</a><ul>
      <li>Previous: <a href="ch13-common-behavior.html" title="previous chapter">13 Common Behavior</a></li>
      <li>Next: <a href="ch15-activities.html" title="next chapter">15 Activities</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2023, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>