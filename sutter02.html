<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>More Exceptional C++ 読書ノート &mdash; 読書ノート v1.3.0</title>
    
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/twitter-button.js"></script>
    <link rel="top" title="読書ノート v1.3.0" href="index.html" />
    <link rel="next" title="Joel on Software 読書ノート" href="joel04.html" />
    <link rel="prev" title="Effective STL 読書ノート" href="meyers01.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート v1.3.0</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="more-exceptional-c">
<h1><a class="toc-backref" href="#id35">More Exceptional C++ 読書ノート</a><a class="headerlink" href="#more-exceptional-c" title="Permalink to this headline">¶</a></h1>
<p>2009 年の正月だったと思う。
かの名著 Exceptional C++ の続編を秋葉原駅前ヨドバシの有隣堂書店で発見した。
前作が「本物」であったがゆえに、本書も購入してみたのだが───。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Herb Sutter</td>
</tr>
<tr class="field-even field"><th class="field-name">訳者:</th><td class="field-body">浜田真理</td>
</tr>
<tr class="field-odd field"><th class="field-name">出版社:</th><td class="field-body">ピアソン・エデュケーション</td>
</tr>
<tr class="field-even field"><th class="field-name">ISBN:</th><td class="field-body">978-4-89471-483-0</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#more-exceptional-c" id="id35">More Exceptional C++ 読書ノート</a><ul>
<li><a class="reference internal" href="#id2" id="id36">序章</a></li>
<li><a class="reference internal" href="#c" id="id37">汎用プログラミングと C++ 標準ライブラリ</a><ul>
<li><a class="reference internal" href="#id3" id="id38">ストリームの操作</a></li>
<li><a class="reference internal" href="#id4" id="id39">ステートフル述語</a></li>
<li><a class="reference internal" href="#traits" id="id40">継承と特性 (traits)</a></li>
<li><a class="reference internal" href="#id5" id="id41">コンテナではないコンテナ</a></li>
<li><a class="reference internal" href="#vector-deque" id="id42">vector と deque</a></li>
<li><a class="reference internal" href="#set-map" id="id43">set と map</a></li>
<li><a class="reference internal" href="#id6" id="id44">等価なコード？</a></li>
<li><a class="reference internal" href="#id7" id="id45">テンプレートの特殊化とオーバーロード</a></li>
<li><a class="reference internal" href="#id8" id="id46">マスターマインドゲーム</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9" id="id47">最適化と効率</a><ul>
<li><a class="reference internal" href="#inline" id="id48">inline</a></li>
<li><a class="reference internal" href="#part-1" id="id49">遅延最適化 Part 1</a></li>
<li><a class="reference internal" href="#part-2" id="id50">遅延最適化 Part 2</a></li>
<li><a class="reference internal" href="#part-3" id="id51">遅延最適化 Part 3</a></li>
<li><a class="reference internal" href="#part-4" id="id52">遅延最適化 Part 4</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10" id="id53">例外安全問題とテクニック</a><ul>
<li><a class="reference internal" href="#id11" id="id54">コンストラクタの失敗 Part 1</a></li>
<li><a class="reference internal" href="#id12" id="id55">コンストラクタの失敗 Part 2</a></li>
<li><a class="reference internal" href="#id13" id="id56">捕捉されない例外</a></li>
<li><a class="reference internal" href="#id14" id="id57">管理されていないポインタに関する問題 Part 1</a></li>
<li><a class="reference internal" href="#id15" id="id58">管理されていないポインタに関する問題 Part 2</a></li>
<li><a class="reference internal" href="#id16" id="id59">例外安全なクラス設計 Part 1</a></li>
<li><a class="reference internal" href="#id17" id="id60">例外安全なクラス設計 Part 2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18" id="id61">継承とポリモルフィズム</a><ul>
<li><a class="reference internal" href="#id19" id="id62">多重継承を使う理由とは何か？</a></li>
<li><a class="reference internal" href="#id20" id="id63">多重継承と「シャム双生児」関数</a></li>
<li><a class="reference internal" href="#id21" id="id64">純粋仮想関数と非純粋仮想関数</a></li>
<li><a class="reference internal" href="#id22" id="id65">ポリモルフィズムの制御</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id23" id="id66">メモリとリソースの管理</a><ul>
<li><a class="reference internal" href="#auto-ptr" id="id67">auto_ptr の使用</a></li>
<li><a class="reference internal" href="#id24" id="id68">クラスメンバとしてのスマートポインタ Part 1</a></li>
<li><a class="reference internal" href="#id25" id="id69">クラスメンバとしてのスマートポインタ Part 2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id26" id="id70">フリー関数とマクロ</a><ul>
<li><a class="reference internal" href="#id27" id="id71">再帰宣言</a></li>
<li><a class="reference internal" href="#id28" id="id72">ネスト関数のシミュレート</a></li>
<li><a class="reference internal" href="#id29" id="id73">プリプロセッサマクロ</a></li>
<li><a class="reference internal" href="#define" id="id74">#define</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id30" id="id75">各種トピック</a><ul>
<li><a class="reference internal" href="#id31" id="id76">初期化</a></li>
<li><a class="reference internal" href="#id32" id="id77">先行宣言</a></li>
<li><a class="reference internal" href="#typedef" id="id78">typedef</a></li>
<li><a class="reference internal" href="#id33" id="id79">名前空間 Part 2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id34" id="id80">あとがき以降のノート</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id36">序章</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>&lt;古代ギリシャの哲学者ソクラテスは、問答によって弟子に伝授した&gt;
→ソクラテスメソッド</li>
<li>&lt;標準 C++ と標準ライブラリの効果的な利用方法&gt;</li>
<li>&lt;合理的根拠&gt;</li>
<li>本書は &lt;標準ライブラリの効果的な使用方法に重点を置いている&gt; と繰り返す。</li>
<li>読者に求める前提条件として、&lt;古典的な名著&gt; である
Bjarne Stroustrup, &#8220;The C++ Programming Language&#8221; やら
Stan Lippman and Josée Lajoie, &#8220;C++ Primer&#8221; を挙げている。
これらの本は分厚くて、まともに読みこなせなかったことを思い出した。</li>
<li>&lt;特に、私の管理下にないものは移動する。&gt;</li>
<li>&lt;インターネット社会における印刷メディアの過酷な状況&gt;</li>
<li>著者は本書レビュアーに対して
&lt;酷評を惜しみなく浴びせてくださいました&gt; と礼を述べている。</li>
</ul>
</div>
<div class="section" id="c">
<h2><a class="toc-backref" href="#id37">汎用プログラミングと C++ 標準ライブラリ</a><a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h2>
<p>前作にも同じテーマの章があった。</p>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id38">ストリームの操作</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">basic_ostream</span></tt> が、 <tt class="docutils literal"><span class="pre">basic_streambuf</span></tt> オブジェクトを入力として受け付ける
<tt class="docutils literal"><span class="pre">operator&lt;&lt;()</span></tt> を提供&gt; (p. 3) しているので、ここでの回答である
<tt class="docutils literal"><span class="pre">cout</span> <span class="pre">&lt;&lt;</span> <span class="pre">cin.rdbuf()</span></tt> の形を着想できる。</li>
<li><tt class="docutils literal"><span class="pre">is_open()</span></tt> はこういう形でないと使わないな。</li>
<li>&lt;均衡のとれた判断&gt; &lt;適切な妥協点&gt; (p. 5)</li>
<li>&lt;拡張性を考慮した設計がしばしばカプセル化を意味している&gt; (p. 6)</li>
<li>&lt;関連性の分離を適切に行う&gt; (p. 6)</li>
</ul>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id39">ステートフル述語</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;一般に「ステートフル」であると言えば、変更可能な状態のことを意味する。
したがって、ステートフル述語においては適用過程の順が重要になる&gt; (p. 14)</li>
<li>&lt;ステートフル述語とそれ以外の述語には重要な相違点がある&gt; (p. 15)
と切り出して、ステートフル述語のコピーがオリジナルと等価とならないものと、
適用順が不定の実装であるような <tt class="docutils literal"><span class="pre">remove_if</span></tt> についての思考実験を始める。
それで標準アルゴリズムの要件が厳密には足りていないよ、と著者は指摘したい。</li>
</ul>
</div>
<div class="section" id="traits">
<h3><a class="toc-backref" href="#id40">継承と特性 (traits)</a><a class="headerlink" href="#traits" title="Permalink to this headline">¶</a></h3>
<p>クラステンプレート <tt class="docutils literal"><span class="pre">traits</span></tt> について。</p>
<ul class="simple">
<li>テンプレートの特殊化がキモ。</li>
<li><tt class="docutils literal"><span class="pre">std::char_traits&lt;T&gt;</span></tt></li>
<li>[C++98] 17.1.18</li>
<li>Requirements - 制約クラス</li>
<li>&lt;<tt class="docutils literal"><span class="pre">B</span></tt> の意味がわからない限り、 <tt class="docutils literal"><span class="pre">instantiated_type</span></tt> についてもわからない&gt; (p. 35)</li>
<li>&lt;空の基底クラス <tt class="docutils literal"><span class="pre">X_base</span></tt> は、 <tt class="docutils literal"><span class="pre">typedef</span></tt> を提供するためだけに存在している。
しかしながら、通常、派生クラスはそれを再度 <tt class="docutils literal"><span class="pre">typedef</span></tt> し直す。
無駄ではないだろうか？&gt; (p. 36)</li>
<li>追記のコードをコンパイルしたいが、手許に環境がない。残念。</li>
</ul>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id41">コンテナではないコンテナ</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">スタニスラウって誰だ。</p>
</li>
<li><p class="first">&lt;ポインタが無効化される時期にさえ注意すれば安全だ。
それはまた、イテレータが無効化される時期でもある&gt; (p. 39)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">map&lt;Name,</span> <span class="pre">PhoneNumber&gt;</span></tt> の逆方向検索マップが
<tt class="docutils literal"><span class="pre">map&lt;PhoneNumber*,</span> <span class="pre">Name*,</span> <span class="pre">Deref&gt;</span></tt> になるのが面白い。</p>
</li>
<li><p class="first">某書にもあるが &lt;<tt class="docutils literal"><span class="pre">std::vector&lt;bool&gt;</span></tt> はその「どんなコンテナ」に含まれない&gt; (p. 41)</p>
</li>
<li><p class="first">&lt;「プロキシコンテナ」とは、オブジェクトに対する直接的なアクセスや操作ができないコンテナのことである&gt; (p. 42)</p>
</li>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">vector&lt;bool&gt;</span></tt> のアクセスは遅い&gt; (p. 43)</p>
</li>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">vector&lt;bool&gt;</span></tt> は、プロキシコンテナの実装例を示すことが目的の一部であり、
ディスクベースのコンテナや、直接的なアクセスが難しいオブジェクトのコンテナを実装する際の手本にもなるはずだった。
だが同時に、標準コンテナの要求によってプロキシコンテナが許されないという実例にもなってしまったのだ&gt; (p. 44)</p>
</li>
<li><p class="first">&lt;プロファイラや他のテストを実施しておけば、
その最適化が本当に改善となるかどうかわかる&gt; (p. 45) →実測が基本。</p>
</li>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">vector&lt;bool&gt;</span></tt> の代わりに（略）
<tt class="docutils literal"><span class="pre">deque&lt;bool&gt;</span></tt> を使う方が良い&gt; (p. 46)</p>
</li>
<li><p class="first">もう一回ノートしておこう。&lt;実測上の証拠を握るまで&gt; (p. 47) 最適化はしない。</p>
</li>
</ul>
</div>
<div class="section" id="vector-deque">
<h3><a class="toc-backref" href="#id42">vector と deque</a><a class="headerlink" href="#vector-deque" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>配列でなく <tt class="docutils literal"><span class="pre">vector</span></tt> を利用する理由は
&lt;コンテナの抽象化やカプセル化という点において配列よりも優れており、
簡単かつ安全に利用できるから&gt; (p. 48)</li>
<li>&lt;コンテナ自体とサイズを別々に管理する必要がない&gt; (p. 49)</li>
<li>配列と <tt class="docutils literal"><span class="pre">vector</span></tt> の交換可能性については
&lt;現在、標準は、 <tt class="docutils literal"><span class="pre">vector</span></tt> の要素が配列と同じフォーマットで連続に格納されることを要求している&gt; (p. 50)
ので、安心してレガシーコードに <tt class="docutils literal"><span class="pre">&amp;v[0]</span></tt> を渡せる。</li>
<li>&lt;実のところ、これらの関数を持つことが <tt class="docutils literal"><span class="pre">vector</span></tt> の欠点なのである&gt; (p. 50) という指摘は面白い。
&lt;これらの関数&gt; というのは <tt class="docutils literal"><span class="pre">capacity</span></tt> と <tt class="docutils literal"><span class="pre">reserve</span></tt> のことだが。</li>
<li>今となってはおなじみの、消費メモリ削減テク「一時オブジェクトと <tt class="docutils literal"><span class="pre">swap</span></tt> イディオム」を紹介している。</li>
</ul>
</div>
<div class="section" id="set-map">
<h3><a class="toc-backref" href="#id43">set と map</a><a class="headerlink" href="#set-map" title="Permalink to this headline">¶</a></h3>
<p>何に役立てるのかはわからないが、既存 <tt class="docutils literal"><span class="pre">map</span></tt> オブジェクトのキー、
すなわち <tt class="docutils literal"><span class="pre">map::iterator</span></tt> の <tt class="docutils literal"><span class="pre">first</span></tt> メンバーを無理やり書き換える方法を議論する。</p>
<ul class="simple">
<li>&lt;キーの比較には、必ず引数の Compare 型が使われる&gt; (p. 55)</li>
<li>&lt;問題となるのは、コンテナに挿入済みのキーの相対順を変更するコードだ&gt; (p. 57)</li>
</ul>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id44">等価なコード？</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> が関数型マクロならば &lt;ステートメント <tt class="docutils literal"><span class="pre">f(a++)</span></tt> はどのような意味にもなり得る&gt; (p. 62)
<tt class="docutils literal"><span class="pre">#define</span> <span class="pre">f(x)</span> <span class="pre">(x,x,x,x,x,x,x,x,x)</span></tt> の例を出して説得力を補強。
C++ ではマクロの仕様は可能な限り避ける。</li>
<li>&lt;「無効なイテレータの使用」のバグは非常に見つけにくいからだ
（チェックバージョンのライブラリ実装でデバッグするのが好きならば、話は別だが）&gt; (p. 65)
チェックバージョンは動作が当然遅いので、
プロジェクト内容によってはオプションをオフにしている場合すらある。</li>
</ul>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id45">テンプレートの特殊化とオーバーロード</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>個人的にテンプレートの特殊化は興味がないので読み飛ばす。
それにしても、本項目オチの一文が強烈な皮肉だ。</p>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id46">マスターマインドゲーム</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;厳格かつ健全なソフトウェアエンジニアリングが本書の目的である&gt; (p. 72) が、ここで羽目を外す。
&lt;ステートメントの区切り子としてセミコロンの代わりにカンマを可能な限り使うことにした&gt; (p. 73)
やら &lt;if/else の代わりに 3 項演算子 (?:) を使うことにした&gt; (p. 73) などやりたい放題。</li>
<li>&lt;<tt class="docutils literal"><span class="pre">inner_product()</span></tt> という名前がまだ気になるならば、
この標準アルゴリズムを <tt class="docutils literal"><span class="pre">accumulate()</span></tt> と <tt class="docutils literal"><span class="pre">transform()</span></tt> の合成だと考えればよい&gt; (p. 81)</li>
<li>&lt;実社会の商用コードではめったに使わないカンマ演算子&gt; (p. 84)</li>
</ul>
</div>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id47">最適化と効率</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<div class="section" id="inline">
<h3><a class="toc-backref" href="#id48">inline</a><a class="headerlink" href="#inline" title="Permalink to this headline">¶</a></h3>
<p>個人的には <tt class="docutils literal"><span class="pre">inline</span></tt> は最近本当に使わなくなった。コンパイラーに任せた方が利口だもの。</p>
<ul class="simple">
<li>&lt;そもそも何を最適化したいのか定義せずに答えようとしても意味がない&gt; (p. 88)
と切り出し、候補対象を列挙していく。
個人的には開発速度とビルド時間を優先したいところだ。</li>
<li>ここでも実測主義が全面に出る。この姿勢は本書中で一貫していて気持ちがいい。
&lt;通常、実測に基づいた証拠だけが真のホットスポットを言い当てることができる&gt; (p. 90)</li>
<li>&lt;このような場合でも、やはりプロファイラを使い、
そのアドバイスにしたがって最適化を行うべきである&gt; (p. 90)</li>
<li>最後に &lt;インラインコードはモジュール間の結合を強める&gt; (p. 90)
と締めくくり、読者にあてずっぽな <tt class="docutils literal"><span class="pre">inline</span></tt> の使用を戒めることを忘れない。</li>
</ul>
</div>
<div class="section" id="part-1">
<h3><a class="toc-backref" href="#id49">遅延最適化 Part 1</a><a class="headerlink" href="#part-1" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;一般に、最高のパフォーマンスを示す方法は指数拡張である&gt; (p. 94)</li>
<li>&lt;Koenig は、指数拡張における最良の指数が一般に 2 ではない理由を説明している&gt; (p. 94)</li>
</ul>
</div>
<div class="section" id="part-2">
<h3><a class="toc-backref" href="#id50">遅延最適化 Part 2</a><a class="headerlink" href="#part-2" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;コピー処理を後回しにするため、
<tt class="docutils literal"><span class="pre">String</span></tt> オブジェクト内部でバッファを共有させよう&gt; (p. 95)
<tt class="docutils literal"><span class="pre">String</span></tt> クラスを <tt class="docutils literal"><span class="pre">String</span></tt> と <tt class="docutils literal"><span class="pre">StringBuf</span></tt> に分離して、
後者をコピー不可能なクラスとして、
<tt class="docutils literal"><span class="pre">String</span></tt> オブジェクト同士で共有する作戦らしい。</li>
<li>「参照回数」は <tt class="docutils literal"><span class="pre">StringBuf</span></tt> の内部にあるが、これを更新するのは <tt class="docutils literal"><span class="pre">String</span></tt> のメンバー。</li>
<li>遅延コピーを実装するので、コピーコンストラクターは「浅いコピー」になる。</li>
<li>&lt;<tt class="docutils literal"><span class="pre">AboutToModify()</span></tt> は、まだ実行していなければ「深い」コピーを遅延実行して、
内部バッファの非共有を保証する&gt; (p. 97)</li>
</ul>
</div>
<div class="section" id="part-3">
<h3><a class="toc-backref" href="#id51">遅延最適化 Part 3</a><a class="headerlink" href="#part-3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">operator[]()</span></tt> はそれほど簡単ではない&gt; (p. 100)
&lt;少なくとも、内部表現が共有されていないことを保証する必要がある&gt; (p. 101)
どんどん話が複雑になってきて、&lt;シングルスレッド環境ならば、
まあ、こんなところだろう&gt; (p. 105) と不吉な伏線を張る。</li>
</ul>
</div>
<div class="section" id="part-4">
<h3><a class="toc-backref" href="#id52">遅延最適化 Part 4</a><a class="headerlink" href="#part-4" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">AboutToModify</span></tt> の最初の if 文の条件式がスレッドセーフではないことに気付けないとダメか。</li>
<li>脚注にいいことが書いてある。
Win32 では効率の点から &lt;できる限りクリティカルセクションを利用すべき&gt; (p. 111) だそうだ。</li>
<li>&lt;「深いコピー」の間、ずっとロックを取得していることに注意しよう&gt; (p. 113)
例示のためにちょっと手抜きをしているようだ。</li>
<li>&lt;ロックが必要な操作は <tt class="docutils literal"><span class="pre">refs</span></tt> へのアクセスだけである、ということに注意しよう&gt; (p. 114)</li>
</ul>
</div>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id53">例外安全問題とテクニック</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>&lt;C++ 標準ライブラリを使うのであれば、例外に備える必要がある&gt; (p. 119)</p>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id54">コンストラクタの失敗 Part 1</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>オブジェクトの生存期間の開始時点は、コンストラクタが（正常に） <strong>終了した瞬間</strong> と考える。
また、生存期間の終了時点は、デストラクタが <strong>開始した</strong> 瞬間と考える。</li>
<li>コンストラクタが例外を投げて終了する場合、オブジェクトが存在した事実がないと考える。
&lt;コンストラクタが成功しなかったときにデストラクタが呼ばれない&gt; (p. 123) のだ。</li>
</ul>
</div>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id55">コンストラクタの失敗 Part 2</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;要するに、コンストラクタやデストラクタの関数 try ブロックのハンドラは、
何らかの例外を投げて終了しなければならない、ということだ&gt; (p. 124)</li>
<li>&lt;これまで私は、例外に対して愛情と憎しみの環境を繰り返し抱いてきた&gt; (p. 125)</li>
<li>関数 try ブロックのハンドラに一旦入ると、
コンストラクタ内のローカル変数はスコープから外れ、
（非 static な）メンバオブジェクトは既に存在しない。</li>
<li>標準 C++ の 15.3 paragraph 10 を読んでおくこと。</li>
<li>最大の結論は &lt;他の関数 try ブロックにはどれも実用的な使い道がない&gt; (p. 128) だろう。</li>
<li>非管理リソースの獲得は &lt;決して初期化リストで行ってはならない&gt; (p. 128)
RAII ルールの対偶とでも言うべきか。</li>
<li>&lt;コンストラクタの例外は伝播させなければならない&gt; (p. 129)</li>
</ul>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id56">捕捉されない例外</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">uncaught_exception()</span></tt> の議論だが、ここは読みとばす。</p>
<ul class="simple">
<li>&lt;標準関数 <tt class="docutils literal"><span class="pre">uncaught_exception()</span></tt> は、
「現在アクティブな例外が存在するか」を知る手段である&gt; (p. 132)</li>
</ul>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id57">管理されていないポインタに関する問題 Part 1</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f(g(expr1),</span> <span class="pre">h(expr2))</span></tt> のような処理シーケンスがあるとする。
直感的に <tt class="docutils literal"><span class="pre">g</span></tt>, <tt class="docutils literal"><span class="pre">h</span></tt>, <tt class="docutils literal"><span class="pre">expr1</span></tt>, <tt class="docutils literal"><span class="pre">expr2</span></tt>
のいずれかがリソース確保系統の処理であってはまずいと考えられる。</li>
<li><tt class="docutils literal"><span class="pre">new</span></tt> でオブジェクトを生成しようとして例外によって失敗したときに、
確保済みのメモリは解放されるらしい。</li>
</ul>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id58">管理されていないポインタに関する問題 Part 2</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;明示的なリソース確保は、独立した式で行うこと&gt; (p. 145)</li>
</ul>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id59">例外安全なクラス設計 Part 1</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>「Abrahams の保証」なる名前がついているようだ。</p>
<blockquote>
<div><dl class="docutils">
<dt>基本保証</dt>
<dd>例外が投げられたとしても、リソースリークは起こらない。</dd>
<dt>強い保証</dt>
<dd>例外が投げられたとしても、プログラムの状態は変更されない
（コミットとロールバック）。</dd>
<dt>nothrow 保証</dt>
<dd>例外を投げない。</dd>
</dl>
</div></blockquote>
<ul class="simple">
<li>PIMPL 版 (p. 152) スワップは一見の価値あり。</li>
<li>プログラム全体の状態不変性を保証するのは明らかに厳しい。
「ローカルな強い保証」という考え方で折り合いをつけるのが現実的。</li>
</ul>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id60">例外安全なクラス設計 Part 2</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>クラスとクラスの間の関係について、関係を分類してそれらの性質を検討していく。</p>
<ul class="simple">
<li>&lt;「何らかの形で～を使う」という記述には、大きな自由度が残されている。
<tt class="docutils literal"><span class="pre">T</span></tt> が <tt class="docutils literal"><span class="pre">U</span></tt> のアダプタ、プロキシ、ラッパー、あるいは <tt class="docutils literal"><span class="pre">T</span></tt> 自身の機能を実装するため、
たまたま <tt class="docutils literal"><span class="pre">U</span></tt> を使っているだけの場合まで、広範囲に適用されるからだ&gt; (p. 157)</li>
<li>&lt;経験を積んだ開発者でさえ、継承を使いすぎる傾向がある&gt; (p. 157)
とにかく結合を弱めることに努めること。</li>
<li>脚注も見落とせない。
&lt;クラス <tt class="docutils literal"><span class="pre">X</span></tt> と最強の関係を持つのは friend である&gt; (p. 158)</li>
<li>まとめ (p. 160) は 10 回くらい暗唱するといい。</li>
</ul>
</div>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id61">継承とポリモルフィズム</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id19">
<h3><a class="toc-backref" href="#id62">多重継承を使う理由とは何か？</a><a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>個人的に多重継承とは理解するのがすごく面倒なものだという印象を持っているが、
本項目を読んでも、やはり敬遠したいシステムだという気持ちが拭えない。</p>
<ul>
<li><p class="first">ABC: Abstract Base Class - メンバ変数を持たず、
純粋仮想関数だけから構成された基本クラスのこと。
複数の ABC から多重継承するぶんには構わない。</p>
<p>&lt;面白いことに、継承の機構を持たない言語やモデルが、
この種の多重継承をサポートしている&gt; (p. 164)</p>
</li>
</ul>
</div>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id63">多重継承と「シャム双生児」関数</a><a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>別の基本クラスに同名同シグニチャの仮想関数が存在する場合を議論する。
現実的にそういう場面に出くわすことなどないだろうと思って読んでいたら、
キッチリ牽制された。</p>
<p>&lt;マイクロソフト社の John Kdllin 氏によれば、
COM インターフェースの <tt class="docutils literal"><span class="pre">IOleObject</span></tt> と <tt class="docutils literal"><span class="pre">IConnectionPoint</span></tt>
から派生させたクラスの作成には&gt; それぞれの <tt class="docutils literal"><span class="pre">Unadvise</span></tt>
純粋仮想関数をオーバーライドしなければならない。</p>
<p>解決方法は間接的に両クラスを継承するようにすること。</p>
</div>
<div class="section" id="id21">
<h3><a class="toc-backref" href="#id64">純粋仮想関数と非純粋仮想関数</a><a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">基本クラスのデストラクタは virtual かつ public か、
non-virtual かつ protected のどちらかとする。</p>
<p>いずれ後者の理由を調べておく。</p>
</li>
</ul>
</div>
<div class="section" id="id22">
<h3><a class="toc-backref" href="#id65">ポリモルフィズムの制御</a><a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;ポリモルフィックに使用させるクラスを限定したい場合&gt; (p. 179) の現実的な例が欲しい。</li>
<li>private 継承と friend を組み合わせるという回答。
一見、必要以上に大きなアクセス権を <tt class="docutils literal"><span class="pre">f1</span></tt> に与えているように見えるが、
<tt class="docutils literal"><span class="pre">Derived</span></tt> 固有の protected/private なメンバーがないと仮定すると、
実は何ら問題ないようだ。</li>
</ul>
</div>
</div>
<div class="section" id="id23">
<h2><a class="toc-backref" href="#id66">メモリとリソースの管理</a><a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>&lt;あなたにはできる。あなたにはできる…&gt; (p. 184)</p>
<div class="section" id="auto-ptr">
<h3><a class="toc-backref" href="#id67">auto_ptr の使用</a><a class="headerlink" href="#auto-ptr" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">new</span></tt>, <tt class="docutils literal"><span class="pre">new[]</span></tt>, <tt class="docutils literal"><span class="pre">delete</span></tt>, <tt class="docutils literal"><span class="pre">delete[]</span></tt> を峻別する。混ぜて使わない。</li>
<li>&lt;<cite>p2</cite> に関しては、全ての終了パスに明示的な後始末のコードを書かなければならない。
たとえば、「他の処理」とコメントした部分に
<tt class="docutils literal"><span class="pre">return;</span></tt> というコードで終わる条件分岐がいくつかあった場合を考えてみよう&gt; (p. 189)</li>
<li>&lt;<tt class="docutils literal"><span class="pre">T</span></tt> のコピーコンストラクタとコピー代入演算子が利用できない場合、
<tt class="docutils literal"><span class="pre">T</span></tt> オブジェクトを要素に持つ標準コンテナはインスタンス化できない&gt; (p. 190)</li>
</ul>
</div>
<div class="section" id="id24">
<h3><a class="toc-backref" href="#id68">クラスメンバとしてのスマートポインタ Part 1</a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">X1</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="nl">private:</span>
    <span class="n">Y</span><span class="o">*</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">X2</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="nl">private:</span>
    <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;一般に、生のポインタを管理クラスでラッピングして、
後始末を単純化する方法がよく使われる&gt; (p. 193)
それでも <tt class="docutils literal"><span class="pre">X2</span></tt> の例では注意点があって、
&lt;自動生成のコピーコンストラクタとコピー代入演算子が間違ったことをする、
という問題点の解決には大して役立たない。単に別の間違ったことをする&gt; (p. 193)</li>
<li>&lt;<tt class="docutils literal"><span class="pre">Y</span></tt> の定義を提供したくなければ、たとえ空であっても、
<tt class="docutils literal"><span class="pre">X2</span></tt> のデストラクタを明示的に実装しなければならない&gt; (p. 194) という落とし穴もある。</li>
<li>&lt;クラスのコピー自体に意味がなければ、それらを無効にしておかなければならない&gt; (p. 195)</li>
</ul>
</div>
<div class="section" id="id25">
<h3><a class="toc-backref" href="#id69">クラスメンバとしてのスマートポインタ Part 2</a><a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>この項目でがんばって実装している <tt class="docutils literal"><span class="pre">ValuePtr</span></tt> のようなクラスを自作しようとは思わないが、
議論の後半でクラスに traits を導入するという展開は面白い。
テンプレートの特殊化で、コピーのやり方を増やせる。</p>
</div>
</div>
<div class="section" id="id26">
<h2><a class="toc-backref" href="#id70">フリー関数とマクロ</a><a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id27">
<h3><a class="toc-backref" href="#id71">再帰宣言</a><a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>自分自身のポインタを返す関数とやらを考える。
状態マシンの実装をそれで行いたいようだ。
わからん。</p>
</div>
<div class="section" id="id28">
<h3><a class="toc-backref" href="#id72">ネスト関数のシミュレート</a><a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>C++ にはネストクラスやローカルクラスはあるのに、ネスト関数がない。</p>
<ul class="simple">
<li>&lt;優れた設計とは、モジュール間の結合を弱め、
モジュール自体の凝集度を強めるものだ&gt; (p. 215)</li>
<li>ネスト関数のポイントとしては、<ul>
<li>外側の関数の変数にアクセスできる。</li>
<li>外側の関数内のローカル＝外側の関数のいかなる外側からも呼び出せない。</li>
</ul>
</li>
<li>&lt;ローカルクラスのオブジェクトは、外部の変数にアクセスできない&gt; (p. 219)</li>
<li>まとめに &lt;決して商用コードの中に持ち込んではならない&gt; (p. 223) と書いてあるな。</li>
</ul>
</div>
<div class="section" id="id29">
<h3><a class="toc-backref" href="#id73">プリプロセッサマクロ</a><a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>C++ には <tt class="docutils literal"><span class="pre">const</span></tt> や <tt class="docutils literal"><span class="pre">inline</span></tt> といった便利なものがあるが、
それでもなお &lt;<tt class="docutils literal"><span class="pre">#define</span></tt> と書くべき理由がまだいくつか残っている&gt; (p. 224)</li>
<li>コンパイル時の条件分岐コードは、
&lt;言うまでもなく、プリプロセッサ利用の中でも最重要に分類される&gt; (p. 225)</li>
<li>&lt;通常、プラットフォーム固有のコードは、
ファクトリパターンを使って処理するのが最良の方法である&gt; (p. 226)</li>
</ul>
</div>
<div class="section" id="define">
<h3><a class="toc-backref" href="#id74">#define</a><a class="headerlink" href="#define" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">define</span></tt> マクロには弱点がいっぱいある。</p>
</div>
</div>
<div class="section" id="id30">
<h2><a class="toc-backref" href="#id75">各種トピック</a><a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<p>この章の各項目は、どういうわけか既視感が拭えない。</p>
<div class="section" id="id31">
<h3><a class="toc-backref" href="#id76">初期化</a><a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">T::T(T(u))</span></tt></li>
<li><tt class="docutils literal"><span class="pre">T::T(u.operator</span> <span class="pre">T())</span></tt></li>
<li>変数の初期化には <tt class="docutils literal"><span class="pre">T</span> <span class="pre">t(u)</span></tt> と書く。</li>
<li>&lt;標準の中でも読み応えのある 8.5 節&gt; (p. 235)</li>
</ul>
</div>
<div class="section" id="id32">
<h3><a class="toc-backref" href="#id77">先行宣言</a><a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;名前空間 <tt class="docutils literal"><span class="pre">std</span></tt> に属する実体を先行宣言しようとしてはならない&gt; (p. 238)</li>
</ul>
</div>
<div class="section" id="typedef">
<h3><a class="toc-backref" href="#id78">typedef</a><a class="headerlink" href="#typedef" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">typedef</span></tt> はまた、意味も追加する&gt; (p. 240)</li>
<li>&lt;一般に、 <tt class="docutils literal"><span class="pre">typedef</span></tt> はいわゆる「間接レベルの追加」により、
コードの作成、読解、変更を容易にする&gt; (p. 242)</li>
</ul>
</div>
<div class="section" id="id33">
<h3><a class="toc-backref" href="#id79">名前空間 Part 2</a><a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p>ここに書いてあるガイドラインは、ある程度の期間、実務で
C++ のコードを書いていれば、皮膚感覚で身に付いているはずのものばかり。
いいガイドラインだ。</p>
<ul class="simple">
<li>ヘッダーファイルには <tt class="docutils literal"><span class="pre">using</span></tt> なんとかを書いてはならない。
名前衝突 &lt;意図しない武力衝突&gt; (p. 247) が生じる可能性を高めてどうする。</li>
<li>ソースファイルにおいても、 <tt class="docutils literal"><span class="pre">using</span></tt> なんとかを
<tt class="docutils literal"><span class="pre">#include</span></tt> なんとかよりも前に書いてはならない。ほぼ同じ理由による。</li>
</ul>
<p>業務用を含む自作のヘッダーファイルには <tt class="docutils literal"><span class="pre">std::</span></tt> が山ほど書いてあるものな。</p>
</div>
</div>
<div class="section" id="id34">
<h2><a class="toc-backref" href="#id80">あとがき以降のノート</a><a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>次回作は <cite>Exceptional C++ Style</cite> だ。</li>
<li>付録はコアな人向け。</li>
<li>参考文献一覧。<ul>
<li>書籍の入手は日本語翻訳版が存在するものについては、いずれも容易い。</li>
<li>論文、寄稿モノはインターネットで読めるものとそうでないものが半々くらいの印象。</li>
</ul>
</li>
<li>訳者あとがきの
&lt;（邦訳版出版に）待ちくたびれて（略）
C++ に見切りをつけて他の言語に移行した方もいらっしゃるかもしれません&gt; に笑った。
他言語に移行したが、うっかり本書を購入する暇人も確かに存在する。</li>
</ul>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート v1.3.0</a> &raquo;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_share">
        <a href="https://twitter.com/share" class="twitter-share-button" data-size="large">Tweet</a>
        <script type="text/javascript">render_twitter_button(document, 'script', 'twitter-wjs')</script>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2014, プレハブ小屋 All rights reserved.
      </div>
      <div id="footer_spacer">
        <p>
          Last updated at 2014/11/15 (Sat) 00:38:32.
        </p>
      </div>
    </div>
  </body>
</html>