
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>More Exceptional C++ 読書ノート &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/mermaid.js"></script>
    <link rel="next" title="Joel on Software 読書ノート" href="joel04/index.html" />
    <link rel="prev" title="Effective STL 読書ノート" href="meyers01.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="meyers01.html" title="Previous document">Effective STL 読書ノート</a>
        </li>
        <li>
          <a href="joel04/index.html" title="Next document">Joel on Software 読書ノート</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="more-exceptional-c">
<h1><a class="toc-backref" href="#id35" role="doc-backlink">More Exceptional C++ 読書ノート</a><a class="headerlink" href="#more-exceptional-c" title="Permalink to this heading">¶</a></h1>
<p>2009 年の正月だったと思う。かの名著 Exceptional C++ の続編を秋葉原駅前ヨドバシの有隣堂書店で発見した。前作が「本物」であったがゆえに、本書も購入してみたのだが───。</p>
<dl class="field-list simple">
<dt class="field-odd">著者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Herb Sutter</p>
</dd>
<dt class="field-even">訳者<span class="colon">:</span></dt>
<dd class="field-even"><p>浜田真理</p>
</dd>
<dt class="field-odd">出版社<span class="colon">:</span></dt>
<dd class="field-odd"><p>ピアソン・エデュケーション</p>
</dd>
<dt class="field-even">発行年<span class="colon">:</span></dt>
<dd class="field-even"><p>2008 年</p>
</dd>
<dt class="field-odd">ISBN<span class="colon">:</span></dt>
<dd class="field-odd"><p>978-4-89471-483-0</p>
</dd>
</dl>
<nav class="contents" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#more-exceptional-c" id="id35">More Exceptional C++ 読書ノート</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id36">序章</a></p></li>
<li><p><a class="reference internal" href="#c" id="id37">汎用プログラミングと C++ 標準ライブラリ</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id38">ストリームの操作</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id39">ステートフル述語</a></p></li>
<li><p><a class="reference internal" href="#traits" id="id40">継承と特性 (traits)</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id41">コンテナではないコンテナ</a></p></li>
<li><p><a class="reference internal" href="#vector-deque" id="id42"><code class="docutils literal notranslate"><span class="pre">vector</span></code> と <code class="docutils literal notranslate"><span class="pre">deque</span></code></a></p></li>
<li><p><a class="reference internal" href="#set-map" id="id43"><code class="docutils literal notranslate"><span class="pre">set</span></code> と <code class="docutils literal notranslate"><span class="pre">map</span></code></a></p></li>
<li><p><a class="reference internal" href="#id6" id="id44">等価なコード？</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id45">テンプレートの特殊化とオーバーロード</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id46">マスターマインドゲーム</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id9" id="id47">最適化と効率</a></p>
<ul>
<li><p><a class="reference internal" href="#inline" id="id48"><code class="docutils literal notranslate"><span class="pre">inline</span></code></a></p></li>
<li><p><a class="reference internal" href="#part-1" id="id49">遅延最適化 Part 1</a></p></li>
<li><p><a class="reference internal" href="#part-2" id="id50">遅延最適化 Part 2</a></p></li>
<li><p><a class="reference internal" href="#part-3" id="id51">遅延最適化 Part 3</a></p></li>
<li><p><a class="reference internal" href="#part-4" id="id52">遅延最適化 Part 4</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id10" id="id53">例外安全問題とテクニック</a></p>
<ul>
<li><p><a class="reference internal" href="#id11" id="id54">コンストラクタの失敗 Part 1</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id55">コンストラクタの失敗 Part 2</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id56">捕捉されない例外</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id57">管理されていないポインタに関する問題 Part 1</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id58">管理されていないポインタに関する問題 Part 2</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id59">例外安全なクラス設計 Part 1</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id60">例外安全なクラス設計 Part 2</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id18" id="id61">継承とポリモルフィズム</a></p>
<ul>
<li><p><a class="reference internal" href="#id19" id="id62">多重継承を使う理由とは何か？</a></p></li>
<li><p><a class="reference internal" href="#id20" id="id63">多重継承と「シャム双生児」関数</a></p></li>
<li><p><a class="reference internal" href="#id21" id="id64">純粋仮想関数と非純粋仮想関数</a></p></li>
<li><p><a class="reference internal" href="#id22" id="id65">ポリモルフィズムの制御</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id23" id="id66">メモリとリソースの管理</a></p>
<ul>
<li><p><a class="reference internal" href="#auto-ptr" id="id67"><code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> の使用</a></p></li>
<li><p><a class="reference internal" href="#id24" id="id68">クラスメンバとしてのスマートポインタ Part 1</a></p></li>
<li><p><a class="reference internal" href="#id25" id="id69">クラスメンバとしてのスマートポインタ Part 2</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id26" id="id70">フリー関数とマクロ</a></p>
<ul>
<li><p><a class="reference internal" href="#id27" id="id71">再帰宣言</a></p></li>
<li><p><a class="reference internal" href="#id28" id="id72">ネスト関数のシミュレート</a></p></li>
<li><p><a class="reference internal" href="#id29" id="id73">プリプロセッサマクロ</a></p></li>
<li><p><a class="reference internal" href="#define" id="id74"><code class="docutils literal notranslate"><span class="pre">#define</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id30" id="id75">各種トピック</a></p>
<ul>
<li><p><a class="reference internal" href="#id31" id="id76">初期化</a></p></li>
<li><p><a class="reference internal" href="#id32" id="id77">先行宣言</a></p></li>
<li><p><a class="reference internal" href="#typedef" id="id78"><code class="docutils literal notranslate"><span class="pre">typedef</span></code></a></p></li>
<li><p><a class="reference internal" href="#id33" id="id79">名前空間 Part 2</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id34" id="id80">あとがき以降のノート</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="id2">
<h2><a class="toc-backref" href="#id36" role="doc-backlink">序章</a><a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>&lt;古代ギリシャの哲学者ソクラテスは、問答によって弟子に伝授した&gt; →ソクラテスメソッド</p></li>
<li><p>&lt;標準 C++ と標準ライブラリの効果的な利用方法&gt;</p></li>
<li><p>&lt;合理的根拠&gt;</p></li>
<li><p>本書は &lt;標準ライブラリの効果的な使用方法に重点を置いている&gt; と繰り返す。</p></li>
<li><p>読者に求める前提条件として、&lt;古典的な名著&gt; であるBjarne Stroustrup, “The C++
Programming Language” やら Stan Lippman and Josée Lajoie, “C++ Primer” を挙げている。これらの本は分厚くて、まともに読みこなせなかったことを思い出した。</p></li>
<li><p>&lt;特に、私の管理下にないものは移動する。&gt;</p></li>
<li><p>&lt;インターネット社会における印刷メディアの過酷な状況&gt;</p></li>
<li><p>著者は本書レビュアーに対して &lt;酷評を惜しみなく浴びせてくださいました&gt; と礼を述べている。</p></li>
</ul>
</section>
<section id="c">
<h2><a class="toc-backref" href="#id37" role="doc-backlink">汎用プログラミングと C++ 標準ライブラリ</a><a class="headerlink" href="#c" title="Permalink to this heading">¶</a></h2>
<p>前作にも同じテーマの章があった。</p>
<section id="id3">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">ストリームの操作</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">basic_ostream</span></code> が、<code class="docutils literal notranslate"><span class="pre">basic_streambuf</span></code> オブジェクトを入力として受け付ける
<code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;()</span></code> を提供&gt; (p. 3) しているので、ここでの回答である
<code class="docutils literal notranslate"><span class="pre">cout</span> <span class="pre">&lt;&lt;</span> <span class="pre">cin.rdbuf()</span></code> の形を着想できる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_open()</span></code> はこういう形でないと使わないな。</p></li>
<li><p>&lt;均衡のとれた判断&gt; &lt;適切な妥協点&gt; (p. 5)</p></li>
<li><p>&lt;拡張性を考慮した設計がしばしばカプセル化を意味している&gt; (p. 6)</p></li>
<li><p>&lt;関連性の分離を適切に行う&gt; (p. 6)</p></li>
</ul>
</section>
<section id="id4">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">ステートフル述語</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;一般に「ステートフル」であると言えば、変更可能な状態のことを意味する。したがって、ステートフル述語においては適用過程の順が重要になる&gt; (p. 14)</p></li>
<li><p>&lt;ステートフル述語とそれ以外の述語には重要な相違点がある&gt; (p. 15) と切り出して、ステートフル述語のコピーがオリジナルと等価とならないものと、適用順が不定の実装であるような <code class="docutils literal notranslate"><span class="pre">remove_if</span></code> についての思考実験を始める。それで標準アルゴリズムの要件が厳密には足りていないよ、と著者は指摘したい。</p></li>
</ul>
</section>
<section id="traits">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">継承と特性 (traits)</a><a class="headerlink" href="#traits" title="Permalink to this heading">¶</a></h3>
<p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">traits</span></code> について。</p>
<ul class="simple">
<li><p>テンプレートの特殊化がキモ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::char_traits&lt;T&gt;</span></code></p></li>
<li><p>[C++98] 17.1.18</p></li>
<li><p>Requirements - 制約クラス</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">B</span></code> の意味がわからない限り、<code class="docutils literal notranslate"><span class="pre">instantiated_type</span></code> についてもわからない&gt; (p. 35)</p></li>
<li><p>&lt;空の基底クラス <code class="docutils literal notranslate"><span class="pre">X_base</span></code> は、<code class="docutils literal notranslate"><span class="pre">typedef</span></code> を提供するためだけに存在している。しかしながら、通常、派生クラスはそれを再度 <code class="docutils literal notranslate"><span class="pre">typedef</span></code> し直す。無駄ではないだろうか？&gt; (p. 36)</p></li>
<li><p>追記のコードをコンパイルしたいが、手許に環境がない。残念。</p></li>
</ul>
</section>
<section id="id5">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">コンテナではないコンテナ</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>スタニスラウって誰だ。</p></li>
<li><p>&lt;ポインタが無効化される時期にさえ注意すれば安全だ。それはまた、イテレータが無効化される時期でもある&gt; (p. 39)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">map&lt;Name,</span> <span class="pre">PhoneNumber&gt;</span></code> の逆方向検索マップが
<code class="docutils literal notranslate"><span class="pre">map&lt;PhoneNumber*,</span> <span class="pre">Name*,</span> <span class="pre">Deref&gt;</span></code> になるのが面白い。</p></li>
<li><p>某書にもあるが &lt;<code class="docutils literal notranslate"><span class="pre">std::vector&lt;bool&gt;</span></code> はその「どんなコンテナ」に含まれない&gt;
(p. 41)</p></li>
<li><p>&lt;「プロキシコンテナ」とは、オブジェクトに対する直接的なアクセスや操作ができないコンテナのことである&gt; (p. 42)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code> のアクセスは遅い&gt; (p. 43)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code> は、プロキシコンテナの実装例を示すことが目的の一部であり、ディスクベースのコンテナや、直接的なアクセスが難しいオブジェクトのコンテナを実装する際の手本にもなるはずだった。だが同時に、標準コンテナの要求によってプロキシコンテナが許されないという実例にもなってしまったのだ&gt; (p. 44)</p></li>
<li><p>&lt;プロファイラや他のテストを実施しておけば、その最適化が本当に改善となるかどうかわかる&gt; (p. 45) →実測が基本。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code> の代わりに（略） <code class="docutils literal notranslate"><span class="pre">deque&lt;bool&gt;</span></code> を使う方が良い&gt; (p. 46)</p></li>
<li><p>もう一回ノートしておこう。&lt;実測上の証拠を握るまで&gt; (p. 47) 最適化はしない。</p></li>
</ul>
</section>
<section id="vector-deque">
<h3><a class="toc-backref" href="#id42" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">vector</span></code> と <code class="docutils literal notranslate"><span class="pre">deque</span></code></a><a class="headerlink" href="#vector-deque" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>配列でなく <code class="docutils literal notranslate"><span class="pre">vector</span></code> を利用する理由は &lt;コンテナの抽象化やカプセル化という点において配列よりも優れており、簡単かつ安全に利用できるから&gt; (p. 48)</p></li>
<li><p>&lt;コンテナ自体とサイズを別々に管理する必要がない&gt; (p. 49)</p></li>
<li><p>配列と <code class="docutils literal notranslate"><span class="pre">vector</span></code> の交換可能性については &lt;現在、標準は、<code class="docutils literal notranslate"><span class="pre">vector</span></code> の要素が配列と同じフォーマットで連続に格納されることを要求している&gt; (p. 50) ので、安心してレガシーコードに <code class="docutils literal notranslate"><span class="pre">&amp;v[0]</span></code> を渡せる。</p></li>
<li><p>&lt;実のところ、これらの関数を持つことが <code class="docutils literal notranslate"><span class="pre">vector</span></code> の欠点なのである&gt; (p. 50) という指摘は面白い。 &lt;これらの関数&gt; というのは <code class="docutils literal notranslate"><span class="pre">capacity</span></code> と <code class="docutils literal notranslate"><span class="pre">reserve</span></code> のことだが。</p></li>
<li><p>今となってはおなじみの、消費メモリ削減テク「一時オブジェクトと <code class="docutils literal notranslate"><span class="pre">swap</span></code> イディオム」を紹介している。</p></li>
</ul>
</section>
<section id="set-map">
<h3><a class="toc-backref" href="#id43" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">set</span></code> と <code class="docutils literal notranslate"><span class="pre">map</span></code></a><a class="headerlink" href="#set-map" title="Permalink to this heading">¶</a></h3>
<p>何に役立てるのかはわからないが、既存 <code class="docutils literal notranslate"><span class="pre">map</span></code> オブジェクトのキー、すなわち
<code class="docutils literal notranslate"><span class="pre">map::iterator</span></code> の <code class="docutils literal notranslate"><span class="pre">first</span></code> メンバーを無理やり書き換える方法を議論する。</p>
<ul class="simple">
<li><p>&lt;キーの比較には、必ず引数の Compare 型が使われる&gt; (p. 55)</p></li>
<li><p>&lt;問題となるのは、コンテナに挿入済みのキーの相対順を変更するコードだ&gt; (p. 57)</p></li>
</ul>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id44" role="doc-backlink">等価なコード？</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> が関数型マクロならば &lt;ステートメント <code class="docutils literal notranslate"><span class="pre">f(a++)</span></code> はどのような意味にもなり得る&gt; (p. 62) <code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">f(x)</span> <span class="pre">(x,x,x,x,x,x,x,x,x)</span></code> の例を出して説得力を補強。
C++ ではマクロの仕様は可能な限り避ける。</p></li>
<li><p>&lt;「無効なイテレータの使用」のバグは非常に見つけにくいからだ（チェックバージョンのライブラリ実装でデバッグするのが好きならば、話は別だが）&gt; (p. 65) チェックバージョンは動作が当然遅いので、プロジェクト内容によってはオプションをオフにしている場合すらある。</p></li>
</ul>
</section>
<section id="id7">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">テンプレートの特殊化とオーバーロード</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<p>個人的にテンプレートの特殊化は興味がないので読み飛ばす。それにしても、本項目オチの一文が強烈な皮肉だ。</p>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">マスターマインドゲーム</a><a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;厳格かつ健全なソフトウェアエンジニアリングが本書の目的である&gt; (p. 72) が、ここで羽目を外す。&lt;ステートメントの区切り子としてセミコロンの代わりにカンマを可能な限り使うことにした&gt; (p. 73) やら &lt;if/else の代わりに 3 項演算子 (?:) を使うことにした&gt; (p. 73) などやりたい放題。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">inner_product()</span></code> という名前がまだ気になるならば、この標準アルゴリズムを
<code class="docutils literal notranslate"><span class="pre">accumulate()</span></code> と <code class="docutils literal notranslate"><span class="pre">transform()</span></code> の合成だと考えればよい&gt; (p. 81)</p></li>
<li><p>&lt;実社会の商用コードではめったに使わないカンマ演算子&gt; (p. 84)</p></li>
</ul>
</section>
</section>
<section id="id9">
<h2><a class="toc-backref" href="#id47" role="doc-backlink">最適化と効率</a><a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h2>
<section id="inline">
<h3><a class="toc-backref" href="#id48" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">inline</span></code></a><a class="headerlink" href="#inline" title="Permalink to this heading">¶</a></h3>
<p>個人的には <code class="docutils literal notranslate"><span class="pre">inline</span></code> は最近本当に使わなくなった。コンパイラーに任せた方が利口だもの。</p>
<ul class="simple">
<li><p>&lt;そもそも何を最適化したいのか定義せずに答えようとしても意味がない&gt; (p. 88) と切り出し、候補対象を列挙していく。個人的には開発速度とビルド時間を優先したいところだ。</p></li>
<li><p>ここでも実測主義が全面に出る。この姿勢は本書中で一貫していて気持ちがいい。&lt;通常、実測に基づいた証拠だけが真のホットスポットを言い当てることができる&gt;
(p. 90)</p></li>
<li><p>&lt;このような場合でも、やはりプロファイラを使い、そのアドバイスにしたがって最適化を行うべきである&gt; (p. 90)</p></li>
<li><p>最後に &lt;インラインコードはモジュール間の結合を強める&gt; (p. 90) と締めくくり、読者にあてずっぽな <code class="docutils literal notranslate"><span class="pre">inline</span></code> の使用を戒めることを忘れない。</p></li>
</ul>
</section>
<section id="part-1">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">遅延最適化 Part 1</a><a class="headerlink" href="#part-1" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;一般に、最高のパフォーマンスを示す方法は指数拡張である&gt; (p. 94)</p></li>
<li><p>&lt;Koenig は、指数拡張における最良の指数が一般に 2 ではない理由を説明している&gt;
(p. 94)</p></li>
</ul>
</section>
<section id="part-2">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">遅延最適化 Part 2</a><a class="headerlink" href="#part-2" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;コピー処理を後回しにするため、<code class="docutils literal notranslate"><span class="pre">String</span></code> オブジェクト内部でバッファを共有させよう&gt; (p. 95) <code class="docutils literal notranslate"><span class="pre">String</span></code> クラスを <code class="docutils literal notranslate"><span class="pre">String</span></code> と <code class="docutils literal notranslate"><span class="pre">StringBuf</span></code> に分離して、後者をコピー不可能なクラスとして、 <code class="docutils literal notranslate"><span class="pre">String</span></code> オブジェクト同士で共有する作戦らしい。</p></li>
<li><p>「参照回数」は <code class="docutils literal notranslate"><span class="pre">StringBuf</span></code> の内部にあるが、これを更新するのは <code class="docutils literal notranslate"><span class="pre">String</span></code> のメンバー。</p></li>
<li><p>遅延コピーを実装するので、コピーコンストラクターは「浅いコピー」になる。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">AboutToModify()</span></code> は、まだ実行していなければ「深い」コピーを遅延実行して、内部バッファの非共有を保証する&gt; (p. 97)</p></li>
</ul>
</section>
<section id="part-3">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">遅延最適化 Part 3</a><a class="headerlink" href="#part-3" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">operator[]()</span></code> はそれほど簡単ではない&gt; (p. 100) &lt;少なくとも、内部表現が共有されていないことを保証する必要がある&gt; (p. 101) どんどん話が複雑になってきて、
&lt;シングルスレッド環境ならば、まあ、こんなところだろう&gt; (p. 105) と不吉な伏線を張る。</p></li>
</ul>
</section>
<section id="part-4">
<h3><a class="toc-backref" href="#id52" role="doc-backlink">遅延最適化 Part 4</a><a class="headerlink" href="#part-4" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AboutToModify</span></code> の最初の if 文の条件式がスレッドセーフではないことに気付けないとダメか。</p></li>
<li><p>脚注にいいことが書いてある。 Win32 では効率の点から &lt;できる限りクリティカルセクションを利用すべき&gt; (p. 111) だそうだ。</p></li>
<li><p>&lt;「深いコピー」の間、ずっとロックを取得していることに注意しよう&gt; (p. 113) 例示のためにちょっと手抜きをしているようだ。</p></li>
<li><p>&lt;ロックが必要な操作は <code class="docutils literal notranslate"><span class="pre">refs</span></code> へのアクセスだけである、ということに注意しよう&gt;
(p. 114)</p></li>
</ul>
</section>
</section>
<section id="id10">
<h2><a class="toc-backref" href="#id53" role="doc-backlink">例外安全問題とテクニック</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h2>
<p>&lt;C++ 標準ライブラリを使うのであれば、例外に備える必要がある&gt; (p. 119)</p>
<section id="id11">
<h3><a class="toc-backref" href="#id54" role="doc-backlink">コンストラクタの失敗 Part 1</a><a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>オブジェクトの生存期間の開始時点は、コンストラクタが（正常に） <strong>終了した瞬間</strong>
と考える。また、生存期間の終了時点は、デストラクタが <strong>開始した</strong> 瞬間と考える。</p></li>
<li><p>コンストラクタが例外を投げて終了する場合、オブジェクトが存在した事実がないと考える。 &lt;コンストラクタが成功しなかったときにデストラクタが呼ばれない&gt; (p. 123)
のだ。</p></li>
</ul>
</section>
<section id="id12">
<h3><a class="toc-backref" href="#id55" role="doc-backlink">コンストラクタの失敗 Part 2</a><a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;要するに、コンストラクタやデストラクタの関数 <code class="docutils literal notranslate"><span class="pre">try</span></code> ブロックのハンドラは、何らかの例外を投げて終了しなければならない、ということだ&gt; (p. 124)</p></li>
<li><p>&lt;これまで私は、例外に対して愛情と憎しみの環境を繰り返し抱いてきた&gt; (p. 125)</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">try</span></code> ブロックのハンドラに一旦入ると、コンストラクタ内のローカル変数はスコープから外れ、（非 <code class="docutils literal notranslate"><span class="pre">static</span></code> な）メンバオブジェクトは既に存在しない。</p></li>
<li><p>標準 C++ の 15.3 paragraph 10 を読んでおくこと。</p></li>
<li><p>最大の結論は &lt;他の関数 <code class="docutils literal notranslate"><span class="pre">try</span></code> ブロックにはどれも実用的な使い道がない&gt; (p.
128) だろう。</p></li>
<li><p>非管理リソースの獲得は &lt;決して初期化リストで行ってはならない&gt; (p. 128) RAII
ルールの対偶とでも言うべきか。</p></li>
<li><p>&lt;コンストラクタの例外は伝播させなければならない&gt; (p. 129)</p></li>
</ul>
</section>
<section id="id13">
<h3><a class="toc-backref" href="#id56" role="doc-backlink">捕捉されない例外</a><a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">uncaught_exception()</span></code> の議論だが、ここは読みとばす。</p>
<ul class="simple">
<li><p>&lt;標準関数 <code class="docutils literal notranslate"><span class="pre">uncaught_exception()</span></code> は、「現在アクティブな例外が存在するか」を知る手段である&gt; (p. 132)</p></li>
</ul>
</section>
<section id="id14">
<h3><a class="toc-backref" href="#id57" role="doc-backlink">管理されていないポインタに関する問題 Part 1</a><a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f(g(expr1),</span> <span class="pre">h(expr2))</span></code> のような処理シーケンスがあるとする。直感的に <code class="docutils literal notranslate"><span class="pre">g</span></code>,
<code class="docutils literal notranslate"><span class="pre">h</span></code>, <code class="docutils literal notranslate"><span class="pre">expr1</span></code>, <code class="docutils literal notranslate"><span class="pre">expr2</span></code> のいずれかがリソース確保系統の処理であってはまずいと考えられる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span></code> でオブジェクトを生成しようとして例外によって失敗したときに、確保済みのメモリは解放されるらしい。</p></li>
</ul>
</section>
<section id="id15">
<h3><a class="toc-backref" href="#id58" role="doc-backlink">管理されていないポインタに関する問題 Part 2</a><a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;明示的なリソース確保は、独立した式で行うこと&gt; (p. 145)</p></li>
</ul>
</section>
<section id="id16">
<h3><a class="toc-backref" href="#id59" role="doc-backlink">例外安全なクラス設計 Part 1</a><a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h3>
<p>「Abrahams の保証」なる名前がついているようだ。</p>
<dl class="simple">
<dt>基本保証</dt><dd><p>例外が投げられたとしても、リソースリークは起こらない。</p>
</dd>
<dt>強い保証</dt><dd><p>例外が投げられたとしても、プログラムの状態は変更されない（コミットとロールバック）。</p>
</dd>
<dt>nothrow 保証</dt><dd><p>例外を投げない。</p>
</dd>
</dl>
<ul class="simple">
<li><p>PIMPL 版 (p. 152) スワップは一見の価値あり。</p></li>
<li><p>プログラム全体の状態不変性を保証するのは明らかに厳しい。「ローカルな強い保証」という考え方で折り合いをつけるのが現実的。</p></li>
</ul>
</section>
<section id="id17">
<h3><a class="toc-backref" href="#id60" role="doc-backlink">例外安全なクラス設計 Part 2</a><a class="headerlink" href="#id17" title="Permalink to this heading">¶</a></h3>
<p>クラスとクラスの間の関係について、関係を分類してそれらの性質を検討していく。</p>
<ul class="simple">
<li><p>&lt;「何らかの形で～を使う」という記述には、大きな自由度が残されている。<code class="docutils literal notranslate"><span class="pre">T</span></code> が
<code class="docutils literal notranslate"><span class="pre">U</span></code> のアダプタ、プロキシ、ラッパー、あるいは <code class="docutils literal notranslate"><span class="pre">T</span></code> 自身の機能を実装するため、たまたま <code class="docutils literal notranslate"><span class="pre">U</span></code> を使っているだけの場合まで、広範囲に適用されるからだ&gt;
(p. 157)</p></li>
<li><p>&lt;経験を積んだ開発者でさえ、継承を使いすぎる傾向がある&gt; (p. 157) とにかく結合を弱めることに努めること。</p></li>
<li><p>脚注も見落とせない。&lt;クラス <code class="docutils literal notranslate"><span class="pre">X</span></code> と最強の関係を持つのは <code class="docutils literal notranslate"><span class="pre">friend</span></code> である&gt;
(p. 158)</p></li>
<li><p>まとめ (p. 160) は 10 回くらい暗唱するといい。</p></li>
</ul>
</section>
</section>
<section id="id18">
<h2><a class="toc-backref" href="#id61" role="doc-backlink">継承とポリモルフィズム</a><a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h2>
<section id="id19">
<h3><a class="toc-backref" href="#id62" role="doc-backlink">多重継承を使う理由とは何か？</a><a class="headerlink" href="#id19" title="Permalink to this heading">¶</a></h3>
<p>個人的に多重継承とは理解するのがすごく面倒なものだという印象を持っているが、本項目を読んでも、やはり敬遠したいシステムだという気持ちが拭えない。</p>
<ul>
<li><p>ABC: Abstract Base Class - メンバ変数を持たず、純粋仮想関数だけから構成された基本クラスのこと。複数の ABC から多重継承するぶんには構わない。</p>
<p>&lt;面白いことに、継承の機構を持たない言語やモデルが、この種の多重継承をサポートしている&gt; (p. 164)</p>
</li>
</ul>
</section>
<section id="id20">
<h3><a class="toc-backref" href="#id63" role="doc-backlink">多重継承と「シャム双生児」関数</a><a class="headerlink" href="#id20" title="Permalink to this heading">¶</a></h3>
<p>別の基本クラスに同名同シグニチャの仮想関数が存在する場合を議論する。現実的にそういう場面に出くわすことなどないだろうと思って読んでいたら、キッチリ牽制された。</p>
<p>&lt;マイクロソフト社の John Kdllin 氏によれば、 COM インターフェースの
<code class="docutils literal notranslate"><span class="pre">IOleObject</span></code> と <code class="docutils literal notranslate"><span class="pre">IConnectionPoint</span></code> から派生させたクラスの作成には&gt; それぞれの <code class="docutils literal notranslate"><span class="pre">Unadvise</span></code> 純粋仮想関数をオーバーライドしなければならない。</p>
<p>解決方法は間接的に両クラスを継承するようにすること。</p>
</section>
<section id="id21">
<h3><a class="toc-backref" href="#id64" role="doc-backlink">純粋仮想関数と非純粋仮想関数</a><a class="headerlink" href="#id21" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>基本クラスのデストラクタは <code class="docutils literal notranslate"><span class="pre">virtual</span></code> かつ <code class="docutils literal notranslate"><span class="pre">public</span></code> か、non-<code class="docutils literal notranslate"><span class="pre">virtual</span></code> かつ <code class="docutils literal notranslate"><span class="pre">protected</span></code> のどちらかとする。</p>
<p>いずれ後者の理由を調べておく。</p>
</li>
</ul>
</section>
<section id="id22">
<h3><a class="toc-backref" href="#id65" role="doc-backlink">ポリモルフィズムの制御</a><a class="headerlink" href="#id22" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;ポリモルフィックに使用させるクラスを限定したい場合&gt; (p. 179) の現実的な例が欲しい。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">private</span></code> 継承と <code class="docutils literal notranslate"><span class="pre">friend</span></code> を組み合わせるという回答。一見、必要以上に大きなアクセス権を <code class="docutils literal notranslate"><span class="pre">f1</span></code> に与えているように見えるが、<code class="docutils literal notranslate"><span class="pre">Derived</span></code> 固有の
<code class="docutils literal notranslate"><span class="pre">protected</span></code>/<code class="docutils literal notranslate"><span class="pre">private</span></code> なメンバーがないと仮定すると、実は何ら問題ないようだ。</p></li>
</ul>
</section>
</section>
<section id="id23">
<h2><a class="toc-backref" href="#id66" role="doc-backlink">メモリとリソースの管理</a><a class="headerlink" href="#id23" title="Permalink to this heading">¶</a></h2>
<p>&lt;あなたにはできる。あなたにはできる…&gt; (p. 184)</p>
<section id="auto-ptr">
<h3><a class="toc-backref" href="#id67" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> の使用</a><a class="headerlink" href="#auto-ptr" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">new[]</span></code>, <code class="docutils literal notranslate"><span class="pre">delete</span></code>, <code class="docutils literal notranslate"><span class="pre">delete[]</span></code> を峻別する。混ぜて使わない。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">p2</span></code> に関しては、全ての終了パスに明示的な後始末のコードを書かなければならない。たとえば、「他の処理」とコメントした部分に <code class="docutils literal notranslate"><span class="pre">return;</span></code> というコードで終わる条件分岐がいくつかあった場合を考えてみよう&gt; (p. 189)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">T</span></code> のコピーコンストラクタとコピー代入演算子が利用できない場合、<code class="docutils literal notranslate"><span class="pre">T</span></code> オブジェクトを要素に持つ標準コンテナはインスタンス化できない&gt; (p. 190)</p></li>
</ul>
</section>
<section id="id24">
<h3><a class="toc-backref" href="#id68" role="doc-backlink">クラスメンバとしてのスマートポインタ Part 1</a><a class="headerlink" href="#id24" title="Permalink to this heading">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">X1</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">Y</span><span class="o">*</span><span class="w"> </span><span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">X2</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="w"> </span><span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;一般に、生のポインタを管理クラスでラッピングして、後始末を単純化する方法がよく使われる&gt; (p. 193) それでも <code class="docutils literal notranslate"><span class="pre">X2</span></code> の例では注意点があって、&lt;自動生成のコピーコンストラクタとコピー代入演算子が間違ったことをする、という問題点の解決には大して役立たない。単に別の間違ったことをする&gt; (p. 193)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Y</span></code> の定義を提供したくなければ、たとえ空であっても、<code class="docutils literal notranslate"><span class="pre">X2</span></code> のデストラクタを明示的に実装しなければならない&gt; (p. 194) という落とし穴もある。</p></li>
<li><p>&lt;クラスのコピー自体に意味がなければ、それらを無効にしておかなければならない&gt;
(p. 195)</p></li>
</ul>
</section>
<section id="id25">
<h3><a class="toc-backref" href="#id69" role="doc-backlink">クラスメンバとしてのスマートポインタ Part 2</a><a class="headerlink" href="#id25" title="Permalink to this heading">¶</a></h3>
<p>この項目でがんばって実装している <code class="docutils literal notranslate"><span class="pre">ValuePtr</span></code> のようなクラスを自作しようとは思わないが、議論の後半でクラスに traits を導入するという展開は面白い。テンプレートの特殊化で、コピーのやり方を増やせる。</p>
</section>
</section>
<section id="id26">
<h2><a class="toc-backref" href="#id70" role="doc-backlink">フリー関数とマクロ</a><a class="headerlink" href="#id26" title="Permalink to this heading">¶</a></h2>
<section id="id27">
<h3><a class="toc-backref" href="#id71" role="doc-backlink">再帰宣言</a><a class="headerlink" href="#id27" title="Permalink to this heading">¶</a></h3>
<p>自分自身のポインタを返す関数とやらを考える。状態マシンの実装をそれで行いたいようだ。わからん。</p>
</section>
<section id="id28">
<h3><a class="toc-backref" href="#id72" role="doc-backlink">ネスト関数のシミュレート</a><a class="headerlink" href="#id28" title="Permalink to this heading">¶</a></h3>
<p>C++ にはネストクラスやローカルクラスはあるのに、ネスト関数がない。</p>
<ul class="simple">
<li><p>&lt;優れた設計とは、モジュール間の結合を弱め、モジュール自体の凝集度を強めるものだ&gt; (p. 215)</p></li>
<li><p>ネスト関数のポイントとしては、</p>
<ul>
<li><p>外側の関数の変数にアクセスできる。</p></li>
<li><p>外側の関数内のローカル＝外側の関数のいかなる外側からも呼び出せない。</p></li>
</ul>
</li>
<li><p>&lt;ローカルクラスのオブジェクトは、外部の変数にアクセスできない&gt; (p. 219)</p></li>
<li><p>まとめに &lt;決して商用コードの中に持ち込んではならない&gt; (p. 223) と書いてあるな。</p></li>
</ul>
</section>
<section id="id29">
<h3><a class="toc-backref" href="#id73" role="doc-backlink">プリプロセッサマクロ</a><a class="headerlink" href="#id29" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>C++ には <code class="docutils literal notranslate"><span class="pre">const</span></code> や <code class="docutils literal notranslate"><span class="pre">inline</span></code> といった便利なものがあるが、それでもなお &lt;<code class="docutils literal notranslate"><span class="pre">#define</span></code> と書くべき理由がまだいくつか残っている&gt; (p. 224)</p></li>
<li><p>コンパイル時の条件分岐コードは、&lt;言うまでもなく、プリプロセッサ利用の中でも最重要に分類される&gt; (p. 225)</p></li>
<li><p>&lt;通常、プラットフォーム固有のコードは、ファクトリパターンを使って処理するのが最良の方法である&gt; (p. 226)</p></li>
</ul>
</section>
<section id="define">
<h3><a class="toc-backref" href="#id74" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#define</span></code></a><a class="headerlink" href="#define" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">define</span></code> マクロには弱点がいっぱいある。</p>
</section>
</section>
<section id="id30">
<h2><a class="toc-backref" href="#id75" role="doc-backlink">各種トピック</a><a class="headerlink" href="#id30" title="Permalink to this heading">¶</a></h2>
<p>この章の各項目は、どういうわけか既視感が拭えない。</p>
<section id="id31">
<h3><a class="toc-backref" href="#id76" role="doc-backlink">初期化</a><a class="headerlink" href="#id31" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T::T(T(u))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T::T(u.operator</span> <span class="pre">T())</span></code></p></li>
<li><p>変数の初期化には <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">t(u)</span></code> と書く。</p></li>
<li><p>&lt;標準の中でも読み応えのある 8.5 節&gt; (p. 235)</p></li>
</ul>
</section>
<section id="id32">
<h3><a class="toc-backref" href="#id77" role="doc-backlink">先行宣言</a><a class="headerlink" href="#id32" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;名前空間 <code class="docutils literal notranslate"><span class="pre">std</span></code> に属する実体を先行宣言しようとしてはならない&gt; (p. 238)</p></li>
</ul>
</section>
<section id="typedef">
<h3><a class="toc-backref" href="#id78" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">typedef</span></code></a><a class="headerlink" href="#typedef" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">typedef</span></code> はまた、意味も追加する&gt; (p. 240)</p></li>
<li><p>&lt;一般に、<code class="docutils literal notranslate"><span class="pre">typedef</span></code> はいわゆる「間接レベルの追加」により、コードの作成、読解、変更を容易にする&gt; (p. 242)</p></li>
</ul>
</section>
<section id="id33">
<h3><a class="toc-backref" href="#id79" role="doc-backlink">名前空間 Part 2</a><a class="headerlink" href="#id33" title="Permalink to this heading">¶</a></h3>
<p>ここに書いてあるガイドラインは、ある程度の期間、実務で C++ のコードを書いていれば、皮膚感覚で身に付いているはずのものばかり。いいガイドラインだ。</p>
<ul class="simple">
<li><p>ヘッダーファイルには <code class="docutils literal notranslate"><span class="pre">using</span></code> なんとかを書いてはならない。名前衝突 &lt;意図しない武力衝突&gt; (p. 247) が生じる可能性を高めてどうする。</p></li>
<li><p>ソースファイルにおいても、<code class="docutils literal notranslate"><span class="pre">using</span></code> なんとかを <code class="docutils literal notranslate"><span class="pre">#include</span></code> なんとかよりも前に書いてはならない。ほぼ同じ理由による。</p></li>
</ul>
<p>業務用を含む自作のヘッダーファイルには <code class="docutils literal notranslate"><span class="pre">std::</span></code> が山ほど書いてあるものな。</p>
</section>
</section>
<section id="id34">
<h2><a class="toc-backref" href="#id80" role="doc-backlink">あとがき以降のノート</a><a class="headerlink" href="#id34" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>次回作は <cite>Exceptional C++ Style</cite> だ。</p></li>
<li><p>付録はコアな人向け。</p></li>
<li><p>参考文献一覧。</p>
<ul>
<li><p>書籍の入手は日本語翻訳版が存在するものについては、いずれも容易い。</p></li>
<li><p>論文、寄稿モノはインターネットで読めるものとそうでないものが半々くらいの印象。</p></li>
</ul>
</li>
<li><p>訳者あとがきの &lt;（邦訳版出版に）待ちくたびれて（略） C++ に見切りをつけて他の言語に移行した方もいらっしゃるかもしれません&gt; に笑った。他言語に移行したが、うっかり本書を購入する暇人も確かに存在する。</p></li>
</ul>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="meyers01.html" title="Previous document">Effective STL 読書ノート</a>
        </li>
        <li>
          <a href="joel04/index.html" title="Next document">Joel on Software 読書ノート</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="ou23/index.html">Modern C++ Tutorial: C++ 11/14/17/20 On the Fly 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="bash-v4.html">What’s New In Bash 4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="bash-v5.html">What’s New In Bash 5 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="youtube-dl.html">youtube-dl 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-upgrade.html">Python 移行ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="google-ime.html">Google 日本語入力利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="oh-my-posh.html">Oh My Posh 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="ffmpeg/index.html">FFmpeg 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="pandoc.html">Pandoc 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="zoom.html">Zoom Cloud Meetings 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="meyers01.html" title="previous chapter">Effective STL 読書ノート</a></li>
      <li>Next: <a href="joel04/index.html" title="next chapter">Joel on Software 読書ノート</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2023, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>