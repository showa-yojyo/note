
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>What’s New In C++11 言語仕様 &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="What’s New In C++11 標準ライブラリー" href="library.html" />
    <link rel="prev" title="What’s New In C++11 ノート" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="index.html" title="Previous document">What’s New In C++11 ノート</a>
        </li>
        <li>
          <a href="library.html" title="Next document">What’s New In C++11 標準ライブラリー</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-c-11">
<h1><a class="toc-backref" href="#id33">What’s New In C++11 言語仕様</a><a class="headerlink" href="#what-s-new-in-c-11" title="Permalink to this heading">¶</a></h1>
<p>このノートでは C++11 で注目すべき言語仕様を学習する。すでに <a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> がそのへんをきれいに整理している。それを利用して、読みながら急所を記していくことにする。</p>
<p>タイピングの都合で訳語は <a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> のものと一部変更して記す。</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#what-s-new-in-c-11" id="id33">What’s New In C++11 言語仕様</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id34">一般的な機能</a></p>
<ul>
<li><p><a class="reference internal" href="#auto" id="id35">型推論 <code class="docutils literal notranslate"><span class="pre">auto</span></code></a></p></li>
<li><p><a class="reference internal" href="#decltype" id="id36">式の型を取得 <code class="docutils literal notranslate"><span class="pre">decltype</span></code></a></p></li>
<li><p><a class="reference internal" href="#for" id="id37">範囲 <code class="docutils literal notranslate"><span class="pre">for</span></code> 文</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id38">初期化子リスト</a></p></li>
<li><p><a class="reference internal" href="#brace-or-equal-initializer" id="id39">一様初期化 <em>brace-or-equal-initializer</em></a></p></li>
<li><p><a class="reference internal" href="#id3" id="id40">右辺値参照・ムーブセマンティクス</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id41">ラムダ式</a></p></li>
<li><p><a class="reference internal" href="#noexcept" id="id42">キーワード <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></a></p></li>
<li><p><a class="reference internal" href="#constexpr" id="id43">定数式 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code></a></p></li>
<li><p><a class="reference internal" href="#nullptr" id="id44">空ポインター <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></a></p></li>
<li><p><a class="reference internal" href="#inline-namespace" id="id45">インライン名前空間 <code class="docutils literal notranslate"><span class="pre">inline</span> <span class="pre">namespace</span></code></a></p></li>
<li><p><a class="reference internal" href="#id5" id="id46">ユーザー定義リテラル</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id6" id="id47">クラス</a></p>
<ul>
<li><p><a class="reference internal" href="#default-delete" id="id48">キーワード <code class="docutils literal notranslate"><span class="pre">default</span></code>/<code class="docutils literal notranslate"><span class="pre">delete</span></code></a></p></li>
<li><p><a class="reference internal" href="#id7" id="id49">委譲コンストラクター</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id50">非静的メンバーの初期化</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id51">継承コンストラクター</a></p></li>
<li><p><a class="reference internal" href="#final-override" id="id52">キーワード <code class="docutils literal notranslate"><span class="pre">final</span></code>/<code class="docutils literal notranslate"><span class="pre">override</span></code></a></p></li>
<li><p><a class="reference internal" href="#id10" id="id53">明示的な型変換演算子のオーバーロード</a></p></li>
<li><p><a class="reference internal" href="#friend" id="id54"><code class="docutils literal notranslate"><span class="pre">friend</span></code> 宣言の要件の緩和</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id55">メンバ関数の左辺値／右辺値修飾</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id12" id="id56">クラス以外の型に関する機能</a></p>
<ul>
<li><p><a class="reference internal" href="#scoped-enum" id="id57">Scoped <code class="docutils literal notranslate"><span class="pre">enum</span></code></a></p></li>
<li><p><a class="reference internal" href="#union" id="id58"><code class="docutils literal notranslate"><span class="pre">union</span></code> に対する規制緩和</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id13" id="id59">テンプレート</a></p>
<ul>
<li><p><a class="reference internal" href="#id14" id="id60">テンプレートの <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> を空白を挟まずに書けるようになった</a></p></li>
<li><p><a class="reference internal" href="#extern-template" id="id61">外部テンプレート <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">template</span></code></a></p></li>
<li><p><a class="reference internal" href="#id15" id="id62">別名テンプレート</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id63">可変引数テンプレート</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id64">ローカル型と無名型をテンプレート実引数として使用することができる</a></p></li>
<li><p><a class="reference internal" href="#sfinae" id="id65">SFINAE 強化</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id66">テンプレートのエクスポート機能を削除</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id19" id="id67">並行プログラミング</a></p>
<ul>
<li><p><a class="reference internal" href="#id20" id="id68">スレッドローカルストレージ</a></p></li>
<li><p><a class="reference internal" href="#static" id="id69">ブロックスコープを持つ <code class="docutils literal notranslate"><span class="pre">static</span></code> 変数初期化のスレッドセーフ化</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id21" id="id70">その他</a></p>
<ul>
<li><p><a class="reference internal" href="#id22" id="id71">戻り値の型を後置する関数宣言構文</a></p></li>
<li><p><a class="reference internal" href="#assertion" id="id72">コンパイル時 assertion</a></p></li>
<li><p><a class="reference internal" href="#id23" id="id73">生文字列リテラル</a></p></li>
<li><p><a class="reference internal" href="#utf-16-utf-32" id="id74">UTF-16 と UTF-32 の文字型</a></p></li>
<li><p><a class="reference internal" href="#utf-8" id="id75">UTF-8 文字列リテラル</a></p></li>
<li><p><a class="reference internal" href="#id24" id="id76">属性構文</a></p></li>
<li><p><a class="reference internal" href="#alignas" id="id77">演算子 <code class="docutils literal notranslate"><span class="pre">alignas</span></code> - アライメントを指定する</a></p></li>
<li><p><a class="reference internal" href="#alignof" id="id78">演算子 <code class="docutils literal notranslate"><span class="pre">alignof</span></code> - アライメントを取得する</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id25" id="id79">小さな変更</a></p>
<ul>
<li><p><a class="reference internal" href="#id26" id="id80">更新された定義済みマクロ</a></p></li>
<li><p><a class="reference internal" href="#id27" id="id81">機能テストマクロ</a></p></li>
<li><p><a class="reference internal" href="#id28" id="id82">テンプレート再帰回数の制限緩和</a></p></li>
<li><p><a class="reference internal" href="#typename-template" id="id83">キーワード <code class="docutils literal notranslate"><span class="pre">typename</span></code> および <code class="docutils literal notranslate"><span class="pre">template</span></code> の適用範囲拡大</a></p></li>
<li><p><a class="reference internal" href="#id29" id="id84">入れ子の指定にグローバルスコープ <code class="docutils literal notranslate"><span class="pre">::</span></code> を付加する</a></p></li>
<li><p><a class="reference internal" href="#id30" id="id85">前方宣言時要素数指定配列機能</a></p></li>
<li><p><a class="reference internal" href="#std-posix-posix" id="id86">名前空間 <code class="docutils literal notranslate"><span class="pre">std::posix</span></code> および <code class="docutils literal notranslate"><span class="pre">::posix</span></code></a></p></li>
<li><p><a class="reference internal" href="#sizeof" id="id87">演算子 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> が非静的メンバー変数をオペランドにとれる</a></p></li>
<li><p><a class="reference internal" href="#register" id="id88">キーワード <code class="docutils literal notranslate"><span class="pre">register</span></code> は廃止予定要素となった</a></p></li>
<li><p><a class="reference internal" href="#id31" id="id89">参照への参照はエラーではなくなった</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c99" id="id90">C99 互換機能</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id34">一般的な機能</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<div class="section" id="auto">
<h3><a class="toc-backref" href="#id35">型推論 <code class="docutils literal notranslate"><span class="pre">auto</span></code></a><a class="headerlink" href="#auto" title="Permalink to this heading">¶</a></h3>
<p>いちばんありがたいのが仕様転生したキーワード <code class="docutils literal notranslate"><span class="pre">auto</span></code> だ。変数の宣言と定義を同時にする場合には、右辺の値の型を明示する代わりに <code class="docutils literal notranslate"><span class="pre">auto</span></code> と書く。</p>
<p>テンプレートの型推論機能と同等のものと考えて良いようだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// OK: x has type int</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// OK: v has type const int*, u has type const int</span>
<span class="k">static</span> <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// OK: y has type double</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">escaped_list_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">tok</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">tok</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">tok</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">){</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>従来の自動変数（スタックに積む変数）を意味するためのキーワードという意味は廃止された。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code>/<code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> と共に用いることも可能だ。</p></li>
<li><p>テンプレート型引数や関数引数の型として用いることは許されない。</p></li>
<li><p>この他にも、C++11 から仕様化された <em>trailing-return-type</em> を含む関数宣言でも引数や戻り値など、有効な宣言である限り、この手の <code class="docutils literal notranslate"><span class="pre">auto</span></code> を用いることが許される。</p></li>
</ul>
</div>
<div class="section" id="decltype">
<h3><a class="toc-backref" href="#id36">式の型を取得 <code class="docutils literal notranslate"><span class="pre">decltype</span></code></a><a class="headerlink" href="#decltype" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">decltype</span></code> は型を指定する必要のある場所で用いる。オペランドは式とする。演算結果がその式の返す値の型となる。コンパイル時に評価される。</p>
<p>宣言 <code class="docutils literal notranslate"><span class="pre">decltype(e)</span></code> によって定義される型は次のように決まる：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">e</span></code> が括弧なし <em>id-expression</em> または括弧なしクラスメンバーアクセスのときは
<code class="docutils literal notranslate"><span class="pre">decltype(e)</span></code> は <code class="docutils literal notranslate"><span class="pre">e</span></code> で与えられている実体の型とする。そのような実体が存在しないか、オーバーロード関数の集合を与えるときには、このコードは ill-formed であるとする。</p></li>
<li><p>もしくは <code class="docutils literal notranslate"><span class="pre">e</span></code> が xvalue ならば <code class="docutils literal notranslate"><span class="pre">decltype(e)</span></code> は <code class="docutils literal notranslate"><span class="pre">T&amp;&amp;</span></code> とする。ここで <code class="docutils literal notranslate"><span class="pre">T</span></code> は <code class="docutils literal notranslate"><span class="pre">e</span></code> の型とする。</p></li>
<li><p>もしくは <code class="docutils literal notranslate"><span class="pre">e</span></code> が lvalue ならば <code class="docutils literal notranslate"><span class="pre">decltype(e)</span></code> は <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> とする。</p></li>
<li><p>それ以外の場合には <code class="docutils literal notranslate"><span class="pre">decltype(e)</span></code> は <code class="docutils literal notranslate"><span class="pre">e</span></code> の型そのものとする。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decltype</span></code> は変数宣言の用途にはあまり向かない。式自体を二度書く必要がある。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decltype</span></code> のオペランドは値には評価されない。例えば <code class="docutils literal notranslate"><span class="pre">decltype(2</span> <span class="pre">+</span> <span class="pre">3)</span></code>
とあっても、コンパイラーはこの和を使わない。型だけを見る。</p></li>
</ul>
<p>以下、標準の例コードからの引用だ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">foo</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
<span class="k">const</span> <span class="n">A</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">foo</span><span class="p">())</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// type is const int&amp;&amp;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// type is int</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">)</span> <span class="n">x3</span><span class="p">;</span> <span class="c1">// type is double</span>
<span class="k">decltype</span><span class="p">((</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">))</span> <span class="n">x4</span> <span class="o">=</span> <span class="n">x3</span><span class="p">;</span> <span class="c1">// type is const double&amp;</span>
</pre></div>
</div>
<p>テンプレートが絡むと話は複雑になるのだが、今はこれで十分だろう。</p>
</div>
<div class="section" id="for">
<h3><a class="toc-backref" href="#id37">範囲 <code class="docutils literal notranslate"><span class="pre">for</span></code> 文</a><a class="headerlink" href="#for" title="Permalink to this heading">¶</a></h3>
<p>よそのプログラミング言語ではおなじみの機能が C++11 に追加された。
<a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> のコードを引用する：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この記法が許されるコンテナーは生の配列か、<code class="docutils literal notranslate"><span class="pre">begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">end()</span></code> および反復子を進める機能を提供するコンテナー型オブジェクトだと思って問題ない。</p>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id38">初期化子リスト</a><a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>生の配列や POD 構造体のように、オブジェクトを <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">};</span></code> の構文で初期化できる機能だ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">anim</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;bear&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;cassowary&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;tiger&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">}};</span>
</pre></div>
</div>
<p>パラメーターリストにクラステンプレート <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> の引数を取るコンストラクターが提供されているクラスに対してそのような初期化が許される。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">explicit</span></code> コンストラクターの例はどうも好かない。</p></li>
<li><p>コンストラクターの他に、<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code> 呼び出し、 <code class="docutils literal notranslate"><span class="pre">return</span></code> 文などでも用いることができる。</p></li>
<li><p>初期化子リストに列挙した要素は、先頭から順番に評価される。</p></li>
<li><p>この機能の急所は、テンプレートやオーバーロードの仕様との絡み。いちいち確認するほうがいい。</p></li>
</ul>
</div>
<div class="section" id="brace-or-equal-initializer">
<h3><a class="toc-backref" href="#id39">一様初期化 <em>brace-or-equal-initializer</em></a><a class="headerlink" href="#brace-or-equal-initializer" title="Permalink to this heading">¶</a></h3>
<p>コンストラクターの呼び出しを丸括弧だけではなく、上述の初期化子リストを引数に取るコンストラクターの呼び出しと同じ構文で書ける。</p>
<ul>
<li><p>例えばデフォルトコンストラクターの呼び出しですら（厳密には細かい条件があるものの）こう書ける：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// いずれもデフォルトコンストラクターによる初期化を意味する。</span>
<span class="c1">// コピーコンストラクターもコピー代入演算子も呼び出されない。</span>
<span class="n">MyClass</span> <span class="n">x</span><span class="p">;</span>
<span class="n">MyClass</span> <span class="n">y</span><span class="p">{};</span>
<span class="n">MyClass</span> <span class="n">z</span> <span class="o">=</span> <span class="p">{};</span>
</pre></div>
</div>
<p>標準ではこのような初期化の記法を <em>brace-or-equal-initializer</em> と呼んでいる。特にその記法の構成要素である次のものを <em>braced-init-list</em> と呼ぶ：</p>
<ul class="simple">
<li><p>初期化子リスト（のカンマ区切り）を挟む中括弧全体もしくは</p></li>
<li><p>中身のない中括弧の組</p></li>
</ul>
</li>
<li><p>呼び出し時に列挙した要素は、先頭から順番に評価される。</p></li>
<li><p>この機能の急所もやはり初期化子リストと同様だ。</p></li>
</ul>
</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id40">右辺値参照・ムーブセマンティクス</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>右辺値・左辺値の定義は問題ない。C++03 以前のものが通じる。</p>
<p>と思ったら、C++11 から次のような式の分類法が導入されたようだ：</p>
<div class="figure align-center" id="id32">
<div class="mermaid">
            flowchart BT
glvalue &amp; rvalue --&gt; expression
lvalue --&gt; glvalue
xvalue --&gt; glvalue &amp; rvalue
prvalue --&gt; rvalue

linkStyle 0,1,2,3,4,5 stroke:#000,stroke-width:1px,fill:none;
classDef default fill:none,stroke:none;
        </div><p class="caption"><span class="caption-text">Expression category taxonomy</span><a class="headerlink" href="#id32" title="Permalink to this image">¶</a></p>
</div>
<ul>
<li><p>glvalue は lvalue または xvalue のどちらかに分類される。「一般化された左辺値」くらいの意味。</p>
<ul>
<li><p>lvalue とは関数またはオブジェクトを指す。</p>
<p>例： <code class="docutils literal notranslate"><span class="pre">ptr</span></code> をポインター型の式とすると <code class="docutils literal notranslate"><span class="pre">*ptr</span></code> は
<code class="docutils literal notranslate"><span class="pre">ptr</span></code> が指すオブジェクトまたは関数を参照する lvalue だ。</p>
<p>例：戻り型がある lvalue 参照であるような関数の呼び出し結果は lvalue だ。</p>
</li>
<li><p>xvalue もまたあるオブジェクトを、通常はその寿命の終わりが近い (expiring) ようなものを参照する。
xvalue は rvalue 参照を引き起こすような式の結果だ。</p>
<p>例：戻り型がある rvalue 参照であるような関数の呼び出し結果は xvalue だ。</p>
</li>
</ul>
</li>
<li><p>rvalue とは xvalue であるか、一時オブジェクトまたは部分オブジェクトであるか、あるいはオブジェクトに関係していない値だ。</p>
<ul>
<li><p>prvalue とは xvalue でない rvalue だ。</p>
<p>例：戻り型が参照でない関数の呼び出し結果は prvalue だ。</p>
<p>例：<code class="docutils literal notranslate"><span class="pre">12</span></code> とか <code class="docutils literal notranslate"><span class="pre">7.3e5</span></code> とか <code class="docutils literal notranslate"><span class="pre">true</span></code> のようなリテラル値もまた prvalue だ。</p>
</li>
</ul>
</li>
</ul>
<p>これは分類であるので、任意の C++ の式は
lvalue, xvalue, rvalue のいずれかちょうど一つに当てはまると言っている。</p>
</li>
<li><p>〈右辺値参照は、右辺値を束縛する参照である〉</p>
<ul class="simple">
<li><p>C++03 以前までの参照を <strong>左辺値参照</strong> と呼ぶようになったらしい。
<code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> だろうが <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code> だろうが左辺値参照だ。</p></li>
<li><p>C++11 から rvalue 専用の処理を記述する機能が提供される。</p></li>
<li><p>C++11 で追加になった <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> で宣言される参照型を <strong>右辺値参照</strong> と呼ぶ。</p></li>
</ul>
</li>
<li><p>〈C++11 以降では、代入式 2 の右辺の型は右辺値参照 <code class="docutils literal notranslate"><span class="pre">vector&lt;int&gt;&amp;&amp;</span></code> になり、左辺値参照とは区別して処理される。また、こうした処理のことを「<strong>ムーブ</strong>」と呼ぶ〉</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="n">vv</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">vv</span><span class="p">;</span> <span class="c1">// 代入式 1</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 代入式 2</span>
</pre></div>
</div>
<p>この式自体は <code class="docutils literal notranslate"><span class="pre">std::vector&lt;...&gt;::operator=(rhs)</span></code> の呼び出しとコンストラクターが組み合わさったものだ。本文はこの <code class="docutils literal notranslate"><span class="pre">rhs</span></code> が C++11 では rvalue 参照 <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> であると主張しているようだ。</p>
</li>
</ul>
<p>右辺値参照とは、ムーブされたオブジェクトを示すものだ。</p>
<ul>
<li><p>rvalue を <code class="docutils literal notranslate"><span class="pre">const</span></code> なし lvalue 参照することは許されない。</p></li>
<li><p>lvalue を rvalue 参照することは許されない。</p></li>
<li><p>〈右辺値参照で宣言された変数は右辺値ではなく、左辺値である〉</p>
<p><code class="docutils literal notranslate"><span class="pre">int&amp;&amp;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">0;</span></code> に対して <code class="docutils literal notranslate"><span class="pre">x</span></code> は lvalue であるということを言っている。したがって例えばこの後で <code class="docutils literal notranslate"><span class="pre">int&amp;&amp;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">x;</span></code> などとはできない。</p>
</li>
</ul>
<p>次に <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> について学習する。この関数の挙動を説明するのに右辺値参照の概念が要るのだ。</p>
<ul class="simple">
<li><p>〈ムーブされた変数は右辺値となり、それ以降使える保証はなくなる〉。この Hello world は実際にコードをコンパイルして実行するといい。コメント通りの挙動を確認できる。要するに、ムーブされた変数にもし名前が付いていたならば、それは「抜け殻」になっているので、もはや参照してはならない。</p>
<ul>
<li><p>とにかく <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> すると、その引数は xvalue 化してしかも寿命が尽きると考えればいい。</p></li>
<li><p>実効性のあるムーブはムーブ代入またはムーブ構築で起こると考える。</p></li>
<li><p>この関数自体は単なるキャストしかしていないので、実行時オーバーヘッドなどはない。それどころか実行コードを何ら生成しないまである。</p></li>
</ul>
</li>
<li><p>所有権の移動の実例は自然でわかりやすい。</p></li>
<li><p>C++11 から、コンストラクターおよび代入演算子に（従来型のコピーとは別の）ムーブ版が考えられるようになった。</p>
<ul>
<li><p>ムーブコンストラクターとムーブ代入演算子のシグニチャーに注目。<code class="docutils literal notranslate"><span class="pre">const</span></code> なし <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> 付き。実装例は想像しているとおり。</p></li>
<li><p><a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> の <code class="docutils literal notranslate"><span class="pre">large_class</span></code> のデモコードでは抜け殻のメンバー変数をクリアしていることに注意。</p></li>
</ul>
</li>
<li><p>〈標準ライブラリで提供されるクラスのほとんどは、このようなムーブコンストラクタを用意している〉代入演算子も同様。とにかく lvalue に対して <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> を介せばいい。</p></li>
<li><p>ムーブコンストラクター・ムーブ代入演算子は、それらのコピー版もそうであるように、コンパイラーが自動生成するケースがある。その条件は本文にある通りだが、ここではコピー演算、ムーブ演算の意味が明白でない（演算子ということか？）</p></li>
</ul>
<p>以下のトピックは以上を完全に習得してから学習すること。</p>
<ul>
<li><p>転送参照</p>
<ul>
<li><p>テンプレートや <code class="docutils literal notranslate"><span class="pre">auto</span></code> に <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> をつける場合は上記のときと意味が異なる。右辺値参照しか表さないとは限らない。
<a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> の説明によると、次の関数テンプレート <code class="docutils literal notranslate"><span class="pre">f</span></code> において実引数が</p>
<ul class="simple">
<li><p>lvalue ならば <code class="docutils literal notranslate"><span class="pre">x</span></code> は lvalue 参照となる。</p></li>
<li><p>rvalue ならば <code class="docutils literal notranslate"><span class="pre">x</span></code> は rvalue 参照となる。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>完全転送</p>
<ul>
<li><p>引数を転送参照で宣言した場合、安易にムーブできない。引数は rvalue 参照の場合と lvalue 参照の場合両方があり得る。</p>
<p>例えば上述の関数テンプレート <code class="docutils literal notranslate"><span class="pre">f()</span></code> の定義において、別の関数 <code class="docutils literal notranslate"><span class="pre">g()</span></code> に <code class="docutils literal notranslate"><span class="pre">x</span></code> を渡したいとする。
<code class="docutils literal notranslate"><span class="pre">x</span></code> が rvalue の場合にはムーブするのが自然なのでそうしたい。しかし <code class="docutils literal notranslate"><span class="pre">x</span></code> が lvalue の場合にはそのまま関数 <code class="docutils literal notranslate"><span class="pre">g()</span></code> に引き渡したい。こういう引数の引き渡し方を <strong>完全転送</strong> という。</p>
</li>
<li><p>関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::forward()</span></code> は完全転送を実現する。つまり lvalue 参照の場合はムーブせず、rvalue 参照の場合はムーブして渡す。この関数テンプレートは <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> と違ってテンプレートを明示しなければ呼び出せないのが急所だ。</p></li>
</ul>
</li>
</ul>
<p>あとはこの機能が必要になった背景・経緯を読んでおくといい。やはり <code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> はインターフェイスに問題があった。しかしそのおかげでここで観てきたような諸概念が標準に導入されたのだから良かった。</p>
<p>ちなみに <code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> は C++11 では廃止予定機能。</p>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id41">ラムダ式</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>Python の lambda 式と期待される役割は同じ。ありがたいことに lambda といちいちスペルアウトせずにそれを定義できる。</p></li>
<li><p>概要を理解したら <strong>capture</strong> と呼ばれる機能を理解する。</p>
<ul class="simple">
<li><p>copy と reference とで分類される。</p></li>
<li><p>すべての capture notation を習得する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">this</span></code> を capture した場合、lambda 式が定義する関数オブジェクトは当該クラスの <code class="docutils literal notranslate"><span class="pre">friend</span></code> 扱い。</p></li>
<li><p>〈ラムダ式がデフォルト引数に現れる場合、いかなるキャプチャもしてはならない〉</p></li>
</ul>
</li>
<li><p>文法を習得する。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&quot;[&quot; キャプチャリスト &quot;]&quot;
&quot;(&quot; パラメータリスト &quot;)&quot; &quot;mutable&quot; 例外仕様 属性
&quot;-&gt;&quot; 戻り値の型 &quot;{&quot; 関数の本体 &quot;}&quot;
</pre></div>
</div>
<p>このうちのいくつかは省略できる。</p>
</li>
<li><p>〈ラムダ式は、その場に関数オブジェクトのクラスを定義し、その一時オブジェクトを生成する。関数オブジェクトのクラスを「クロージャ型 (closure type)」、その一時オブジェクトを「クロージャオブジェクト (closure object)」という〉</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">mutable</span></code></p>
<ul class="simple">
<li><p>copy capture した変数を変更するためにこの記述をパラメーターリストの直後に要する。</p></li>
</ul>
</li>
<li><p>〈戻り値の型を省略した場合、その戻り値型は、関数本体の <code class="docutils literal notranslate"><span class="pre">return</span></code> 文から推論される〉ので、次のようなコードは許されない：</p>
<ul class="simple">
<li><p>複数の <code class="docutils literal notranslate"><span class="pre">return</span></code> パスが存在するときに、それらの戻り値の推論型が一致しない場合</p></li>
<li><p>リテラルの <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> による初期化リスト</p></li>
</ul>
</li>
<li><p>〈キャプチャを含まないラムダ式によって生成されたクロージャオブジェクトは、同じパラメータ型と戻り値型のシグニチャを持つ関数ポインタに変換できる〉</p></li>
</ul>
<p>〈標準 C++ のアルゴリズムライブラリには、関数を引数とするものが多くある。それらは各問題を解くために非常に有用ではあったが、アルゴリズムを使用するたびに関数オブジェクトを定義することは非常に冗長で使いにくかった。アルゴリズムをより使いやすくするための言語サポートとして、ラムダ式が導入されることとなった〉</p>
</div>
<div class="section" id="noexcept">
<h3><a class="toc-backref" href="#id42">キーワード <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></a><a class="headerlink" href="#noexcept" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">noexcept</span></code> は C++ という言語の基本にある例外送出に関係する重要な概念なので優先度は高い。</p>
<ul>
<li><p>新キーワード <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> は、関数宣言において、例外を送出するか否かを明示するキーワードだ。必ずしも書かなくともよい。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">h</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>関数が例外を送出するか否かをコンパイル時に判定する演算子</p>
<ul class="simple">
<li><p>関数呼び出しを <code class="docutils literal notranslate"><span class="pre">noexcept()</span></code> で括る。すると例外を送出する可能性のあるものは <code class="docutils literal notranslate"><span class="pre">false</span></code> に展開される。</p></li>
<li><p>その呼び出し自体は実行時に実行されない。</p></li>
</ul>
</li>
<li><p>指定が書いてなければ関数のほとんどは <code class="docutils literal notranslate"><span class="pre">noexcept(false)</span></code> としてコンパイラーが関数を扱う。その例外がデストラクターと <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code> であり、コンパイラーは <code class="docutils literal notranslate"><span class="pre">noexcept(true)</span></code> とみなす。このへんの理由は C++03 時代の書籍で理解できるだろう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noexcept</span></code> の利点の一つにパフォーマンス向上があることに注意。その理由は例外送出時のスタック巻き戻しに必要なメモリ領域を確保するのを省くようになるからだと。もう一つの理由はもちろん no-throw 保証。</p></li>
<li><p>関数宣言のときに用いる <code class="docutils literal notranslate"><span class="pre">throw</span></code> による例外指定は C++11 で廃止予定機能となった。注意。</p>
<ul class="simple">
<li><p>どんな例外を送出するのかということより、例外送出の有無が本質的だったようだ。</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="constexpr">
<h3><a class="toc-backref" href="#id43">定数式 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code></a><a class="headerlink" href="#constexpr" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> は誤解なきよう習得すること。それと <code class="docutils literal notranslate"><span class="pre">std::numeric_limits</span></code> の従来の実装に関する〈抽象化された機能を使うより、抽象化されていない機能の方がよい、というのは、改善すべき事態だった〉という <a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> の一文が印象的だ。</p>
<p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> の目的は値、関数、リテラルを翻訳時に処理するものを宣言することにあるようだ。したがって``constexpr`` を宣言できるのは次のものに限られる：</p>
<blockquote>
<div><ul class="simple">
<li><p>変数定義</p></li>
<li><p>関数宣言、テンプレート関数宣言</p></li>
<li><p>リテラル型の静的メンバー変数の宣言</p></li>
</ul>
</div></blockquote>
<p>あとは細かいルールの列挙になるので、仕様書を見たほうがいい。</p>
<ul class="simple">
<li><p>関数宣言やテンプレート関数宣言のどれか一つでも <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> であるならばその宣言のすべてが <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> でなければならない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 関数および <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> コンストラクターは暗黙的に <code class="docutils literal notranslate"><span class="pre">inline</span></code> となる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 関数の定義には次の制約をすべて満たすものとする：</p>
<ul>
<li><p>仮想関数であってはならない。</p></li>
<li><p>戻り値はリテラル型でなければならない。</p></li>
<li><p>引数の一つ一つがリテラル型でなければならない。</p></li>
<li><p>関数本体が <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span></code> または <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">default</span></code> である。そうでなければ、次に挙げるもの以外を含まない複合文でなければならない：</p>
<ul>
<li><p>空の文</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">static_assert()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">typedef</span></code> 宣言、クラスや列挙型を定義しないような別名宣言</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">using</span></code> 宣言</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">using</span></code> 指令</p></li>
<li><p>厳密に一つの <code class="docutils literal notranslate"><span class="pre">return</span></code> 文</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> コンストラクターの定義では、引数型のそれぞれはリテラル型であるものとする。さらにその関数本体は</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span></code> または <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">default</span></code> であるか、</p></li>
<li><p>上述の制約によく似た制約をすべて満たすものとする。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 関数に対する呼び出しは、あらゆる点において、それと等価な非
<code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 関数に対する呼び出しと同じ結果を生じる。</p></li>
<li><p>コンストラクターを除く非静的メンバー関数に対する <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 指示子は、そのメンバー関数が <code class="docutils literal notranslate"><span class="pre">const</span></code> であることを宣言している。</p>
<ul>
<li><p>なお、メンバー関数に <code class="docutils literal notranslate"><span class="pre">const</span></code> を書いたとしてもコンパイラーはそれを無視する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> メンバー関数を有するクラスはリテラル型であるものとする。</p></li>
</ul>
</li>
<li><p>オブジェクト宣言での <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 指示子はそのオブジェクトが <code class="docutils literal notranslate"><span class="pre">const</span></code> であることを宣言している。そのようなオブジェクトはリテラル型かつ初期化を伴っているものとする。</p></li>
<li><p>あとはテンプレートと絡んだ仕様があるが省略。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>仕様書の定義を読むとすごく時間がかかる。何か直観に訴えるノートにしたい。</p>
</div>
</div>
<div class="section" id="nullptr">
<h3><a class="toc-backref" href="#id44">空ポインター <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></a><a class="headerlink" href="#nullptr" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">nullptr</span></code> の特性はまともな C++03 プログラマーの直観と合致する。しかし <code class="docutils literal notranslate"><span class="pre">0</span></code> と書くほうが楽なのだが。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nullptr</span></code> は唯一のポインターリテラルであり、予約語の形で提供されている。</p></li>
<li><p>型 <code class="docutils literal notranslate"><span class="pre">std::nullptr_t</span></code> の純右辺値 (prvalue) ということになっている。つまり <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code> と同じ立場にいる値だ。</p></li>
</ul>
</div>
<div class="section" id="inline-namespace">
<h3><a class="toc-backref" href="#id45">インライン名前空間 <code class="docutils literal notranslate"><span class="pre">inline</span> <span class="pre">namespace</span></code></a><a class="headerlink" href="#inline-namespace" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">inline</span> <span class="pre">namespace</span></code> はどういう立場になったときに使うのか。</p>
<ul>
<li><p>C++11 で <code class="docutils literal notranslate"><span class="pre">inline</span> <span class="pre">namespace</span></code> という構文が追加された。</p></li>
<li><p>この機能の急所は <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span></code> 文で何がスコープに持ち込まれるのかを見分けることと、引数依存の名前探索ルールを理解することだろう。例えば <a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> の例だが：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">my_namespace</span>
<span class="p">{</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">features</span>
    <span class="p">{</span>
        <span class="kt">void</span> <span class="n">f</span><span class="p">(){</span> <span class="p">...</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">(){</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">my_namespace::features</span></code> の一文だけで
<code class="docutils literal notranslate"><span class="pre">f</span></code> と <code class="docutils literal notranslate"><span class="pre">g</span></code> の両方を宣言するスコープに持ち込める。</p>
</li>
<li><p>このリファレンスの記事だけでは名前なし <code class="docutils literal notranslate"><span class="pre">inline</span> <span class="pre">namespace</span></code> の概要がわからない？</p></li>
</ul>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id46">ユーザー定義リテラル</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>ユーザー定義リテラルはシグニチャーが風変わりであることだけを頭に入れて後回し。</p>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id47">クラス</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<div class="section" id="default-delete">
<h3><a class="toc-backref" href="#id48">キーワード <code class="docutils literal notranslate"><span class="pre">default</span></code>/<code class="docutils literal notranslate"><span class="pre">delete</span></code></a><a class="headerlink" href="#default-delete" title="Permalink to this heading">¶</a></h3>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">default</span></code>, <code class="docutils literal notranslate"><span class="pre">delete</span></code> を関数宣言に付与する使い方。<a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> の当該記事の要約は理想的。そしてこれらの用法は要習得。便利なので。</p>
<p>一定の種類のクラスを定義するときに、ユーザーがそれを明示的に定義しなければ一定の特別なメンバー関数をコンパイラーが自動生成する。
C++11 では、その「暗黙の定義を使う」という宣言を明示的にコードに表すことができる。それが <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">default</span></code> 記法だ。</p>
<p><strong>特別メンバー関数</strong> とは次のメンバー関数の総称だ：</p>
<ul class="simple">
<li><p>デフォルトコンストラクター</p></li>
<li><p>コピーコンストラクター</p></li>
<li><p>コピー代入演算子</p></li>
<li><p>ムーブコンストラクター</p></li>
<li><p>ムーブ代入演算子</p></li>
<li><p>デストラクター</p></li>
</ul>
<p>反対に、コンパイラーに自動生成を禁止するように指示するのが <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span></code> 記法だ。例えば Singleton クラスを定義するときにこれが有用であることは想像できる。
C++03 では <code class="docutils literal notranslate"><span class="pre">private</span></code> メンバーとして宣言だけしておくという技法を用いていた。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span></code> はフリー関数にも適用可能。これは特定のオーバーロードを禁じるという用法になる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">default</span></code> は関数定義にも書かれる。他方 <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span></code> は宣言時に限定される。</p></li>
</ul>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id49">委譲コンストラクター</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<p>委譲コンストラクターも要習得。コンストラクターが複数あるクラスを書いたことがある人間ならばこの新機能の意義は肌感覚で理解できる。</p>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id50">非静的メンバーの初期化</a><a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<p>非静的メンバ変数の初期化。コンストラクターの定義によってはこの代入が実際に行われないことがあることに注意。</p>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id51">継承コンストラクター</a><a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h3>
<p>派生クラスのコンストラクターの引数リストは基底クラスのそれと同じになりがちだということで生まれた新機能。
<code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">BaseClassName::BaseClassName;</span></code> を派生クラスに一筆加える。オプショナルに、その上派生クラス独自の定義をしてもよい。</p>
</div>
<div class="section" id="final-override">
<h3><a class="toc-backref" href="#id52">キーワード <code class="docutils literal notranslate"><span class="pre">final</span></code>/<code class="docutils literal notranslate"><span class="pre">override</span></code></a><a class="headerlink" href="#final-override" title="Permalink to this heading">¶</a></h3>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">final</span></code> は用途が二つある。クラス丸ごとと仮想メンバー関数ごと。</p>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">override</span></code> の存在がうれしいかと言われると微妙だ。オーバーライドするつもりが間違えてオーバーロードになってしまうミスを防ぐくらいにしか役に立たない？</p>
<p>これらのキーワードはコンテキスト依存キーワードという特別なキーワードとのこと。</p>
<p>この記事では角括弧を二重に使う新文法が見える。これは属性構文というもので後述する。</p>
</div>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id53">明示的な型変換演算子のオーバーロード</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<p>C++03 以前に <code class="docutils literal notranslate"><span class="pre">explicit</span></code> コンストラクターというのがある。この考え方を
C++11 では型変換演算子 <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">T()</span></code> にも適用できる。</p>
<p>これはいい仕様追加だ。</p>
<p><a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> のサンプルコードが実のところ少し高級かもしれない。
<code class="docutils literal notranslate"><span class="pre">bool</span></code> 型でないほうがわかりやすい？</p>
</div>
<div class="section" id="friend">
<h3><a class="toc-backref" href="#id54"><code class="docutils literal notranslate"><span class="pre">friend</span></code> 宣言の要件の緩和</a><a class="headerlink" href="#friend" title="Permalink to this heading">¶</a></h3>
<p>私は <code class="docutils literal notranslate"><span class="pre">friend</span></code> 機能を一切採用しないのでスキップ。<a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> の記事も短いし。</p>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id55">メンバ関数の左辺値／右辺値修飾</a><a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span>
    <span class="n">voif</span> <span class="nf">g</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>メンバー関数が左辺値・右辺値である場合にしか呼び出されないことを保証する記法が仕様に含まれた。メンバー関数の宣言の末尾に <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> または <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> を付加することでそのような制限を加えることを意味する。〈これを使用することで、「一時オブジェクトな <code class="docutils literal notranslate"><span class="pre">*this</span></code> に対して特定のメンバ関数を呼び出せてはならない制約」、「<code class="docutils literal notranslate"><span class="pre">*this</span></code> が左辺値もしくは右辺値である場合の効率的な実装を使い分ける」といった設計ができるようになる〉。</p>
<p>サンプルコード。〈参照を返すと一時オブジェクトの寿命が尽きてしまうため、ムーブで返す〉とある。これだと何か悪いことを避けているように読めるが違う。ここで示しているのは、むしろ寿命が尽きることを利用して <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> を使ってデータを流用してコピーを避けるという優れた技法だ。</p>
</div>
</div>
<div class="section" id="id12">
<h2><a class="toc-backref" href="#id56">クラス以外の型に関する機能</a><a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h2>
<div class="section" id="scoped-enum">
<h3><a class="toc-backref" href="#id57">Scoped <code class="docutils literal notranslate"><span class="pre">enum</span></code></a><a class="headerlink" href="#scoped-enum" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>新文法 <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> で列挙型を定義すると、暗黙の型変換が無効になり、列挙子が列挙型スコープを有する。</p></li>
<li><p>「基底型」を宣言することができる。列挙子が少なければ <code class="docutils literal notranslate"><span class="pre">char</span></code> で十分とか？</p>
<ul>
<li><p>従来の <code class="docutils literal notranslate"><span class="pre">enum</span></code> にもこれが適用できる。</p></li>
</ul>
</li>
<li><p>これにより列挙型の前方宣言が可能になった。宣言と定義の「ガワ」は一致していなければならない。</p></li>
</ul>
</div>
<div class="section" id="union">
<h3><a class="toc-backref" href="#id58"><code class="docutils literal notranslate"><span class="pre">union</span></code> に対する規制緩和</a><a class="headerlink" href="#union" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">union</span></code> のメンバー変数にユーザー定義型オブジェクトを置くことができる。共用体は全く使わないのでどうでもいい。</p>
</div>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id59">テンプレート</a><a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h2>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id60">テンプレートの <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> を空白を挟まずに書けるようになった</a><a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h3>
<p>これは仕事で C++ をやった人間なら一発で理解できる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">positions</span><span class="p">;</span>
</pre></div>
</div>
<p>みたいなものが次のように書けるようになったということ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">positions</span><span class="p">;</span>
</pre></div>
</div>
<p>コンパイラーが後の方の宣言を <code class="docutils literal notranslate"><span class="pre">operator&gt;&gt;</span></code> として扱って結果的に構文エラーになっていた。
C++11 でこれがなくなる。</p>
</div>
<div class="section" id="extern-template">
<h3><a class="toc-backref" href="#id61">外部テンプレート <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">template</span></code></a><a class="headerlink" href="#extern-template" title="Permalink to this heading">¶</a></h3>
<p>クラステンプレート C または関数テンプレート F が存在して、それを実体化するとサイズが巨大になるようなものであると仮定する。さらに、複数の cpp で C または F を参照するとし、cpp の一つで特定の実体化がされているとする。</p>
<p>このとき、別の cpp で次のように宣言すると、その cpp では実体化をしなくなる。別の cpp の実体化を参照するのだろう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">C</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">template</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">the_parameter_list</span><span class="p">);</span>
</pre></div>
</div>
<p>この機能をどうやって検証しよう？</p>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id62">別名テンプレート</a><a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<p>テンプレートを含む型に別名をつける方法ができた。例えば次のようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Vec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">using</span></code> の強化の話をまだ学習していないことに注意。別名定義はテンプレートが関係していなくてもいい。例えば次のような宣言も正しい：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">VecInt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id63">可変引数テンプレート</a><a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;typename...</span> <span class="pre">Args&gt;</span></code> というような文法になる。この <code class="docutils literal notranslate"><span class="pre">...</span></code> はこのままタイプする。ここで <code class="docutils literal notranslate"><span class="pre">Args</span></code> のことを parameter pack という。</p>
<p>定義中で paramter pack を他の要素に転送するときは <code class="docutils literal notranslate"><span class="pre">Args...</span></code> というような記法を使う。</p>
<ul class="simple">
<li><p>問題はたぶん parameter pack の要素を一つずつ参照・処理する場合だろう。</p></li>
<li><p>サンプルコードを g++ (GCC) 10.2.0 でコンパイルしたら時間がかかって驚く。</p></li>
</ul>
<p>あと paramter pack の拡張機能というのがある。要素それぞれに同じ処理を適用する式を書くこともできる。これは使うかもしれない。</p>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id64">ローカル型と無名型をテンプレート実引数として使用することができる</a><a class="headerlink" href="#id17" title="Permalink to this heading">¶</a></h3>
<p>〈ローカルで定義した型と、名前のない型を、テンプレート引数として渡すことが許可された〉そうだ。</p>
<p>関数スコープで古典的な <code class="docutils literal notranslate"><span class="pre">enum</span></code> を定義することを考える。これは無名列挙型として定義する必要がある。そうなると、そのスコープから関数テンプレートなどの実引数として列挙子を与えるコードがコンパイルエラーを引き起こしていた。関数スコープでの定義を諦めることで回避していたが、その必要がなくなる。</p>
</div>
<div class="section" id="sfinae">
<h3><a class="toc-backref" href="#id65">SFINAE 強化</a><a class="headerlink" href="#sfinae" title="Permalink to this heading">¶</a></h3>
<p>SFINAE の概念については <em>Exceptional C++</em> あたりを参照すること。ほんとうの問題は私が SFINAE を必要とするコードを書く可能性があるかどうかだ。ないと思う。</p>
</div>
<div class="section" id="id18">
<h3><a class="toc-backref" href="#id66">テンプレートのエクスポート機能を削除</a><a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h3>
<p>ここは読まなくていい。</p>
</div>
</div>
<div class="section" id="id19">
<h2><a class="toc-backref" href="#id67">並行プログラミング</a><a class="headerlink" href="#id19" title="Permalink to this heading">¶</a></h2>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id68">スレッドローカルストレージ</a><a class="headerlink" href="#id20" title="Permalink to this heading">¶</a></h3>
<p>〈変数宣言の際に、記憶域として <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> キーワードを指定することで、スレッドごとの静的記憶域に変数が保持される〉ので、このような変数は
<code class="docutils literal notranslate"><span class="pre">static</span></code> であると考えるほうが理解しやすい。スレッド別に <code class="docutils literal notranslate"><span class="pre">static</span></code> なわけだ。</p>
<p>乱数のほうのサンプルコード、改行文字を出力するコードを
<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span> <span class="pre">std::endl</span></code> に書き換えて実行すると面白いことに改行されない。</p>
</div>
<div class="section" id="static">
<h3><a class="toc-backref" href="#id69">ブロックスコープを持つ <code class="docutils literal notranslate"><span class="pre">static</span></code> 変数初期化のスレッドセーフ化</a><a class="headerlink" href="#static" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">static</span></code> 変数の初期化のときに暗黙的にロックがかかるようになったと解釈してよいだろうか。</p>
</div>
</div>
<div class="section" id="id21">
<h2><a class="toc-backref" href="#id70">その他</a><a class="headerlink" href="#id21" title="Permalink to this heading">¶</a></h2>
<div class="section" id="id22">
<h3><a class="toc-backref" href="#id71">戻り値の型を後置する関数宣言構文</a><a class="headerlink" href="#id22" title="Permalink to this heading">¶</a></h3>
<p>従来の関数宣言文法に加え、戻り値の型をとりあえず <code class="docutils literal notranslate"><span class="pre">auto</span></code> と書いておいて、パラメーターリストの後に <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> を書いて最後に戻り値の型を（おそらく間接的な形式で）書く文法が追加された。</p>
</div>
<div class="section" id="assertion">
<h3><a class="toc-backref" href="#id72">コンパイル時 assertion</a><a class="headerlink" href="#assertion" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">static_assert()</span></code> が言語レベルでサポートされるようになった。
Boost にあった類似機能が標準に昇格したのだろう。あちらはマクロだったと記憶している。</p>
<ul class="simple">
<li><p>コンパイルオプションによっては第二引数を与えなければエラーになる。例えば <code class="docutils literal notranslate"><span class="pre">g++</span></code> ならば <code class="docutils literal notranslate"><span class="pre">-std=c++17</span></code> が必要。つまり C++17 から引数がちょうど一個であるオーバーロードを追加したということか。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">static_assert()</span></code> は <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> な何かを引数に取ると覚えておくといいだろう。</p></li>
</ul>
</div>
<div class="section" id="id23">
<h3><a class="toc-backref" href="#id73">生文字列リテラル</a><a class="headerlink" href="#id23" title="Permalink to this heading">¶</a></h3>
<p>Python でいう <code class="docutils literal notranslate"><span class="pre">r'...'</span></code> に相当する仕様。SQL にもある。ユースケースも同じ。
C++11 では <code class="docutils literal notranslate"><span class="pre">R&quot;(...)&quot;</span></code> という形で書く。括弧については変種を許す。</p>
</div>
<div class="section" id="utf-16-utf-32">
<h3><a class="toc-backref" href="#id74">UTF-16 と UTF-32 の文字型</a><a class="headerlink" href="#utf-16-utf-32" title="Permalink to this heading">¶</a></h3>
<p>使いにくそう。</p>
<ul class="simple">
<li><p>C++11 では新しく組み込み型 <code class="docutils literal notranslate"><span class="pre">char16_t</span></code> と <code class="docutils literal notranslate"><span class="pre">char32_t</span></code> が加わる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u&quot;...&quot;</span></code> と <code class="docutils literal notranslate"><span class="pre">U&quot;...&quot;</span></code> でそれぞれ <code class="docutils literal notranslate"><span class="pre">char16_t</span></code> 型配列と <code class="docutils literal notranslate"><span class="pre">char32_t</span></code> 型配列のリテラルを宣言できる。</p></li>
</ul>
<p>等々。Unicode の知識が要る。</p>
</div>
<div class="section" id="utf-8">
<h3><a class="toc-backref" href="#id75">UTF-8 文字列リテラル</a><a class="headerlink" href="#utf-8" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">u8</span></code> プレフィクスを付与した文字列リテラルがあるとする。これはコンパイル時に UTF-8 に符号化される。</p>
</div>
<div class="section" id="id24">
<h3><a class="toc-backref" href="#id76">属性構文</a><a class="headerlink" href="#id24" title="Permalink to this heading">¶</a></h3>
<p>二重の角括弧で囲まれた属性を C++ コードの構成要素に付与することで、コンパイラーが助かるらしい。今は <code class="docutils literal notranslate"><span class="pre">[[noreturn]]</span></code> と <code class="docutils literal notranslate"><span class="pre">[[carries_dependency]]</span></code> の二つしかない。</p>
<p><code class="docutils literal notranslate"><span class="pre">[[noreturn]]</span></code> は関数に対する属性であって、文字通り <code class="docutils literal notranslate"><span class="pre">return</span></code> することがない関数に付与する。
<a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> の例では、実行時に必ず例外が送出する関数に対して適用している。</p>
<p><code class="docutils literal notranslate"><span class="pre">[[carries_dependency]]</span></code> は難しい。並行プログラミングで用いられる。関数に付与するものと、引数に付与するものの二種類ある。あとでやろう。</p>
</div>
<div class="section" id="alignas">
<h3><a class="toc-backref" href="#id77">演算子 <code class="docutils literal notranslate"><span class="pre">alignas</span></code> - アライメントを指定する</a><a class="headerlink" href="#alignas" title="Permalink to this heading">¶</a></h3>
<p>C/C++ のコードを機械語レベルに落として考えるプログラマーならこの機能の役割はすぐにわかると思う。</p>
<p>〈構造体やクラスの宣言時に使用した場合、その型のインスタンス全てをアライメントする〉とある。例えば 28 バイトの構造体を定義しても、その型の変数を定義するとアドレスが 32 バイト境界に揃えられるということだろう。</p>
<p>このルールは構造体やクラスのメンバー変数についても適用される。</p>
<p><code class="docutils literal notranslate"><span class="pre">alinas(nn)</span> <span class="pre">typename</span> <span class="pre">identifier;</span></code> のような文法で指定する（ここで <code class="docutils literal notranslate"><span class="pre">alinas</span></code> だけがキーワード）。</p>
<p><a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> のサンプルコードは 4 バイト型の align を 1, 2 などで指定しようと試みていることに注意。そんなことはできないので結局 4 バイト境界揃えになる。</p>
<p>g++ (GCC) 10.0.2 では <code class="docutils literal notranslate"><span class="pre">alinas(0)</span></code> は認められない。あるいはコンパイルオプションの指定が悪いのかもしれない。</p>
</div>
<div class="section" id="alignof">
<h3><a class="toc-backref" href="#id78">演算子 <code class="docutils literal notranslate"><span class="pre">alignof</span></code> - アライメントを取得する</a><a class="headerlink" href="#alignof" title="Permalink to this heading">¶</a></h3>
<p>演算子 <code class="docutils literal notranslate"><span class="pre">alignof</span></code> は型に対して作用する。<code class="docutils literal notranslate"><span class="pre">sizeof</span></code> が型にも変数にも作用するのとは違う。</p>
<p>さっきの演算子も含め alignment 関連の演算子は C++ ではなく C の仕様とするべきだと思う（たぶんそうなっている）。</p>
<p><a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> のデモコードに対しては 32bit 環境での結果が掲載されている。
64bit 環境で出力すると結果の一部が 4 から 8 になる。</p>
</div>
</div>
<div class="section" id="id25">
<h2><a class="toc-backref" href="#id79">小さな変更</a><a class="headerlink" href="#id25" title="Permalink to this heading">¶</a></h2>
<div class="section" id="id26">
<h3><a class="toc-backref" href="#id80">更新された定義済みマクロ</a><a class="headerlink" href="#id26" title="Permalink to this heading">¶</a></h3>
<p>読まなくていい。</p>
</div>
<div class="section" id="id27">
<h3><a class="toc-backref" href="#id81">機能テストマクロ</a><a class="headerlink" href="#id27" title="Permalink to this heading">¶</a></h3>
<p>g++ (GCC) 10.0.2 では <code class="docutils literal notranslate"><span class="pre">__has_cpp_attribute(carries_dependency)</span></code> が使えないようだ。</p>
</div>
<div class="section" id="id28">
<h3><a class="toc-backref" href="#id82">テンプレート再帰回数の制限緩和</a><a class="headerlink" href="#id28" title="Permalink to this heading">¶</a></h3>
<p>読まなくていい。</p>
</div>
<div class="section" id="typename-template">
<h3><a class="toc-backref" href="#id83">キーワード <code class="docutils literal notranslate"><span class="pre">typename</span></code> および <code class="docutils literal notranslate"><span class="pre">template</span></code> の適用範囲拡大</a><a class="headerlink" href="#typename-template" title="Permalink to this heading">¶</a></h3>
<p><a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> のデモコードの関数 <code class="docutils literal notranslate"><span class="pre">main</span></code> の二行とも、従来は何かのテンプレートの中でしか書けないコードだった。二行目は C++03 時代でもお目にかかったことがない文法だが。</p>
</div>
<div class="section" id="id29">
<h3><a class="toc-backref" href="#id84">入れ子の指定にグローバルスコープ <code class="docutils literal notranslate"><span class="pre">::</span></code> を付加する</a><a class="headerlink" href="#id29" title="Permalink to this heading">¶</a></h3>
<p><a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> の記事だけでは何のことか理解できないので、あとで仕様を見に行く。</p>
</div>
<div class="section" id="id30">
<h3><a class="toc-backref" href="#id85">前方宣言時要素数指定配列機能</a><a class="headerlink" href="#id30" title="Permalink to this heading">¶</a></h3>
<p>これは試すのが面倒臭い。そしてこれも詳細がわからない（意味はわかる）。</p>
</div>
<div class="section" id="std-posix-posix">
<h3><a class="toc-backref" href="#id86">名前空間 <code class="docutils literal notranslate"><span class="pre">std::posix</span></code> および <code class="docutils literal notranslate"><span class="pre">::posix</span></code></a><a class="headerlink" href="#std-posix-posix" title="Permalink to this heading">¶</a></h3>
<p>これらの名前空間が予約された。我々一般プログラマーはこの名前空間を定義してはならない。</p>
</div>
<div class="section" id="sizeof">
<h3><a class="toc-backref" href="#id87">演算子 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> が非静的メンバー変数をオペランドにとれる</a><a class="headerlink" href="#sizeof" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">sizeof</span> <span class="pre">MyClass::my_member</span></code> のような書き方が許されるようになった。クラス <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> のどのオブジェクトも <code class="docutils literal notranslate"><span class="pre">sizeof</span> <span class="pre">my_member</span></code> の値は等しいのだから問題ない。</p>
</div>
<div class="section" id="register">
<h3><a class="toc-backref" href="#id88">キーワード <code class="docutils literal notranslate"><span class="pre">register</span></code> は廃止予定要素となった</a><a class="headerlink" href="#register" title="Permalink to this heading">¶</a></h3>
<p>いにしえの記憶域制御系キーワードだが、ついに廃止予定要素になった。遠い未来の C++ では <code class="docutils literal notranslate"><span class="pre">auto</span></code> のように転生するかもしれない。</p>
</div>
<div class="section" id="id31">
<h3><a class="toc-backref" href="#id89">参照への参照はエラーではなくなった</a><a class="headerlink" href="#id31" title="Permalink to this heading">¶</a></h3>
<p>テンプレートメタプログラミングでありがちなコンパイルエラーであったが、これが C++11 からコンパイラーは単なる参照として扱うようになる。</p>
</div>
</div>
<div class="section" id="c99">
<h2><a class="toc-backref" href="#id90">C99 互換機能</a><a class="headerlink" href="#c99" title="Permalink to this heading">¶</a></h2>
<p>C++11 というより C の仕様なのでここでは細かく分析しない。</p>
<ul class="simple">
<li><p>ノートにはとらないが <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> の件はふつうに重要なので一読すること。64bit 固定とは意味が異なる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__func__</span></code> は Python にも似たものがある (<code class="docutils literal notranslate"><span class="pre">__func__.__name__</span></code>) が、<code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">const</span> <span class="pre">char*</span></code>
型の変数として関数名をその関数のスコープの内部から参照できる。</p></li>
<li><p>列挙子の末尾へのカンマ付加を許可。まさか <code class="docutils literal notranslate"><span class="pre">enum</span></code> しか認められていない？</p></li>
<li><p>divmod 演算の丸め結果はだいじなので学習する。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> を負かもしれない整数型変数とする。いちおう断るが <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">!=</span> <span class="pre">0</span></code> とする。このとき値 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">/</span> <span class="pre">b</span></code> は整数であって、この除算を小数で考えるときに得られる商をゼロ方向に丸める値と等しいものとする。</p></li>
<li><p>恒等式 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">/</span> <span class="pre">b)</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span> <span class="pre">==</span> <span class="pre">a</span></code> を憶えること。</p></li>
</ul>
</li>
</ul>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="index.html" title="Previous document">What’s New In C++11 ノート</a>
        </li>
        <li>
          <a href="library.html" title="Next document">What’s New In C++11 標準ライブラリー</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power-toys.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">What’s New In C++11 ノート</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">What’s New In C++11 ノート</a></li>
      <li>Next: <a href="library.html" title="next chapter">What’s New In C++11 標準ライブラリー</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>