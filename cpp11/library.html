
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>What’s New In C++11 標準ライブラリー &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/prefab.css" />
    
    <script src="../_static/mathjax-v3.js"></script>
    <script src="../_static/mermaid.js"></script>
    
    <link rel="next" title="What’s New In C++14 ノート" href="../cpp14/index.html" />
    <link rel="prev" title="What’s New In C++11 言語仕様" href="language.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../cpp14/index.html" title="What’s New In C++14 ノート"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="language.html" title="What’s New In C++11 言語仕様"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What’s New In C++11 ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">What’s New In C++11 標準ライブラリー</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-c-11">
<h1><a class="toc-backref" href="#id17">What’s New In C++11 標準ライブラリー</a><a class="headerlink" href="#what-s-new-in-c-11" title="Permalink to this headline">¶</a></h1>
<p>このノートでは C++11 で注目すべき標準ライブラリーの機能を学習する。すでに <a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> がそのへんをきれいに整理している。それを利用して、読みながら急所を記していくことにする。興味のないもの、知らなくて良いものは積極的に無視する。</p>
<p>以下、断っても断らなくても名前空間 <code class="docutils literal notranslate"><span class="pre">std</span></code> にライブラリー要素があるものとする。</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#what-s-new-in-c-11" id="id17">What’s New In C++11 標準ライブラリー</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id18">コンテナー</a></p>
<ul>
<li><p><a class="reference internal" href="#std-array" id="id19">固定長配列 <code class="docutils literal notranslate"><span class="pre">std::array</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-forward-list" id="id20">単方向リンクリスト <code class="docutils literal notranslate"><span class="pre">std::forward_list</span></code></a></p></li>
<li><p><a class="reference internal" href="#id2" id="id21">ハッシュベースの連想コンテナー</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id22">コンテナー全般がムーブセマンティクスに対応</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id23">初期化子リストでオブジェクトを初期化できる</a></p></li>
<li><p><a class="reference internal" href="#std-initializer-list" id="id24">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> 追加</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id5" id="id25">反復子</a></p>
<ul>
<li><p><a class="reference internal" href="#std-next-std-prev" id="id26">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::next()</span></code> および <code class="docutils literal notranslate"><span class="pre">std::prev()</span></code> 追加</a></p></li>
<li><p><a class="reference internal" href="#std-move-iterator" id="id27">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::move_iterator</span></code> 追加</a></p></li>
<li><p><a class="reference internal" href="#std-begin-std-end" id="id28">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::begin()</span></code> および <code class="docutils literal notranslate"><span class="pre">std::end()</span></code> 追加</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id6" id="id29">アルゴリズム</a></p>
<ul>
<li><p><a class="reference internal" href="#std-all-of-std-any-of" id="id30">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::all_of()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::any_of()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-find-if-not" id="id31">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::find_if_not()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-copy-n" id="id32">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::copy_n()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-copy-if" id="id33">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::copy_if()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-move-std-move-backward" id="id34">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::move()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::move_backward()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-shuffle" id="id35">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::shuffle()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-is-sorted" id="id36">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::is_sorted()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-min-std-max" id="id37">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::min()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::max()</span></code> に初期化リスト版追加</a></p></li>
<li><p><a class="reference internal" href="#std-minmax-std-minmax-element" id="id38">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::minmax()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::minmax_element()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-iota" id="id39">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::iota()</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id7" id="id40">メモリー管理</a></p>
<ul>
<li><p><a class="reference internal" href="#std-allocator-traits" id="id41">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::allocator_traits</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-shared-ptr-std-unique-ptr" id="id42">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> および <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-auto-ptr" id="id43">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> を廃止予定要素とする</a></p></li>
<li><p><a class="reference internal" href="#std-addressof" id="id44">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::addressof()</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id8" id="id45">入出力</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id46">文字列処理</a></p>
<ul>
<li><p><a class="reference internal" href="#std-u16string-std-u32string" id="id47">クラス <code class="docutils literal notranslate"><span class="pre">std::u16string</span></code> および <code class="docutils literal notranslate"><span class="pre">std::u32string</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-wstring-convert" id="id48">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::wstring_convert</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-to-string-std-to-wstring" id="id49">関数 <code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code> および <code class="docutils literal notranslate"><span class="pre">std::to_wstring()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-stoi-std-stof" id="id50">関数 <code class="docutils literal notranslate"><span class="pre">std::stoi()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::stof()</span></code> など</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id10" id="id51">関数オブジェクト</a></p>
<ul>
<li><p><a class="reference internal" href="#std-function" id="id52">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::function</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-bind" id="id53">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::bind()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-mem-fn" id="id54">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::mem_fn()</span></code></a></p></li>
<li><p><a class="reference internal" href="#id11" id="id55">左辺値参照を渡すための各種要素</a></p></li>
<li><p><a class="reference internal" href="#std-hash" id="id56">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::hash</span></code></a></p></li>
<li><p><a class="reference internal" href="#id12" id="id57">ビット演算関数オブジェクト</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id13" id="id58">並行プログラミング</a></p>
<ul>
<li><p><a class="reference internal" href="#std-thread" id="id59">クラス <code class="docutils literal notranslate"><span class="pre">std::thread</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-mutex" id="id60">クラス <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> などの排他制御装置</a></p></li>
<li><p><a class="reference internal" href="#std-call-once" id="id61">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::call_once()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-condition-variable-std-condition-variable-any" id="id62">クラス <code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> と <code class="docutils literal notranslate"><span class="pre">std::condition_variable_any</span></code></a></p></li>
<li><p><a class="reference internal" href="#future" id="id63">Future デザインパターン</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id64">アトミック操作</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id15" id="id65">ユーティリティー</a></p>
<ul>
<li><p><a class="reference internal" href="#std-swap" id="id66">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::swap()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-move" id="id67">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::move()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-forward" id="id68">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::forward()</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-pair" id="id69">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::pair</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-tuple" id="id70">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code></a></p></li>
<li><p><a class="reference internal" href="#std-declval" id="id71">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::declval()</span></code></a></p></li>
<li><p><a class="reference internal" href="#chrono" id="id72">ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;chrono&gt;</span></code></a></p></li>
<li><p><a class="reference internal" href="#type-traits" id="id73">ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;type_traits&gt;</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id16" id="id74">エラー報告</a></p></li>
<li><p><a class="reference internal" href="#regex" id="id75">正規表現 <code class="docutils literal notranslate"><span class="pre">&lt;regex&gt;</span></code></a></p></li>
<li><p><a class="reference internal" href="#random" id="id76">乱数 <code class="docutils literal notranslate"><span class="pre">&lt;random&gt;</span></code></a></p></li>
<li><p><a class="reference internal" href="#c" id="id77">C 互換ライブラリー</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="id1">
<h2><a class="toc-backref" href="#id18">コンテナー</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<section id="std-array">
<h3><a class="toc-backref" href="#id19">固定長配列 <code class="docutils literal notranslate"><span class="pre">std::array</span></code></a><a class="headerlink" href="#std-array" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;array&gt;</span></code> に定義がある。</p></li>
<li><p>組み込み配列で事欠かないので後回しでいい。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.size()</span></code> と <code class="docutils literal notranslate"><span class="pre">.fill()</span></code> が少し便利なくらいか。</p></li>
</ul>
</section>
<section id="std-forward-list">
<h3><a class="toc-backref" href="#id20">単方向リンクリスト <code class="docutils literal notranslate"><span class="pre">std::forward_list</span></code></a><a class="headerlink" href="#std-forward-list" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">forward_list</span></code> に定義がある。</p></li>
<li><p>一言で言えば「末尾がよくわからないリスト」か。例えば <code class="docutils literal notranslate"><span class="pre">.front()</span></code> はあるが <code class="docutils literal notranslate"><span class="pre">.back()</span></code> がない。その他、メンバー関数の名前が <code class="docutils literal notranslate"><span class="pre">_front</span></code> や <code class="docutils literal notranslate"><span class="pre">_after</span></code> で終わるものがある。</p></li>
</ul>
</section>
<section id="id2">
<h3><a class="toc-backref" href="#id21">ハッシュベースの連想コンテナー</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>従来の <code class="docutils literal notranslate"><span class="pre">std::map</span></code>, <code class="docutils literal notranslate"><span class="pre">std::multimap</span></code>, <code class="docutils literal notranslate"><span class="pre">std::set</span></code>, <code class="docutils literal notranslate"><span class="pre">std::multiset</span></code> のハッシュ実装が追加された。これらは積極的に採用するべきだろう。</p>
<ul class="simple">
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::unordered_map</span></code> は役割としては <code class="docutils literal notranslate"><span class="pre">std::map</span></code> と同じだ。違いはハッシュによる実装だということだ。</p>
<ul>
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;unordered_map&gt;</span></code> に定義がある。</p></li>
<li><p>インターフェイスは <code class="docutils literal notranslate"><span class="pre">std::map</span></code> とよく似ているので、使い方がわからないというようなことはなさそうだ。</p></li>
<li><p>デモコードの <code class="docutils literal notranslate"><span class="pre">um[&quot;5th&quot;]</span></code> が 0 を返すことに注意。オブジェクトが存在しないときは、新しい要素が追加される。</p></li>
</ul>
</li>
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::unordered_multimap</span></code> は <code class="docutils literal notranslate"><span class="pre">std::map</span></code> に対する <code class="docutils literal notranslate"><span class="pre">std::multimap</span></code> と類比的なコンテナー型だ。つまり、同一キーに対して複数の異なる値を格納することが許されるハッシュマップだ。</p>
<ul>
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;unordered_map&gt;</span></code> に定義がある。</p></li>
<li><p>インターフェイスは <code class="docutils literal notranslate"><span class="pre">std::unordered_map</span></code> と同様。<code class="docutils literal notranslate"><span class="pre">operator[]</span></code> についての注意も同様。</p></li>
</ul>
</li>
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::unordered_set</span></code> は <code class="docutils literal notranslate"><span class="pre">std::set</span></code> のハッシュ実装版と考えて良い。</p>
<ul>
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;unordered_set&gt;</span></code> に定義がある。</p></li>
<li><p>特定の要素が含まれるかどうかのテストには <code class="docutils literal notranslate"><span class="pre">.count()</span></code> を用いるのは C++03 から変わりない。後年の仕様変更で <code class="docutils literal notranslate"><span class="pre">.contains()</span></code> が登場する。</p></li>
</ul>
</li>
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::unordered_multiset</span></code> は <code class="docutils literal notranslate"><span class="pre">std::set</span></code> に対する <code class="docutils literal notranslate"><span class="pre">std::multiset</span></code> と類比的なコンテナー型だ。
Python でいう <code class="docutils literal notranslate"><span class="pre">collections.Counter</span></code> のような役割を期待したい。</p>
<ul>
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;unordered_set&gt;</span></code> に定義がある。</p></li>
<li><p>インターフェイスは <code class="docutils literal notranslate"><span class="pre">std::unordered_set</span></code> と同様。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id3">
<h3><a class="toc-backref" href="#id22">コンテナー全般がムーブセマンティクスに対応</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>言語仕様で習ったように、コピー処理が省ける文法が追加された。そこでそれをサポートするメンバー関数のオーバーロードが既存のコンテナーに追加された。</p>
<ul>
<li><p>クラステンプレートのパラメータ <code class="docutils literal notranslate"><span class="pre">T</span></code> はムーブ構築のみ可能な型も許される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">push_back()</span></code> や <code class="docutils literal notranslate"><span class="pre">insert()</span></code> 等の要素追加のためのメンバ関数が、一時オブジェクトも受け取れて、move で挿入することが許される。</p></li>
<li><p>要素追加のためのメンバ関数として、クラステンプレートのパラメータ <code class="docutils literal notranslate"><span class="pre">T</span></code> のコンストラクタ引数を受け取り、一時オブジェクトの生成コストを減らせるものが追加。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.emplace()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.emplace_back()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.emplace_front()</span></code></p></li>
</ul>
<p>例えば次のコードが有効であるとする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">commands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Command</span><span class="p">(</span><span class="s">&quot;save&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>このコードは次のように書ける：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">commands</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&quot;save&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id4">
<h3><a class="toc-backref" href="#id23">初期化子リストでオブジェクトを初期化できる</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="language.html"><span class="doc">What’s New In C++11 言語仕様</span></a> で習ったように、特に標準ライブラリーのコンテナーのオブジェクトを次のようにしても初期化することができる（実はイコール記号も不要）：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>連想コンテナーの場合には結果的に中括弧が入れ子になるだろう。</p>
</section>
<section id="std-initializer-list">
<h3><a class="toc-backref" href="#id24">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> 追加</a><a class="headerlink" href="#std-initializer-list" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>ヘッダーファイルは <code class="docutils literal notranslate"><span class="pre">&lt;initializer_list&gt;</span></code> だ。</p></li>
<li><p>初期化リストを渡したい関数の引数リストに <code class="docutils literal notranslate"><span class="pre">std::initializer_list&lt;T&gt;</span></code> オブジェクトを（値渡しで）受けとる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.begin()</span></code> と <code class="docutils literal notranslate"><span class="pre">.end()</span></code> があるので、ループで全要素を順にアクセスすることができる。</p></li>
</ul>
<p><a class="reference internal" href="language.html"><span class="doc">What’s New In C++11 言語仕様</span></a> も参照。</p>
</section>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id25">反復子</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<section id="std-next-std-prev">
<h3><a class="toc-backref" href="#id26">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::next()</span></code> および <code class="docutils literal notranslate"><span class="pre">std::prev()</span></code> 追加</a><a class="headerlink" href="#std-next-std-prev" title="Permalink to this headline">¶</a></h3>
<p>受け取った反復子を指定数ぶん次へ進めた、または前へ戻した反復子を返す。</p>
<ul class="simple">
<li><p>どちらもヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;iterator&gt;</span></code> で宣言されている。</p></li>
<li><p>オプショナルにいくつ進めるかを指定できる。デフォルト引数は 1 である。</p>
<ul>
<li><p>たぶん <code class="docutils literal notranslate"><span class="pre">it</span> <span class="pre">+</span> <span class="pre">2</span></code> とか <code class="docutils literal notranslate"><span class="pre">it</span> <span class="pre">-</span> <span class="pre">5</span></code> というコードで間に合うと思うがどうだろう。</p></li>
</ul>
</li>
<li><p>C++03 に <code class="docutils literal notranslate"><span class="pre">advance()</span></code> というものがあるが、これとは異なって引数の反復子を動かさない。</p></li>
</ul>
</section>
<section id="std-move-iterator">
<h3><a class="toc-backref" href="#id27">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::move_iterator</span></code> 追加</a><a class="headerlink" href="#std-move-iterator" title="Permalink to this headline">¶</a></h3>
<p>間接参照時に、参照先の要素を move するためのアダプターとして振る舞う。</p>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;iterator&gt;</span></code> に定義されている。</p></li>
<li><p>オブジェクトを生成するにはコンストラクターよりも <code class="docutils literal notranslate"><span class="pre">make_move_iterator()</span></code> を呼び出すのが普通。</p></li>
<li><p>デモコードでは <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> の <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> オブジェクトを <code class="docutils literal notranslate"><span class="pre">assign()</span></code> している。この代入はコピーではなくムーブ代入となる。</p></li>
</ul>
</section>
<section id="std-begin-std-end">
<h3><a class="toc-backref" href="#id28">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::begin()</span></code> および <code class="docutils literal notranslate"><span class="pre">std::end()</span></code> 追加</a><a class="headerlink" href="#std-begin-std-end" title="Permalink to this headline">¶</a></h3>
<p>これらの関数の意味は想像通りだ。フリー関数として提供されるというのが本質的だ。</p>
<ul>
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;iterator&gt;</span></code> で提供されているが、これをインクルードする必要はない。新スタイルの <code class="docutils literal notranslate"><span class="pre">for</span></code> ループを成立させるためにこれらの関数テンプレートが存在する必要がある。</p></li>
<li><p>適用できるオブジェクトの型は</p>
<ul class="simple">
<li><p>メンバー関数としての <code class="docutils literal notranslate"><span class="pre">.begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">.end()</span></code> を持つものか、</p></li>
<li><p>組み込みの配列</p></li>
</ul>
<p>のどちらかとなっている。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::cbegin()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::cend()</span></code> は C++11 にはない。次の C++14 で追加される。</p></li>
</ul>
</section>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id29">アルゴリズム</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>C++ といえばアルゴリズムというくらい私はこれを重視している。以下、ヘッダーファイルは断らない限り <code class="docutils literal notranslate"><span class="pre">&lt;algorithm&gt;</span></code> をインクルードするものとする。</p>
<section id="std-all-of-std-any-of">
<h3><a class="toc-backref" href="#id30">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::all_of()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::any_of()</span></code></a><a class="headerlink" href="#std-all-of-std-any-of" title="Permalink to this headline">¶</a></h3>
<p>Python の組み込み関数 <code class="docutils literal notranslate"><span class="pre">all()</span></code> および <code class="docutils literal notranslate"><span class="pre">any()</span></code> の C++ 版だ。指定範囲が空のときの戻り値も Python と同様の考え方（というより数学）に基づき、それぞれ <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code> を返す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">InputIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Predicate</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">all_of</span><span class="p">(</span><span class="n">InputIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">InputIterator</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">Predicate</span><span class="w"> </span><span class="n">pred</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">InputIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Predicate</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">any_of</span><span class="p">(</span><span class="n">InputIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">InputIterator</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">Predicate</span><span class="w"> </span><span class="n">pred</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="std-find-if-not">
<h3><a class="toc-backref" href="#id31">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::find_if_not()</span></code></a><a class="headerlink" href="#std-find-if-not" title="Permalink to this headline">¶</a></h3>
<p>指定された述語が偽であるような最初の要素を指す反復子を戻すアルゴリズムだ。おそらく <code class="docutils literal notranslate"><span class="pre">std::find()</span></code> とラムダ式と否定を組み合わせるのが面倒だから提供されているのだろう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">InputIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Predicate</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">InputIterator</span><span class="w"> </span><span class="n">find_if_not</span><span class="p">(</span><span class="n">InputIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">InputIterator</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Predicate</span><span class="w"> </span><span class="n">pred</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="std-copy-n">
<h3><a class="toc-backref" href="#id32">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::copy_n()</span></code></a><a class="headerlink" href="#std-copy-n" title="Permalink to this headline">¶</a></h3>
<p>反復子の指す要素から初めて、指定個数だけ要素をコピーするアルゴリズムだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">InputIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Size</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">OutputIterator</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">OutputIterator</span><span class="w"> </span><span class="n">copy_n</span><span class="p">(</span><span class="n">InputIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">Size</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">OutputIterator</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>従来は <code class="docutils literal notranslate"><span class="pre">std::copy(first,</span> <span class="pre">first</span> <span class="pre">+</span> <span class="pre">n,</span> <span class="pre">result)</span></code> としていた。</p>
</section>
<section id="std-copy-if">
<h3><a class="toc-backref" href="#id33">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::copy_if()</span></code></a><a class="headerlink" href="#std-copy-if" title="Permalink to this headline">¶</a></h3>
<p>範囲 <code class="docutils literal notranslate"><span class="pre">[first,</span> <span class="pre">last)</span></code> にある要素から、述語 <code class="docutils literal notranslate"><span class="pre">pred</span></code> が真であるような要素だけを反復子 <code class="docutils literal notranslate"><span class="pre">result</span></code> 以降に戻すアルゴリズムだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">InputIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">OutputIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Predicate</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">OutputIterator</span><span class="w"> </span><span class="n">copy_if</span><span class="p">(</span><span class="n">InputIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">InputIterator</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">OutputIterator</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">Predicate</span><span class="w"> </span><span class="n">pred</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>古の C++ の書籍でその不存在を不思議がられていたアルゴリズムがついに実装された。</p>
</section>
<section id="std-move-std-move-backward">
<h3><a class="toc-backref" href="#id34">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::move()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::move_backward()</span></code></a><a class="headerlink" href="#std-move-std-move-backward" title="Permalink to this headline">¶</a></h3>
<p>これらは <code class="docutils literal notranslate"><span class="pre">std::copy()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::copy_backward()</span></code> の move 版アルゴリズムだ。だいたい次のようなものだと覚えておいて良い。実際の実装はもっと凝っているだろう：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">InputIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">OutputIterator</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">OutputIterator</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">InputIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">InputIterator</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">OutputIterator</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">while</span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">){</span><span class="w"></span>
<span class="w">         </span><span class="o">*</span><span class="n">result</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// この move は単体版</span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">BidirectionalIterator1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BidirectionalIterator2</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">BidirectionalIterator2</span><span class="w"> </span><span class="n">move_backward</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">BidirectionalIterator1</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BidirectionalIterator1</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BidirectionalIterator2</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="o">*--</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="o">*--</span><span class="n">last</span><span class="p">);</span><span class="w"> </span><span class="c1">// この move は単体版</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>最後に、copy 系と move 系のアルゴリズムでは C++03 と同じく、入力と出力の範囲が重なり合わないように注意する必要があることを記しておく。</p>
</section>
<section id="std-shuffle">
<h3><a class="toc-backref" href="#id35">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::shuffle()</span></code></a><a class="headerlink" href="#std-shuffle" title="Permalink to this headline">¶</a></h3>
<p>範囲 <code class="docutils literal notranslate"><span class="pre">[first,</span> <span class="pre">last)</span></code> を無作為に並び替える。
Python の <code class="docutils literal notranslate"><span class="pre">random.shuffle()</span></code> と同じ役割を期待する。</p>
</section>
<section id="std-is-sorted">
<h3><a class="toc-backref" href="#id36">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::is_sorted()</span></code></a><a class="headerlink" href="#std-is-sorted" title="Permalink to this headline">¶</a></h3>
<p>範囲 <code class="docutils literal notranslate"><span class="pre">[first,</span> <span class="pre">last)</span></code> がソート済みであるかどうかをテストするアルゴリズムだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ForwardIterator</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">is_sorted</span><span class="p">(</span><span class="n">ForwardIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">ForwardIterator</span><span class="w"> </span><span class="n">last</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ForwardIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Compare</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">is_sorted</span><span class="p">(</span><span class="n">ForwardIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">ForwardIterator</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">Compare</span><span class="w"> </span><span class="n">comp</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>補助関数に <code class="docutils literal notranslate"><span class="pre">std::is_sorted_until()</span></code> というものがあり、これの戻り値と
<code class="docutils literal notranslate"><span class="pre">last</span></code> が等しいかどうかで、指定範囲全体がソート済みであるかどうかを決定するようだ。</p>
</section>
<section id="std-min-std-max">
<h3><a class="toc-backref" href="#id37">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::min()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::max()</span></code> に初期化リスト版追加</a><a class="headerlink" href="#std-min-std-max" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">std::min()</span></code> も <code class="docutils literal notranslate"><span class="pre">std::max()</span></code> も追加内容は同じなので <code class="docutils literal notranslate"><span class="pre">std::min</span></code> だけ記す。</p>
<p>C++03 までは引数をちょうど二つとる関数しかなかったが、C++11 では
<code class="docutils literal notranslate"><span class="pre">std::initializer_list&lt;T&gt;</span></code> 型オブジェクトを受け取るものが追加された。これにより、<code class="docutils literal notranslate"><span class="pre">std::min()</span></code> は有限集合を引数に取るとみなすことができるようになった。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Compare</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">comp</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>呼び出し事前条件は通常版の <code class="docutils literal notranslate"><span class="pre">std::min()</span></code> に準じるものとする。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initializer_list</span></code> 版では引数が 0 個である可能性があるが、それは呼び出し側で避ける。</p></li>
</ul>
</section>
<section id="std-minmax-std-minmax-element">
<h3><a class="toc-backref" href="#id38">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::minmax()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::minmax_element()</span></code></a><a class="headerlink" href="#std-minmax-std-minmax-element" title="Permalink to this headline">¶</a></h3>
<p>そうなると、一度の呼び出しで最小値と最大値を同時に得ることもできる。そこでこれらのアルゴリズムも C++11 で提供されるようになった。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;&gt;</span><span class="w"> </span><span class="n">minmax</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Compare</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;&gt;</span><span class="w"> </span><span class="n">minmax</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">comp</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">minmax</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Compare</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">minmax</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">comp</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>呼び出し事前条件は <code class="docutils literal notranslate"><span class="pre">std::min()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::max()</span></code> に準じるものとする。</p></li>
<li><p>戻り値の <code class="docutils literal notranslate"><span class="pre">.first</span></code> と <code class="docutils literal notranslate"><span class="pre">.second</span></code> がそれぞれ最小値と最大値。</p></li>
</ul>
</section>
<section id="std-iota">
<h3><a class="toc-backref" href="#id39">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::iota()</span></code></a><a class="headerlink" href="#std-iota" title="Permalink to this headline">¶</a></h3>
<p>アルゴリズムというのとは違うが、この枠で紹介されているのでここで習う。</p>
<p>関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::iota()</span></code> はヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;numeric&gt;</span></code> が提供するもので、開始値を指定して、そこから連続した値の数列を生成するために用いられる。シェルで言うなら <code class="docutils literal notranslate"><span class="pre">seq</span></code> のような、Python で言うなら <code class="docutils literal notranslate"><span class="pre">range()</span></code> のような働きをする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ForwardIterator</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">iota</span><span class="p">(</span><span class="n">ForwardIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">ForwardIterator</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(;</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">first</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="o">++</span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>増分が <code class="docutils literal notranslate"><span class="pre">T&amp;</span> <span class="pre">T::operator++()</span></code> の定義で一意的に決まるので、柔軟性がない。</p>
</section>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id40">メモリー管理</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>C++11 では強力なスマートポインターが追加された。Boost 出身の機能と思われる。以下はヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;memory&gt;</span></code> にある機能だ。</p>
<section id="std-allocator-traits">
<h3><a class="toc-backref" href="#id41">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::allocator_traits</span></code></a><a class="headerlink" href="#std-allocator-traits" title="Permalink to this headline">¶</a></h3>
<p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::allocator_traits</span></code> はアロケーター型すべてに対する一様なインターフェイスを与えるものだ。たとえ必要とされるインターフェイス丸ごとを <code class="docutils literal notranslate"><span class="pre">std::allocator_traits</span></code> が提供しているとしても、アロケーターとは非クラス型ではあり得ないものだ。</p>
<p>コンテナークラスはアロケーターを持っているが、そのアロケーターの機能を直接操作するのではなく、この <code class="docutils literal notranslate"><span class="pre">std::allocator_traits</span></code> を介して操作するように書ける。</p>
</section>
<section id="std-shared-ptr-std-unique-ptr">
<h3><a class="toc-backref" href="#id42">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> および <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code></a><a class="headerlink" href="#std-shared-ptr-std-unique-ptr" title="Permalink to this headline">¶</a></h3>
<p>これらは C++11 の目玉の一つと考える。どちらもヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;memory&gt;</span></code> にある。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> は一つのポインターの所有権を複数のオブジェクトで共有することができる</p>
<ul>
<li><p>内部的には参照カウンター方式で参照数を管理している。これはスレッドセーフとする。</p></li>
<li><p>フリー関数 <code class="docutils literal notranslate"><span class="pre">std::make_shared()</span></code> でオブジェクトを作成するとよい。なぜならコンストラクターの呼び出しを書くのが面倒だから。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> はポインターの所有権を唯一保持するオブジェクトを意味する。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> を完全に置き換えるテンプレートだ。</p></li>
<li><p>コピー代入操作はサポートされない。ムーブ代入はサポートされるが、所有権が代入先に移ることを意味する。</p></li>
<li><p>配列もサポート。</p></li>
<li><p>フリー関数 <code class="docutils literal notranslate"><span class="pre">std::make_unique()</span></code> でオブジェクトを作成するとよい。</p></li>
</ul>
</li>
</ul>
</section>
<section id="std-auto-ptr">
<h3><a class="toc-backref" href="#id43">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> を廃止予定要素とする</a><a class="headerlink" href="#std-auto-ptr" title="Permalink to this headline">¶</a></h3>
<p>この存在が C++11 の新概念と新機能のいくつかの誕生に貢献していると考えたい。廃止予定要素になっても私は <code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> のことを忘れない。</p>
</section>
<section id="std-addressof">
<h3><a class="toc-backref" href="#id44">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::addressof()</span></code></a><a class="headerlink" href="#std-addressof" title="Permalink to this headline">¶</a></h3>
<p>演算子 <code class="docutils literal notranslate"><span class="pre">operator&amp;()</span></code> がオーバーロードされている型のオブジェクトに対しても、そのアドレスを取得することが可能であるように、関数 <code class="docutils literal notranslate"><span class="pre">std::addressof()</span></code> が追加された。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">addressof</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id8">
<h2><a class="toc-backref" href="#id45">入出力</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;istream&gt;</span></code> および <code class="docutils literal notranslate"><span class="pre">&lt;ostream&gt;</span></code> に次の関数テンプレート <code class="docutils literal notranslate"><span class="pre">operator&gt;&gt;()</span></code> および
<code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;()</span></code> が追加。一時オブジェクトとしてのストリームというのが想像しづらいのだが。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;istream&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">CharT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Traits</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span><span class="w"> </span><span class="n">Traits</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span><span class="w"> </span><span class="n">Traits</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">is</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="c1">// &lt;ostream&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">CharT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Traits</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">basic_ostream</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span><span class="w"> </span><span class="n">Traits</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">basic_ostream</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span><span class="w"> </span><span class="n">Traits</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id9">
<h2><a class="toc-backref" href="#id46">文字列処理</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>新しい文字列型と一方が文字列型であるような型変換関数が追加された。</p>
<section id="std-u16string-std-u32string">
<h3><a class="toc-backref" href="#id47">クラス <code class="docutils literal notranslate"><span class="pre">std::u16string</span></code> および <code class="docutils literal notranslate"><span class="pre">std::u32string</span></code></a><a class="headerlink" href="#std-u16string-std-u32string" title="Permalink to this headline">¶</a></h3>
<p>あるクラステンプレートの別名なのだが、表題の文字列型が新たに追加された。言語仕様のところで見てきた <code class="docutils literal notranslate"><span class="pre">char16_t</span></code> と <code class="docutils literal notranslate"><span class="pre">char32_t</span></code> をそれぞれ文字型とする文字列型だ。両方ともヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> にある。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">u16string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char16_t</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">u32string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char32_t</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>本質的には <code class="docutils literal notranslate"><span class="pre">std::basic_string</span></code> であるので、使い方は <code class="docutils literal notranslate"><span class="pre">std::string</span></code> と同じだと考える。</p>
</section>
<section id="std-wstring-convert">
<h3><a class="toc-backref" href="#id48">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::wstring_convert</span></code></a><a class="headerlink" href="#std-wstring-convert" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;locale&gt;</span></code> にあるクラステンプレート <code class="docutils literal notranslate"><span class="pre">std::wstring_convert</span></code> はマルチバイト文字とワイド文字列の相互変換を行う機能を提供する。</p>
<p>大雑把に説明すると、変換したい二つの文字列型をテンプレート引数として指定して、メンバー関数
<code class="docutils literal notranslate"><span class="pre">.from_bytes()</span></code> や <code class="docutils literal notranslate"><span class="pre">.to_bytes()</span></code> などを利用することを想定しているようだ。</p>
</section>
<section id="std-to-string-std-to-wstring">
<h3><a class="toc-backref" href="#id49">関数 <code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code> および <code class="docutils literal notranslate"><span class="pre">std::to_wstring()</span></code></a><a class="headerlink" href="#std-to-string-std-to-wstring" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> に以下の関数が追加された。これらのオーバーロードは <code class="docutils literal notranslate"><span class="pre">sprintf()</span></code> または <code class="docutils literal notranslate"><span class="pre">swprintf()</span></code> によって数値を文字列に変換する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span><span class="w"></span>
<span class="n">wstring</span><span class="w"> </span><span class="nf">to_wstring</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="std-stoi-std-stof">
<h3><a class="toc-backref" href="#id50">関数 <code class="docutils literal notranslate"><span class="pre">std::stoi()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::stof()</span></code> など</a><a class="headerlink" href="#std-stoi-std-stof" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> に以下の関数が追加された。いずれも文字列を数値に変換する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">stod</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="nf">stod</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">stof</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">stof</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">stoi</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">stoi</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="nf">stol</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="nf">stol</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">stold</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">stold</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">stoll</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">stoll</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">stoul</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">stoul</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">stoull</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">stoull</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>数値への変換が行われなかった場合に <code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code> を送出する。</p></li>
<li><p>数値が変換範囲外であるときなどの場合に <code class="docutils literal notranslate"><span class="pre">std::out_of_range</span></code> を送出する。</p></li>
<li><p>これらはグローバルロケールの影響を受けて異なる結果を出力する。</p></li>
</ul>
</section>
</section>
<section id="id10">
<h2><a class="toc-backref" href="#id51">関数オブジェクト</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>自然なインターフェイスの関数オブジェクトアダプター、バインダーが新規に追加された。これによって、従来のアダプター、バインダーが廃止予定要素とされることに注意したい。</p>
<p><code class="docutils literal notranslate"><span class="pre">std::function</span></code>, <code class="docutils literal notranslate"><span class="pre">std::bind()</span></code> は必修。</p>
<section id="std-function">
<h3><a class="toc-backref" href="#id52">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::function</span></code></a><a class="headerlink" href="#std-function" title="Permalink to this headline">¶</a></h3>
<p>パラメータの型リスト <code class="docutils literal notranslate"><span class="pre">ArgTypes...</span></code>、戻り値の型 <code class="docutils literal notranslate"><span class="pre">R</span></code> に合致するあらゆる関数的なオブジェクトを保持し、<code class="docutils literal notranslate"><span class="pre">operator()</span></code> でそれを呼び出すことができるクラステンプレートだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">ArgTypes</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">ArgTypes</span><span class="p">...)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> をインクルードして利用する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::function</span></code> のテンプレート引数の指定方法が不慣れなので修練が必要だ。</p></li>
<li><p>コンストラクターは、関数ポインター、関数オブジェクト、ラムダ式など、関数的なオブジェクトを引数に取る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator()</span></code> で保持している関数を呼び出し、その戻り値そのものを戻す。</p></li>
<li><p>本機能の追加に伴い、<code class="docutils literal notranslate"><span class="pre">std::unary_function</span></code>, <code class="docutils literal notranslate"><span class="pre">std::binary_function</span></code>, etc. は廃止予定要素となる。</p></li>
</ul>
</section>
<section id="std-bind">
<h3><a class="toc-backref" href="#id53">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::bind()</span></code></a><a class="headerlink" href="#std-bind" title="Permalink to this headline">¶</a></h3>
<p>バインダーというのは次のような性質の関数であると考えるのが早い。引数として関数オブジェクトと、その引数の一部をとる。そして本体を呼び出すときになって初めて残りの引数を指定して本体を呼び出す装置だ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">BoundArgs</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">unspecified</span><span class="w"> </span><span class="n">bind</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">BoundArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">bound_args</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">BoundArgs</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">unspecified</span><span class="w"> </span><span class="n">bind</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">BoundArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">bound_args</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>ここで <code class="docutils literal notranslate"><span class="pre">f</span></code> と　<code class="docutils literal notranslate"><span class="pre">bound_args</span></code> は関数オブジェクトとその引数リストをそれぞれ意味する。引数リストは実引数とプレースホルダーで構成される。</p>
<ul>
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> をインクルードして利用する。</p></li>
<li><p>プレースホルダーは <code class="docutils literal notranslate"><span class="pre">_1</span></code>, <code class="docutils literal notranslate"><span class="pre">_2</span></code>, … のような識別子であり、ふつうは</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="o">::</span><span class="nn">placeholders</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>を宣言してから用いる。</p>
<p>プレースホルダー <code class="docutils literal notranslate"><span class="pre">_i</span></code> は、後で呼び出すときの第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 引数をこの引数位置で渡す、の意。</p>
</li>
<li><p>本機能の追加に伴い、<code class="docutils literal notranslate"><span class="pre">std::bind1st()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::bind2nd()</span></code> は廃止予定要素となる。練習問題として、これらを <code class="docutils literal notranslate"><span class="pre">std::bind()</span></code> で実装するといい。</p></li>
</ul>
</section>
<section id="std-mem-fn">
<h3><a class="toc-backref" href="#id54">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::mem_fn()</span></code></a><a class="headerlink" href="#std-mem-fn" title="Permalink to this headline">¶</a></h3>
<p>関数オブジェクトのメンバー関数版と言っていいのか。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">unspecified</span><span class="w"> </span><span class="n">mem_fn</span><span class="p">(</span><span class="n">R</span><span class="w"> </span><span class="n">T</span><span class="o">::*</span><span class="w"> </span><span class="n">pm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>よくあるユースケースは、ユーザー定義型のオブジェクト（のポインター）からなるコンテナーがあるときに、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">func</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>とするものだ。</p>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> をインクルードして利用する。</p></li>
<li><p>本機能の追加に伴い、<code class="docutils literal notranslate"><span class="pre">std::mem_fun()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::mem_fun_ref()</span></code> は廃止予定要素となる。</p></li>
</ul>
</section>
<section id="id11">
<h3><a class="toc-backref" href="#id55">左辺値参照を渡すための各種要素</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>アダプターやバインダーで引数として参照を明示的に指定するための一連の要素を記す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">reference_wrapper</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ref</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ref</span><span class="p">(</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cref</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cref</span><span class="p">(</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> をインクルードして利用する。</p></li>
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::reference_wrapper</span></code> は関数テンプレートに変数を参照として渡すために用いられる。</p></li>
<li><p>関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::ref()</span></code> は変数への参照を保持する <code class="docutils literal notranslate"><span class="pre">std::reference_wrapper</span></code> オブジェクトを生成して戻す。関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::cref()</span></code> はその <code class="docutils literal notranslate"><span class="pre">const</span></code> 参照版だ。</p></li>
<li><p>生の参照を引数にとるオーバーロードは <code class="docutils literal notranslate"><span class="pre">std::reference_wrapper</span></code> オブジェクトを生成するが、他方、<code class="docutils literal notranslate"><span class="pre">std::reference_wrapper</span></code> オブジェクトを引数に取るオーバーロードは受け取った引数そのものを戻す。</p></li>
</ul>
</section>
<section id="std-hash">
<h3><a class="toc-backref" href="#id56">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::hash</span></code></a><a class="headerlink" href="#std-hash" title="Permalink to this headline">¶</a></h3>
<p>先述のようにハッシュ系連想コンテナーが提供される。そのためにはキーのためにハッシュ計算が必要だ。
Python でいう特殊メソッド <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> に相当する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hash</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hash</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hash</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hash</span><span class="o">&lt;</span><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ...</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hash</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> をインクルードして利用する。</p></li>
<li><p>組み込み型のほとんど、および任意のポインター型に対してはテンプレートの特殊化が定義されている。それ以外の型についてはハッシュ計算を <code class="docutils literal notranslate"><span class="pre">operator()</span></code> を定義することで、必要に応じてユーザーが実装しなければならない。</p></li>
</ul>
</section>
<section id="id12">
<h3><a class="toc-backref" href="#id57">ビット演算関数オブジェクト</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>二項演算子 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> を作用させる関数オブジェクト
<code class="docutils literal notranslate"><span class="pre">std::bit_and</span></code>, <code class="docutils literal notranslate"><span class="pre">std::bit_or</span></code>, <code class="docutils literal notranslate"><span class="pre">std::xor</span></code> が追加された。</p>
<p>シグニチャーはすべて同様なので、<code class="docutils literal notranslate"><span class="pre">&amp;</span></code> を示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bit_and</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">first_argument_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">second_argument_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">result_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> をインクルードして利用する。</p>
</section>
</section>
<section id="id13">
<h2><a class="toc-backref" href="#id58">並行プログラミング</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>マルチスレッドプログラミングの材料が突如 C++ にやってきたようだ。</p>
<section id="std-thread">
<h3><a class="toc-backref" href="#id59">クラス <code class="docutils literal notranslate"><span class="pre">std::thread</span></code></a><a class="headerlink" href="#std-thread" title="Permalink to this headline">¶</a></h3>
<p>Python の <code class="docutils literal notranslate"><span class="pre">threading.thread</span></code> のようなクラスが新規追加されたようだ。</p>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;thread&gt;</span></code> で宣言されている。</p></li>
<li><p>このクラスのオブジェクトはコピー不能。</p></li>
<li><p>非自明なコンストラクターの引数リストは <code class="docutils literal notranslate"><span class="pre">functional.bind()</span></code> のそれとよく似ている。ただし、このスレッド関数の引数の全てと戻り値は move-construct 可能である必要がある。</p></li>
<li><p>メンバー関数 <code class="docutils literal notranslate"><span class="pre">.join()</span></code> で呼び出し元のスレッドをブロックする。Python と同じ。</p></li>
<li><p>メンバー関数 <code class="docutils literal notranslate"><span class="pre">.detach()</span></code> という、オブジェクトと内的スレッドを切り離す機能がある。意味としてはスマートポインターの <code class="docutils literal notranslate"><span class="pre">.release()</span></code> と同じだろう。</p></li>
</ul>
</section>
<section id="std-mutex">
<h3><a class="toc-backref" href="#id60">クラス <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> などの排他制御装置</a><a class="headerlink" href="#std-mutex" title="Permalink to this headline">¶</a></h3>
<p>クラス <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> に絞って記す。意味は Python のそれと同じ。</p>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;mutex&gt;</span></code> で宣言されている。</p></li>
<li><p>このクラスのオブジェクトはコピー不能。</p></li>
<li><p>メンバー関数 <code class="docutils literal notranslate"><span class="pre">.lock()</span></code> および <code class="docutils literal notranslate"><span class="pre">.unlock()</span></code> が提供されている。これらの呼び出しにより排他制御をオン・オフする。ただし <code class="docutils literal notranslate"><span class="pre">.unlock()</span></code> はデストラクターで自動的に呼び出されるわけではない。別途クラス <code class="docutils literal notranslate"><span class="pre">std::lock_guard</span></code> などのオブジェクトを作成することで、そのコンストラクターとデストラクターがそれぞれ
<code class="docutils literal notranslate"><span class="pre">.lock()</span></code> と <code class="docutils literal notranslate"><span class="pre">.unlock()</span></code> を呼び出す。</p></li>
</ul>
</section>
<section id="std-call-once">
<h3><a class="toc-backref" href="#id61">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::call_once()</span></code></a><a class="headerlink" href="#std-call-once" title="Permalink to this headline">¶</a></h3>
<p>関数 <code class="docutils literal notranslate"><span class="pre">std::call_once()</span></code> は複数スレッドから呼び出されたいが、実際には一度しか処理をしたくないときに利用するものだ。メインスレッドで支度しておけばよさそうなものだが？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Callable</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">call_once</span><span class="p">(</span><span class="n">once_flag</span><span class="o">&amp;</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="n">Callable</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;mutex&gt;</span></code> で宣言されている。</p></li>
<li><p>第一引数はクラス <code class="docutils literal notranslate"><span class="pre">std::once_flag</span></code> のオブジェクトだ。<code class="docutils literal notranslate"><span class="pre">call_once()</span></code> の初回の呼び出し時のみオブジェクトが初期状態であることにより、一度しか処理をしないことができるというわけだ。</p></li>
</ul>
</section>
<section id="std-condition-variable-std-condition-variable-any">
<h3><a class="toc-backref" href="#id62">クラス <code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> と <code class="docutils literal notranslate"><span class="pre">std::condition_variable_any</span></code></a><a class="headerlink" href="#std-condition-variable-std-condition-variable-any" title="Permalink to this headline">¶</a></h3>
<p>クラス <code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> は Python でいう <code class="docutils literal notranslate"><span class="pre">threading.Condition</span></code> と同じように、特定の条件を満たすまでスレッドの実行を待機するのに用いられる。</p>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;condition_variable&gt;</span></code> で宣言されている。</p></li>
<li><p>コピー不能。さらにムーブ不能。</p></li>
<li><p>メンバー関数 <code class="docutils literal notranslate"><span class="pre">.wait()</span></code> 系で条件を指定するとともにスレッドを待機させる。指定方式により使用するメンバー関数が異なる。</p></li>
<li><p>メンバー関数 <code class="docutils literal notranslate"><span class="pre">.notify_one()</span></code> または <code class="docutils literal notranslate"><span class="pre">.notify_all()</span></code> で待機解除を通知する。</p></li>
<li><p>ロックは <code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code> しか使えない。</p></li>
</ul>
<p>クラス <code class="docutils literal notranslate"><span class="pre">std::condition_variable_any</span></code> は <code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code> 以外のロックも併用可能な
<code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> とみなしてよい。</p>
</section>
<section id="future">
<h3><a class="toc-backref" href="#id63">Future デザインパターン</a><a class="headerlink" href="#future" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;future&gt;</span></code> からクラステンプレート <code class="docutils literal notranslate"><span class="pre">std::future</span></code> や
<code class="docutils literal notranslate"><span class="pre">std::promise</span></code> が提供されている。Python の <code class="docutils literal notranslate"><span class="pre">concurrent.futures</span></code> のようなもののはずだが、インターフェイスはやや異なるようだ。</p>
<ul class="simple">
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::future</span></code> には次のようなメンバー関数がある。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">.get()</span></code>: サブスレッドの処理結果を得る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.wait()</span></code> 系。サブスレッドの処理が終わるまで待機する。</p></li>
</ul>
</li>
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::promise</span></code> には次のようなメンバー関数がある。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">.get_future()</span></code>: サブスレッドの処理結果を保持している <code class="docutils literal notranslate"><span class="pre">std::future</span></code> オブジェクトを得る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.set_value()</span></code>, <code class="docutils literal notranslate"><span class="pre">.set_exception()</span></code>: サブスレッドが処理結果を出力するのに用いる。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id14">
<h3><a class="toc-backref" href="#id64">アトミック操作</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> が新たに追加され、そこでは組み込み型に対するアトミック操作をするための特殊化テンプレートが定義されている。</p>
<p>例えば整数系の型については <code class="docutils literal notranslate"><span class="pre">.fetch_add()</span></code>, <code class="docutils literal notranslate"><span class="pre">.fetch_sub()</span></code> などの算術演算のアトミック版が提供されている。</p>
</section>
</section>
<section id="id15">
<h2><a class="toc-backref" href="#id65">ユーティリティー</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<section id="std-swap">
<h3><a class="toc-backref" href="#id66">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::swap()</span></code></a><a class="headerlink" href="#std-swap" title="Permalink to this headline">¶</a></h3>
<p>C++03 ではたいへん重宝した関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::swap()</span></code> の居場所が変わった。インクルードするべきヘッダーファイルが <code class="docutils literal notranslate"><span class="pre">&lt;algorithm&gt;</span></code> から <code class="docutils literal notranslate"><span class="pre">&lt;utility&gt;</span></code> に変わった。</p>
</section>
<section id="std-move">
<h3><a class="toc-backref" href="#id67">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::move()</span></code></a><a class="headerlink" href="#std-move" title="Permalink to this headline">¶</a></h3>
<p>左辺値を右辺値にキャストする便利関数 <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> がヘッダーファイル
<code class="docutils literal notranslate"><span class="pre">&lt;utility&gt;</span></code> に宣言されている。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">typename</span><span class="w"> </span><span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><a class="reference external" href="https://cpprefjp.github.io/site">cpprefjp</a> のサンプルコードが単純かつ全てを語る素晴らしいものなので、一度見るといい。</p>
</section>
<section id="std-forward">
<h3><a class="toc-backref" href="#id68">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::forward()</span></code></a><a class="headerlink" href="#std-forward" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="language.html"><span class="doc">What’s New In C++11 言語仕様</span></a> のムーブセマンティクスのところで述べた理由により、全称参照をする関数テンプレートの定義で、別の関数呼び出しに仮引数を引き渡すときに <code class="docutils literal notranslate"><span class="pre">std::forward()</span></code> で「包む」必要が生じる。</p>
<p>次のコードはクラステンプレート <code class="docutils literal notranslate"><span class="pre">std::queue</span></code> のメンバー関数テンプレート <code class="docutils literal notranslate"><span class="pre">.emplace()</span></code>
のコードだ。可変テンプレート引数はさておいて、こうすると <code class="docutils literal notranslate"><span class="pre">args</span></code> が lvalue 参照だろうが
rvalue 参照だろうが、それらが入り混じっていようが、適切に <code class="docutils literal notranslate"><span class="pre">.emplace_back()</span></code> に引き渡される。その結果オブジェクトを適切にキューに追加する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="std-pair">
<h3><a class="toc-backref" href="#id69">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::pair</span></code></a><a class="headerlink" href="#std-pair" title="Permalink to this headline">¶</a></h3>
<p>それぞれの要素型のコンストラクター引数を直接受け取れるようになった</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">piecewise_construct_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">constexpr</span><span class="w"> </span><span class="n">piecewise_construct_t</span><span class="w"> </span><span class="n">piecewise_construct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">piecewise_construct_t</span><span class="p">();</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args2</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">pair</span><span class="p">(</span><span class="n">piecewise_construct_t</span><span class="p">,</span><span class="w"></span>
<span class="w">     </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Args1</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">first_args</span><span class="p">,</span><span class="w"></span>
<span class="w">     </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Args2</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">second_args</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;utility&gt;</span></code> に宣言されている補助オブジェクト
<code class="docutils literal notranslate"><span class="pre">std::piecewise_construct</span></code> を第一引数に指定する必要がある。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.first</span></code>, <code class="docutils literal notranslate"><span class="pre">.second</span></code> になる予定の値のコンストラクターの引数リストに相当する
<code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> のオブジェクトそれぞれで指定する。</p></li>
</ul>
</section>
<section id="std-tuple">
<h3><a class="toc-backref" href="#id70">クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code></a><a class="headerlink" href="#std-tuple" title="Permalink to this headline">¶</a></h3>
<p>Python の <code class="docutils literal notranslate"><span class="pre">tuple</span></code> のようなクラステンプレートがヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;tuple&gt;</span></code> で宣言されている。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">tuple</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>オブジェクト生成はコンストラクターよりもフリー関数 <code class="docutils literal notranslate"><span class="pre">std::make_tuple()</span></code> を利用するほうがタイプが楽だろう。
<em>brace-or-equal-initializer</em> もよし。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> 番目の要素を得るにはフリー関数 <code class="docutils literal notranslate"><span class="pre">std::get&lt;i&gt;()</span></code> を用いる。</p></li>
</ul>
</section>
<section id="std-declval">
<h3><a class="toc-backref" href="#id71">関数テンプレート <code class="docutils literal notranslate"><span class="pre">std::declval()</span></code></a><a class="headerlink" href="#std-declval" title="Permalink to this headline">¶</a></h3>
<p>これは <code class="docutils literal notranslate"><span class="pre">decltype()</span></code> や <code class="docutils literal notranslate"><span class="pre">noexcept()</span></code> の引数に使うためのものであるようだ。後回し。</p>
</section>
<section id="chrono">
<h3><a class="toc-backref" href="#id72">ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;chrono&gt;</span></code></a><a class="headerlink" href="#chrono" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;chrono&gt;</span></code> には時間に関する機能が宣言されている。</p>
<ul class="simple">
<li><p>このヘッダーファイルにある全機能は名前空間 <code class="docutils literal notranslate"><span class="pre">std::chrono</span></code> に含まれる。</p></li>
<li><p>Python でいうと <code class="docutils literal notranslate"><span class="pre">datetime</span></code> のようなライブラリーだろう。</p></li>
</ul>
</section>
<section id="type-traits">
<h3><a class="toc-backref" href="#id73">ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;type_traits&gt;</span></code></a><a class="headerlink" href="#type-traits" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;type_traits&gt;</span></code> には、型の「特性」を判定、操作するためのクラスが宣言されている。</p>
<ul class="simple">
<li><p>テンプレート特殊化を利用して、指定した型がたとえば「コピー代入可能か否か」などの特性を決定する機能をまとめたものだ。</p></li>
<li><p>この機能にははるか昔に何度か見た感じがあるのだが思い出せない。</p></li>
</ul>
</section>
</section>
<section id="id16">
<h2><a class="toc-backref" href="#id74">エラー報告</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;system_error&gt;</span></code> が追加された。OS エラーに関する機能を提供する。</p>
<p>クラス <code class="docutils literal notranslate"><span class="pre">std::system_error</span></code> は何らかの OS エラーを表現する <code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code> だ。メンバー関数 <code class="docutils literal notranslate"><span class="pre">.error_code()</span></code> はエラーコード（をカプセル化したオブジェクト）を返す。</p>
</section>
<section id="regex">
<h2><a class="toc-backref" href="#id75">正規表現 <code class="docutils literal notranslate"><span class="pre">&lt;regex&gt;</span></code></a><a class="headerlink" href="#regex" title="Permalink to this headline">¶</a></h2>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;regex&gt;</span></code> が追加された。正規表現に関する機能を提供する。</p>
<ul class="simple">
<li><p>正規表現それ自体はクラス <code class="docutils literal notranslate"><span class="pre">std::regex</span></code> または <code class="docutils literal notranslate"><span class="pre">std::wregex</span></code> で表現される。</p></li>
<li><p>正規表現による検索や置換には次のフリー関数テンプレートを呼び出すことで実現する：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">std::regex_match()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::regex_search()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::regex_replace()</span></code></p></li>
</ul>
</li>
<li><p>検索・置換結果を扱うのにマッチオブジェクトというのを用いる。上記関数を呼び出す前に用意する必要があるので面倒そうだ。</p></li>
</ul>
</section>
<section id="random">
<h2><a class="toc-backref" href="#id76">乱数 <code class="docutils literal notranslate"><span class="pre">&lt;random&gt;</span></code></a><a class="headerlink" href="#random" title="Permalink to this headline">¶</a></h2>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;random&gt;</span></code> が追加された。乱数に関する機能を提供する。</p>
<ul class="simple">
<li><p>実践的・典型的な乱数発生コードを 2, 3 習得すること。体系的に理解する必要はないだろう。どうせ乱数だ。</p></li>
<li><p>乱数生成器がよくわからない概念だ。</p></li>
<li><p>分布生成器とは確率分布のことだ。このヘッダーファイルに <code class="docutils literal notranslate"><span class="pre">std::normal_distribution</span></code>
など、確率統計でおなじみの確率分布が多数宣言されている。このオブジェクトの <code class="docutils literal notranslate"><span class="pre">operator()</span></code> にエンジンを与えると乱数が一つ出力されるという構造になっている。</p></li>
</ul>
</section>
<section id="c">
<h2><a class="toc-backref" href="#id77">C 互換ライブラリー</a><a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h2>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;cstdint&gt;</span></code> が追加された。ビット数が規定された整数型の別名およびマクロが定義されている。</p>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;stdint.h&gt;</span></code> の提供する機能と同じものが名前空間 <code class="docutils literal notranslate"><span class="pre">std</span></code> に提供されている。</p></li>
<li><p>例としては <code class="docutils literal notranslate"><span class="pre">std::uint32_t</span></code> など。</p></li>
<li><p>関数形式のマクロはコンストラクターのように書けるだろう。</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../cpp14/index.html" title="What’s New In C++14 ノート"
             >next</a></li>
        <li class="right" >
          <a href="language.html" title="What’s New In C++11 言語仕様"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >What’s New In C++11 ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">What’s New In C++11 標準ライブラリー</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>