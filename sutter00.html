
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Exceptional C++ 読書ノート &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/mathjax-v3.js"></script>
    
    <link rel="next" title="Modern C++ Design 読書ノート" href="alexandrescu01/index.html" />
    <link rel="prev" title="達人プログラマー 読書ノート 3/3" href="hunt00/note3.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="alexandrescu01/index.html" title="Modern C++ Design 読書ノート"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="hunt00/note3.html" title="達人プログラマー 読書ノート 3/3"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Exceptional C++ 読書ノート</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="exceptional-c">
<h1><a class="toc-backref" href="#id41">Exceptional C++ 読書ノート</a><a class="headerlink" href="#exceptional-c" title="Permalink to this headline">¶</a></h1>
<p>2003 年の 3 月に本書をブックストア談浜松町駅店で購入した記録がある。が、当時読書ノートを遺していなかったので、再読し、ノートをとる次第だ。</p>
<dl class="field-list simple">
<dt class="field-odd">著者</dt>
<dd class="field-odd"><p>Herb Sutter</p>
</dd>
<dt class="field-even">訳者</dt>
<dd class="field-even"><p>浜田真理</p>
</dd>
<dt class="field-odd">出版社</dt>
<dd class="field-odd"><p>ピアソン・エデュケーション</p>
</dd>
<dt class="field-even">発行年</dt>
<dd class="field-even"><p>2000 年</p>
</dd>
<dt class="field-odd">ISBN</dt>
<dd class="field-odd"><p>978-4-89471-270-6</p>
</dd>
</dl>
<div class="contents topic" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#exceptional-c" id="id41">Exceptional C++ 読書ノート</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id42">はじめに</a></p></li>
<li><p><a class="reference internal" href="#c" id="id43">汎用プログラミングと C++ 標準ライブラリ</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id44">イテレータ</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id45">大文字小文字を区別しない文字列</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id46">最大限に再利用できる汎用コンテナ</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id47">一時オブジェクト</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id48">標準ライブラリの使用（もしくは、一時オブジェクト再考）</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id8" id="id49">例外安全に関する問題点とテクニック</a></p>
<ul>
<li><p><a class="reference internal" href="#id9" id="id50">例外に対して安全なコードを書く</a></p>
<ul>
<li><p><a class="reference internal" href="#id10" id="id51">例外安全を保証する手段</a></p></li>
<li><p><a class="reference internal" href="#stackimpl" id="id52"><code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> に分離する</a></p></li>
<li><p><a class="reference internal" href="#stackimpl-private" id="id53"><code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> を private 継承で利用する場合</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id54"><code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> を包含で利用する場合</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id55">例外を投げるデストラクタ</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id13" id="id56">コードの複雑性</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id14" id="id57">クラスの設計と継承</a></p>
<ul>
<li><p><a class="reference internal" href="#id15" id="id58">クラスの機構</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id59">仮想関数のオーバーライド</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id60">クラス間の関係</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id61">継承の使用と誤用</a></p></li>
<li><p><a class="reference internal" href="#id19" id="id62">オブジェクト指向プログラミング</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#pimpl" id="id63">コンパイラファイアウォールと Pimpl イディオム</a></p>
<ul>
<li><p><a class="reference internal" href="#id20" id="id64">コンパイル時の依存性を最小限にする</a></p></li>
<li><p><a class="reference internal" href="#id21" id="id65">コンパイラファイアウォール</a></p></li>
<li><p><a class="reference internal" href="#id22" id="id66">高速 Pimpl イディオム</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id23" id="id67">名前の自動照合、名前空間、インターフェイス原則</a></p>
<ul>
<li><p><a class="reference internal" href="#id24" id="id68">名前の自動照合とインターフェイス原則</a></p>
<ul>
<li><p><a class="reference internal" href="#koenig" id="id69">Koenig の自動照合</a></p></li>
<li><p><a class="reference internal" href="#id25" id="id70">クラスの「構成要素」とインターフェイス</a></p></li>
<li><p><a class="reference internal" href="#opearator" id="id71"><code class="docutils literal notranslate"><span class="pre">opearator&lt;&lt;()</span></code> の最適な提供手段</a></p></li>
<li><p><a class="reference internal" href="#id26" id="id72">名前の隠蔽</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#id27" id="id73">メモリ管理</a></p>
<ul>
<li><p><a class="reference internal" href="#id28" id="id74">メモリ管理</a></p>
<ul>
<li><p><a class="reference internal" href="#id29" id="id75">C++ で使用する主なメモリ領域</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#new-delete" id="id76"><code class="docutils literal notranslate"><span class="pre">new/delete</span></code></a></p></li>
<li><p><a class="reference internal" href="#auto-ptr" id="id77"><code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id30" id="id78">罠、落とし穴、そして反イディオム</a></p>
<ul>
<li><p><a class="reference internal" href="#id31" id="id79">オブジェクトの同一性</a></p></li>
<li><p><a class="reference internal" href="#id32" id="id80">自動型変換</a></p></li>
<li><p><a class="reference internal" href="#id33" id="id81">オブジェクトの生存期間</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id34" id="id82">その他のトピック</a></p>
<ul>
<li><p><a class="reference internal" href="#id35" id="id83">変数の初期化──それとも？</a></p></li>
<li><p><a class="reference internal" href="#const" id="id84">const の正しい利用</a></p></li>
<li><p><a class="reference internal" href="#id36" id="id85">キャスト</a></p></li>
<li><p><a class="reference internal" href="#bool" id="id86">真偽値 (bool)</a></p></li>
<li><p><a class="reference internal" href="#id37" id="id87">転送関数</a></p></li>
<li><p><a class="reference internal" href="#id38" id="id88">制御フロー</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id39" id="id89">あとがき</a></p></li>
<li><p><a class="reference internal" href="#id40" id="id90">参考文献</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id42">はじめに</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>本書の目的、対象読者、執筆動機、そして謝辞で構成されている。</p>
<ul>
<li><p>&lt;C++ での実際的な商用ソフトウェアの設計を主眼としている&gt; (p. vii)</p></li>
<li><p>&lt;C++ の基本をすでに心得ている読者を対象としている&gt; (p. vii)</p>
<ul>
<li><p>基本書として</p>
<ol class="arabic simple">
<li><p>Stroustrup 本、</p></li>
<li><p>C++ Primer</p></li>
<li><p>Effective C++</p></li>
</ol>
<p>を勧めている。</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="c">
<h2><a class="toc-backref" href="#id43">汎用プログラミングと C++ 標準ライブラリ</a><a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id44">イテレータ</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>アルゴリズム <code class="docutils literal notranslate"><span class="pre">std::find</span></code> は、指定された値が見つからなかった場合に第 2 引数を返す。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">--e.end()</span></code> という表現が、不正であるかもしれない&gt; (p. 2) というのは盲点だった。普通はこういう書き方はしないから気にしていなかった。</p></li>
<li><p>イテレータ使用時の 4 つの注意事項は必修。何が「無効」なのかをおさえること。</p></li>
</ul>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id45">大文字小文字を区別しない文字列</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>まず最初に「大文字小文字を区別しない文字列クラス」を書くことを検討している。
basic_string テンプレートの traits パラメータに相当する構造体を自作する手法による。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ci_char_traits</span> <span class="o">:</span> <span class="k">public</span> <span class="n">char_traits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">eq</span><span class="p">(</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c2</span><span class="p">){</span> <span class="p">...</span> <span class="p">}</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">lt</span><span class="p">(</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c2</span><span class="p">){</span> <span class="p">...</span> <span class="p">}</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">){</span> <span class="p">...</span> <span class="p">}</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">){</span> <span class="p">...</span> <span class="p">}</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">ci_char_traits</span><span class="o">&gt;</span> <span class="n">ci_string</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;多くの場合、大文字小文字の区別を比較処理の機能としたほうがより便利である。しかしながら、著者の経験では、これをオブジェクトの機能とする方が便利な場合もある&gt;
(p. 7)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ci_string</span></code> はそのままでは I/O ストリームに流せないことに注意。出力だけなら <code class="docutils literal notranslate"><span class="pre">c_str()</span></code> をストリームに流せばよい。</p></li>
<li><p>&lt;標準ライブラリは、<code class="docutils literal notranslate"><span class="pre">traits</span></code> オブジェクトを多様的に使わない&gt; (p. 9)</p></li>
</ul>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id46">最大限に再利用できる汎用コンテナ</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">fixed_class</span></code> という固定長 <code class="docutils literal notranslate"><span class="pre">vector</span></code> クラスの、コピーコンストラクタおよび代入演算子を実装することがテーマ。</p>
<p>&lt;できるだけ単純な設定で重要な問題の解決に当たろうとしていることを理解してほしい&gt;
(p. 11)</p>
<ul>
<li><p>テンプレートメンバ関数は、決してコピーコンストラクタ、代入演算子たり得ない。</p></li>
<li><p>例外安全という用語が、本書で初めて登場する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">O</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">osize</span><span class="o">&gt;</span>
<span class="n">fixed_vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">fixed_vector</span><span class="o">&lt;</span><span class="n">O</span><span class="p">,</span> <span class="n">osize</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">osize</span><span class="p">),</span> <span class="n">begin</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>&lt;<code class="docutils literal notranslate"><span class="pre">T</span></code> 代入演算子の 1 つが <code class="docutils literal notranslate"><span class="pre">copy()</span></code> 操作の途中で失敗すると、そのオブジェクトは矛盾した状態に陥ってしまう。私達の <code class="docutils literal notranslate"><span class="pre">fixed_vector</span></code> オブジェクトの内容のいくつかは、代入に失敗する前の状態を保つだろうが、他の部分はすでに更新されてしまっていることになる&gt;
(p. 17)</p>
<p>今はとりあえず次の言い回しを頭の片隅に憶えておけばいい。</p>
<ul class="simple">
<li><p>「矛盾した状態」</p></li>
<li><p>アトミックで例外を投げない <code class="docutils literal notranslate"><span class="pre">Swap()</span></code></p></li>
<li><p>「一時オブジェクトを作成して交換する」イディオム</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id47">一時オブジェクト</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>&lt;オブジェクトは値渡しではなく <code class="docutils literal notranslate"><span class="pre">const&amp;</span></code> で渡すこと&gt;(p. 20)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for</span></code> ループの終了条件部で <code class="docutils literal notranslate"><span class="pre">end()</span></code> を呼ばぬよう注意。
&lt;一度だけ値を計算して、ローカルオブジェクトに格納し再利用すべきである&gt; (p. 20)</p></li>
<li><p>&lt;前置インクリメントを使おう&gt; (p. 21)</p></li>
<li><p>コンストラクタに <code class="docutils literal notranslate"><span class="pre">explicit</span></code> を指定したり、変換演算子を提供しないようにする理由は、一時オブジェクトを密かに生成される機会を牽制するためのようだ。</p></li>
<li><p>SE/SE (single-entry/single-exit) 規則なるものの存在を初めて知った。もちろん、これは一般に通用しない規則だ。</p></li>
</ul>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id48">標準ライブラリの使用（もしくは、一時オブジェクト再考）</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>前項のハンドメイドの <code class="docutils literal notranslate"><span class="pre">for</span></code> ループを <code class="docutils literal notranslate"><span class="pre">find</span></code> アルゴリズムに置き換えた上で、以下のように説く。
&lt;ファンクタと <code class="docutils literal notranslate"><span class="pre">find_if</span></code> を用いて、もっと格好良くすることも可能だが、
<code class="docutils literal notranslate"><span class="pre">find</span></code> の単純な再利用が、プログラミング努力の節減と実行時効率にどれだけ効果的か考えてほしい&gt;
(p. 26)</p>
</div>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id49">例外安全に関する問題点とテクニック</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>本章の存在が本書の本書たる所以。</p>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id50">例外に対して安全なコードを書く</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>Cargill 氏の論文の <code class="docutils literal notranslate"><span class="pre">Stack</span></code> クラステンプレートを、例外安全かつ例外中立にしていく。</p>
<dl class="simple">
<dt>例外安全:</dt><dd><p>例外が発生しても適切に処理する。</p>
</dd>
<dt>例外中立:</dt><dd><p>すべての例外を呼び出し側に伝える。</p>
</dd>
</dl>
<ul>
<li><p>デフォルトコンストラクタの検討は、特に問題ない。</p></li>
<li><p>デストラクタは <code class="docutils literal notranslate"><span class="pre">T::~T()</span></code> が例外を投げないことを仮定できればという条件付きで、問題なし。</p></li>
<li><p>コピーコンストラクタ・代入演算子の実装方法として、ヘルパー関数 <code class="docutils literal notranslate"><span class="pre">NewCopy</span></code> をまず定義し、これを利用して実装する。</p>
<p>この <code class="docutils literal notranslate"><span class="pre">NewCopy</span></code> の実装のポイントは、</p>
<ol class="arabic simple">
<li><p>例外が発生した場合は <code class="docutils literal notranslate"><span class="pre">Stack</span></code> オブジェクトの状態を一切変更しないことと、</p></li>
<li><p>オブジェクトの状態を、絶対に例外を発生しないコードによって変更できていることだ。</p></li>
</ol>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">Push(const</span> <span class="pre">T&amp;</span> <span class="pre">t)</span></code> についても <code class="docutils literal notranslate"><span class="pre">NewCopy</span></code> で実装する。</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NewCopy</span></code> の呼び出し、</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete[]</span></code> の呼び出し、</p></li>
<li><p>組み込み型の代入、</p></li>
<li><p>主目的の <code class="docutils literal notranslate"><span class="pre">v_[used_]</span> <span class="pre">=</span> <span class="pre">t</span></code></p></li>
<li><p>要素数の更新を、</p></li>
</ol>
<p>オブジェクトの状態に矛盾が生じない順序で処理している。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">Pop()</span></code> を例外安全に実装するのは不可能。というより、呼び出し元で不可能になる。
&lt;一時オブジェクトを返すように、つまり二つの処理効果を担うように書かれた
<code class="docutils literal notranslate"><span class="pre">Pop()</span></code> では、完全な例外安全にすることができない&gt; (p. 38)</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">Pop(T&amp;</span> <span class="pre">result)</span></code> みたいな形式でならば可能だが、問題点はそういうことではない。「取得する」機能と「取り除く」機能を分離することが望ましい。</p></li>
</ul>
</li>
</ul>
<div class="section" id="id10">
<h4><a class="toc-backref" href="#id51">例外安全を保証する手段</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt>基本的な保証</dt><dd><p>例外が発生しても、リソースリークを生じない。</p>
</dd>
<dt>強い保証</dt><dd><p>&lt;例外によってある操作が終了した場合に、プログラムの状態が変更されていないこと。これは常にコミットロールバックを意味し、ある操作が失敗してもコンテナへの参照やイテレータが無効化されないことを含んでいる&gt; (p. 42)</p>
</dd>
<dt>nothrow 保証</dt><dd><p>例外を投げない関数であること。ある種の関数は、この保証を満たしていることを要求される。</p>
</dd>
</dl>
</div>
<div class="section" id="stackimpl">
<h4><a class="toc-backref" href="#id52"><code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> に分離する</a><a class="headerlink" href="#stackimpl" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Stack</span></code> のメモリ管理処理を分離してカプセル化する。
&lt;<code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> が、元の <code class="docutils literal notranslate"><span class="pre">Stack</span></code> のデータメンバをすべて持っていることに注意&gt; (p. 44)</p>
<dl class="simple">
<dt>コンストラクタ</dt><dd><p>initializer で <code class="docutils literal notranslate"><span class="pre">v_</span></code> に対して <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new(sizeof(T)</span> <span class="pre">*</span> <span class="pre">size))</span></code> しているのが目を引く。</p>
</dd>
<dt>デストラクタ</dt><dd><p><code class="docutils literal notranslate"><span class="pre">v_</span></code> に対して <code class="docutils literal notranslate"><span class="pre">std::destroy()</span></code> と <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete()</span></code> を行う。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Swap</span></code></dt><dd><p>すべてのメンバーデータに対して、<code class="docutils literal notranslate"><span class="pre">other</span></code> のそれと <code class="docutils literal notranslate"><span class="pre">std::swap()</span></code> するだけ。これにより、nothrow 保証が提供できる。ここが <code class="docutils literal notranslate"><span class="pre">Stack</span></code> の例外安全を実現する。</p>
</dd>
</dl>
</div>
<div class="section" id="stackimpl-private">
<h4><a class="toc-backref" href="#id53"><code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> を private 継承で利用する場合</a><a class="headerlink" href="#stackimpl-private" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p>コンストラクタは、単に <code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> に初期要素数を渡すだけ。</p></li>
<li><p>デストラクタは書く必要がなくなった。</p></li>
<li><p>コピーコンストラクタは <code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> のコピーコンストラクタを呼び <strong>出さない</strong>
（そもそも禁止されている）。
<code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> にメモリ確保だけをお願いして、
<code class="docutils literal notranslate"><span class="pre">Stack</span></code> 側で <code class="docutils literal notranslate"><span class="pre">std::construct</span></code> による <code class="docutils literal notranslate"><span class="pre">T</span></code> オブジェクトの構築と、
<code class="docutils literal notranslate"><span class="pre">StackImpl::vused_</span></code> の更新を行う。</p></li>
<li><p>代入演算子。以下のコードが本書最大の功績の一つだろう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Stack</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Stack</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Stack</span> <span class="nf">temp</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>  <span class="c1">// これがすべての仕事を行う。</span>
    <span class="n">Swap</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>         <span class="c1">// これは例外を投げない。</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Count()</span></code> は <code class="docutils literal notranslate"><span class="pre">StackImpl::vused_</span></code> を返すだけ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Push()</span></code> でも一時オブジェクトの <code class="docutils literal notranslate"><span class="pre">Swap</span></code> 技法を適用する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Top()</span></code> は <code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> 導入前と変更なし。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pop()</span></code> も <code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> 導入前と変更なし。ただし <code class="docutils literal notranslate"><span class="pre">std::destroy</span></code> をここで行う。</p></li>
</ul>
<p>&lt;リソースの所有権を分割したクラスにカプセル化することの最大の成果は、
<code class="docutils literal notranslate"><span class="pre">Stack</span></code> のコンストラクタとデストラクタに見ることができる&gt; (p. 54)</p>
</div>
<div class="section" id="id11">
<h4><a class="toc-backref" href="#id54"><code class="docutils literal notranslate"><span class="pre">StackImpl</span></code> を包含で利用する場合</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>基本的には private 継承の場合と同じ。結合度が低くなるのはよいが、コーディングが面倒になる。著者は包含スタイルを推奨している。</p>
</div>
<div class="section" id="id12">
<h4><a class="toc-backref" href="#id55">例外を投げるデストラクタ</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>&lt;<strong>例外で終了するようなデストラクタを書いてはいけない</strong> 。このようなデストラクタを持つクラスを書くと、オブジェクトの配列に対し、安全な <code class="docutils literal notranslate"><span class="pre">new[]</span></code> や <code class="docutils literal notranslate"><span class="pre">delete[]</span></code> を保証できない&gt; (p. 63)</p></li>
<li><p>オーバーロードした <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete()</span></code>, <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete[]()</span></code> も同様。</p></li>
<li><p>上述の関数を含む削除系関数はすべて <code class="docutils literal notranslate"><span class="pre">throw()</span></code> とすること。</p></li>
</ul>
</div>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id56">コードの複雑性</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>「基本的な保証」「強い保証」「例外を投げない保証」を人に口頭で説明する場合は、以下のように言えばよさそうだ。</p>
<blockquote>
<div><p>&lt;基本的な保証は、デストラクタによる削除が完全に機能し、リークが発生しないことを保証する。強い保証は、これに加えて、完全なコミットロールバックの特徴を保証する。また、例外を投げない保証は、関数が例外を投げないことを保証する&gt; (p. 70)</p>
</div></blockquote>
<ul class="simple">
<li><p>「強い保証」を担保することは、しばしばパフォーマンスが犠牲になる。</p></li>
<li><p>すべての関数に「強い保証」を担保することはない。</p></li>
</ul>
</div>
</div>
<div class="section" id="id14">
<h2><a class="toc-backref" href="#id57">クラスの設計と継承</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id58">クラスの機構</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>クラスの各種メンバー関数や演算子を定義するときの、一般的なガイドラインについて列挙している。</p>
<ul class="simple">
<li><p>オブジェクトは値渡しではなく const 参照渡しの方がよい。無意味なコピーを省く。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">b</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#64;=</span> <span class="pre">b</span></code> とする。効率の向上が望める。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator&#64;()</span></code> を提供する場合、</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">operator&#64;=()</span></code> も同時に提供すること。</p></li>
<li><p>前者は後者で実装すること。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;</span></code> と <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code> の関係を自然にすること。</p></li>
</ul>
</li>
<li><p>演算子をメンバ関数とするか、非メンバ関数とするかの決定は重要。ある種の規則がある。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">()</span> <span class="pre">[]</span> <span class="pre">-&gt;</span></code> はメンバ関数でなければならない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">&lt;&lt;</span></code> は非メンバ関数とする。</p></li>
<li><p>関数が仮想である場合、メンバ関数とする。</p></li>
<li><p>以下略。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code> と <code class="docutils literal notranslate"><span class="pre">operator&gt;&gt;</span></code> の戻り値は、引数のストリームの参照とすること。</p></li>
<li><p>後置インクリメントを前置インクリメントで実装すること。</p></li>
<li><p>アンダースコアで始まる識別子を作ってはいけない。
C++ コンパイラ作成者のために予約されている。</p></li>
</ul>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id59">仮想関数のオーバーライド</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>基底クラスのデストラクタを virtual とすること。ただし、派生クラスのオブジェクトを基底クラスへのポインタ経由で
delete しないことになっている場合は別。</p></li>
<li><p>継承された関数と同じ名前のメンバ関数を提供する場合、基底クラス側の関数は「隠れる」。</p>
<ul>
<li><p>隠す意図がない場合は、public 部に <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">Base::f;</span></code> と宣言する。</p></li>
<li><p>隠す意図がある場合は、private 部に <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">Base::f;</span></code> と宣言する。</p></li>
</ul>
</li>
<li><p>&lt;オーバーロードした継承関数のデフォルトパラメータ値は、決して変更してはならない&gt; (p. 88)</p></li>
<li><p>&lt;デフォルトパラメータはオブジェクトの静的な型から決まる&gt; (p. 89)</p></li>
</ul>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id60">クラス間の関係</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>最初の著者の主張は「実装のために public 継承を用いるな」ということだ。特に p. 91 の最後の長いパラグラフが最高。</p>
<ul class="simple">
<li><p>ところで、ここで紹介しているクラスは仮想関数がデストラクタ以外にないのだが、これは意味があるのか。</p></li>
<li><p>仮想関数を public にすることを避けるように説いている。代わりに Template Method デザインパターンを導入することを勧めている。完全に同意できる。</p></li>
<li><p>&lt;人間が 2 種類の仕事を受け持つとストレスを受ける&gt; (p. 96)</p></li>
</ul>
</div>
<div class="section" id="id18">
<h3><a class="toc-backref" href="#id61">継承の使用と誤用</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>この項目は大切なことをたくさん述べている。まとめるのが難しく、ノートを取りにくい。</p>
</div>
<div class="section" id="id19">
<h3><a class="toc-backref" href="#id62">オブジェクト指向プログラミング</a><a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>ノート省略。</p>
</div>
</div>
<div class="section" id="pimpl">
<h2><a class="toc-backref" href="#id63">コンパイラファイアウォールと Pimpl イディオム</a><a class="headerlink" href="#pimpl" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>&lt;依存性の管理をうまく行うことは、強固なコードを書くための必要不可欠な部分である&gt; (p. 114)</p></li>
</ul>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id64">コンパイル時の依存性を最小限にする</a><a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>&lt;プログラマの多くは、習慣的に、必要以上に多くのヘッダファイルをインクルードしている。あいにく、それはビルド時間に大きな打撃を与えることになる&gt; (p. 114)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;ostream&gt;</span></code> は <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iosfwd&gt;</span></code> に置き換えられるか調べるとよさそうだ。</p></li>
<li><p>一般に、先行宣言で十分な場合は、対応するヘッダファイルをインクルードしないことだ。</p></li>
<li><p>&lt;private 部がヘッダファイルで見えてしまっているので、クライアントコードは、
private 部の使用する全ての型に依存してしまう&gt; (p. 118)
private 部に変更があったときでも、クライアント側に再コンパイルを強いるのは不親切。</p></li>
<li><p>Pimpl とは著者による造語だと思われる。クラスの private 部を曝さぬように、隠蔽ポインタメンバーデータを使用するものだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// x.h ファイル</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="c1">// public と protected メンバ</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">struct</span> <span class="nc">XImpl</span><span class="o">*</span> <span class="n">pimpl_</span><span class="p">;</span> <span class="c1">// 先行宣言してあるクラスへのポインタ</span>
<span class="p">};</span>

<span class="c1">// x.cpp ファイル</span>
<span class="k">struct</span> <span class="nc">X</span><span class="o">::</span><span class="n">XImpl</span>
<span class="p">{</span>
    <span class="c1">// X の private 部相当を実装</span>
<span class="p">};</span>
</pre></div>
</div>
<p>利点はコンパイルの依存性を断ち切ることであり、欠点はパフォーマンスが高くつくかもしれないこと。
<code class="docutils literal notranslate"><span class="pre">XImpl</span></code> のメモリ確保・削除、
<code class="docutils literal notranslate"><span class="pre">XImpl</span></code> - <code class="docutils literal notranslate"><span class="pre">X</span></code> 間の参照が面倒、等。</p>
</li>
<li><p>&lt;私の結論は簡単だ。継承は、HAS-A や USES-A よりも強い関係にある。それゆえ、依存性を管理することになれば、常に継承でなく包含を選択すべきだ&gt;
(p. 122)</p></li>
</ul>
</div>
<div class="section" id="id21">
<h3><a class="toc-backref" href="#id65">コンパイラファイアウォール</a><a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">XImpl</span></code> の中に <code class="docutils literal notranslate"><span class="pre">X</span></code> の何を入れるべきかという問題。著者は <code class="docutils literal notranslate"><span class="pre">X</span></code> のすべての private メンバ（データと関数の両方）を
<code class="docutils literal notranslate"><span class="pre">XImpl</span></code> に入れることを推奨している。ただし仮想関数は除外する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">XImpl</span></code> には <code class="docutils literal notranslate"><span class="pre">X</span></code> オブジェクトへの逆参照ポインタが時には必要になる。</p></li>
</ul>
</div>
<div class="section" id="id22">
<h3><a class="toc-backref" href="#id66">高速 Pimpl イディオム</a><a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>この項はなかったことに────。</p>
</div>
</div>
<div class="section" id="id23">
<h2><a class="toc-backref" href="#id67">名前の自動照合、名前空間、インターフェイス原則</a><a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id24">
<h3><a class="toc-backref" href="#id68">名前の自動照合とインターフェイス原則</a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>Koenig の自動照合の簡単な説明からスタートして、「クラスとインターフェイスを同一の場所に置く」という結論に至るように議論が進む。</p>
<div class="section" id="koenig">
<h4><a class="toc-backref" href="#id69">Koenig の自動照合</a><a class="headerlink" href="#koenig" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p>Koenig の自動照合を簡単に説明すると、次のようになる。
&lt;関数の引数がクラス型の場合、コンパイラは、正しい関数名を照合するため、関数の引数の型定義を含む名前空間で、一致する関数名がないか調べる&gt; (p. 139)</p>
<p>例えば、以下のコードはコンパイルされる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">NS</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">T</span><span class="p">{</span> <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">NS</span><span class="o">::</span><span class="n">T</span> <span class="n">parm</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">parm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id25">
<h4><a class="toc-backref" href="#id70">クラスの「構成要素」とインターフェイス</a><a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p>ここで、著者はインターフェイス原則を次のように提案する。</p>
<p>ある関数がクラス <code class="docutils literal notranslate"><span class="pre">X</span></code> に対して次の条件を満たすときに、その関数は論理的にクラス <code class="docutils literal notranslate"><span class="pre">X</span></code> の構成要素である。</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">X</span></code> に言及している。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X</span></code> と一緒に提供される。</p></li>
</ol>
<ul>
<li><p>定義から自動的に、任意の <code class="docutils literal notranslate"><span class="pre">X</span></code> のメンバ関数は構成要素ということになる。</p></li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">X</span></code> と同じヘッダ内で、フリー関数の引数に <code class="docutils literal notranslate"><span class="pre">X</span></code> が用いられるものも、
<code class="docutils literal notranslate"><span class="pre">X</span></code> の構成要素である。例えば</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">{</span> <span class="p">};</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// これは構成要素</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">operator+</span></code> は左辺の引数の型変換を可能にするため、メンバ関数とすべきではない&gt; (p. 144)</p></li>
<li><p>&lt;Koenig の自動照合は、コンパイラに適切な動作をさせる&gt; (p. 145)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1"> // cout</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="c1"> // 文字列の operator&lt;&lt;() の宣言を含む</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hello</span> <span class="o">=</span> <span class="s">&quot;Hello, world&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hello</span><span class="p">;</span> <span class="c1">// 自動照合により、std::operator&lt;&lt; を呼び出す。</span>

    <span class="c1">// もし自動照合が存在せず、using namespace std; をしないならば</span>
    <span class="c1">// こういうふうに書かなければいけなかった。</span>
    <span class="n">std</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="n">hello</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>名前空間に関数を追加することは、その名前空間の外側のコードを「破壊」する。次のコード片で <code class="docutils literal notranslate"><span class="pre">A</span></code> と <code class="docutils literal notranslate"><span class="pre">B</span></code> の作者・定義場所が違うときのケースを考える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">X</span><span class="p">{</span> <span class="p">};</span>
    <span class="c1">//void f(X); // コメントを解除するだけで B::g をコンパイル不可能にする。</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">B</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">X</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">X</span> <span class="n">parm</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">f</span><span class="p">(</span><span class="n">parm</span><span class="p">);</span> <span class="c1">// A::f を生かすとオーバーロードの解決に失敗する。</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="opearator">
<h4><a class="toc-backref" href="#id71"><code class="docutils literal notranslate"><span class="pre">opearator&lt;&lt;()</span></code> の最適な提供手段</a><a class="headerlink" href="#opearator" title="Permalink to this headline">¶</a></h4>
<p>クラスに対する <code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;()</span></code> を書く方法は主に二つ。</p>
<ol class="loweralpha">
<li><p>クラスの通常のインターフェイスのみ使うフリー関数とする方法</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">{</span> <span class="p">};</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>クラスのヘルパー関数 <code class="docutils literal notranslate"><span class="pre">Print()</span></code> を呼び出すフリー関数とする方法</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
<ul class="simple">
<li><p>インターフェイス原則を適用すると、どちらの方法も同程度 <code class="docutils literal notranslate"><span class="pre">X</span></code> は <code class="docutils literal notranslate"><span class="pre">ostream</span></code> に依存していると見られる。</p></li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">A</span></code> と <code class="docutils literal notranslate"><span class="pre">B</span></code> が「一緒に提供される」とき、
<code class="docutils literal notranslate"><span class="pre">A</span></code> のメンバ関数 <code class="docutils literal notranslate"><span class="pre">A::g(B)</span></code> は <code class="docutils literal notranslate"><span class="pre">B</span></code> の構成要素でもある。</p></li>
<li><p>&lt;「一緒に提供される」とは「同じヘッダもしくは名前空間に現れる」ことと解釈すればよい&gt; (p. 154)</p></li>
</ul>
</div>
<div class="section" id="id26">
<h4><a class="toc-backref" href="#id72">名前の隠蔽</a><a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>&lt;該当する関数を全く見つけられなかった場合に限り、そのすぐ外を囲んでいるスコープを見にいく&gt; (p. 155)</p></li>
<li><p>&lt;極端な例をあげると、パラメータの型だけを見た場合、ほぼ一致するメンバ関数が、完全に一致するグローバル関数よりも好まれるということは、直感的に予想できる&gt; (p. 156)</p></li>
<li><p>&lt;名前空間にクラスを入れる場合、同じ名前空間にヘルパー関数を演算子もすべて置くようにする。これをしないと、他の場所のコードに驚くべき影響が出るかもしれない&gt; (p. 157)</p></li>
<li><p>クラスを名前空間に全く入れないという選択肢もアリ。</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="id27">
<h2><a class="toc-backref" href="#id73">メモリ管理</a><a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id28">
<h3><a class="toc-backref" href="#id74">メモリ管理</a><a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id29">
<h4><a class="toc-backref" href="#id75">C++ で使用する主なメモリ領域</a><a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<p>詳しい表が p. 164 にある。</p>
<dl class="simple">
<dt>定数データ</dt><dd><ul class="simple">
<li><p>コンパイル時に値が確定できるデータを格納する。</p></li>
<li><p>クラス型のオブジェクトはこの領域に存在できない。</p></li>
<li><p>すべて読み取り専用であり、変更しようとする動作は未定義になる。</p></li>
</ul>
</dd>
<dt>スタック</dt><dd><ul class="simple">
<li><p>自動変数を格納する。</p></li>
<li><p>オブジェクトは、定義された時点で直ちに確保・生成され、そのスコープを出た時点で直ちに削除・解放される。</p></li>
<li><p>メモリ確保がとても速い。</p></li>
</ul>
</dd>
<dt>フリーストア</dt><dd><ul class="simple">
<li><p>動的メモリ領域</p></li>
<li><p>確保と解放は <code class="docutils literal notranslate"><span class="pre">new</span></code>/<code class="docutils literal notranslate"><span class="pre">delete</span></code> で行う。</p></li>
</ul>
</dd>
<dt>ヒープ</dt><dd><ul class="simple">
<li><p>動的メモリ領域</p></li>
<li><p>確保と解放は <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 系の関数と <code class="docutils literal notranslate"><span class="pre">free</span></code> で行う。</p></li>
<li><p>ヒープとフリーストアは同じ領域ではなく、どちらかで確保したメモリを、他方で安全に解放することはできない。</p></li>
</ul>
</dd>
<dt>グローバル・静的</dt><dd><ul class="simple">
<li><p>オブジェクトは、プログラムの開始時にメモリ領域が確保される。</p></li>
<li><p>グローバル変数の、翻訳単位をまたぐ初期化順は定義されておらず、グローバルオブジェクトの依存性を管理する場合は、特別な注意が必要。</p></li>
</ul>
</dd>
</dl>
<ul class="simple">
<li><p>&lt;特にヒープ (Heap) とフリーストア (Free Store) は通常、便宜的に使用される用語で、
2 種類の動的に確保されるメモリを区別している&gt; (p. 163)</p></li>
</ul>
</div>
</div>
<div class="section" id="new-delete">
<h3><a class="toc-backref" href="#id76"><code class="docutils literal notranslate"><span class="pre">new/delete</span></code></a><a class="headerlink" href="#new-delete" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>&lt;クラス専用の <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new()</span></code>, <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new[]()</span></code> は、それぞれ必ず <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete()</span></code>, <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete[]()</span></code> とのセットで提供すること&gt; (p. 168)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new()</span></code> と <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete()</span></code> は、たとえ <code class="docutils literal notranslate"><span class="pre">static</span></code> と宣言していなくても、必ず <code class="docutils literal notranslate"><span class="pre">static</span></code> メンバ関数となる。これらの関数を独自に宣言する場合、C++ では明示的に“<code class="docutils literal notranslate"><span class="pre">static</span></code>” と宣言することをプログラマに強制しないが、そう書いておくほうが無難だ。自分がコードを書くときだけでなく、他のプログラマがそのコードを保守する際にも目安となるからだ&gt; (p. 169)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete()</span></code> は static 関数であり、仮想関数とはできないが、仮想関数のように振る舞うのだ&gt; (p. 169)</p></li>
</ul>
</div>
<div class="section" id="auto-ptr">
<h3><a class="toc-backref" href="#id77"><code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code></a><a class="headerlink" href="#auto-ptr" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>多くの商用ライブラリは、洗練されたスマートポインタを提供している。標準の <code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> は単純かつ汎用目的のスマートポインタ。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> の仕事は、動的に確保されたオブジェクトを所有し、そのオブジェクトが不要になった時点で自動的に後始末を行うことである&gt; (p. 174)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> は &lt;単に自動変数オブジェクトとして使われるので&gt; (p. 175)
そう呼ばれる。スコープから外れる時点で削除される。</p></li>
<li><p>&lt;関数が正常に終了しようが、例外によって中断しようが、メモリリークを生じない&gt; (p. 175)</p></li>
<li><p>ポインタデータメンバを安全にラップすることにも使用できる。
Pimpl イディオム実装時に頻出。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// c.h</span>
<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">C</span><span class="p">();</span>
    <span class="o">~</span><span class="n">C</span><span class="p">();</span>
    <span class="c1">//...</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">struct</span> <span class="nc">CImpl</span><span class="p">;</span> <span class="c1">// 先行宣言</span>
    <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">CImpl</span><span class="o">&gt;</span> <span class="n">pimpl_</span><span class="p">;</span>
    <span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">C</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// c.cpp</span>
<span class="k">class</span> <span class="nc">C</span><span class="o">::</span><span class="n">CImpl</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="n">C</span><span class="o">::</span><span class="n">C</span><span class="p">()</span> <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span><span class="k">new</span> <span class="n">CImpl</span><span class="p">){</span> <span class="p">}</span>
<span class="n">C</span><span class="o">::~</span><span class="n">C</span><span class="p">(){</span> <span class="p">}</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> では、 <strong>コピー同士が等しくない。</strong></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> のコピーコンストラクタ、代入演算子の引数は、非 const 参照を取るようになっているはず。</p></li>
<li><p>ある関数が 2 つの処理を含んでいるとする。このとき「関数がアトミックに振る舞う」と説明されたら、「どちらも実行した、あるいは、どちらも実行しなかった」と解釈する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto_ptr</span></code> イディオム：
&lt;<code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> に <code class="docutils literal notranslate"><span class="pre">const</span></code> をつけることによって、所有権を決して手放さなくなったことの意味は大きい&gt; (p. 184)</p></li>
</ul>
</div>
</div>
<div class="section" id="id30">
<h2><a class="toc-backref" href="#id78">罠、落とし穴、そして反イディオム</a><a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id31">
<h3><a class="toc-backref" href="#id79">オブジェクトの同一性</a><a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<p>代入演算子のコードにおける <code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">!=</span> <span class="pre">&amp;other</span></code> テストの是非について。</p>
<ul class="simple">
<li><p>代入のロジックが、自己代入時には通じぬようなものであってはならない。
<code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">!=</span> <span class="pre">&amp;other</span></code> テストが、自己代入に対する適切な動作を保証する目的ならばダメ（不必要な処理を省く最適化という文脈でならば可とする）。</p></li>
</ul>
<p>ポインタ同士の比較は、&lt;人が考えているようには行われない場合もある&gt; (p. 188)</p>
<ul class="simple">
<li><p>文字列リテラル同士の比較は未定義。特に、コンパイラは
&lt;2 つの異なる文字列リテラルに対して同じポインタ値を割り当てることもでき&gt; (p. 188) るので、比較結果が等しくなる場合がある。</p></li>
<li><p>&lt;一般に、組み込み演算子の <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">&lt;=</span> <span class="pre">&gt;</span> <span class="pre">&gt;=</span></code> を使って任意の生のポインタを比較しても、結果は不定となる&gt; (p. 188)</p></li>
</ul>
</div>
<div class="section" id="id32">
<h3><a class="toc-backref" href="#id80">自動型変換</a><a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>これまでも何度か紹介されていたが、一般に、暗黙の型変換は安全ではないとされている。理由は次の二点にある。</p>
<ol class="arabic simple">
<li><p>オーバーロードの解決を阻害する。</p></li>
<li><p>間違ったコードのコンパイルを簡単に通してしまう。</p></li>
</ol>
<p>2. の例として、<code class="docutils literal notranslate"><span class="pre">string</span></code> が <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> に暗黙の型変換が存在するとすれば、次のコードのコンパイルが通る。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">;</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">-</span> <span class="n">s3</span><span class="p">;</span> <span class="c1">// 右辺は const char* ポインタの差となり、左辺 s1 に代入しようとする</span>
</pre></div>
</div>
<p>結論：型変換演算子も、非 explicit 変換コンストラクタも書かないようにする。</p>
</div>
<div class="section" id="id33">
<h3><a class="toc-backref" href="#id81">オブジェクトの生存期間</a><a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p>エキセントリックなコード例を挙げ、そういうことはするなという議論をする。</p>
</div>
</div>
<div class="section" id="id34">
<h2><a class="toc-backref" href="#id82">その他のトピック</a><a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id35">
<h3><a class="toc-backref" href="#id83">変数の初期化──それとも？</a><a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="n">t</span><span class="p">;</span>  <span class="c1">// デフォルト初期化であり、T::T() で初期化される</span>
<span class="n">T</span> <span class="nf">t</span><span class="p">();</span> <span class="c1">// T 型のオブジェクトを返す関数 t の宣言</span>
<span class="n">T</span> <span class="nf">t</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="c1">// 直接初期化であり、適当なコンストラクタ T::T(u) を呼び出す。</span>
<span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span> <span class="c1">// コピーコンストラクタが呼び出される。T t(u); または T t(T(u)) と同じ。</span>
</pre></div>
</div>
</div>
<div class="section" id="const">
<h3><a class="toc-backref" href="#id84">const の正しい利用</a><a class="headerlink" href="#const" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>値渡しする関数のパラメータは <code class="docutils literal notranslate"><span class="pre">const</span></code> 宣言しない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> 値を返す関数はテンプレートの実体化の邪魔になる。組み込み型に対してはそもそも冗長。</p></li>
<li><p>物理的には非 <code class="docutils literal notranslate"><span class="pre">const</span></code> メンバ関数であっても、論理的に <code class="docutils literal notranslate"><span class="pre">const</span></code> 関数ならばそのように宣言する。変更を加えたいメンバ変数は、元から <code class="docutils literal notranslate"><span class="pre">mutable</span></code> 宣言しておけばよい。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">mutable</span></code> を正しく使うことは、<code class="docutils literal notranslate"><span class="pre">const</span></code> を正しく使うことの重要な一部である&gt; (p. 212)</p></li>
<li><p>&lt;できれば、ライブラリベンダーの怠慢への不平と、代替製品を切望している次第を傍に詳しくコメントしておくと良い&gt; (p. 212)</p></li>
</ul>
</div>
<div class="section" id="id36">
<h3><a class="toc-backref" href="#id85">キャスト</a><a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">const</span></code> または <code class="docutils literal notranslate"><span class="pre">volatile</span></code> 属性をキャストで取り除くのは、通常、まずいスタイル例である。ポインタまたは参照の <code class="docutils literal notranslate"><span class="pre">const</span></code> 属性を合法的に取り除きたい場合のほとんどは、クラスのメンバ変数に関係しており、<code class="docutils literal notranslate"><span class="pre">mutable</span></code> キーワードで処理される&gt; (p. 217)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> はクロスキャストにも用いることができる。</p></li>
</ul>
</div>
<div class="section" id="bool">
<h3><a class="toc-backref" href="#id86">真偽値 (bool)</a><a class="headerlink" href="#bool" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">wchar_t</span></code> は C では <code class="docutils literal notranslate"><span class="pre">typedef</span></code> だったが、C++ では組み込み型。</p></li>
</ul>
</div>
<div class="section" id="id37">
<h3><a class="toc-backref" href="#id87">転送関数</a><a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>&lt;今日、コンパイラがコピーコンストラクタを取り除くことのできる状況は、戻り値の最適化 (Return Value Optimization) と、一時オブジェクトに関してのみである&gt; (p. 224)</p></li>
<li><p>&lt;早い話が、デフォルトではすべての関数をアウトラインにした方が良い&gt; (p. 225)</p></li>
</ul>
</div>
<div class="section" id="id38">
<h3><a class="toc-backref" href="#id88">制御フロー</a><a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>コンストラクタの初期化リストにある <strong>基底クラスの</strong> リストは、クラス定義にそれらが出現する順と同じにしておく。</p></li>
<li><p>コンストラクタの初期化リストにある <strong>メンバ変数の</strong> リストは、クラス定義にそれらが出現する順と同じにしておく。</p></li>
</ul>
</div>
</div>
<div class="section" id="id39">
<h2><a class="toc-backref" href="#id89">あとがき</a><a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h2>
<p>次回作の予告みたいなことが記されている。実際、More Exceptional C++ はここに書かれている内容を盛り込んでいる。</p>
</div>
<div class="section" id="id40">
<h2><a class="toc-backref" href="#id90">参考文献</a><a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Lippman98 <em>C++ Primer</em> はアスキーから日本語版が出ているはず。</p></li>
<li><p>Meyers98 <em>Effective C++, Second Edition</em> これは Third Edition が出ているはず。</p></li>
</ul>
</div>
</div>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="alexandrescu01/index.html" title="Modern C++ Design 読書ノート"
             >next</a></li>
        <li class="right" >
          <a href="hunt00/note3.html" title="達人プログラマー 読書ノート 3/3"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Exceptional C++ 読書ノート</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2021, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>