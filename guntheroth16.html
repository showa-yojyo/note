
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Optimized C++ 下読みノート &#8212; 読書ノート v1.4</title>
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/mathjaxconf.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="next" title="Effective Debugging 読書ノート" href="speinellis17.html" />
    <link rel="prev" title="Effective Python 読書ノート" href="slatkin16.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="speinellis17.html" title="Effective Debugging 読書ノート"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="slatkin16.html" title="Effective Python 読書ノート"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">読書ノート</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="optimized-c">
<h1><a class="toc-backref" href="#id14">Optimized C++ 下読みノート</a><a class="headerlink" href="#optimized-c" title="Permalink to this headline">¶</a></h1>
<p>ここ数年 C++ の本をまったく読んでいなくて、何かリハビリになるものがないかと思って手にとった一冊。この本は自分が浦島太郎状態であることを知らせてくれた。</p>
<p>以下、下読みのときにとったメモを写しておく。このあと本書を熟読することがあれば、使える形のノートとして更新する。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Kurt Guntheroth</td>
</tr>
<tr class="field-even field"><th class="field-name">訳者:</th><td class="field-body">黒川 利明</td>
</tr>
<tr class="field-odd field"><th class="field-name">出版社:</th><td class="field-body">オライリー・ジャパン</td>
</tr>
<tr class="field-even field"><th class="field-name">発行年:</th><td class="field-body">2017 年</td>
</tr>
<tr class="field-odd field"><th class="field-name">ISBN:</th><td class="field-body">978-4-87311-792-8</td>
</tr>
<tr class="field-even field"><th class="field-name">関連 URL:</th><td class="field-body"><a class="reference external" href="https://www.oreilly.co.jp/books/9784873117928/">詳細</a></td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#optimized-c" id="id14">Optimized C++ 下読みノート</a><ul>
<li><a class="reference internal" href="#id2" id="id15">1 章 最適化とは</a></li>
<li><a class="reference internal" href="#id3" id="id16">2 章 最適化に影響するマシンの振る舞い</a></li>
<li><a class="reference internal" href="#id4" id="id17">3 章 性能を測定する</a></li>
<li><a class="reference internal" href="#id5" id="id18">4 章 文字列使用を最適化する</a></li>
<li><a class="reference internal" href="#id6" id="id19">5 章 アルゴリズムを最適化する</a></li>
<li><a class="reference internal" href="#id7" id="id20">6 章 動的変数割り当てを最適化する</a></li>
<li><a class="reference internal" href="#id8" id="id21">7 章 ホットな文を最適化する</a></li>
<li><a class="reference internal" href="#id9" id="id22">8 章 優れたライブラリを使う</a></li>
<li><a class="reference internal" href="#id10" id="id23">9 章 探索と整列を最適化する</a></li>
<li><a class="reference internal" href="#id11" id="id24">10 章 データ構造を最適化する</a></li>
<li><a class="reference internal" href="#i-o" id="id25">11 章 I/O を最適化する</a></li>
<li><a class="reference internal" href="#id12" id="id26">12 章 並行性を最適化する</a></li>
<li><a class="reference internal" href="#id13" id="id27">13 章 メモリ管理を最適化する</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id15">1 章 最適化とは</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>この章は最後のまとめを一読すれば差し当たり間に合う。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id16">2 章 最適化に影響するマシンの振る舞い</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>この章もまとめを一読しておけばよい。</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id17">3 章 性能を測定する</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">最適化の式 (p. 29) は誤植かもしれない。次の式でないと以降の説明の筋が通らない：</p>
<div class="math notranslate nohighlight">
\[S_T = \cfrac{1}{1 - P + \cfrac{P}{S_P}}.\]</div>
</li>
<li><p class="first">囲み記事の線形探索 vs 二分探索の話は理解できる。</p>
</li>
<li><p class="first">最適化は収穫逓減プロセスだ。</p>
</li>
<li><p class="first">測定時にはライブラリーのデバッグ版とリンクしないこと。適切なビルドオプションを指定する。</p>
</li>
<li><p class="first">(C++11) <code class="docutils literal notranslate"><span class="pre">std::chrono</span></code> という名前空間があり、そこでは時間計測に関する機能が備わっている。</p>
</li>
</ul>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id18">4 章 文字列使用を最適化する</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>(C++11) <code class="docutils literal notranslate"><span class="pre">std::string</span></code> の実装としては COW が許されていない。</li>
<li>ここでムーブ代入演算子の話が出てくる。</li>
<li><code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">reserve()</span></code> の話は理解できる。</li>
<li>次の <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">&amp;</span></code> で値渡しよりも 8% 遅くなったというのは驚く。</li>
<li>文字列の文字にアクセスするのに、添字よりイテレーターのほうが効率的というのも意外だ。</li>
<li>文字列を <code class="docutils literal notranslate"><span class="pre">return</span></code> するよりも引数にセットするほうが効率的というのは理解できる。</li>
<li><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> を採用すると明らかに速いわけだが、当然安全性とのトレードオフだ。</li>
<li>(C++14) <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code></li>
<li>アロケーターの話が少し出てくる。</li>
</ul>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id19">5 章 アルゴリズムを最適化する</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Skiena 本をアルゴリズムの教科書として推薦している。あれは面白かった。</li>
<li>アルゴリズムの議論なので <span class="math notranslate nohighlight">\(O(f(n))\)</span> 表記を多用する。</li>
<li>すべての探索は <span class="math notranslate nohighlight">\(n\)</span> が小さいならば等しい。理解できる。</li>
<li>ソートの話題は注意して読んだほうが良さそうだ。ツリーソート、ティムソート、イントロソートなど、初めて耳にするアルゴリズムが出てくる。<ul>
<li>ティムソートは Python の標準のソートだ。最良 <span class="math notranslate nohighlight">\(O(n)\)</span> で平均と最悪が <span class="math notranslate nohighlight">\(O(n\log n)\)</span> だという。</li>
<li>イントロソートとはクイックソートとヒープソートのハイブリッドアルゴリズムだ。これが C++11 以降の <code class="docutils literal notranslate"><span class="pre">std::sort</span></code> の実装になっているらしい。</li>
<li>フラッシュソートという、基数ソートの変形アルゴリズムがある。</li>
</ul>
</li>
<li>§5.5 の最適化のパターン。小節全体の価値が高い。</li>
</ul>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id20">6 章 動的変数割り当てを最適化する</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>(C++11) <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> というキーワードがある。これで修飾された変数は、それが存在するスレッドに限定して一度だけ初期化される？</li>
<li>オブジェクトには値であるか、エンティティーであるかという意味があるとみなす。</li>
<li>(C+11) <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> というキーワードがある。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;T&gt;</span></code></li>
<li>動的変数の所有権を共有することは高くつく。納得できる。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;T&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">std::array&lt;T&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">std::make_shared()</span></code></li>
<li>所有権を不必要に共有しない。</li>
<li>動的変数の再割り当てを減らすには <code class="docutils literal notranslate"><span class="pre">reserve()</span></code> のようなものを利用する。この知識は今でも有効。</li>
<li>ループ内で動的割り当てをしないで、外でやる。これは当然だ。</li>
<li>(C++11) <code class="docutils literal notranslate"><span class="pre">delete</span></code> キーワードをコピーコンストラクターと代入演算子の各宣言のケツに書ける。この場合、これらの宣言は <code class="docutils literal notranslate"><span class="pre">public</span></code> とする。</li>
<li>RVO</li>
<li>深いコピー vs 浅いコピー</li>
<li>§6.6 move semantics は学ぶことがたくさんある。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::swap</span></code> の考えを推し進めるとムーブの概念に至るようだ。</li>
<li>ムーブは値にもエンティティーにも効く。</li>
<li>Effective Modern C++ 推奨。これはまだ読んでいないな。</li>
<li>ムーブは難しいところがある。</li>
<li>ムーブコピーコンストラクター・代入演算子を <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> でなければならない。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::swap</span></code> のムーブによる実装例。なるほど。</li>
<li>RVO と右辺値参照が干渉し合う。ここのところ難しい。</li>
</ul>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id21">7 章 ホットな文を最適化する</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>この章は常識的なことが丁寧に述べられているように思える。</p>
<ul class="simple">
<li>PIMPL をやめる。現代ではコンパイル時間が高速化したというのが理由。なんと……。</li>
<li>定数同士の演算を連結させるようにまとめることで、コンパイル時に値を評価、決定させる。</li>
<li><code class="docutils literal notranslate"><span class="pre">double</span></code> は <code class="docutils literal notranslate"><span class="pre">float</span></code> より速いと考えてよい。FPU の仕組みがそのようになっている。確かに <code class="docutils literal notranslate"><span class="pre">float</span></code> は OpenGL のプログラムを除けば使ったことがない。</li>
</ul>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id22">8 章 優れたライブラリを使う</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>標準ライブラリーに関する諸注意と自分でライブラリーを設計するときの助言。</p>
<ul class="simple">
<li>とにかく平坦に設計する。</li>
<li>全能関数（神関数）は高価だ。</li>
<li>囲み記事の <code class="docutils literal notranslate"><span class="pre">printf</span></code> と <code class="docutils literal notranslate"><span class="pre">puts</span></code> の話は覚えておく。</li>
</ul>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id23">9 章 探索と整列を最適化する</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">std::string</span></code> をキーとする <code class="docutils literal notranslate"><span class="pre">std::map</span></code> の考察。<ul>
<li>(C++11) <code class="docutils literal notranslate"><span class="pre">std::map</span></code> の初期化構文。</li>
<li>キーである文字列を工夫することで最適化できる。例えば固定長 C 形式文字列を採用するとか。</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">std::binary_search()</span></code> は探索の成否しかわからない。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::equal_range()</span></code> の衝撃の性能。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::lower_bound()</span></code> が <code class="docutils literal notranslate"><span class="pre">std::map</span></code> と互角。</li>
<li>(C++11) <code class="docutils literal notranslate"><span class="pre">std::unordered_map</span></code> 系を使うときはハッシュをどうするかという問題が起こる。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::sort()</span></code> vs <code class="docutils literal notranslate"><span class="pre">std::stable_sort()</span></code> だが、この性能比較表は想像とかなり違う。これを見ただけでも本書を手にして良かった。</li>
</ul>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id24">10 章 データ構造を最適化する</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">std::unordered_</span></code> 系連想コンテナーを学習する機会があれば、ここを読み返そう。</p>
<ul class="simple">
<li>(C++11) <code class="docutils literal notranslate"><span class="pre">std::unordered_</span></code> 系連想コンテナー。</li>
<li>囲み記事の <code class="docutils literal notranslate"><span class="pre">&lt;random&gt;</span></code> を見ると、かなり高度な乱数生成機能があるようだ。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::list</span></code> のコピーはコピー代入演算子よりも（空のオブジェクトに）末尾要素追加系のメソッドを呼び出す方が速い。なぜだ。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::forward_list</span></code> はメモリ制約がよほど厳しいプロセッサーでない限り勧められない。</li>
</ul>
</div>
<div class="section" id="i-o">
<h2><a class="toc-backref" href="#id25">11 章 I/O を最適化する</a><a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h2>
<p>語られることがあまりない API が現れて面白い。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">istreambuf_iterator</span></code> と <code class="docutils literal notranslate"><span class="pre">rdbuf()</span></code> がさっそくコード例に現れる。</li>
<li><code class="docutils literal notranslate"><span class="pre">tellg()</span></code> と <code class="docutils literal notranslate"><span class="pre">seekg()</span></code> を上手く使えばストリームの「長さ」を得られるというのは盲点だった。というか Python ではよくやっているのに。</li>
<li><code class="docutils literal notranslate"><span class="pre">pubsetbuf()</span></code> と <code class="docutils literal notranslate"><span class="pre">sgetn()</span></code> という、標準仕様書でしかお目にかかったことのない機能の利用例も見られる。</li>
<li>カスタムストリームバッファーを作ることは役に立たない。</li>
<li><code class="docutils literal notranslate"><span class="pre">std::endl</span></code> は出力をフラッシュする。そしてフラッシュ処理は高くつく。なので、単に改行したいだけならば改行文字を出力するだけにとどめるのがよい。</li>
<li>最後に <code class="docutils literal notranslate"><span class="pre">std::cout</span></code> の性能を高めるのに <code class="docutils literal notranslate"><span class="pre">std::ios_base::sync_with_stdio()</span></code> が利用できることを述べている。もう少し丁寧に理解したい。</li>
</ul>
</div>
<div class="section" id="id12">
<h2><a class="toc-backref" href="#id26">12 章 並行性を最適化する</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">並行プログラミングはまったく知らないので保留。せっかくだから今学ぼうという機運がない。</p>
</div>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id27">13 章 メモリ管理を最適化する</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">delete</span></code> 全般の説明。</li>
<li>C 由来のメモリ管理関数。</li>
<li>専用マネージャー作成。固定サイズブロック。これは <code class="docutils literal notranslate"><span class="pre">new</span></code> と <code class="docutils literal notranslate"><span class="pre">delete</span></code> の提供をも含む。</li>
<li>標準アロケーターのカスタマイズ。</li>
<li>アロケーターは元々はメモリ管理だけを意味するものではなく、
Windows で言えば <code class="docutils literal notranslate"><span class="pre">near</span></code> とか <code class="docutils literal notranslate"><span class="pre">far</span></code> とかの修飾を煩わせないような工夫も備えていた。</li>
<li>同サイズを要求するマネージャーが特に効果的だ。</li>
<li>良くて 30% 程度。</li>
</ul>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="speinellis17.html" title="Effective Debugging 読書ノート"
             >next</a></li>
        <li class="right" >
          <a href="slatkin16.html" title="Effective Python 読書ノート"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">読書ノート</a> &#187;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2018, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>