<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Chapter 07: Parallelism and Concurrency &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="Chapter 08: File System" href="chapter08.html" />
    <link rel="prev" title="Chapter 06: Regular Expression" href="chapter06.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="chapter06.html" title="Previous document">Chapter 06: Regular Expression</a>
        </li>
        <li>
          <a href="chapter08.html" title="Next document">Chapter 08: File System</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="chapter-07-parallelism-and-concurrency">
<h1><a class="toc-backref" href="#id4" role="doc-backlink">Chapter 07: Parallelism and Concurrency</a><a class="headerlink" href="#chapter-07-parallelism-and-concurrency" title="Permalink to this heading">¶</a></h1>
<p><a class="reference external" href="https://changkun.de/modern-cpp/en-us/07-thread/">Chapter 07: Parallelism and Concurrency</a>
に関するノート。テーマが難解なので紙一枚で収まるわけがない。やれるところまでやる。</p>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>このテーマは疎いので、随時調べながら読む。</p>
<dl class="simple">
<dt><em class="dfn">Parallelism</em></dt><dd><p>マルチコアプロセッサーのような複数の計算資源を持つハードウェア上で、複数のタスクや同じタスクの部分タスクが文字通り同時に実行される処理を表す。</p>
</dd>
<dt><em class="dfn">Concurrency</em></dt><dd><p>複数のタスクが特定の順序によらず、重なり合う時間帯に開始、実行、完了するような処理を指す。</p>
</dd>
</dl>
</div>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#chapter-07-parallelism-and-concurrency" id="id4">Chapter 07: Parallelism and Concurrency</a></p>
<ul>
<li><p><a class="reference internal" href="#basic-of-parallelism" id="id5">7.1 Basic of Parallelism</a></p></li>
<li><p><a class="reference internal" href="#mutex-and-critical-section" id="id6">7.2 Mutex and Critical Section</a></p></li>
<li><p><a class="reference internal" href="#future" id="id7">7.3 Future</a></p></li>
<li><p><a class="reference internal" href="#condition-variable" id="id8">7.4 Condition Variable</a></p></li>
<li><p><a class="reference internal" href="#atomic-operation-and-memory-model" id="id9">7.5 Atomic Operation and Memory Model</a></p>
<ul>
<li><p><a class="reference internal" href="#atomic-operation" id="id10">Atomic Operation</a></p></li>
<li><p><a class="reference internal" href="#consistency-model" id="id11">Consistency Model</a></p>
<ul>
<li><p><a class="reference internal" href="#linear-consistency" id="id12">Linear Consistency</a></p></li>
<li><p><a class="reference internal" href="#sequential-consistency" id="id13">Sequential Consistency</a></p></li>
<li><p><a class="reference internal" href="#causal-consistency" id="id14">Causal Consistency</a></p></li>
<li><p><a class="reference internal" href="#final-consistency" id="id15">Final Consistency</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#memory-orders" id="id16">Memory Orders</a></p>
<ul>
<li><p><a class="reference internal" href="#relaxed-model" id="id17">Relaxed model</a></p></li>
<li><p><a class="reference internal" href="#release-consumption-model" id="id18">Release/consumption model</a></p></li>
<li><p><a class="reference internal" href="#release-acquire-model" id="id19">Release/Acquire model</a></p></li>
<li><p><a class="reference internal" href="#sequential-consistent-model" id="id20">Sequential Consistent Model</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#conclusion" id="id21">Conclusion</a></p></li>
<li><p><a class="reference internal" href="#exercises" id="id22">Exercises</a></p></li>
<li><p><a class="reference internal" href="#further-readings" id="id23">Further Readings</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="basic-of-parallelism">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">7.1 Basic of Parallelism</a><a class="headerlink" href="#basic-of-parallelism" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::thread</span></code> が並行プログラミングの基礎となるものだ。</p></li>
<li><p>使用する際にはヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;thread&gt;</span></code> を含める。</p></li>
<li><p>ID を取得する <code class="docutils literal notranslate"><span class="pre">get_id()</span></code> やスレッドの実行が終了するのを待つ <code class="docutils literal notranslate"><span class="pre">join()</span></code> など、基本的な操作がいくつかある。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t</span><span class="p">([](){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;hello world.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="mutex-and-critical-section">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">7.2 Mutex and Critical Section</a><a class="headerlink" href="#mutex-and-critical-section" title="Permalink to this heading">¶</a></h2>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>英語の mutex だが、中国語の原書では「互斥量」と表記している概念を、本ノートでは排他制御と表記する。しかたがない。</p>
<p>排他制御の考え方は、共有データが複数スレッドから同時にアクセスされないように保護することを主眼としている。何らかの同期を伴う。</p>
</div>
<p>C++11 では排他制御に関連するクラス群が導入され、関連するすべての関数がヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;mutex&gt;</span></code> に記述されている。</p>
<p>C++11 で最も基本的な排他制御クラスは <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> だ。これをインスタンス化することで排他制御ができる。メンバー関数 <code class="docutils literal notranslate"><span class="pre">lock()</span></code>/<code class="docutils literal notranslate"><span class="pre">unlock()</span></code> で施錠、解錠することができる。しかし、実際にはこれらを直接呼び出さない方がよい。C++11 では RAII 対応したクラステンプレート <code class="docutils literal notranslate"><span class="pre">std::lock_guard</span></code> も用意されている。</p>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p><code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> が排他的で非再帰的な所有権の枠組みで機能することを押さえる必要がある。</p>
<ul class="simple">
<li><p>呼び出し元のスレッドは、<code class="docutils literal notranslate"><span class="pre">lock()</span></code> を正常に呼び出してから <code class="docutils literal notranslate"><span class="pre">unlock</span></code> を呼び出すまでの間、当該 <code class="docutils literal notranslate"><span class="pre">mutex</span></code> の所有権がある。</p></li>
<li><p>あるスレッドが <code class="docutils literal notranslate"><span class="pre">mutex</span></code> を所有しているとき、他のスレッドは、当該 <code class="docutils literal notranslate"><span class="pre">mutex</span></code>
の所有権を主張しようとすると、ブロックするはずだ。</p></li>
<li><p>呼び出し元となるスレッドは <code class="docutils literal notranslate"><span class="pre">lock()</span></code> を呼ぶ前に <code class="docutils literal notranslate"><span class="pre">mutex</span></code> を所有してはいけない。</p></li>
</ul>
<p>上の規則一覧は <code class="docutils literal notranslate"><span class="pre">lock()</span></code> で説明したが、<code class="docutils literal notranslate"><span class="pre">try_lock()</span></code> という似たメソッドもある。これはブロックの代わりに <code class="docutils literal notranslate"><span class="pre">false</span></code> が戻るというものだ。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">critical_section</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">change_v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// execute contention works</span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">change_v</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// mtx will be released after leaving the scope</span>
<span class="p">}</span>
</pre></div>
</div>
<p>オブジェクト <code class="docutils literal notranslate"><span class="pre">lock</span></code> がスタックに生成されるため、<code class="docutils literal notranslate"><span class="pre">critical_section()</span></code> が正常に返ろうが、途中で例外が発生しようが、スコープ終了時点でスタックのロールバックが発生し、デストラクター経由で <code class="docutils literal notranslate"><span class="pre">unlock()</span></code> が自動的に呼び出されることに注意する。</p>
<p><code class="docutils literal notranslate"><span class="pre">std::lock_guard</span></code> よりも柔軟なのが <code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code> だ。
<code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code> オブジェクトは排他的所有権を持つ <code class="docutils literal notranslate"><span class="pre">mutex</span></code> オブジェクトに対する施錠と解錠を管理する。他の <code class="docutils literal notranslate"><span class="pre">unique_lock</span></code> オブジェクトに <code class="docutils literal notranslate"><span class="pre">mutex</span></code> オブジェクト所有権はあり得ない。したがって、並行プログラミングでは <code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code>
を使用するのが望ましい。</p>
<p>先の <code class="docutils literal notranslate"><span class="pre">std::lock_guard</span></code> は <code class="docutils literal notranslate"><span class="pre">lock</span></code>/<code class="docutils literal notranslate"><span class="pre">unlock</span></code> を明示的に呼び出すことができない。一方 <code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code> は宣言後の任意の場所でそのどちらも呼び出すことができる。所有権専有域を狭め、より高い並行性を実現する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">critical_section</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">change_v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// do contention operations</span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">change_v</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// release the lock</span>
<span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// during this period,</span>
<span class="w">    </span><span class="c1">// others are allowed to acquire v</span>

<span class="w">    </span><span class="c1">// start another group of contention operations</span>
<span class="w">    </span><span class="c1">// lock again</span>
<span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>条件変数 <code class="docutils literal notranslate"><span class="pre">std::condition_variable::wait</span></code> を使用する場合、引数には
<code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code> を使用する必要がある。条件変数については後述される。</p>
</section>
<section id="future">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">7.3 Future</a><a class="headerlink" href="#future" title="Permalink to this heading">¶</a></h2>
<p>C++11 で <code class="docutils literal notranslate"><span class="pre">std::future</span></code> が導入される以前は、以下のようなやり方が普通だった：</p>
<ol class="arabic simple">
<li><p>スレッド A を作る</p></li>
<li><p>スレッド A でタスク B を開始する</p></li>
<li><p>準備ができたらイベントを送り、</p></li>
<li><p>その結果をグローバル変数に保存する</p></li>
<li><p>メイン機能のスレッド A は他のことをやっている</p></li>
<li><p>結果が必要になったら、関数の実行結果を待つスレッドが呼び出される</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">std::future</span></code> はこの処理を簡略化する。非同期タスクの結果を取得するために利用する。スレッド同期の簡単な手段、すなわちバリアたり得ることが容易に想像できる。</p>
<p>本書の次のコード例では <code class="docutils literal notranslate"><span class="pre">future</span></code> オブジェクトをまともに生成するために
<code class="docutils literal notranslate"><span class="pre">packaged_task</span></code> というものを用いているが、後でスレッド同期 (<code class="docutils literal notranslate"><span class="pre">result.wait()</span></code>)
を実現する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;future&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// pack a lambda expression that returns 7 into a std::packaged_task</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">task</span><span class="p">([](){</span><span class="k">return</span><span class="w"> </span><span class="mi">7</span><span class="p">;});</span>

<span class="w">    </span><span class="c1">// get the future of task</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span><span class="w">    </span><span class="c1">// run task in a thread</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">)).</span><span class="n">detach</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;waiting...&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"> </span><span class="c1">// block until future has arrived</span>

<span class="w">    </span><span class="c1">// output result</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;done!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="w"> </span><span class="n">endl</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;future result is &quot;</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="condition-variable">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">7.4 Condition Variable</a><a class="headerlink" href="#condition-variable" title="Permalink to this heading">¶</a></h2>
<p><em class="dfn">条件変数</em> を表現するクラステンプレート <code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> はデッドロックを解決するために生まれ、排他制御だけでは不十分な場合のために導入された。例えば、あるスレッドが実行を続けるために、ある条件が真になるのを待つ必要があるという場合がある。デッドウェイトループは、他のすべてのスレッドがクリティカルセクションに入るのに失敗するため、条件が真になったときにデッドロックが発生する可能性がある。メソッド <code class="docutils literal notranslate"><span class="pre">notify_one()</span></code> はスレッドを目覚めさせるために、
<code class="docutils literal notranslate"><span class="pre">notify_all()</span></code> はすべてのスレッドに通知するために用いられる。</p>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>条件変数は排他制御と同様に同期装置の一種だ。別のスレッドが「条件」を変更し、条件変数に通知することを両方するまでは、それ以外のスレッド全部をブロックするという仕組みだ。</p>
<p>共有変数を変更しようとするスレッドは以下のことが必要だ：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> 所有権を取得する</p></li>
<li><p>所有している間に共有変数を変更する</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> に対して <code class="docutils literal notranslate"><span class="pre">notify_one</span></code> または <code class="docutils literal notranslate"><span class="pre">notify_all</span></code>
を呼び出す。所有権を放棄した後に実行可能だ。</p></li>
</ol>
<p>一方、<code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> 上待機しようとするスレッドは次のことをせねばならない：</p>
<ol class="arabic simple">
<li><p>共有変数の保護に使われる <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> に対して <code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code> を取得する。</p></li>
<li><p>次のいずれかをする：</p>
<ul class="simple">
<li><p>すでに更新され通知されている場合は、その状態を確認する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> に対して <code class="docutils literal notranslate"><span class="pre">wait</span></code> 系メソッドを呼び出す。</p></li>
<li><p>状態を確認し、満足できない場合は待機を再開する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wait</span></code> 系メソッド述語オーバーロード版を用いる。それは上述と同じ三ステップを実行する。</p></li>
</ul>
</li>
</ol>
</div>
<p>本書のコード生産者消費者モデルの例。まずは <code class="docutils literal notranslate"><span class="pre">main</span></code> の先頭の変数宣言を調べる。これらのオブジェクト、変数すべてを生産者と消費者のどちらも参照する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">produced_nums</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="w"> </span><span class="n">cv</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">notified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// notification sign</span>
</pre></div>
</div>
<p>次に生産者スレッドのタスクを見る。本文の言うように <code class="docutils literal notranslate"><span class="pre">unique_lock</span></code> を用いる。
0.5 秒ふかしてからキューに値を押し込み、フラグをオンにして <code class="docutils literal notranslate"><span class="pre">cv.notify_all</span></code> を呼び出すというものだ：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">producer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;producing &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">produced_nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">notified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::this_thread</span></code> は名前空間だ。</p></li>
<li><p>その関数である <code class="docutils literal notranslate"><span class="pre">sleep_for</span></code> は現在のスレッドの実行を、指定された時間以上ブロックする。スケジューリングや資源競合の遅延により、指定時間よりも長い時間ブロックすることがある。</p></li>
</ul>
</div>
<p>消費者スレッドタスク。消費者は複数ある。排他制御スコープが二つに分かれていることに注意。生産物を消費した後のフラグの変更が怪しい。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">consumer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">notified</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// avoid spurious wakeup</span>
<span class="w">            </span><span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// temporal unlock to allow producer produces more rather than</span>
<span class="w">        </span><span class="c1">// let consumer hold the lock until its consumed.</span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// consumer is slower</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">produced_nums</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;consuming &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">produced_nums</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">            </span><span class="n">produced_nums</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">notified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>あとは生産者スレッド一つと消費者スレッド複数を生成して、その全てに対して <code class="docutils literal notranslate"><span class="pre">join</span></code>
するコードが続く。</p>
<p>生産者では <code class="docutils literal notranslate"><span class="pre">notify_one()</span></code> を使用することもできるがそれは推められない。複数の消費者が存在する場合、ここでの消費者の実装は単にロック保持を放棄しているが、他の消費者がこのロックを奪い合うことが可能になり、複数消費者間の並行性をより活用することができるからだ。</p>
<p>とはいえ、実際には <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> の排他性から、複数の消費者が並列消費者キューで中身を生成できることは期待できないので、やはりよりきめ細かい取り組み方が必要だ。</p>
</section>
<section id="atomic-operation-and-memory-model">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">7.5 Atomic Operation and Memory Model</a><a class="headerlink" href="#atomic-operation-and-memory-model" title="Permalink to this heading">¶</a></h2>
<p>次のコードを実行すると、<code class="docutils literal notranslate"><span class="pre">b</span></code> の値は何であるかという問題だ：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t1</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">flag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;b = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t2</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">        </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>結論から言うと <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">0</span></code> の場合もあり得る。<code class="docutils literal notranslate"><span class="pre">a</span></code> や <code class="docutils literal notranslate"><span class="pre">flag</span></code> については並列スレッドで読み書きを行うため、コード自体の挙動が未定義なのだ。競合が発生している。また、読み書きの競合を無視しても、CPU の out-of-order 実行や、コンパイラーによる命令の並べ替えの影響を受ける可能性がある。つまり <code class="docutils literal notranslate"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">1</span></code> の後に <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">5</span></code>
を発生させる可能性がある。</p>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>このコードを手許の環境で実行したら <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">5</span></code> がいつでも出力される。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> を付けても外しても。</p>
</div>
<p>用語をよく習得しておくこと。</p>
<section id="atomic-operation">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Atomic Operation</a><a class="headerlink" href="#atomic-operation" title="Permalink to this heading">¶</a></h3>
<p>排他制御実装は、次の基本原則があるため OS レベルの機能となる：</p>
<ol class="arabic simple">
<li><p>スレッド間の自動的な状態遷移、つまり「ロック」状態を提供する</p></li>
<li><p>排他制御操作の間、操作される変数のメモリーがクリティカルセクションから隔離されていることを保証する</p></li>
</ol>
<p>この同期条件は強力で、最終的に CPU 命令一つにコンパイルされるとき、多くの命令のように振る舞うことになる。不可分操作しか必要としない（中間状態を必要としない）変数にはこれは厳しいようだ。</p>
<p>現代の CPU アーキテクチャーでは、CPU 命令レベルでの不可分操作が提供されているということを理解する必要がある。したがって、C++11 のマルチスレッド共有変数の読み書きでは、<code class="docutils literal notranslate"><span class="pre">std::atomic</span></code> の導入により、不可分型をインスタンス化することになる。不可分型の読み書きは、命令集合から単一の CPU 命令へ最小化される。例：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/thread">Concurrency support library (since C++11)</a>
によると、ヘッダーファイルの内容については説明がある：</p>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> のコンポーネントは、ロックなし並行 (concurrent)
プログラミングを可能にするきめ細かい不可分操作を実現するためにある。不可分演算それぞれは、そのオブジェクトを使う他のどんな不可分操作演算に関して分割されない。不可分オブジェクトには、データ競合がない。</p>
</div>
<p>また、整数や浮動小数点数の不可分型に対応した基本的な数値演算関数が用意されている：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atomic&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t1</span><span class="p">([](){</span>
<span class="w">        </span><span class="n">count</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t2</span><span class="p">([](){</span>
<span class="w">        </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w">        </span><span class="c1">// identical to fetch_add</span>
<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">     </span><span class="c1">// identical to fetch_add</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">atomic&lt;int&gt;::operator++()</span></code> も <code class="docutils literal notranslate"><span class="pre">atomic&lt;int&gt;::operator+=(1)</span></code> も
<code class="docutils literal notranslate"><span class="pre">atomic&lt;int&gt;::fetch_add(1)</span></code> と同じだと言っている。</p>
<p>不可分操作を提供できない操作もある。そこで、型が <code class="docutils literal notranslate"><span class="pre">T</span></code> 不可分操作をサポートするかどうかを確認するには、<code class="docutils literal notranslate"><span class="pre">std::atomic&lt;T&gt;::is_lock_free</span></code> をチェックすればいい。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atomic&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">is_lock_free</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>このコードは最初、手許の g++ でコンパイルエラーとなった。調べるとリンクオプション <code class="docutils literal notranslate"><span class="pre">-latomic</span></code> が要るのだった。</p>
</div>
</section>
<section id="consistency-model">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Consistency Model</a><a class="headerlink" href="#consistency-model" title="Permalink to this heading">¶</a></h3>
<p>複数のスレッドが並列に実行されるシステムはおおよそ分散システムと見なすことができる。分散システムでは、通信やローカル操作でさえも時間を消費し、信頼性の低い通信も発生する。</p>
<p>複数のスレッドにまたがる変数 <code class="docutils literal notranslate"><span class="pre">v</span></code> の操作を不可分、つまり <code class="docutils literal notranslate"><span class="pre">v</span></code> を操作するどのスレッドも他のスレッドと並行して <code class="docutils literal notranslate"><span class="pre">v</span></code> の変化を認識するように強制すると、変数
<code class="docutils literal notranslate"><span class="pre">v</span></code> に対して逐次実行として振る舞うプログラムは、マルチスレッドの導入による効率化の恩恵を受けられない。これを適切に高速化するためには、プロセス間同期条件を弱める。</p>
<p>原理的には、各スレッドはクラスターノード一つに対応することができ、スレッド間の通信はクラスターノード間の通信とほぼ等価だ。プロセス間の同期条件を弱めるために、以下で述べられる四種の異なる整合性モデルを考慮する。</p>
<section id="linear-consistency">
<h4><a class="toc-backref" href="#id12" role="doc-backlink">Linear Consistency</a><a class="headerlink" href="#linear-consistency" title="Permalink to this heading">¶</a></h4>
<p>強い整合性、不可分整合性とも呼ばれる。ある読み出し操作が特定のデータの最新の書き込みを読み出し、操作の順序がグローバル時計下の順序とすべてのスレッドで一致することを必要とする。</p>
<figure class="align-center" id="id1">
<div class="mermaid">
            sequenceDiagram
    participant T1
    participant T2
    participant x
    T1-&gt;&gt;+x: store(1)
    T2-&gt;&gt;+x: store(2)
    T1-&gt;&gt;+x: load()
        </div><figcaption>
<p><span class="caption-text">Linear Consistency</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>この場合、スレッド <code class="docutils literal notranslate"><span class="pre">T1</span></code>, <code class="docutils literal notranslate"><span class="pre">T2</span></code> による <code class="docutils literal notranslate"><span class="pre">x</span></code> への二度の書き込み操作は不可分であり、 <code class="docutils literal notranslate"><span class="pre">x.store(1)</span></code> は <code class="docutils literal notranslate"><span class="pre">x.store(2)</span></code> の前に厳密に起こり、<code class="docutils literal notranslate"><span class="pre">x.store(2)</span></code> は
<code class="docutils literal notranslate"><span class="pre">x.load()</span></code> の前に厳密に起こる。線形一貫性のための大域時計の要件は達成するのが難しいので、この条件よりも弱い条件で他の一貫性のためのアルゴリズムを研究し続ける理由は注目に値する。</p>
</section>
<section id="sequential-consistency">
<h4><a class="toc-backref" href="#id13" role="doc-backlink">Sequential Consistency</a><a class="headerlink" href="#sequential-consistency" title="Permalink to this heading">¶</a></h4>
<p>ここでも、どのような読み出し操作でも、最後に書き込まれたデータを読み出すことを要求する。ただし大域時計の順序との一貫性は要求しない。</p>
<figure class="align-center" id="id2">
<div class="mermaid">
            sequenceDiagram
    participant T1
    participant T2
    participant x
    par
        T1-&gt;&gt;+x: store(1)
        T2-&gt;&gt;+x: store(2)
    end
    T1-&gt;&gt;+x: store(3)
    T1-&gt;&gt;+x: load()
        </div><figcaption>
<p><span class="caption-text">Sequential Consistency</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>逐次整合性の要求下では、<code class="docutils literal notranslate"><span class="pre">x.load()</span></code> は最終的に書き込まれたデータを読まなければならない。<code class="docutils literal notranslate"><span class="pre">T2</span></code> の <code class="docutils literal notranslate"><span class="pre">x.store(2)</span></code> が <code class="docutils literal notranslate"><span class="pre">x.store(3)</span></code> より前に発生するならば、
<code class="docutils literal notranslate"><span class="pre">x.store(1)</span></code> には何の保証もないことになる。</p>
</section>
<section id="causal-consistency">
<h4><a class="toc-backref" href="#id14" role="doc-backlink">Causal Consistency</a><a class="headerlink" href="#causal-consistency" title="Permalink to this heading">¶</a></h4>
<p>要件はさらに緩和され、因果関係のある操作の順序しか保証されず、因果関係のない操作の順序は要求されない。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>      a = 1      b = 2
T1 ----+-----------+----------------------------&gt;


T2 ------+--------------------+--------+--------&gt;
      x.store(3)         c = a + b    y.load()
</pre></div>
</div>
<p>または</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>      a = 1      b = 2
T1 ----+-----------+----------------------------&gt;


T2 ------+--------------------+--------+--------&gt;
      x.store(3)          y.load()   c = a + b
</pre></div>
</div>
<p>または</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>     b = 2       a = 1
T1 ----+-----------+----------------------------&gt;


T2 ------+--------------------+--------+--------&gt;
      y.load()            c = a + b  x.store(3)
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>この場合は sequence diagram を作図するのが難しい。</p>
</div>
<p>上に挙げたどの三つの例でも工程全体で</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> だけが <code class="docutils literal notranslate"><span class="pre">a</span></code> と <code class="docutils literal notranslate"><span class="pre">b</span></code> に依存関係を持ち、</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> はこの例では関連性がない</p></li>
</ul>
<p>ため、すべて因果的整合性がある（実際の場面では、<code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> が関連していないと判断するには何らかの根拠が要る）。</p>
</section>
<section id="final-consistency">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">Final Consistency</a><a class="headerlink" href="#final-consistency" title="Permalink to this heading">¶</a></h4>
<p>これが最も弱い整合性要件だ。操作が将来のある時点で観察されることの保証しかせず、それが観察される時間を要求しない。よって、例えば、操作が観測される時間が常に有界であることを指定するなどして、この条件を少し厳しくすることも可能だ。</p>
<figure class="align-center" id="id3">
<div class="mermaid">
            sequenceDiagram
    participant T1
    participant T2
    participant x
    par
        T1-&gt;&gt;+x: store(3)
        T1-&gt;&gt;+x: store(4)
    and
        loop 4 times
            T2-&gt;&gt;+x: load()
        end
    end
        </div><figcaption>
<p><span class="caption-text">Final Consistency</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>上記の場合、<code class="docutils literal notranslate"><span class="pre">x</span></code> の初期値を <code class="docutils literal notranslate"><span class="pre">0</span></code> とすると、<code class="docutils literal notranslate"><span class="pre">T2</span></code> における四度の <code class="docutils literal notranslate"><span class="pre">x.read()</span></code>
の結果は以下の場合が考えられ、これに限定されない：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">x.read()</span></code></p></th>
<th class="head"><p>状況</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>3, 4, 4, 4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span></code> への書き込み動作がただちに確認された</p></td>
</tr>
<tr class="row-odd"><td><p>0, 3, 3, 4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span></code> への書き込み動作の観測時間に遅延がある</p></td>
</tr>
<tr class="row-even"><td><p>0, 0, 0, 4</p></td>
<td><p>最後の読み出しで最終的な <code class="docutils literal notranslate"><span class="pre">x</span></code> の値を読み出したが、それまでの変化は観察されなかった</p></td>
</tr>
<tr class="row-odd"><td><p>0, 0, 0, 0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span></code> への書き込み動作は現在の時間帯では観測されない（しかし <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">4</span></code> という状況は将来のある時点で観測される可能性がある）</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="memory-orders">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Memory Orders</a><a class="headerlink" href="#memory-orders" title="Permalink to this heading">¶</a></h3>
<p>さまざまな強度要件整合性を実現するために、C++11 では不可分操作のためのメモリー順序を六種類定義している。列挙型 <code class="docutils literal notranslate"><span class="pre">std::memory_order</span></code> は複数スレッド間の同期モデルを四つ表現する。</p>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>&lt;<a class="reference external" href="https://en.cppreference.com/w/cpp/atomic/memory_order">https://en.cppreference.com/w/cpp/atomic/memory_order</a>&gt; には以下のようなことが述べられている：</p>
<p><code class="docutils literal notranslate"><span class="pre">std::memory_order</span></code> は通常の（可分な）メモリーアクセスを含むメモリアクセスが、不可分操作の周囲でどのように順序付けられるかを指定するものだ。マルチコアシステムでの制約がない場合、複数のスレッドが複数変数の読み書きを同時に行うと、あるスレッドは、別のスレッドが書き込んだ順番とは異なる順番で値が変化するのを観察できる。実際、見かけ上の変化の順序は、複数の観察スレッド間で異なることさえある。また、メモリーモデルによってコンパイラーが変換を行うため、単プロセッサーシステムでも同様の現象が発生することがある。</p>
</div>
<section id="relaxed-model">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">Relaxed model</a><a class="headerlink" href="#relaxed-model" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::memory_order_relaxed</span></code> で指定されるこのモデルでは、単一スレッド内の不可分操作は順次実行される。命令の並び替えは許されないが、異なるスレッド間の不可分操作の順序は任意である。例：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vt</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">        </span><span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;current counter:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">counter.fetch_add(1)</span></code> はカウンターを 1 増やすのをクリティカルセクションで行うものと思ってよい。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v.emplace_back(args)</span></code> は <code class="docutils literal notranslate"><span class="pre">v.push_back(T(args))</span></code> のようなもの。</p></li>
<li><p>実行結果は <code class="docutils literal notranslate"><span class="pre">100</span></code> が出力されるはずだ。手許の環境でそうなる。</p></li>
</ul>
</div>
</section>
<section id="release-consumption-model">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">Release/consumption model</a><a class="headerlink" href="#release-consumption-model" title="Permalink to this heading">¶</a></h4>
<p>このモデルでは、あるスレッドが値を変更する必要があるときに、別のスレッドがその値に対する特定の操作に依存するようになる場合、つまり、後者が前者に依存するようになる場合、プロセス間の操作順序を制限するようにする。</p>
<p>具体的には、スレッド A が <code class="docutils literal notranslate"><span class="pre">x</span></code> への書き込み三つを完了し、スレッド B が <code class="docutils literal notranslate"><span class="pre">x</span></code> への最初の二つの書き込みとは無関係に、<code class="docutils literal notranslate"><span class="pre">x</span></code> への書き込みのうち三番目だけに依存する場合、A が <code class="docutils literal notranslate"><span class="pre">x.release()</span></code> を開始すると（ここで <code class="docutils literal notranslate"><span class="pre">std::memory_order_release</span></code> を使う）、オプション <code class="docutils literal notranslate"><span class="pre">std::memory_order_consume</span></code> によって、B は <code class="docutils literal notranslate"><span class="pre">x.load()</span></code> が呼ばれたときに A 内の <code class="docutils literal notranslate"><span class="pre">x</span></code> への三度目の書き込みを観測する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// initialize as nullptr to prevent consumer load a dangling pointer</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">ptr</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="nf">producer</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span>
<span class="w">    </span><span class="n">ptr</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
<span class="p">});</span>

<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="nf">consumer</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">)));</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;*p: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;v: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">});</span>

<span class="n">producer</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">consumer</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></div>
</div>
<p>このコードを実行すると <code class="docutils literal notranslate"><span class="pre">*p:</span> <span class="pre">42</span></code> と <code class="docutils literal notranslate"><span class="pre">v:</span> <span class="pre">1024</span></code> が出力される。</p>
<div class="admonition- admonition">
<p class="admonition-title">読者ノート</p>
<p>仕様が改訂されて <code class="docutils literal notranslate"><span class="pre">std::memory_order_consume</span></code> の使用は C++17 から暫定的に非推奨となっているそうだ。</p>
</div>
</section>
<section id="release-acquire-model">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">Release/Acquire model</a><a class="headerlink" href="#release-acquire-model" title="Permalink to this heading">¶</a></h4>
<p>このモデルでは、<code class="docutils literal notranslate"><span class="pre">std::memory_order_release</span></code> と <code class="docutils literal notranslate"><span class="pre">std::memory_order_acquire</span></code>
の間のタイミングを指定することで、異なるスレッド間の不可分操作の順序制限をさらに厳しくすることができる。解放操作の前の書き込み操作のすべてが他のどのスレッドからも見える。</p>
<p><code class="docutils literal notranslate"><span class="pre">std::memory_order_release</span></code> は、解放操作後にそれ以前の書き込みが発生しないことを保証する（後方バリア）。</p>
<p><code class="docutils literal notranslate"><span class="pre">std::memory_order_acquire</span></code> は、取得操作後の読み取りまたは書き込みが獲得操作の前に発生しないようにする（前進バリア）。</p>
<p>オプションの <code class="docutils literal notranslate"><span class="pre">std::memory_order_acq_rel</span></code> はこの二つを組み合わせて、現在のスレッドのメモリーへの読み書きが、この操作の前後で順序が変わって交差しないように、メモリーバリアを一意に決定する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="nf">release</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="n">flag</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
<span class="p">});</span>

<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="nf">acqrel</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// must before compare_exchange_strong</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">))</span>
<span class="w">        </span><span class="n">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// must after compare_exchange_strong</span>
<span class="w">    </span><span class="c1">// flag has changed to 2</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="nf">acquire</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// must be 42</span>
<span class="p">});</span>

<span class="n">release</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">acqrel</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">acquire</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></div>
</div>
<p>今回 <code class="docutils literal notranslate"><span class="pre">compare_exchange_strong</span></code> という比較・交換プリミティブを使用するが、これには <code class="docutils literal notranslate"><span class="pre">compare_exchange_weak</span></code> という弱バージョンがあり、交換が成功しても失敗を返すことができる。その理由は、一部のプラットフォームで偽失敗が発生するためで、具体的には、CPU がコンテキストスイッチを行った際に、別のスレッドが同じアドレスをロードすることによって不整合が発生する。さらに、<code class="docutils literal notranslate"><span class="pre">compare_exchange_strong</span></code> の性能は <code class="docutils literal notranslate"><span class="pre">compare_exchange_weak</span></code> より若干劣るかもしれないが、ほとんどの場合、<code class="docutils literal notranslate"><span class="pre">compare_exchange_weak</span></code> はその使用の複雑さを考えると、推奨されない。</p>
<p>この例では <code class="docutils literal notranslate"><span class="pre">flag</span></code> と <code class="docutils literal notranslate"><span class="pre">expected</span></code> の値が一定の条件で exchange されるというのだろう。</p>
</section>
<section id="sequential-consistent-model">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">Sequential Consistent Model</a><a class="headerlink" href="#sequential-consistent-model" title="Permalink to this heading">¶</a></h4>
<p>このモデルでは、不可分操作は順序整合性を満たすが、その分、性能上の損失が発生し得る。これを <code class="docutils literal notranslate"><span class="pre">std::memory_order_seq_cst</span></code> で明示的に指定する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vt</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">        </span><span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;current counter:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>この例は、最初の例で不可分演算のメモリー順序を <code class="docutils literal notranslate"><span class="pre">memory_order_seq_cst</span></code> に変更しただけだ。出力はもちろん <code class="docutils literal notranslate"><span class="pre">100</span></code> だ。この二種類の性能差を測定するといい。</p>
</section>
</section>
</section>
<section id="conclusion">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Conclusion</a><a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>並行プログラミングの重要なツール</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">std::thread</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::mutex</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::future</span></code></p></li>
</ul>
</li>
<li><p>メモリーモデル</p></li>
</ul>
</section>
<section id="exercises">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Exercises</a><a class="headerlink" href="#exercises" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ThreadPool</span></code> を実装しろ。コンストラクター、メソッド <code class="docutils literal notranslate"><span class="pre">enqueue</span></code>, etc.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::atomic&lt;bool&gt;</span></code> を使って排他制御を実装しろ。</p></li>
</ol>
</section>
<section id="further-readings">
<h2><a class="toc-backref" href="#id23" role="doc-backlink">Further Readings</a><a class="headerlink" href="#further-readings" title="Permalink to this heading">¶</a></h2>
<dl class="simple">
<dt><a class="reference external" href="https://www.amazon.com/dp/1617294691/ref=cm_sw_em_r_mt_dp_U_siEmDbRMMF960">C++ Concurrency in Action</a></dt><dd><p>専門書</p>
</dd>
<dt><a class="reference external" href="https://en.cppreference.com/w/cpp/thread">Thread document</a></dt><dd><p>本章が要点を整理する元になった機能群。</p>
</dd>
<dt><a class="reference external" href="https://doi.org/10.1145/78969.78972">Herlihy, M. P. &amp; Wing, J. M. (1990). Linearizability: a correctness condition for concurrent objects. ACM Transactions on Programming Languages and Systems, 12(3), 463-492.</a></dt><dd><p>何かの論文。</p>
</dd>
</dl>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="chapter06.html" title="Previous document">Chapter 06: Regular Expression</a>
        </li>
        <li>
          <a href="chapter08.html" title="Next document">Chapter 08: File System</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">図書・教科書・仕様書ノート</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Modern C++ Tutorial: C++ 11/14/17/20 On the Fly 読書ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ノートにまとまっていない書籍類一覧</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">シェルノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v5.html">What’s New In Bash 5 ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">C++ ノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python ノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../youtube-dl.html">youtube-dl 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ソフトウェア・ツール・パッケージ・ライブラリーノート</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../google-ime.html">Google 日本語入力利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wslg.html">Windows Subsystem for Linux GUI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oh-my-posh.html">Oh My Posh 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ffmpeg/index.html">FFmpeg 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zoom.html">Zoom Cloud Meetings 利用ノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">その他</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">テーマ別</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../javascript.html">JavaScript 総合</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Modern C++ Tutorial: C++ 11/14/17/20 On the Fly 読書ノート</a><ul>
      <li>Previous: <a href="chapter06.html" title="previous chapter">Chapter 06: Regular Expression</a></li>
      <li>Next: <a href="chapter08.html" title="next chapter">Chapter 08: File System</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2023, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>