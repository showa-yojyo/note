
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenGL Shading Language 4.60 Specification 読書ノート Part 7 &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script async="async" src="../_static/mathjax-v3.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="OpenGL Shading Language 4.60 Specification 読書ノート Part 8" href="note8.html" />
    <link rel="prev" title="OpenGL Shading Language 4.60 Specification 読書ノート Part 6" href="note6.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note6.html" title="Previous document">OpenGL Shading Language 4.60 Specification 読書ノート Part 6</a>
        </li>
        <li>
          <a href="note8.html" title="Next document">OpenGL Shading Language 4.60 Specification 読書ノート Part 8</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="opengl-shading-language-4-60-specification-part-7">
<h1><a class="toc-backref" href="#id2">OpenGL Shading Language 4.60 Specification 読書ノート Part 7</a><a class="headerlink" href="#opengl-shading-language-4-60-specification-part-7" title="Permalink to this heading">¶</a></h1>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#built-in-variables">仕様書該当部分</a></p>
<div class="contents topic" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#opengl-shading-language-4-60-specification-part-7" id="id2">OpenGL Shading Language 4.60 Specification 読書ノート Part 7</a></p>
<ul>
<li><p><a class="reference internal" href="#built-in-variables" id="id3">7. Built-In Variables</a></p>
<ul>
<li><p><a class="reference internal" href="#built-in-language-variables" id="id4">7.1. Built-In Language Variables</a></p>
<ul>
<li><p><a class="reference internal" href="#vertex-shader-special-variables" id="id5">7.1.1. Vertex Shader Special Variables</a></p></li>
<li><p><a class="reference internal" href="#tessellation-control-shader-special-variables" id="id6">7.1.2. Tessellation Control Shader Special Variables</a></p>
<ul>
<li><p><a class="reference internal" href="#tessellation-control-input-variables" id="id7">Tessellation Control Input Variables</a></p></li>
<li><p><a class="reference internal" href="#tessellation-control-output-variables" id="id8">Tessellation Control Output Variables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tessellation-evaluation-shader-special-variables" id="id9">7.1.3. Tessellation Evaluation Shader Special Variables</a></p>
<ul>
<li><p><a class="reference internal" href="#tessellation-evaluation-input-variables" id="id10">Tessellation Evaluation Input Variables</a></p></li>
<li><p><a class="reference internal" href="#tessellation-evaluation-output-variables" id="id11">Tessellation Evaluation Output Variables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#geometry-shader-special-variables" id="id12">7.1.4. Geometry Shader Special Variables</a></p>
<ul>
<li><p><a class="reference internal" href="#geometry-shader-input-variables" id="id13">Geometry Shader Input Variables</a></p></li>
<li><p><a class="reference internal" href="#geometry-shader-output-variables" id="id14">Geometry Shader Output Variables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fragment-shader-special-variables" id="id15">7.1.5. Fragment Shader Special Variables</a></p></li>
<li><p><a class="reference internal" href="#compute-shader-special-variables" id="id16">7.1.6. Compute Shader Special Variables</a></p></li>
<li><p><a class="reference internal" href="#compatibility-profile-built-in-language-variables" id="id17">7.1.7. Compatibility Profile Built-In Language Variables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#compatibility-profile-vertex-shader-built-in-inputs" id="id18">7.2. Compatibility Profile Vertex Shader Built-In Inputs</a></p></li>
<li><p><a class="reference internal" href="#built-in-constants" id="id19">7.3. Built-In Constants</a></p>
<ul>
<li><p><a class="reference internal" href="#compatibility-profile-built-in-constants" id="id20">7.3.1. Compatibility Profile Built-In Constants</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#built-in-uniform-state" id="id21">7.4. Built-In Uniform State</a></p>
<ul>
<li><p><a class="reference internal" href="#compatibility-profile-state" id="id22">7.4.1. Compatibility Profile State</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#redeclaring-built-in-blocks" id="id23">7.5. Redeclaring Built-In Blocks</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="built-in-variables">
<h2><a class="toc-backref" href="#id3">7. Built-In Variables</a><a class="headerlink" href="#built-in-variables" title="Permalink to this heading">¶</a></h2>
<div class="section" id="built-in-language-variables">
<h3><a class="toc-backref" href="#id4">7.1. Built-In Language Variables</a><a class="headerlink" href="#built-in-language-variables" title="Permalink to this heading">¶</a></h3>
<p>シェーダーの機能外で行われたり、シェーダー実行形式に値を提供したり、シェーダー実行形式から値を受け取ったりする必要がある操作もある。シェーダーは、組み込み入力変数と出力変数を使って、固定機能のパイプライン段階や、オプションで他のシェーダー実行形式と通信する。</p>
<div class="section" id="vertex-shader-special-variables">
<h4><a class="toc-backref" href="#id5">7.1.1. Vertex Shader Special Variables</a><a class="headerlink" href="#vertex-shader-special-variables" title="Permalink to this heading">¶</a></h4>
<p>本文で示されているように、組み込み頂点シェーダー変数が内的に宣言されている。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#vertex-shader-special-variables">コード片</a></p>
</div>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> は同次座標系の頂点位置を書き込むためのものだ。シェーダー実行中のいつでも書き込むことができる。この値が用いられるのは、頂点処理が行われた後に基本形状を操作する基本形状組み立て、切り取り、間引き、その他の固定機能操作だ。基本形状への操作が存在すれば、頂点の処理が行われた後に起こる。頂点シェーダー実行形式が <code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> を書いていない場合、頂点処理段階後ではその値は未定義となる。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_PointSize</span></code> は、ラスタライズされる点の大きさをシェーダーが書き込むためのものだ。これは画素で測定される。
<code class="docutils literal notranslate"><span class="pre">gl_PointSize</span></code> が書き込まれない場合、その値は後続のパイプ段階では未定義となる。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> は、切り取り距離を書き込むためのもので、ユーザー切り取りを制御するための前方互換装置だ。要素 <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance[i]</span></code> は、各平面 <code class="docutils literal notranslate"><span class="pre">i</span></code> に対する切り取り距離を指定する。距離が 0 であれば、頂点が平面上にあることを意味し、正の距離であれば、頂点が切り取り平面の内側にあることを意味し、負の距離であれば、頂点が切り取り平面の外側にあることを意味する。切り取り距離は基本形状全体を線形補間し、補間された距離が 0 より小さい基本形状の部分が切り取られる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> 配列はサイズなしとして事前に宣言されているので、シェーダーが明示的にサイズを再宣言するか、定整数式のみでインデックスをつけて暗黙的にサイズを決める必要がある。これには有効になっているすべての切り取り平面を含むように配列のサイズを API を通じて決める必要がある。サイズが有効平面すべてを含まない場合、結果は未定義だ。サイズは最大で <code class="docutils literal notranslate"><span class="pre">gl_MaxClipDistances</span></code> となる。
<code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> が消費する varying 成分の個数は、平面がいくつ有効であろうが、配列のサイズと一致する。シェーダはまた、APIを介して有効にされた <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> のすべての値を設定しなければならない。有効化されていない平面に対する <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> に書き込まれる値は何の効果もない。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> は、ユーザー間引きを制御するための装置だ。要素 <code class="docutils literal notranslate"><span class="pre">gl_CullDistance[i]</span></code> は平面 <code class="docutils literal notranslate"><span class="pre">i</span></code> の間引き距離を指定する。距離が 0 であれば、頂点が平面上にあることを意味し、正の距離であれば、頂点が間引きボリュームの内側にあることを意味し、負の距離であれば、頂点が間引きボリュームの外側にあることを意味する。すべての頂点が平面 <code class="docutils literal notranslate"><span class="pre">i</span></code> に対して負の間引き距離である基本形状は破棄される。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> 配列はサイズなしと事前宣言されており、シェーダーがサイズを再宣言するか、定整数式だけでインデックスをつけるかして、サイズを決めなければならない。サイズは、有効間引き距離の個数と集合を決定するものであって、最大で
<code class="docutils literal notranslate"><span class="pre">gl_MaxCullDistances</span></code> となる。
<code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> が消費する　varying 成分数は配列のサイズと一致する。
<code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> を書いているシェーダーは、有効距離すべてを書かなければならず、さもなければ間引きの結果は未定義となる。</p>
<p>出力変数としての <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> はシェーダーがこれらの距離を書き込む場所を用意する。断片言語以外では入力として、直前のシェーダー段階で書き込まれた値を読み込む。断片言語では、
<code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> 配列は、シェーダーによって <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> 頂点出力変数に書き込まれた頂点値を線形補間した値を含む。</p>
<p>プログラムを構成する一連のシェーダーにおいて、
<code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> 配列と <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> 配列のサイズの合計が
<code class="docutils literal notranslate"><span class="pre">gl_MaxCombinedClipAndCullDistances</span></code> よりも大きくなると、コンパイルエラーまたはリンクエラー。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_VertexID</span></code> は OpenGL 仕様書の 11.1.3.9 “Shader Inputs” で定義されている、頂点の整数インデックスを保持する頂点シェーダー入力変数だ。これは Vulkan を対象にしていない場合に限って存在する。存在するとしても、
<code class="docutils literal notranslate"><span class="pre">gl_VertexID</span></code> の値が常に定義されているとは限らない。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_InstanceID</span></code> は頂点シェーダの入力変数で、インスタンス化された描画呼び出しにおける現在の基本形状のインスタンス番号を保持する。これは Vulkan を対象にしていない場合に限って存在する。現在の基本形状がインスタンス化された描画呼び出しによるものでない場合、
<code class="docutils literal notranslate"><span class="pre">gl_InstanceID</span></code> の値はゼロだ。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_VertexIndex</span></code> は頂点言語の入力変数で、ある基準 (a base) からの頂点の整数インデックスを保持する。これは Vulkan を対象にしている場合に限って存在する。存在するとしても、
<code class="docutils literal notranslate"><span class="pre">gl_VertexIndex</span></code> の値が常に定義されているとは限らない。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_InstanceIndex</span></code> は、頂点言語の入力変数で、インスタンス化された描画呼び出しにおける現在の基本形状のインスタンス番号を、ある基準 (a base) からの相対値で保持する。これは Vulkan を対象にしている場合に限り存在する。現在の基本形状がインスタンス化された描画呼び出しによるものでない場合、
<code class="docutils literal notranslate"><span class="pre">gl_InstanceIndex</span></code> の値はゼロだ。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_DrawID</span></code> は頂点シェーダーの入力変数であり、現在の頂点が属する描画命令の整数インデックスを保持する。頂点が <code class="docutils literal notranslate"><span class="pre">Multi*</span></code> 形式の描画命令によって呼び出されていない場合、
<code class="docutils literal notranslate"><span class="pre">gl_DrawID</span></code> の値はゼロだ。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_BaseVertex</span></code> は頂点シェーダー入力変数であり、現在のシェーダーの呼び出しを起こした命令の
<code class="docutils literal notranslate"><span class="pre">baseVertex</span></code> 引数に渡された整数値を保持する。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_BaseInstance</span></code> は頂点シェーダー入力変数であり、現在のシェーダー呼び出しを起こした命令の
<code class="docutils literal notranslate"><span class="pre">baseInstance</span></code> 引数に渡された整数値を保持する。</p>
</div>
<div class="section" id="tessellation-control-shader-special-variables">
<h4><a class="toc-backref" href="#id6">7.1.2. Tessellation Control Shader Special Variables</a><a class="headerlink" href="#tessellation-control-shader-special-variables" title="Permalink to this heading">¶</a></h4>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>細分化制御シェーダーで内在的に宣言されている組み込み変数の仕様。
<a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html##tessellation-control-shader-special-variables">コード片</a></p>
</div>
<div class="section" id="tessellation-control-input-variables">
<h5><a class="toc-backref" href="#id7">Tessellation Control Input Variables</a><a class="headerlink" href="#tessellation-control-input-variables" title="Permalink to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">gl_Position</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_PointSize</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> には、直前のシェーダー段階に対応する出力に書き込まれた値を含む。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_PatchVerticesIn</span></code> はシェーダーで処理される入力パッチの頂点数を含む。単一のシェーダーが異なるサイズのパッチを読み込むことができるので、
<code class="docutils literal notranslate"><span class="pre">gl_PatchVerticesIn</span></code> の値はパッチ間で異なる可能性がある。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> は、レンダリング基本形状の現在の集合が開始された以降にシェーダーによって処理された基本形状の数を含む。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_InvocationID</span></code> は、細分化制御シェーダーの呼び出しに代入した出力パッチ頂点数を含む。範囲 <span class="math notranslate nohighlight">\({[0, N-1]}\)</span> の整数値が代入されており、N は基本形状ごとの出力パッチ頂点の個数だ。</p>
</div>
<div class="section" id="tessellation-control-output-variables">
<h5><a class="toc-backref" href="#id8">Tessellation Control Output Variables</a><a class="headerlink" href="#tessellation-control-output-variables" title="Permalink to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">gl_Position</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_PointSize</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> は対応する頂点シェーダーの出力変数と同じ方法で使用される。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_TessLevelOuter</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_TessLevelInner</span></code> に書き込まれた値は、出力パッチの対応する外側・内側細分化レベルに代入される。これらの値は細分化基本形状生成器が基本形状細分化を制御するために使用され、細分化評価シェーダーが読み取ることができる。</p>
</div>
</div>
<div class="section" id="tessellation-evaluation-shader-special-variables">
<h4><a class="toc-backref" href="#id9">7.1.3. Tessellation Evaluation Shader Special Variables</a><a class="headerlink" href="#tessellation-evaluation-shader-special-variables" title="Permalink to this heading">¶</a></h4>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>細分化評価シェーダーで内在的に宣言されている組み込み変数の仕様。
<a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#tessellation-evaluation-shader-special-variables">コード片</a></p>
</div>
<div class="section" id="tessellation-evaluation-input-variables">
<h5><a class="toc-backref" href="#id10">Tessellation Evaluation Input Variables</a><a class="headerlink" href="#tessellation-evaluation-input-variables" title="Permalink to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">gl_Position</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_PointSize</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> は、直前のシェーダー段階に対応する出力に書き込まれた値を含む。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_PatchVerticesIn</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> は細分化制御シェーダーで対応する入力変数と同じ方法で定義される。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_TessCoord</span></code> は細分化される基本形状に対するシェーダーで処理される頂点の位置を識別する三成分 <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v</span> <span class="pre">,w)</span></code> ベクトルを指定する。値は以下の性質に従い、細分計算を再現する援助とする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c1">// two operations performed</span><span class="w"></span>
<span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="c1">// two operations performed</span><span class="w"></span>
<span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">gl_TessCoord</span><span class="p">.</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="c1">// two operations performed</span><span class="w"></span>
</pre></div>
</div>
<p>細分化制御シェーダーがアクティブな場合、入力変数 <code class="docutils literal notranslate"><span class="pre">gl_TessLevelOuter</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_TessLevelInner</span></code> はその細分化制御シェーダーによって書き込まれた出力に対応するもので埋められる。それ以外の場合は、OpenGL 仕様の 11.2.3.3 “Tessellation Evaluation Shader Inputs”で指定された既定の細分化レベルが代入される。</p>
</div>
<div class="section" id="tessellation-evaluation-output-variables">
<h5><a class="toc-backref" href="#id11">Tessellation Evaluation Output Variables</a><a class="headerlink" href="#tessellation-evaluation-output-variables" title="Permalink to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">gl_Position</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_PointSize</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> は対応する頂点シェーダーの出力変数と同じ方法で使用される。</p>
</div>
</div>
<div class="section" id="geometry-shader-special-variables">
<h4><a class="toc-backref" href="#id12">7.1.4. Geometry Shader Special Variables</a><a class="headerlink" href="#geometry-shader-special-variables" title="Permalink to this heading">¶</a></h4>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>幾何シェーダーで内在的に宣言されている組み込み変数の仕様。
<a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#geometry-shader-special-variables">コード片</a></p>
</div>
<div class="section" id="geometry-shader-input-variables">
<h5><a class="toc-backref" href="#id13">Geometry Shader Input Variables</a><a class="headerlink" href="#geometry-shader-input-variables" title="Permalink to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">gl_Position</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_PointSize</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> には直前のシェーダー段階で対応する出力に書き込まれた値を含む。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_PrimitiveIDIn</span></code> は、レンダリング基本形状の現在の集合が開始された以降にシェーダーによって処理された基本形状の数を含む。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_InvocationID</span></code> は、幾何シェーダーの呼び出しに代入した呼び出し番号を含む。範囲 <span class="math notranslate nohighlight">\({[0, N-1]}\)</span> の整数値が代入されており、N は基本形状ごとの幾何シェーダーの呼び出し回数だ。</p>
</div>
<div class="section" id="geometry-shader-output-variables">
<h5><a class="toc-backref" href="#id14">Geometry Shader Output Variables</a><a class="headerlink" href="#geometry-shader-output-variables" title="Permalink to this heading">¶</a></h5>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>ここの節は未知の概念が特に多く含まれる。何か手がかりとなるものはないか。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_Position</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_PointSize</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> は対応する頂点シェーダーの出力変数と同じ方法で使用される。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> には、断片シェーダーに対する基本形状識別子として機能する単一の整数で埋められる。これは断片シェーダーが利用できるもので、シェーディングされる基本形状の provoking 頂点から書き込まれた基本形状 ID を選択することになる。
<code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> を使用する断片シェーダーがアクティブで、幾何シェーダーもアクティブな場合、幾何シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> に書き込まなければ、断片シェーダーの入力 <code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> は未定義となる。詳しくは OpenGL 仕様の 11.3.4.5 “Geometry Shader Outputs” を参照。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> は多重レイヤーフレームバッファー付属物の特定のレイヤー（またはキューブマップの面とレイヤー）を選択するために使用される。実際に使用されるレイヤーは、シェーディングされている基本形状の頂点一つに由来する。その由来がどこかは、OpenGL 仕様書 11.3.4.6 “Layer and Viewport Selection” で議論されているように決定されるが、未定義の場合もあるので、基本形状の頂点すべてに同じレイヤーの値を書くのがよかろう。シェーダが静的に <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> に値を代入すると、レイヤーありレンダリングモードが有効になる。詳細は OpenGL 仕様書の 11.3.4.5 と 9.4.9 “Layered Framebuffers” を参照。シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> に静的に値を代入し、
<code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> を設定しないシェーダーの実行経路がある場合、その経路を通るシェーダーの実行では <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> の値は未定義となる。</p>
<p>出力変数 <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> は、キューブマップテクスチャーの配列で使用される場合、特別な値をとる。レイヤーを参照するばかりではなく、キューブマップの面とレイヤーを選択するために使用される。
<code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> に値 <code class="docutils literal notranslate"><span class="pre">layer</span> <span class="pre">*</span> <span class="pre">6</span> <span class="pre">+</span> <span class="pre">face</span></code> を設定すると、レンダリングは <code class="docutils literal notranslate"><span class="pre">layer</span></code> レイヤーで定義された立方体の面に行われる。面値は OpenGL 仕様書 9.4.9 表 9.3 に定義されている：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Face Value</p></th>
<th class="head"><p>Resulting Target</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TEXTURE_CUBE_MAP_POSITIVE_X</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TEXTURE_CUBE_MAP_NEGATIVE_X</span></code></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TEXTURE_CUBE_MAP_POSITIVE_Y</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TEXTURE_CUBE_MAP_NEGATIVE_Y</span></code></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TEXTURE_CUBE_MAP_POSITIVE_Z</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TEXTURE_CUBE_MAP_NEGATIVE_Z</span></code></p></td>
</tr>
</tbody>
</table>
<p>例えば、キューブマップ配列の第 5 層に位置する正の <code class="docutils literal notranslate"><span class="pre">y</span></code> のキューブマップ面にレンダリングするには、
<code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> を <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">6</span> <span class="pre">+</span> <span class="pre">2</span></code> に設定する。</p>
<p>出力変数 <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> は、幾何シェーダーが出力する次回基本形状が描画されるべきビューポートのインデックスを提供する。幾何シェーダーが生成する基本形状は <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> の値によって選択されたビューポート変換と鋏矩形を使用して、ビューポート変換と鋏検定を行う。使用されるビューポートインデックスは、シェーディングされる基本形状の頂点の一つに由来する。しかし、ビューポートインデックスがどの頂点から来ているかは実装依存であるので、基本形状の頂点すべてに同じビューポートインデックスを使用するのが得策だ。幾何シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> に値を代入していない場合、ビューポート変換と鋏矩形 0 が使用される。幾何シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> に値を静的代入し、シェーダーの中に <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> に値を代入しない実行経路がある場合、そこを通るシェーダーの実行時には <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> の値は未定義となる。詳細については OpenGL 仕様書の 11.3.4.6 “Layer and Viewport Selection” を参照。</p>
</div>
</div>
<div class="section" id="fragment-shader-special-variables">
<h4><a class="toc-backref" href="#id15">7.1.5. Fragment Shader Special Variables</a><a class="headerlink" href="#fragment-shader-special-variables" title="Permalink to this heading">¶</a></h4>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>断片シェーダーで内在的に宣言されている組み込み変数の仕様。
<a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#">コード片</a></p>
</div>
<p>断片シェーダー実行形式の出力は、API パイプラインの後段にある固定機能演算によって処理される。</p>
<p>断片に対する固定機能で計算された奥行きは <code class="docutils literal notranslate"><span class="pre">gl_FragCoord.z</span></code> を読み取ることで得られる可能性がある。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> に書き込むと、処理中の断片の奥行き値が確定する。奥行きバッファリングが有効で、どのシェーダーも <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> を書き込まない場合は、奥行きの固定関数値が断片の奥行き値として使用される。シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> に値を静的代入し、シェーダーの中に
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> を設定しない実行経路がある場合、その経路を通るシェーダーの実行では、断片の奥行きの値が未定義になる可能性がある。つまり、リンクされた断片シェーダーの集合が
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> への書き込みを静的に含む場合は、常にそれを書き込む責任がある。</p>
<p>シェーダーが <code class="docutils literal notranslate"><span class="pre">discard</span></code> キーワードを実行した場合、断片は廃棄され、ユーザー定義断片出力、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_SampleMask</span></code> の値は意味がなくなる。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> は断片シェーダー内からの入力変数として利用でき、断片のウィンドウ相対座標 <code class="docutils literal notranslate"><span class="pre">(x、y、z、1/w)</span></code> の値を保持する。多重サンプリングの場合、この値は画素内の任意の位置、または断片標本の一つたり得る。
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> を使用しても、この値は現在の基本形状の内部に制限されない。この値は頂点処理後の基本形状を補間して断片を生成する固定機能の結果だ。
<code class="docutils literal notranslate"><span class="pre">z</span></code> 成分はどのシェーダーも <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> への書き込みを含んでいない場合に、断片の奥行きに使用されるであろう値だ。これは、シェーダーが条件付きで <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> を計算するが、そうでなければ固定機能の断片の奥行きを求める場合のばらつきに役立つ。</p>
<p>断片シェーダーは入力組み込み変数 <code class="docutils literal notranslate"><span class="pre">gl_FrontFacing</span></code> にアクセスでき、その値は断片が正面基本形状に属していれば真となる。使い方としては、頂点シェーダーや幾何シェーダーで計算された二つの色のうちの一つを選択することで、両面照光を模倣することができる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_PointCoord</span></code> の値は点スプライトが有効な場合、点基本形状の中で現在の断片がどの位置にあるかを示す二次元座標だ。これらの値は、点全体で 0.0 から 1.0 の範囲にある。現在の基本形状が点でない場合や、点スプライトが有効でない場合は
<code class="docutils literal notranslate"><span class="pre">gl_PointCoord</span></code> から読み取られる値は未定義だ。</p>
<p>入力配列 <code class="docutils literal notranslate"><span class="pre">gl_SampleMaskIn[]</span></code> と出力配列 <code class="docutils literal notranslate"><span class="pre">gl_SampleMask[]</span></code> の両方について、マスク M の、ここでは <code class="docutils literal notranslate"><span class="pre">gl_SampleMaskIn[M]</span></code> または <code class="docutils literal notranslate"><span class="pre">gl_SampleMask[M]</span></code> のビット
B は標本 <code class="docutils literal notranslate"><span class="pre">32</span> <span class="pre">*</span> <span class="pre">M</span> <span class="pre">+</span> <span class="pre">B</span></code> に対応する。これらの配列は
<code class="docutils literal notranslate"><span class="pre">ceil(s</span> <span class="pre">/</span> <span class="pre">32)</span></code> 個の要素を持つ。ここで <code class="docutils literal notranslate"><span class="pre">s</span></code> は実装で対処されている色標本の最大数だ。</p>
<p>入力変数 <code class="docutils literal notranslate"><span class="pre">gl_SampleMaskIn</span></code> は、多重標本ラスタライズ時に断片を生成する基本形状が被覆する標本の集合を示す。</p>
<p>出力配列 <code class="docutils literal notranslate"><span class="pre">gl_SampleMask[]</span></code> は、処理中の断片の標本マスクを設定する。現在の断片に対する被覆範囲は、被覆範囲マスクと出力の
<code class="docutils literal notranslate"><span class="pre">gl_SampleMask</span></code> の論理積になる。この配列は、断片シェーダーの中で、最大標本数で決まる実装依存の最大標本マスク（32 ビット要素の配列として）よりも大きくならないようにサイズを暗黙的または明示的に決めなければならない。断片シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_SampleMask</span></code> に値を静的代入する場合、値の代入に失敗するどのような断片シェーダー呼び出しのどのような配列要素についても標本マスクは未定義となる。シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_SampleMask</span></code> に値を静的代入していない場合、標本マスクは断片の処理に影響を与えない。</p>
<p>入力変数 <code class="docutils literal notranslate"><span class="pre">gl_SampleID</span></code> には現在処理されている標本の標本番号が入る。この変数は 0 から <code class="docutils literal notranslate"><span class="pre">gl_NumSamples</span> <span class="pre">-</span> <span class="pre">1</span></code> の範囲にある。ここで
<code class="docutils literal notranslate"><span class="pre">gl_NumSamples</span></code> はフレームバッファー内の標本の総数であり、非多重標本フレームバッファーにレンダリングする場合は 1 だ。断片シェーダーでのこの変数の静的使用は、シェーダー全体が標本ごとに評価されるようになる。</p>
<p>入力変数 <code class="docutils literal notranslate"><span class="pre">gl_SamplePosition</span></code> は、多重標本描画バッファー内の現在の標本の位置を含む。
<code class="docutils literal notranslate"><span class="pre">gl_SamplePosition</span></code> の <code class="docutils literal notranslate"><span class="pre">x</span></code> および <code class="docutils literal notranslate"><span class="pre">y</span></code> 成分には、現在の標本の部分画素座標が含まれており、0.0 から 1.0 の範囲の値を持つ。断片シェーダーでのこの変数の静的使用は、シェーダー全体が標本ごとに評価されるようになる。</p>
<p>値 <code class="docutils literal notranslate"><span class="pre">gl_HelperInvocation</span></code> は断片シェーダーの呼び出しが補助呼び出しとみなされる場合は真、そうでない場合は偽になる。補助呼び出しとは、断片シェーダー非補助呼び出しで使用するための微分係数を評価する目的でのみ作成された断片シェーダー呼び出しだ。このような微分係数は、組み込み関数 <code class="docutils literal notranslate"><span class="pre">texture()</span></code> で暗黙的に計算され
(<a class="reference internal" href="note8.html#texture-functions"><span class="std std-ref">8.9. Texture Functions</span></a>)、例えば <code class="docutils literal notranslate"><span class="pre">dFdx()</span></code> や <code class="docutils literal notranslate"><span class="pre">dFdy()</span></code> など、
<a class="reference internal" href="note8.html#derivative-functions"><span class="std std-ref">8.14.1. Derivative Functions</span></a> の導関数で明示的に計算される。</p>
<p>断片シェーダー補助呼び出しは、非補助呼び出しと同じシェーダーコードを実行するが、フレームバッファーや他のシェーダーにアクセス可能なメモリーを修正する副作用はない。特に：</p>
<ul class="simple">
<li><p>補助呼び出しに対応する断片は、シェーダーの実行が完了すると、フレームバッファーを更新することなく破棄される。</p></li>
<li><p>補助呼び出しによって実行される画像およびバッファー変数への格納は、裏方の画像またはバッファーのメモリーに影響を与えない。</p></li>
<li><p>補助の呼び出しによって実行される、画像、バッファー、不可分計数器変数への不可分操作は、裏方の画像、バッファーメモリに影響を与えない。このような不可分操作によって返される値は未定義だ。</p></li>
</ul>
<p>補助呼び出しは、レンダリングされている基本形状によって被覆されていない画素に対して生成されることがある。
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> 修飾された断片シェーダーの入力は、通常、画素と基本形状の交点で採取される必要があるが、画素と基本形状の間には交点がないため、このような画素ではその要求は無視される。</p>
<p>補助呼び出しは、断片が早期断片検定（修飾子 <code class="docutils literal notranslate"><span class="pre">early_fragment_tests</span></code> を使用）によって殺されたときにレンダリングされる基本形状が被覆する断片に対して生成されるかもしれないし、断片シェーダーを実行しても他の断片シェーダー呼び出しのための導関数の計算を支援する以外の効果がないことを実装が判断できる場合にも生成される。</p>
<p>基本形状の任意の集合を処理するときに生成される補助呼び出しの集合は実装依存だ。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> は、シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> 出力変数に書き込む頂点パイプラインの値を線形補間した値を含む。この配列の中で切り取りが有効になっている要素しか定義された値を持たないことになる。</p>
<p>入力変数 <code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> には、幾何シェーダーが存在する場合は、
<code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> 幾何シェーダー出力に書き込まれた値が入る。それ以外の場合は、レンダリング基本形状の現在の集合が開始されてから、シェーダーによって処理された基本形状の個数で埋められる。</p>
<p>入力変数 <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> には、幾何シェーダーが存在する場合は、
<code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> 幾何シェーダー出力に書き込まれた値が入る。幾何段階が値を <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> に動的代入しない場合、断片段階での <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> の値は未定義となる。幾何段階が <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> に静的代入を行わない場合、断片段階の入力値は 0 になる。そうでなければ、断片段階は、幾何段階が書き込んだ値と同じ値を、その値が範囲外であったとしても読み込む。断片シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_Layer</span></code> への静的アクセスを含む場合、それは断片段階への入力の最大数に対する実装定義の限界に加味される。</p>
<p>入力変数 <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> には、幾何シェーダーが存在する場合には、幾何段階の出力変数 <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> に書き込まれた値が入る。幾何段階で <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> に値を動的代入しない場合は、断片シェーダーでの <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> の値は未定義となる。幾何段階が <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> に静的代入を行わない場合、断片段階は 0 を読み取る。そうでなければ、たとえその値が範囲外であったとしても、断片段階は幾何段階が書き込んだのと同じ値を読み取る。断片シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_ViewportIndex</span></code> への静的アクセスを含む場合、それは断片段階への入力の最大数に対する実装定義の限界に加味される。</p>
</div>
<div class="section" id="compute-shader-special-variables">
<h4><a class="toc-backref" href="#id16">7.1.6. Compute Shader Special Variables</a><a class="headerlink" href="#compute-shader-special-variables" title="Permalink to this heading">¶</a></h4>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>計算シェーダーで宣言されている組み込み変数の仕様。
<a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#compute-shader-special-variables">コード片</a></p>
</div>
<p>組み込み変数 <code class="docutils literal notranslate"><span class="pre">gl_NumWorkGroups</span></code> とは計算シェーダー入力変数であって、計算シェーダーを実行する dispatch の各次元の作業グループ数を含むものだ。その内容は DispatchCompute API 入場地点に渡された
<code class="docutils literal notranslate"><span class="pre">num_groups_x</span></code>, <code class="docutils literal notranslate"><span class="pre">num_groups_y</span></code>, <code class="docutils literal notranslate"><span class="pre">num_groups_z</span></code> の各引数が指定する値に等しい。</p>
<p>組み込み定数 <code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> は、シェーダーの作業グループサイズを含む計算シェーダー定数だ。
X, Y, Z 次元における作業グループのサイズは <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> の各成分に格納される。
<code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> の定数値は、現在のシェーダーに必要な
<code class="docutils literal notranslate"><span class="pre">local_size_x</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_y</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> レイアウト修飾子で指定されたものと一致する。作業グループ内で共有できるメモリーの配列のサイズを決めるのに使用できるようにするためにこれは定数だ。固定の作業グープサイズを宣言していないシェーダーで、あるいはそのシェーダーが固定の作業グループサイズを宣言する前に、
<code class="docutils literal notranslate"><span class="pre">local_size_x</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_y</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> を使って
<code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> を使用するとコンパイルエラーとなる。</p>
<p>組み込み変数 <code class="docutils literal notranslate"><span class="pre">gl_WorkGroupID</span></code> は、現在の呼び出しが実行されている作業グループの三次元インデックスを含む計算シェーダーの入力変数だ。取り得る値は <code class="docutils literal notranslate"><span class="pre">DispatchCompute</span></code> に渡された引数の範囲、すなわち <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> から
<code class="docutils literal notranslate"><span class="pre">(gl_NumWorkGroups.x</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">gl_NumWorkGroups.y</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">gl_NumWorkGroups.z</span> <span class="pre">-</span> <span class="pre">1)</span></code>
までだ。</p>
<p>組み込み変数 <code class="docutils literal notranslate"><span class="pre">gl_LocalInvocationID</span></code> は、作業グループ内の現在の作業項目の三次元インデックスを含む計算シェーダーの入力変数だ。この変数の取り得る値は、作業グループのサイズの範囲、すなわち <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> から
<code class="docutils literal notranslate"><span class="pre">(gl_WorkGroupSize.x</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">gl_WorkGroupSize.y</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">gl_WorkGroupSize.z</span> <span class="pre">-</span> <span class="pre">1)</span></code>
までだ。
<code class="docutils literal notranslate"><span class="pre">gl_LocalInvocationID</span></code> の使用は、
<code class="docutils literal notranslate"><span class="pre">local_size_x</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_y</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> の宣言の前に許される。</p>
<p>組み込み変数 <code class="docutils literal notranslate"><span class="pre">gl_GlobalInvocationID</span></code> は、現在の作業項目の大域インデックスを含む計算シェーダーの入力変数だ。この値は、現在の <code class="docutils literal notranslate"><span class="pre">DispatchCompute</span></code> 呼び出しによって開始されたすべての作業グループにわたる他のすべての呼び出しからこの呼び出しを一意に識別する。これは次のように計算される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="nb">gl_GlobalInvocationID</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="nb">gl_WorkGroupID</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_WorkGroupSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">gl_LocalInvocationID</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>組み込み変数 <code class="docutils literal notranslate"><span class="pre">gl_LocalInvocationIndex</span></code> は <code class="docutils literal notranslate"><span class="pre">gl_LocalInvocationID</span></code> の一次元表現を含む計算シェーダーの入力変数だ。これは次のように計算される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="nb">gl_LocalInvocationIndex</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="nb">gl_LocalInvocationID</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_WorkGroupSize</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_WorkGroupSize</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">    </span><span class="nb">gl_LocalInvocationID</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_WorkGroupSize</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">    </span><span class="nb">gl_LocalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_LocalInvocationIndex</span></code> の使用は、
<code class="docutils literal notranslate"><span class="pre">local_size_x</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_y</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> を宣言する前に許される。</p>
</div>
<div class="section" id="compatibility-profile-built-in-language-variables">
<h4><a class="toc-backref" href="#id17">7.1.7. Compatibility Profile Built-In Language Variables</a><a class="headerlink" href="#compatibility-profile-built-in-language-variables" title="Permalink to this heading">¶</a></h4>
<p>互換性プロファイルを使用する場合、GL は頂点および断片のプログラム可能パイプライン段階に固定機能の動作を供給することができる。例えば、固定機能の頂点段階とプログラム可能な断片段階を混在させることができる。</p>
<p>後続のプログラム可能シェーダ段階や固定機能の断片段階の入力を指定するために、次の組み込み頂点、細分化制御、細分化評価、幾何出力変数が利用可能だ。特定の変数は、対応する断片シェーダーまたは固定パイプラインのいずれかの機能がその変数またはその変数から派生した状態を使用する場合、書き込まれるべきだ。それ以外の場合、動作は未定義だこれらの言語では、出力 <code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> ブロックに以下のメンバーが追加されている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="nb">gl_PerVertex</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// part of the gl_PerVertex block described in 7.1</span><span class="w"></span>
<span class="w">    </span><span class="c1">// in addition to other gl_PerVertex members...</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_ClipVertex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_FrontColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_BackColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_FrontSecondaryColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_BackSecondaryColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_TexCoord</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_FogFragCoord</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>出力変数 <code class="docutils literal notranslate"><span class="pre">gl_ClipVertex</span></code> は、頂点シェーダーと幾何シェーダーが、ユーザー切り取り平面で使用する座標を書き込む場所を与える。
<code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> への書き込みは、ユーザー切り取りのための好ましい方法だ。プログラムを構成する一連のシェーダーが <code class="docutils literal notranslate"><span class="pre">gl_ClipVertex</span></code> と
<code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> または <code class="docutils literal notranslate"><span class="pre">gl_CullDistance</span></code> の両方を静的に読み書きすることは、コンパイルエラーまたはリンクエラーとなる。
<code class="docutils literal notranslate"><span class="pre">gl_ClipVertex</span></code> も <code class="docutils literal notranslate"><span class="pre">gl_ClipDistance</span></code> も書き込まれていない場合、それらの値は未定義であり、ユーザー切り取り平面に対するいかなる切り取りも未定義となる。</p>
<p>前にコアプロファイルについて説明したのと同様に、
<code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> ブロックをシェーダーで再宣言して、これらの追加メンバーを明示的に含めることができる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="nb">gl_PerVertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_Position</span><span class="p">;</span><span class="w">    </span><span class="c1">// will use gl_Position</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FrontColor</span><span class="p">;</span><span class="w">  </span><span class="c1">// will consume gl_color in the fragment shader</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_BackColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_TexCoord</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"> </span><span class="c1">// 3 elements of gl_TexCoord will be used</span><span class="w"></span>
<span class="p">};</span><span class="w"> </span><span class="c1">// no other aspects of the fixed interface will be used</span><span class="w"></span>
</pre></div>
</div>
<p>ユーザーは切り取り頂点とユーザー切り取り平面が同じ座標空間で定義されていることを間違いなくする必要がある。ユーザー切り取り平面は線形変換のもとでしか適切に動作しない。非線形変換のもとで何が起こるかは未定義である。</p>
<p>出力変数 <code class="docutils literal notranslate"><span class="pre">gl_FrontColor</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_FrontSecondaryColor</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_BackColor</span></code>,
<code class="docutils literal notranslate"><span class="pre">gl_BackSecondaryColor</span></code> は、処理される頂点を含む基本形状の正面と背面の一次色と二次色を代入する。出力変数 <code class="docutils literal notranslate"><span class="pre">gl_TexCoord</span></code> は処理される頂点のテクスチャー座標を代入する。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_FogFragCoord</span></code> の場合、OpenGL 仕様の互換性プロファイルの 16.4 “Fog” の“c” 値として、固定機能パイプラインで使用されるので、書き込まれた値が使用される。例えば、カメラ空間における断片の <code class="docutils literal notranslate"><span class="pre">z</span></code> 座標を “c” としたい場合、それが頂点シェーダーの実行形式が <code class="docutils literal notranslate"><span class="pre">gl_FogFragCoord</span></code> に書き込むべき値だ。</p>
<p>すべての配列と同様に、
<code class="docutils literal notranslate"><span class="pre">gl_TexCoord</span></code> の添字に使用されるインデックスは、定整数式であるか、またはこの配列がシェーダーによってサイズと一緒に再宣言されなければならない。このサイズは最大 <code class="docutils literal notranslate"><span class="pre">gl_MaxTextureCoords</span></code> にすることができる。
0 に近いインデックスを使用すると、実装が様々な (varying) 資源を保存するのに役立つかもしれない。
<code class="docutils literal notranslate"><span class="pre">gl_TexCoord</span></code> の再宣言は、例えば、大域スコープで行うこともできる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_TexCoord</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_TexCoord</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>なお、この処理は <code class="docutils literal notranslate"><span class="pre">gl_TexCoord[]</span></code> の特殊な場合であり、ブロックのメンバーを再宣言するための一般的な方法ではない。
<code class="docutils literal notranslate"><span class="pre">gl_TexCoord[]</span></code> を大域スコープで再宣言すると、対応する組み込みブロックの再宣言がある場合にはコンパイルエラーとなる。シェーダー内では一つの形式の再宣言しか認められない（それゆえ、ブロックの再宣言はそれを使用するすべてのシェーダーに亘って一致しなければならないため、段階内でも同様だ）。</p>
<p>細分化制御、同評価、幾何シェーダーでは、上述の直前段階の出力は、これらの言語の入力 <code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> ブロックでも利用可能だ。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="nb">gl_PerVertex</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// part of the gl_PerVertex block described in 7.1</span><span class="w"></span>
<span class="w">    </span><span class="c1">// in addition to other gl_PerVertex members...</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_ClipVertex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_FrontColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_BackColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_FrontSecondaryColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_BackSecondaryColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_TexCoord</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_FogFragCoord</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="nb">gl_in</span><span class="p">[];</span><span class="w"></span>
</pre></div>
</div>
<p>これらは、前述の出力ブロック <code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> と同様に、明示的なパイプラインインターフェイスを設置するために再宣言することができ、入力の再宣言は、直前段階の出力再宣言と一致しなければならない。ただし、インスタンス名を持つ組み込みインターフェースブロック（
<code class="docutils literal notranslate"><span class="pre">gl_in</span></code> など）を再宣言する場合は、再宣言にインスタンス名を含めなければならない。組み込みインスタンス名を含まない場合や、名前を変更する場合は、コンパイルエラーとなる。例えば、以下のようになる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="nb">gl_PerVertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_ClipVertex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FrontColor</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="nb">gl_in</span><span class="p">[];</span><span class="w"> </span><span class="c1">// must be present and must be &quot;gl_in[]&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>サイズとともに宣言済み組み込みブロック配列は、サイズなしの構文で再宣言することができる。これにより、それらのサイズは元の宣言済みサイズと等しくなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_TexCoord[]</span></code> の再宣言の扱いも、出力ブロックの <code class="docutils literal notranslate"><span class="pre">gl_TexCoord[]</span></code> の再宣言で述べたと同じだ。</p>
<p>次の断片入力ブロックは、互換性プロファイルを使用する場合、断片シェーダーでも使用できる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="nb">gl_PerFragment</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_FogFragCoord</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_TexCoord</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_Color</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w">  </span><span class="nb">gl_SecondaryColor</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_Color</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_SecondaryColor</span></code> の値は、断片を生成する基本形状でどの面が見えているかに基づいて、
<code class="docutils literal notranslate"><span class="pre">gl_FrontColor</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_BackColor</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_FrontSecondaryColor</span></code>,
<cite>gl_BackSecondaryColor`</cite> からシステムが自動的に導き出す。頂点処理に固定機能が使われている場合は、
<code class="docutils literal notranslate"><span class="pre">gl_FogFragCoord</span></code> は、カメラ空間における断片の <code class="docutils literal notranslate"><span class="pre">z</span></code> 座標か、
OpenGL 仕様の互換性プロファイルの 16.4 “Fog” で記述されている霧座標の補間になる。
<code class="docutils literal notranslate"><span class="pre">gl_TexCoord[]</span></code> の値は、頂点シェーダーからの補間された
<code class="docutils literal notranslate"><span class="pre">gl_TexCoord[]</span></code> の値か、固定パイプライン基準頂点機能のテクスチャー座標だ。</p>
<p>断片シェーダーの <code class="docutils literal notranslate"><span class="pre">gl_TexCoord</span></code> 配列に対するインデックスは、上記の頂点シェーダーテキストで記述したとおりだ。</p>
<p>入力および出力 <code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> ブロックについて上述したように、
<code class="docutils literal notranslate"><span class="pre">gl_PerFragment</span></code> ブロックは、別のプログラムへの明示的なインターフェイスを作成するために再宣言することができる。別々のプログラム間でこれらのインターフェイスを合致させる場合、
<code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> 出力ブロック内のメンバーは、それらから生成された対応する断片シェーダーメンバーが <code class="docutils literal notranslate"><span class="pre">gl_PerFragment</span></code> 入力ブロック内に存在する場合かつその場合に限り、宣言されなければならない。これらの合致については、OpenGL 仕様書 7.4.1 “Shader Interface Matching” で詳しく説明されている。プログラム内でこれらが一致しない場合、リンクエラー。不一致が二つのプログラム間にある場合、プログラム間で渡される値は未定義となる。他のすべてのブロックマッチングとは異なり、
<code class="docutils literal notranslate"><span class="pre">gl_PerFragment</span></code> 内の宣言の順番はシェーダー間で一致する必要はなく、一致する <code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> の再宣言の宣言の順番と一致する必要もない。</p>
<p>互換性プロファイルを使用する場合、以下の断片出力変数が断片シェーダーで使用できる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FragColor</span><span class="p">;</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FragData</span><span class="p">[</span><span class="nb">gl_MaxDrawBuffers</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragColor</span></code> に書き込むと、後続の固定機能パイプラインで使用される断片色を指定する。後続の固定機能が断片色を消費し、断片シェーダー実行形式の実行時に
<code class="docutils literal notranslate"><span class="pre">gl_FragColor</span></code> に値を書き込まなかった場合、消費される断片色は未定義だ。</p>
<p>変数 <code class="docutils literal notranslate"><span class="pre">gl_FragData</span></code> は配列だ。
<code class="docutils literal notranslate"><span class="pre">gl_FragData[n]</span></code> へ書き込むと、後続の固定機能パイプラインがデータ <code class="docutils literal notranslate"><span class="pre">n</span></code> に対して使用する断片データを指定する。後続の固定機能が断片データを消費し、断片シェーダー実行形式の実行がその値を書き込まない場合、消費される断片データは未定義だ。</p>
<p>シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_FragColor</span></code> に値を静的代入する場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragData</span></code> のどの要素にも値を代入してはならない。シェーダーが <code class="docutils literal notranslate"><span class="pre">gl_FragData</span></code> の任意の要素に値を静的に書き込む場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragColor</span></code> に値を代入してはならない。つまり、シェーダーは <code class="docutils literal notranslate"><span class="pre">gl_FragColor</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_FragData</span></code> のどちらか一方にしか値を代入することができない。両方に代入することはできない。また、リンクされている複数のシェーダーも、一貫してこれらの変数をただ一つ書かなければならない。同様に、ユーザー宣言された出力変数が使用された（静的代入された）場合には、組み込み変数 <code class="docutils literal notranslate"><span class="pre">gl_FragColor</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_FragData</span></code> に代入してはいけない。これらの不正な使用方法は、いずれもコンパイルエラーまたはリンクエラーとなる。</p>
<p>シェーダーが <code class="docutils literal notranslate"><span class="pre">discard</span></code> キーワードを実行した場合、断片は廃棄され、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_FragColor</span></code> の値は無意味になる。</p>
</div>
</div>
<div class="section" id="compatibility-profile-vertex-shader-built-in-inputs">
<h3><a class="toc-backref" href="#id18">7.2. Compatibility Profile Vertex Shader Built-In Inputs</a><a class="headerlink" href="#compatibility-profile-vertex-shader-built-in-inputs" title="Permalink to this heading">¶</a></h3>
<p>以下の宣言済み入力名は、互換性プロファイルを使用する際に、頂点シェーダーから OpenGL 状態の現在の値にアクセスするために使用できる：</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#compatibility-profile-vertex-shader-built-in-inputs">コード片</a></p>
</div>
</div>
<div class="section" id="built-in-constants">
<h3><a class="toc-backref" href="#id19">7.3. Built-In Constants</a><a class="headerlink" href="#built-in-constants" title="Permalink to this heading">¶</a></h3>
<p>以下の組み込み定数は、すべてのシェーダーで宣言されている。実際に使用される値は実装依存だが、少なくとも示された値はなければならない：</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#built-in-constants">コード片</a></p>
</div>
<p>定数 <code class="docutils literal notranslate"><span class="pre">gl_MaxVaryingFloats</span></code> はコアプロファイルで削除された。代わりに <code class="docutils literal notranslate"><span class="pre">gl_MaxVaryingComponents</span></code> を使用する。</p>
<div class="section" id="compatibility-profile-built-in-constants">
<h4><a class="toc-backref" href="#id20">7.3.1. Compatibility Profile Built-In Constants</a><a class="headerlink" href="#compatibility-profile-built-in-constants" title="Permalink to this heading">¶</a></h4>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#compatibility-profile-built-in-constants">コード片</a></p>
</div>
</div>
</div>
<div class="section" id="built-in-uniform-state">
<h3><a class="toc-backref" href="#id21">7.4. Built-In Uniform State</a><a class="headerlink" href="#built-in-uniform-state" title="Permalink to this heading">¶</a></h3>
<p>SPIR-V を生成する際、組み込み一様状態は利用できない。その他、OpenGL 処理状態にアクセスするための支援として、以下の一様変数が OpenGL Shading Language に組み込まれている：</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#built-in-uniform-state">コード片</a></p>
</div>
<p>これらの変数は、断片段階でのみ利用可能であることが保証されている。他の段階では、その存在と機能は実装定義だ。</p>
<div class="section" id="compatibility-profile-state">
<h4><a class="toc-backref" href="#id22">7.4.1. Compatibility Profile State</a><a class="headerlink" href="#compatibility-profile-state" title="Permalink to this heading">¶</a></h4>
<p>これらの変数は、互換性プロファイルにしか存在しない。計算シェーダー以外のシェーダーで使用できる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#compatibility-profile-state">コード片</a></p>
</div>
</div>
</div>
<div class="section" id="redeclaring-built-in-blocks">
<h3><a class="toc-backref" href="#id23">7.5. Redeclaring Built-In Blocks</a><a class="headerlink" href="#redeclaring-built-in-blocks" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> ブロックをシェーダー内で再宣言することで、固定パイプラインインターフェイスのどの部分集合を使用するかを明示的に示すことができる。これは複数のプログラム間のインターフェイスを設定するために必要だ。例えば、以下のようになる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="nb">gl_PerVertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_Position</span><span class="p">;</span><span class="w">   </span><span class="c1">// will use gl_Position</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_PointSize</span><span class="p">;</span><span class="w"> </span><span class="c1">// will use gl_PointSize</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">             </span><span class="c1">// error, only gl_PerVertex members allowed</span><span class="w"></span>
<span class="p">};</span><span class="w"> </span><span class="c1">// no other members of gl_PerVertex will be used</span><span class="w"></span>
</pre></div>
</div>
<p>これはシェーダーが後続のパイプライン段階で使用する出力インターフェイスを設定する。これは <code class="docutils literal notranslate"><span class="pre">gl_PerVertex</span></code> の組み込みメンバーの部分集合でなければならない。このような再宣言では、不変修飾子、補間修飾子、レイアウト修飾子
<code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code>, <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> を追加することができる。また、サイズなし配列に対しては、配列のサイズを追加することもできる。例えば、以下のようになる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">xfb_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="nb">gl_PerVertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_Position</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_ClipDistance</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">location</span></code> のような他のレイアウト修飾子は、特に明記されていない限り、このような再宣言に追加することはできない。</p>
<p>組み込みインターフェイスブロックを再宣言する場合は、組み込み宣言に含まれるメンバーを使用する前にシェーダに現れなければならず、そうでない場合はコンパイルエラーとなる。ブロックを二度以上再宣言したり、組み込みブロックを再宣言した後に再宣言に含まれていない組み込みブロックのメンバーを使用することもコンパイルエラーになる。また、組み込みインターフェイスブロックが再宣言された場合、ブロックの再宣言の外側で組み込み宣言のメンバーを再宣言することはできない。同じインターフェイスに属する組み込みブロックのメンバーを使用する複数のシェーダーが同一プログラム内でリンクされている場合、すべてのシェーダーが同じ方法で組み込みブロックを再宣言しなければ、リンクエラーとなる
(<a class="reference internal" href="note4.html#interface-blocks"><span class="std std-ref">4.3.9. Interface Blocks</span></a>)。また、あるプログラム内のシェーダーが特定の組み込みインターフェイスブロックを再宣言しているにもかかわらず、そのプログラム内の別のシェーダーがそのインターフェイスブロックを再宣言していないにもかかわらず、そのインターフェイスブロックのメンバーを使用している場合も、リンクエラーとなる。組込みインターフェイスが異なるプログラムのシェーダー間に形成されている場合、シェーダーはすべて同じ方法で（単一のプログラムについて記述されたように）組込みブロックを再宣言しなければ、インターフェイスに沿って渡される値は未定義となる。</p>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note6.html" title="Previous document">OpenGL Shading Language 4.60 Specification 読書ノート Part 6</a>
        </li>
        <li>
          <a href="note8.html" title="Next document">OpenGL Shading Language 4.60 Specification 読書ノート Part 8</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a><ul>
      <li>Previous: <a href="note6.html" title="previous chapter">OpenGL Shading Language 4.60 Specification 読書ノート Part 6</a></li>
      <li>Next: <a href="note8.html" title="next chapter">OpenGL Shading Language 4.60 Specification 読書ノート Part 8</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>