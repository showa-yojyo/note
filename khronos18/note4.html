
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>OpenGL Shading Language 4.60 Specification 読書ノート Part 4 &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="OpenGL Shading Language 4.60 Specification 読書ノート Part 5" href="note5.html" />
    <link rel="prev" title="OpenGL Shading Language 4.60 Specification 読書ノート Part 3" href="note3.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note3.html" title="Previous document">OpenGL Shading Language 4.60 Specification 読書ノート Part 3</a>
        </li>
        <li>
          <a href="note5.html" title="Next document">OpenGL Shading Language 4.60 Specification 読書ノート Part 5</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="opengl-shading-language-4-60-specification-part-4">
<h1><a class="toc-backref" href="#id2">OpenGL Shading Language 4.60 Specification 読書ノート Part 4</a><a class="headerlink" href="#opengl-shading-language-4-60-specification-part-4" title="Permalink to this heading">¶</a></h1>
<p><a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#variables-and-types">仕様書該当部分</a></p>
<div class="contents topic" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#opengl-shading-language-4-60-specification-part-4" id="id2">OpenGL Shading Language 4.60 Specification 読書ノート Part 4</a></p>
<ul>
<li><p><a class="reference internal" href="#variables-and-types" id="id3">4. Variables and Types</a></p>
<ul>
<li><p><a class="reference internal" href="#basic-types" id="id4">4.1. Basic Types</a></p>
<ul>
<li><p><a class="reference internal" href="#void" id="id5">4.1.1. Void</a></p></li>
<li><p><a class="reference internal" href="#booleans" id="id6">4.1.2. Booleans</a></p></li>
<li><p><a class="reference internal" href="#integers" id="id7">4.1.3. Integers</a></p></li>
<li><p><a class="reference internal" href="#floats" id="id8">4.1.4. Floats</a></p></li>
<li><p><a class="reference internal" href="#vectors" id="id9">4.1.5. Vectors</a></p></li>
<li><p><a class="reference internal" href="#matrices" id="id10">4.1.6. Matrices</a></p></li>
<li><p><a class="reference internal" href="#opaque-types" id="id11">4.1.7. Opaque Types</a></p>
<ul>
<li><p><a class="reference internal" href="#texture-combined-samplers" id="id12">Texture-Combined Samplers</a></p></li>
<li><p><a class="reference internal" href="#images" id="id13">Images</a></p></li>
<li><p><a class="reference internal" href="#atomic-counters" id="id14">Atomic Counters</a></p></li>
<li><p><a class="reference internal" href="#texture-sampler-and-samplershadow-types" id="id15">Texture, sampler, and samplerShadow Types</a></p></li>
<li><p><a class="reference internal" href="#subpass-inputs" id="id16">Subpass Inputs</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#structures" id="id17">4.1.8. Structures</a></p></li>
<li><p><a class="reference internal" href="#arrays" id="id18">4.1.9. Arrays</a></p></li>
<li><p><a class="reference internal" href="#implicit-conversions" id="id19">4.1.10. Implicit Conversions</a></p></li>
<li><p><a class="reference internal" href="#initializers" id="id20">4.1.11. Initializers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#scoping" id="id21">4.2. Scoping</a></p></li>
<li><p><a class="reference internal" href="#storage-qualifiers" id="id22">4.3. Storage Qualifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#default-storage-qualifier" id="id23">4.3.1. Default Storage Qualifier</a></p></li>
<li><p><a class="reference internal" href="#constant-qualifier" id="id24">4.3.2. Constant Qualifier</a></p></li>
<li><p><a class="reference internal" href="#constant-expressions" id="id25">4.3.3. Constant Expressions</a></p></li>
<li><p><a class="reference internal" href="#input-variables" id="id26">4.3.4. Input Variables</a></p></li>
<li><p><a class="reference internal" href="#uniform-variables" id="id27">4.3.5. Uniform Variables</a></p></li>
<li><p><a class="reference internal" href="#output-variables" id="id28">4.3.6. Output Variables</a></p></li>
<li><p><a class="reference internal" href="#buffer-variables" id="id29">4.3.7. Buffer Variables</a></p></li>
<li><p><a class="reference internal" href="#shared-variables" id="id30">4.3.8. Shared Variables</a></p></li>
<li><p><a class="reference internal" href="#interface-blocks" id="id31">4.3.9. Interface Blocks</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#layout-qualifiers" id="id32">4.4. Layout Qualifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#input-layout-qualifiers" id="id33">4.4.1. Input Layout Qualifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#tessellation-evaluation-inputs" id="id34">Tessellation Evaluation Inputs</a></p></li>
<li><p><a class="reference internal" href="#geometry-shader-inputs" id="id35">Geometry Shader Inputs</a></p></li>
<li><p><a class="reference internal" href="#fragment-shader-inputs" id="id36">Fragment Shader Inputs</a></p></li>
<li><p><a class="reference internal" href="#compute-shader-inputs" id="id37">Compute Shader Inputs</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#output-layout-qualifiers" id="id38">4.4.2. Output Layout Qualifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#transform-feedback-layout-qualifiers" id="id39">Transform Feedback Layout Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#tessellation-control-outputs" id="id40">Tessellation Control Outputs</a></p></li>
<li><p><a class="reference internal" href="#geometry-outputs" id="id41">Geometry Outputs</a></p></li>
<li><p><a class="reference internal" href="#fragment-outputs" id="id42">Fragment Outputs</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#uniform-variable-layout-qualifiers" id="id43">4.4.3. Uniform Variable Layout Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#subroutine-function-layout-qualifiers" id="id44">4.4.4. Subroutine Function Layout Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#uniform-and-shader-storage-block-layout-qualifiers" id="id45">4.4.5. Uniform and Shader Storage Block Layout Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#opaque-uniform-layout-qualifiers" id="id46">4.4.6. Opaque Uniform Layout Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#atomic-counter-layout-qualifiers" id="id47">4.4.7. Atomic Counter Layout Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#format-layout-qualifiers" id="id48">4.4.8. Format Layout Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#subpass-input-qualifier" id="id49">4.4.9. Subpass Input Qualifier</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#interpolation-qualifiers" id="id50">4.5. Interpolation Qualifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#redeclaring-built-in-interpolation-variables-in-the-compatibility-profile" id="id51">4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#parameter-qualifiers" id="id52">4.6. Parameter Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#precision-and-precision-qualifiers" id="id53">4.7. Precision and Precision Qualifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#range-and-precision" id="id54">4.7.1. Range and Precision</a></p></li>
<li><p><a class="reference internal" href="#precision-qualifiers" id="id55">4.7.2. Precision Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#default-precision-qualifiers" id="id56">4.7.3. Default Precision Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#available-precision-qualifiers" id="id57">4.7.4. Available Precision Qualifiers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#variance-and-the-invariant-qualifier" id="id58">4.8. Variance and the Invariant Qualifier</a></p>
<ul>
<li><p><a class="reference internal" href="#the-invariant-qualifier" id="id59">4.8.1. The Invariant Qualifier</a></p></li>
<li><p><a class="reference internal" href="#invariance-of-constant-expressions" id="id60">4.8.2. Invariance of Constant Expressions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-precise-qualifier" id="id61">4.9. The Precise Qualifier</a></p></li>
<li><p><a class="reference internal" href="#memory-qualifiers" id="id62">4.10. Memory Qualifiers</a></p></li>
<li><p><a class="reference internal" href="#specialization-constant-qualifier" id="id63">4.11. Specialization-Constant Qualifier</a></p></li>
<li><p><a class="reference internal" href="#order-and-repetition-of-qualification" id="id64">4.12. Order and Repetition of Qualification</a></p></li>
<li><p><a class="reference internal" href="#empty-declarations" id="id65">4.13. Empty Declarations</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="variables-and-types">
<h2><a class="toc-backref" href="#id3">4. Variables and Types</a><a class="headerlink" href="#variables-and-types" title="Permalink to this heading">¶</a></h2>
<p>変数と関数はすべて使用する前に宣言する必要がある。変数や関数の名前とは識別子だ。</p>
<p>既定の型はない。変数と関数の宣言にはすべて、宣言された型が必要で、修飾子がオプションだ。変数を宣言するには、型を指定した後、カンマで区切って一つ以上の名前を指定する。多くの場合、代入演算子 <code class="docutils literal notranslate"><span class="pre">=</span></code> を使って、宣言の一部として変数を初期化することができる。</p>
<p>ユーザー定義型は、既存の型のリストを一つの名前に集約するために
<code class="docutils literal notranslate"><span class="pre">struct</span></code> を使って定義することができる。</p>
<p>OpenGL Shading Language は型安全だ。型の間には暗黙の変換がある。どのような場合にどのような変換が行われるかについては、
<a class="reference internal" href="#implicit-conversions"><span class="std std-ref">4.1.10. Implicit Conversions</span></a> で述べられ、本仕様書の他の項からも参照されている。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>おそらく仕様を C/C++ に寄せている。</p>
</div>
<section id="basic-types">
<h3><a class="toc-backref" href="#id4">4.1. Basic Types</a><a class="headerlink" href="#basic-types" title="Permalink to this heading">¶</a></h3>
<p><strong>基本型</strong> (a basic type) とは当言語のキーワードにより定義されている型だ。</p>
<p>OpenGL Shading Language では、以下のように基本型を分類している：</p>
<ul class="simple">
<li><p>Transparent Types: <code class="docutils literal notranslate"><span class="pre">void</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, etc.</p></li>
<li><p>Floating-Point Opaque Types: <code class="docutils literal notranslate"><span class="pre">sampler1D</span></code>, <code class="docutils literal notranslate"><span class="pre">texture1D</span></code>, <code class="docutils literal notranslate"><span class="pre">image1D</span></code>, etc.</p></li>
<li><p>Signed Integer Opaque Types: <code class="docutils literal notranslate"><span class="pre">isampler1D</span></code>, <code class="docutils literal notranslate"><span class="pre">itexture1D</span></code>, <code class="docutils literal notranslate"><span class="pre">iimage1D</span></code>, etc.</p></li>
<li><p>Unsigned Integer Opaque Types: <code class="docutils literal notranslate"><span class="pre">usampler1D</span></code>, <code class="docutils literal notranslate"><span class="pre">utexture1D</span></code>, <code class="docutils literal notranslate"><span class="pre">uimage1D</span></code>, etc.</p></li>
<li><p>Sampler Opaque Types: <code class="docutils literal notranslate"><span class="pre">sampler</span></code>, <code class="docutils literal notranslate"><span class="pre">samplerShadow</span></code>.</p></li>
</ul>
<p>これに加え、これらの基本型を配列や構造体を使って集約し、より複雑な型を構築することができる。</p>
<p>ポインター型はない。</p>
<p>本仕様書では、集約型 (an aggregate) は構造体や配列を意味する。行列やベクトルはそれ自体は集約型ではない。集約型、行列、ベクトルを総称して <strong>合成</strong> (composites) と呼ぶ。</p>
<section id="void">
<h4><a class="toc-backref" href="#id5">4.1.1. Void</a><a class="headerlink" href="#void" title="Permalink to this heading">¶</a></h4>
<p>値を返さない関数は <code class="docutils literal notranslate"><span class="pre">void</span></code> として宣言しなければならない。既定の戻り値の型はない。キーワード <code class="docutils literal notranslate"><span class="pre">void</span></code> は他の宣言では使用できない（空の仮引数リストや実引数リストを除く）。さもないとコンパイルエラーになる。</p>
</section>
<section id="booleans">
<h4><a class="toc-backref" href="#id6">4.1.2. Booleans</a><a class="headerlink" href="#booleans" title="Permalink to this heading">¶</a></h4>
<p><strong>真偽型</strong> (a boolean type) とは <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">bvec2</span></code>, <code class="docutils literal notranslate"><span class="pre">bvec3</span></code>, <code class="docutils literal notranslate"><span class="pre">bvec4</span></code>
の任意のいずれかだ。</p>
<ul class="simple">
<li><p>コードの条件付き実行を表現しやすくするために、真偽型を対処している。</p></li>
<li><p>ハードウェアがこの型の変数を直接対処することは想定していない。</p></li>
<li><p>これは本物の真偽型であり、真か偽かの二つの値のうちただ一つを保持する。</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">true</span></code> と <code class="docutils literal notranslate"><span class="pre">false</span></code> がリテラルな定数として使用できる。</p></li>
<li><p>条件付きジャンプ (<code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>, <code class="docutils literal notranslate"><span class="pre">while</span></code>, <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code>)
に使われる式は真偽型に評価されなければならない。</p></li>
</ul>
</section>
<section id="integers">
<h4><a class="toc-backref" href="#id7">4.1.3. Integers</a><a class="headerlink" href="#integers" title="Permalink to this heading">¶</a></h4>
<p><strong>整数型</strong> (an integral type) とは、符号あり、符号なし、スカラー、ベクトル整数型のことだ。配列や構造体は含まれない。</p>
<p><strong>スカラー整数型</strong> (a scalar integral type) とは、符号ありまたは符号なし整数型のスカラーだ。</p>
<p><strong>ベクトル整数型</strong> (a vector integral type) とは、符号ありまたは符号なしの整数のベクトルだ。</p>
<hr class="docutils" />
<ul class="simple">
<li><p>符号ありおよび符号なしの整数変数が完全に対処されている。この文書では、整数という言葉は、符号あり整数と符号なし整数の両方を一般的に意味する。</p></li>
<li><p>OpenGL では、符号なし整数は正確に 32 ビットの精度を持つ。</p></li>
<li><p>OpenGL では、符号あり整数は、符号ビットを含む 32 ビットを 2 の補数形式で使用する。</p></li>
<li><p>加算、減算、および乗算でオーバーフローまたはアンダーフローが発生した場合は、正しい結果 R の低次 32 ビットが得られる。ここで R はオーバーフローまたはアンダーフローを回避するのに十分な精度で計算される。オーバーフローの結果となる除算は、未定義の値となる。</p></li>
</ul>
<hr class="docutils" />
<p>C 言語と同様にしてリテラル整数定数を十進数、八進数、16 進数で表すことができる。</p>
<p>ビットパターンが 32 ビットに収まらないリテラル整数を用意すると、コンパイルエラーになる。リテラルのビットパターンは常に変更されずに使用される。そのため、ビットパターンに符号ビットが設定されている符号ありリテラルは負の値を生じる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>仕様書の例をよく見ておくこと。例えば <code class="docutils literal notranslate"><span class="pre">-1u</span></code> はどんな値であるか言えるようになること。</p>
</div>
</section>
<section id="floats">
<h4><a class="toc-backref" href="#id8">4.1.4. Floats</a><a class="headerlink" href="#floats" title="Permalink to this heading">¶</a></h4>
<p>一般に、浮動小数点という言葉は、単精度浮動小数点と倍精度浮動小数点の両方を指す。</p>
<p>浮動小数点変数は、以下の例のように定義される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5</span><span class="p">;</span><span class="w"> </span><span class="c1">// single-precision floating-point</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="n">LF</span><span class="p">;</span><span class="w"> </span><span class="c1">// double-precision floating-point</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>いずれかの処理単位への入力値として、単精度または倍精度の浮動小数点変数は、精度とダイナミックレンジについて、対応する IEEE 754 浮動小数点定義と一致することが期待される。シェーダー内の浮動小数点変数も、単精度浮動小数点値の IEEE 754 仕様に従って符号化される（物理的には必ずしもそうではないが、論理的には）。</p></li>
<li><p>符号化は論理的には IEEE 754 だが、演算は必ずしも IEEE 754 の要求通りには行われない。精度や NaN, Inf の使い方の詳細については <a class="reference internal" href="#range-and-precision"><span class="std std-ref">4.7.1. Range and Precision</span></a> を参照。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>指数部が存在する場合は、小数点 <code class="docutils literal notranslate"><span class="pre">.</span></code> は必要ない。</p></li>
<li><p>接尾辞の前も含め、浮動小数点定数の中には空白を入れてはいけない。</p></li>
<li><p>トークン化の際には、仕様書の BNF による定義に合致する最大のトークンが認識されてから新しいトークンが開始する。</p></li>
<li><p>接尾辞 <code class="docutils literal notranslate"><span class="pre">lf</span></code> または <code class="docutils literal notranslate"><span class="pre">LF</span></code> がある場合、リテラルの型は <code class="docutils literal notranslate"><span class="pre">double</span></code> だ。それ以外の場合、リテラルは <code class="docutils literal notranslate"><span class="pre">float</span></code> 型だ。</p></li>
<li><p>先頭の単項マイナス記号 <code class="docutils literal notranslate"><span class="pre">-</span></code> は単項演算子として解釈され、浮動小数点定数の一部ではない。</p></li>
</ul>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>浮動小数点数とダイナミックレンジの関係を別途理解しておくこと。</p>
</div>
</section>
<section id="vectors">
<h4><a class="toc-backref" href="#id9">4.1.5. Vectors</a><a class="headerlink" href="#vectors" title="Permalink to this heading">¶</a></h4>
<p>浮動小数点値、整数値、真偽値の 2, 3, 4 成分それぞれの汎用ベクトルのデータ型がある。</p>
<ul class="simple">
<li><p>浮動小数点ベクトル変数は、色、法線、位置、テクスチャー座標、テクスチャー検索結果などを格納するのに使用できる。</p></li>
<li><p>真偽値のベクトルは、数値のベクトルの成分ごとの比較に使用できる。</p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec2</span><span class="w"> </span><span class="n">texcoord1</span><span class="p">,</span><span class="w"> </span><span class="n">texcoord2</span><span class="p">;</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">myRGBA</span><span class="p">;</span><span class="w"></span>
<span class="kt">ivec2</span><span class="w"> </span><span class="n">textureLookup</span><span class="p">;</span><span class="w"></span>
<span class="kt">bvec3</span><span class="w"> </span><span class="n">less</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>ベクトルの初期化はコンストラクターで行う。
<a class="reference internal" href="note5.html#vector-and-matrix-constructors"><span class="std std-ref">5.4.2. Vector and Matrix Constructors</span></a> に記述がある。</p>
</section>
<section id="matrices">
<h4><a class="toc-backref" href="#id10">4.1.6. Matrices</a><a class="headerlink" href="#matrices" title="Permalink to this heading">¶</a></h4>
<p>2×2, 2×3, 2×4, 3×2, 3×3, 3×4, 4×2, 4×3, 4×4 の浮動小数点数の行列の型が組み込まれている。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mat</span></code> で始まる行列型は単精度成分を持ち、</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dmat</span></code> で始まる行列型は倍精度成分を持つ。</p></li>
<li><p>型の最初の数字は列数、二番目の数字は行数をそれぞれ表す。数字が一つしかない場合、それは正方行列だ。</p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">mat2</span><span class="w"> </span><span class="n">mat2D</span><span class="p">;</span><span class="w"></span>
<span class="kt">mat3</span><span class="w"> </span><span class="n">optMatrix</span><span class="p">;</span><span class="w"></span>
<span class="kt">mat4</span><span class="w"> </span><span class="n">view</span><span class="p">,</span><span class="w"> </span><span class="n">projection</span><span class="p">;</span><span class="w"></span>
<span class="kt">mat4x4</span><span class="w"> </span><span class="n">view</span><span class="p">;</span><span class="w"> </span><span class="c1">// an alternate way of declaring a mat4</span><span class="w"></span>
<span class="kt">mat3x2</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="c1">// a matrix with 3 columns and 2 rows</span><span class="w"></span>
<span class="kt">dmat4</span><span class="w"> </span><span class="n">highPrecisionMVP</span><span class="p">;</span><span class="w"></span>
<span class="kt">dmat2x4</span><span class="w"> </span><span class="n">dm</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>行列の値の初期化は、コンストラクターを用いて、列優先順 (column-major order) で行われる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>行列コンストラクターには列ベクトルを渡すような書き方をする。ただし、テキストエディター上では列ベクトルの要素を一行で書くことになるはずだから、そこで混乱しないようにする。</p>
</div>
</section>
<section id="opaque-types">
<h4><a class="toc-backref" href="#id11">4.1.7. Opaque Types</a><a class="headerlink" href="#opaque-types" title="Permalink to this heading">¶</a></h4>
<p><strong>不透明型</strong> (an opaque type) とは、型であって、その内部構造が言語から隠されているものだ。</p>
<hr class="docutils" />
<p>不透明型は他のオブジェクトへの不透明なハンドルとなる変数を宣言する。これらのオブジェクトは、宣言された変数を直接読み書きするのではなく、組み込み関数を通してアクセスされる。これらのオブジェクトは、関数の引数または <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 修飾された変数としてしか宣言できない。メモリー修飾子を取る不透明な型は <code class="docutils literal notranslate"><span class="pre">image</span></code> 型だけだ。配列の添字、構造体のメンバーの選択、括弧を除き、不透明変数は式のオペランドになることはできず、そのような使い方をするとコンパイルエラーになる。</p>
<p>不透明な変数は左辺値として扱うことができない。したがって、<code class="docutils literal notranslate"><span class="pre">out</span></code> または <code class="docutils literal notranslate"><span class="pre">inout</span></code> の関数引数として使用することも、代入することもできない。このような使い方をすると、コンパイルエラーになる。ただし、型と記憶修飾子が一致する <code class="docutils literal notranslate"><span class="pre">in</span></code> 引数として渡すことは可能だ。また、初期化子を付けて宣言することはできない。</p>
<p>単一の不透明型宣言ではハンドル自身と、そのハンドルとなるオブジェクトの二つのオブジェクトが効果的に宣言されるため、格納修飾子とメモリー修飾子の両方を使用する余地がある。格納修飾子は不透明ハンドルを修飾し、メモリー修飾子はハンドルであるオブジェクトを修飾する。</p>
<section id="texture-combined-samplers">
<h5><a class="toc-backref" href="#id12">Texture-Combined Samplers</a><a class="headerlink" href="#texture-combined-samplers" title="Permalink to this heading">¶</a></h5>
<p>テクスチャー混合採取器型 (texture-combined sampler types) とは、
<a class="reference internal" href="#basic-types"><span class="std std-ref">4.1. Basic Types</span></a> の表（注：仕様書の本物を参照）に記載されている、テクスチャーにアクセスするためのハンドルとなる採取器型のことだ。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sampler</span></code> や <code class="docutils literal notranslate"><span class="pre">samplerShadow</span></code> は含まれない。</p></li>
</ul>
<p>テクスチャー対象ごとに、また、
<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">integer</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">integer</span></code> の各データ型ごとに、異なるテクスチャー混合採取器型がある。テクスチャーへのアクセスは、組み込みテクスチャー関数
(<a class="reference internal" href="note8.html#texture-functions"><span class="std std-ref">8.9. Texture Functions</span></a>) を使って行われるが、どのテクスチャーにアクセスするか、またどのようにフィルターリングするかを指定するために、テクスチャー混合採取器型が使われる。</p>
<p>テクスチャー混合採取器型は不透明型で、前述の不透明型と同様に宣言され、動作する。シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、そうでない場合、結果は未定義となる。</p>
</section>
<section id="images">
<h5><a class="toc-backref" href="#id13">Images</a><a class="headerlink" href="#images" title="Permalink to this heading">¶</a></h5>
<p>画像型は不透明型で、上記の不透明型と同様に宣言され、動作する。さらにメモリー修飾子で修飾することができる。シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、そうでない場合、結果は未定義となる。</p>
<p>画像変数は、画像単位に束縛されたテクスチャー画像の単一レベルのすべてまたは一部に対応する
1, 2, 3 次元のいずれかの画像のハンドルだ。</p>
<p>画像変数はテクスチャー対象ごとに、また、
<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">integer</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">integer</span></code> の各データ型ごとに、異なる型がある。画像へのアクセスは、レベルが画像単位に束縛されているテクスチャーの対象に一致する画像型を使用する必要がある。もしくは、3D または配列画像の非レイヤー束縛の場合は、画像のレイヤーの次元に一致する画像型を使用する必要がある。</p>
<ul class="simple">
<li><p>つまり、3D, 2DArray, Cube, CubeArray のレイヤーは <code class="docutils literal notranslate"><span class="pre">image2D</span></code> を使用し、</p></li>
<li><p>1DArray のレイヤーは <code class="docutils literal notranslate"><span class="pre">image1D</span></code> を使用し、</p></li>
<li><p>2DMSArray のレイヤーは <code class="docutils literal notranslate"><span class="pre">image2DMS</span></code></p></li>
</ul>
<p>をそれぞれ使用する必要がある。このように画像対象型が束縛された画像と一致しない場合、データ型が束縛された画像と一致しない場合、フォーマットレイアウト修飾子が OpenGL 仕様 8.25 Texture Image Loads and Stores
に記載されている画像単位表現形式と一致しない場合、画像アクセスの結果は未定義となるが、プログラムの終了を含むことはできない。</p>
<p>画像変数は <a class="reference internal" href="note8.html#image-functions"><span class="std std-ref">8.12. Image Functions</span></a> で記述されている画像のロード、格納、不可分関数において、アクセスする画像を指定するために用いられる。</p>
</section>
<section id="atomic-counters">
<h5><a class="toc-backref" href="#id14">Atomic Counters</a><a class="headerlink" href="#atomic-counters" title="Permalink to this heading">¶</a></h5>
<p>不可分計数器型とは、計数器への不透明なハンドルであって、前述の不透明型と同様に宣言され、動作するものだ。宣言された変数は、<a class="reference internal" href="note8.html#atomic-counter-functions"><span class="std std-ref">8.10. Atomic Counter Functions</span></a> で記述がある、組み込み不可分計数器関数を使用するときに、どの計数器にアクセスするかを指定する。また、<a class="reference internal" href="#atomic-counter-layout-qualifiers"><span class="std std-ref">4.4.7. Atomic Counter Layout Qualifiers</span></a> で記述があるように、バッファーに束縛される。</p>
<p>シェーダー内の配列に集約された不可分計数器は、動的一様な整数式でしかインデックスを付けることができない。そうでない場合、結果は未定義だ。</p>
<p>構造体のメンバーは不可分計数器型として宣言できない。</p>
</section>
<section id="texture-sampler-and-samplershadow-types">
<h5><a class="toc-backref" href="#id15">Texture, sampler, and samplerShadow Types</a><a class="headerlink" href="#texture-sampler-and-samplershadow-types" title="Permalink to this heading">¶</a></h5>
<p>テクスチャー、採取器、samplerShadow 型は不透明型で、上記の不透明な型と同様に宣言され、動作する。シェーダー内で配列に集約されている場合、これらの型は動的一様な式でしかインデックスを付けることができない。そうしないとテクスチャー検索は未定義の値になる。</p>
<p>テクスチャー変数は、<a class="reference internal" href="#basic-types"><span class="std std-ref">4.1. Basic Types</span></a> の表に列挙されている一次元、二次元、三次元のテクスチャー、キューブマップなどのハンドルだ。テクスチャー型は、テクスチャー対象ごとに、また、
<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">integer</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">integer</span></code> の各データ型ごとに異なる。</p>
<p>テクスチャーは、採取器型または samplerShadow 型の変数と組み合わせて、テクスチャーを混合した採取器型 (<code class="docutils literal notranslate"><span class="pre">sampler2D</span></code>, <code class="docutils literal notranslate"><span class="pre">sampler2DShadow</span></code>, etc.)
を作ることができる。これはコンストラクターで行う。例えば、</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sampler2D(texture2D,</span> <span class="pre">sampler)</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sampler2DShadow(texture2D,</span> <span class="pre">sampler)</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sampler2DShadow(texture2D,</span> <span class="pre">samplerShadow)</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sampler2D(texture2D,</span> <span class="pre">samplerShadow)</span></code></p></li>
</ul>
<p>などだ。詳細は <a class="reference internal" href="note5.html#constructors"><span class="std std-ref">5.4. Constructors</span></a> で述べる。</p>
</section>
<section id="subpass-inputs">
<h5><a class="toc-backref" href="#id16">Subpass Inputs</a><a class="headerlink" href="#subpass-inputs" title="Permalink to this heading">¶</a></h5>
<p>サブパス入力型 (e.g. <code class="docutils literal notranslate"><span class="pre">subpassInput</span></code>) は不透明型で、上記の不透明型と同様に宣言され、動作するものだ。シェーダ内ーで配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、そうでない場合、結果は未定義となる。</p>
<p>サブパス入力型は、二次元の単一採取または複数採取された画像を扱うもので、
<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">integer</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">integer</span></code> のデータ型ごとに異なる型がある。</p>
<p>サブパス入力型は、断片シェーダーでのみ利用可能だ。他の段階での使用はコンパイルエラーとなる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>名詞 subpass の概念が（というより pass のそれが）わからないので、わかるまでこのままカタカナにしておく。</p>
</div>
</section>
</section>
<section id="structures">
<h4><a class="toc-backref" href="#id17">4.1.8. Structures</a><a class="headerlink" href="#structures" title="Permalink to this heading">¶</a></h4>
<p>C/C++ 言語の構造体 <code class="docutils literal notranslate"><span class="pre">struct</span></code> と同じようなことができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">intensity</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">lightVar</span><span class="p">;</span><span class="w"></span>

<span class="n">light</span><span class="w"> </span><span class="n">lightVar2</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>ただし、C/C++ のそれよりは弱い：</p>
<ul>
<li><p>構造体には少なくとも一つのメンバー宣言が必要。</p></li>
<li><p>メンバー宣言には精度修飾子を付けることができるが、それ以外の修飾子を使用するとコンパイルエラー。</p></li>
<li><p>ビットフィールドは対処されていない。</p></li>
<li><p>メンバー型はすでに定義されている必要がある（前方参照不可）。</p></li>
<li><p>メンバー宣言に初期化子が含まれているとコンパイルエラー。</p></li>
<li><p>メンバー宣言には、配列を含めることができる。配列にはサイズが指定されていなければならない。サイズはゼロより大きい定数の整数表現でなければならない
(<a class="reference internal" href="#constant-expressions"><span class="std std-ref">4.3.3. Constant Expressions</span></a>)。</p></li>
<li><p>各レベルの構造体は、メンバー宣言子で指定された名前に対して独自の名前空間を持つ。このような名前は、その名前空間内で一意であればよい。</p></li>
<li><p>匿名構造体は対処されていない。</p></li>
<li><p>埋め込み構造体の定義は対処されていない。コンパイルエラーになる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span><span class="p">;</span><span class="w">              </span><span class="c1">// Error: anonymous structures disallowed</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// Error: embedded structures disallowed</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>構造体をコンストラクターを使用して宣言時に初期化することができる
(<a class="reference internal" href="note5.html#structure-constructors"><span class="std std-ref">5.4.3. Structure Constructors</span></a>)。</p></li>
<li><p>型や修飾子の使用に関するあらゆる制限は、その型や修飾子のメンバーを含むすべての構造体にも適用される。これは、構造体である構造体メンバーにも再帰的に適用される。</p></li>
</ul>
</section>
<section id="arrays">
<h4><a class="toc-backref" href="#id18">4.1.9. Arrays</a><a class="headerlink" href="#arrays" title="Permalink to this heading">¶</a></h4>
<p>細かいことが色々と仕様化されている。</p>
<ul class="simple">
<li><p>同じ型の変数は、名前の後に大括弧 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">]</span></code> でそのサイズを囲んで宣言することで、配列に集約することができる。</p></li>
<li><p>宣言の中で配列のサイズを指定する場合、それはゼロより大きい定数整数式
(<a class="reference internal" href="#constant-expressions"><span class="std std-ref">4.3.3. Constant Expressions</span></a>) でなければならない。</p></li>
<li><p>シェーダー格納ブロック (<a class="reference internal" href="#interface-blocks"><span class="std std-ref">4.3.9. Interface Blocks</span></a>) の最後に宣言されたメンバーを除き、配列のサイズは、一定の整数式以外でインデックスを付ける前に宣言 (explicitly sized)
しなければならない。</p></li>
<li><p>任意の配列のサイズは、それを関数の引数として渡す前に宣言しなければならない。これらの規則に違反すると、コンパイルエラーが発生する。</p></li>
<li><p>サイズを指定しないで配列を宣言 (unsized) し、後で同じ名前の配列を同じ型の配列として再宣言してサイズを指定するか、定数整数式のみでインデックスを付ける (implicitly sized) ことは適法だ。ただし、特に断りのない限り、ブロックを再宣言することはできない。</p></li>
<li><p>ユーザーが宣言したブロック内のサイズのない配列メンバーは、ブロックの再宣言によってサイズを変更することはできない。</p></li>
<li><p>サイズを指定して配列を宣言し、後で（同じシェーダー内で）宣言されたサイズ以上の定数整数式で同じ配列をインデックスするとコンパイルエラー。</p></li>
<li><p>サイズのない配列を再宣言して、その配列のインデックスとしてシェーダ内で以前に使用されたインデックスと同等かそれ以下のサイズにすることは、コンパイルエラー。また、負の定数式で配列をインデックスすることもコンパイルエラー。</p></li>
<li><p>関数宣言で仮引数として宣言された配列は、サイズを指定しなければならない。</p></li>
<li><p>配列のサイズ以上、または 0 未満の非定数式で配列をインデックスすると、未定義の動作となる。</p></li>
<li><p>配列は一次元しか持たないが、配列の配列を宣言することができる。</p></li>
<li><p>すべての型（基本型、構造体、配列）を配列にすることができる。</p></li>
</ul>
<hr class="docutils" />
<p>すべての配列は本質的に同質 (homogeneous) であり、すべて同じ型とサイズの要素で構成されているが、例外が一つある。サイズのない配列を最後のメンバーとして持つシェーダー格納ブロックだ
(runtime-sized)。このようなシェーダー格納ブロックからは、格納ブロックの最後のメンバーの長さが異なっていたとしても、配列を形成することができる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">frequencies</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="n">light</span><span class="w"> </span><span class="n">lights</span><span class="p">[];</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLights</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">light</span><span class="w"> </span><span class="n">lights</span><span class="p">[</span><span class="n">numLights</span><span class="p">];</span><span class="w"></span>

<span class="c1">// a shader storage block, introduced in section 4.3.7 &quot;Buffer Variables&quot;</span><span class="w"></span>
<span class="k">buffer</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="p">[];</span><span class="w"> </span><span class="c1">// an error, unless u gets statically sized by link time</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">[];</span><span class="w">  </span><span class="c1">// okay, v will be sized dynamically, if not statically</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w">     </span><span class="c1">// when the block is arrayed, all u will be the same size,</span><span class="w"></span>
<span class="w">               </span><span class="c1">// but not necessarily all v, if sized dynamically</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>配列型は、非配列型の後に配列指定子を指定することで形成できる。このような配列指定子の次元すべてにサイズを含める必要がある。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">    </span><span class="c1">// an array of size [5] of float</span><span class="w"></span>
<span class="kt">float</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">// an array of size [2][3] of float, not size [3] of float[2]</span><span class="w"></span>
</pre></div>
</div>
<p>この型は、他の型が使用できる場所であればどこでも使用できる。関数からの戻り値であってもいい：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>配列のコンストラクターとして：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="p">[</span><span class="mi">5</span><span class="p">](</span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="mf">4.2</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.2</span><span class="p">,</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>名前なし引数として：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">float</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>
<p>または変数や関数の引数パラメータを宣言する手段の代わりとしても使用できる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>配列は、配列コンストラクターから形成される初期化子を持つことができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">5</span><span class="p">](</span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="mf">4.2</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.2</span><span class="p">,</span><span class="w"> </span><span class="mf">1.1</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">[](</span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="mf">4.2</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.2</span><span class="p">,</span><span class="w"> </span><span class="mf">1.1</span><span class="p">);</span><span class="w">  </span><span class="c1">// same thing</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>配列の配列を宣言することができる：次の宣言はどれも <code class="docutils literal notranslate"><span class="pre">vec4</span></code> の長さ 2 の一次元配列の長さ 3 の一次元配列だ。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// size-3 array of size-2 array of vec4</span><span class="w"></span>
<span class="kt">vec4</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"> </span><span class="c1">// size-3 array of size-2 array of vec4</span><span class="w"></span>
<span class="kt">vec4</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// size-3 array of size-2 array of vec4</span><span class="w"></span>
</pre></div>
</div>
<p>透過的なメモリー（一様ブロックなど）では、最内周（宣言では右端）の次元が外周の次元よりも速く反復されるレイアウトになっている。上記の配列の場合、メモリー上の順序は次のようになる：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Low address : a[0][0] : a[0][1] : a[1][0] : a[1][1] : a[2][0] : a[2][1] : High address
</pre></div>
</div>
<hr class="docutils" />
<p>コンストラクターと名前なしの引数の両方に必要な <code class="docutils literal notranslate"><span class="pre">a</span></code> の型は <code class="docutils literal notranslate"><span class="pre">vec4[3][2]</span></code> となる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.1</span><span class="p">));</span><span class="w"></span>
<span class="kt">vec4</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">](</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// constructor</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">vec4</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span><span class="w"> </span><span class="c1">// prototype with unnamed parameter</span><span class="w"></span>
</pre></div>
</div>
<p>初期化子リスト構文を使って配列の配列を初期化することもできる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">vec4</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)),</span><span class="w"></span>
<span class="w">                 </span><span class="kt">vec4</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)),</span><span class="w"></span>
<span class="w">                 </span><span class="kt">vec4</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>サイズなし配列を宣言時に初期化子で明示的にサイズを指定することができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">  </span><span class="c1">// b is explicitly size 5</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// means the same thing</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">[](</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// also explicitly sizes to 5</span><span class="w"></span>
</pre></div>
</div>
<p>しかし、サイズなし配列に代入するのはコンパイルエラーとなる。これは、初期化子と代入が異なるセマンティクスを持っているように見えるまれなケースだ。配列の配列では、サイズなし次元は初期化子によってサイズが明示的に決まる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">a</span><span class="p">[][]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">vec4</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)),</span><span class="w"> </span><span class="c1">// okay, size to a[3][2]</span><span class="w"></span>
<span class="w">               </span><span class="kt">vec4</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)),</span><span class="w"></span>
<span class="w">               </span><span class="kt">vec4</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>配列は <code class="docutils literal notranslate"><span class="pre">length()</span></code> メソッドを使って含まれる要素の数を取得できる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="c1">// returns 5</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>配列のサイズが明示的に決められている場合、
<code class="docutils literal notranslate"><span class="pre">length()</span></code> が返す値は定数式だ。</p></li>
<li><p>配列のサイズが明示的に設定されておらず、シェーダー格納ブロックの最後に宣言された</p></li>
<li><p>メンバーである場合、戻り値は定数式ではなく、ブロックに対して格納所を用意するバッファーオブジェクトのサイズに基づいて実行時に決定される。このような配列は runtime sized だ。
runtime sized 配列において、配列が 0 より小さいか、配列内のブロック数以上の非定数式でインデックス付けられたシェーダー格納ブロックの配列に含まれている場合、
<code class="docutils literal notranslate"><span class="pre">length()</span></code> の戻り値は未定義だ。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">length()</span></code> を runtime sized ではなく、かつ明示的にサイズが設定されていない配列に対しては呼び出すことができない。コンパイルエラーとなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">length()</span></code> がコンパイル時定数を返す場合、
<code class="docutils literal notranslate"><span class="pre">length()</span></code> が適用される式は、式中の左辺値への書き込みや、それ自体が副作用を持つ関数呼び出しなどの副作用を含めることはできない。コンパイル時定数 <code class="docutils literal notranslate"><span class="pre">length</span></code> 自体しか計算する必要はない。</p>
<p>式に他の効果が含まれている場合、コンパイルエラー報告を含め、動作と結果は未定義だ。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="n">a</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">b</span><span class="p">).</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="c1">// illegal side effects</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">length()</span></code> は配列の配列に対しても同様に機能する：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="w">    </span><span class="c1">// this is 3</span><span class="w"></span>
<span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">length</span><span class="p">()</span><span class="w"> </span><span class="c1">// this is 2</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">length()</span></code> がコンパイル時定数を返す場合、括弧 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">]</span></code> 内の式は解析され、配列のインデックスに必要な規則に従うものの、配列を逆参照しない。このように、式に副作用がない限り、式の実行時の値が範囲外であっても、動作はきちんと定義される。</p>
<p><code class="docutils literal notranslate"><span class="pre">length()</span></code> が（コンパイル時定数ではなく）実行時の値を返すと、配列を逆参照する。例えば、
<code class="docutils literal notranslate"><span class="pre">x</span></code> がコンパイル時定数ではなく、範囲外の場合は、未定義の値を返す。より一般的には、関係する式すべてが完全に評価され、実行される。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// for a compile time-sized array b containing a member array a:</span><span class="w"></span>
<span class="n">b</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">].</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="c1">// b is never dereferenced, x+3 is evaluated and checked</span><span class="w"></span>
<span class="n">b</span><span class="p">[</span><span class="o">++</span><span class="n">x</span><span class="p">].</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="c1">// not allowed; results are undefined</span><span class="w"></span>

<span class="c1">// for an array s of a shader storage object (run-time sized) containing a member array a:</span><span class="w"></span>
<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">x</span><span class="p">].</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="c1">// s is dereferenced; ++x needs to be a valid index</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>暗黙的なサイズの配列や実行時サイズの配列では、最も外側の次元しかサイズを欠落することができない。不明な配列サイズを含む型は、明示的なサイズが得られるまで配列を形成することができない。ただし、シェーダー格納ブロックの場合は、唯一であるサイズなし配列メンバーがブロックの最後のメンバーになる。</p>
<p>シェーダー格納ブロックでは、最後のメンバーは明示的なサイズを指定せずに宣言することができる。この場合、実効的な配列サイズは、インターフェイスブロックをバックアップするデータ格納場所のサイズから実行時に推論される。このような実行時サイズの配列は、一般的な整数式でインデックスを付けることができる。ただし、関数の引数として渡したり、負の定数式でインデックスを作成したりするとコンパイルエラーとなる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>ゴチャゴチャした節だが、配列の理論はレンダリングの観点から明らかに重要だ。読み落としはいけない。</p>
</div>
</section>
<section id="implicit-conversions">
<h4><a class="toc-backref" href="#id19">4.1.10. Implicit Conversions</a><a class="headerlink" href="#implicit-conversions" title="Permalink to this heading">¶</a></h4>
<p>状況によっては、式とその型が暗黙的に異なる型に変換されることがある。許されるすべての暗黙の変換が表に示されている。</p>
<p>暗黙の変換は、コンストラクターを使った明示的な変換と同じだ。コンストラクターによる明示的な変換については
<a class="reference internal" href="note5.html#conversion-and-scalar-constructors"><span class="std std-ref">5.4.1. Conversion and Scalar Constructors</span></a> にある。</p>
<p>二項演算子の暗黙の変換を行う場合、オペランド二つが変換できるデータ型が複数ある場合がある。例えば <code class="docutils literal notranslate"><span class="pre">int</span></code> 型の値を <code class="docutils literal notranslate"><span class="pre">uint</span></code> 型の値に加算する場合、両方の値が <code class="docutils literal notranslate"><span class="pre">uint</span></code>,
<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code> に暗黙的に変換される可能性がある。</p>
<ul class="simple">
<li><p>このような場合、どちらかのオペランドが浮動小数点型であれば、浮動小数点型が採用される。</p></li>
<li><p>また、どちらかのオペランドが符号なし整数型であれば、符号あり整数型が採用される。</p></li>
<li><p>それ以外の場合は、符号あり整数型が採用される。</p></li>
<li><p>オペランドが同じ基本データ型から派生する複数のデータ型に暗黙的に変換できる場合は、構成要素のサイズが最も小さいデータ型が採用される。</p></li>
</ul>
</section>
<section id="initializers">
<h4><a class="toc-backref" href="#id20">4.1.11. Initializers</a><a class="headerlink" href="#initializers" title="Permalink to this heading">¶</a></h4>
<p>宣言には、変数の初期値を指定することができ、等号 <code class="docutils literal notranslate"><span class="pre">=</span></code> の後に初期化子を指定する。初期化子 (an initializer) とは、
<em>assignment-expression</em> であるか、中括弧 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">}</span></code> で囲まれた初期化子のリストのどちらかをいう。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>仕様書の BNF によると、モダン C++ のそれと同じと考えて良さそうだ。</p>
</div>
<p><em>assignment-expression</em> は通常の式であって、括弧の外にあるカンマ <code class="docutils literal notranslate"><span class="pre">,</span></code> は初期化子の終わりと解釈される。これにより入れ子になった初期化子を記述することができる。変数型型とその初期化子は、入れ子、各レベルに存在する成分・要素・メンバーの数・型の点で正確に一致しなければならない。大域スコープの <em>assignment-expression</em> には、ユーザー定義関数の呼び出しを含めることができる。</p>
<p>初期化子にある <em>assignment-expression</em> は、初期化するオブジェクトと同じ型であるか、
<a class="reference internal" href="#implicit-conversions"><span class="std std-ref">4.1.10. Implicit Conversions</span></a> に従ってオブジェクトの型に変換できる型でなければならない。コンストラクターを含むため、合成変数はコンストラクターでも初期化リストでも初期化でき、初期化リストの要素をコンストラクターにすることもできる。</p>
<p>初期化子が中括弧で囲まれた初期化子リストの場合、宣言する変数はベクトル、行列、配列、構造体のいずれかでなければならない。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// illegal, i is not a composite</span><span class="w"></span>
</pre></div>
</div>
<p>釣り合う中括弧で囲まれた初期化子のリストが合成体一つに適用される。これは、宣言されている変数、または宣言されている変数に含まれる合成体であってかまわない。初期化子リストの個々の初期化子は、合成体の要素・メンバーに対してその順に適用される。</p>
<ul class="simple">
<li><p>合成体がベクトル型の場合、リストの初期化子は、ベクトルの成分に成分 0 から順に適用される。初期化子の数は成分の数と一致しなければならない。</p></li>
<li><p>合成体が行列型の場合、リストの初期化子はベクトルの初期化子でなければならず、行列の列に、列 0 から順に適用される。初期化子の数は行列の列数と一致しなければならない。</p></li>
<li><p>合成体に構造体型がある場合、リストの初期化子は、構造体で宣言されている順序で、最初のメンバーから順に構造体のメンバーに適用される。初期化子の数はメンバーの数と一致しなければならない。</p></li>
</ul>
<p>これらの規則が適用されるので、次の宣言はすべて同値だ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">mat2x2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">mat2</span><span class="p">(</span><span class="w">  </span><span class="kt">vec2</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="kt">vec2</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="kt">mat2x2</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="kt">vec2</span><span class="p">(</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="kt">vec2</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kt">mat2x2</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w">      </span><span class="p">{</span><span class="w">     </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span><span class="w">     </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>次の宣言はすべてコンパイルエラーだ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="mf">4.2</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="w"> </span><span class="p">};</span><span class="w">         </span><span class="c1">// illegal</span><span class="w"></span>
<span class="kt">vec2</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="w"> </span><span class="p">};</span><span class="w">             </span><span class="c1">// illegal</span><span class="w"></span>
<span class="kt">mat3x3</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// illegal</span><span class="w"></span>
<span class="kt">mat2x2</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">};</span><span class="w">      </span><span class="c1">// illegal, can&#39;t flatten nesting</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span><span class="w">                    </span><span class="c1">// illegal</span><span class="w"></span>
</pre></div>
</div>
<p>いずれの場合も、オブジェクトに適用される最も内側の初期化子（つまり、中括弧で囲まれた初期化子のリストではない）は、初期化されるオブジェクトと同じ型であるか、
<a class="reference internal" href="#implicit-conversions"><span class="std std-ref">4.1.10. Implicit Conversions</span></a> に従ってオブジェクトの型に変換できる型でなければならない。後者の場合、代入が行われる前に初期化子に対して暗黙の変換が行われる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// legal, all types match</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span><span class="w">   </span><span class="c1">// legal, first initializer is converted</span><span class="w"></span>
</pre></div>
</div>
<p>次の宣言はすべてコンパイルエラーだ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">                         </span><span class="c1">// illegal</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">};</span><span class="w">       </span><span class="c1">// illegal</span><span class="w"></span>
<span class="kt">mat4x2</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// illegal</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">d</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">S1</span><span class="p">(</span><span class="kt">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">1.1</span><span class="p">))</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// illegal</span><span class="w"></span>
</pre></div>
</div>
<p>サイズなし配列に初期化子（いずれかの形式）が提供されている場合、配列のサイズは、初期化子内のトップレベルの（入れ子になっていない）初期化子の数が決定する。以下の宣言はすべて、明示的に 5 要素を持つ配列を生成する：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">[](</span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="mf">4.2</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.2</span><span class="p">,</span><span class="w"> </span><span class="mf">1.1</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="mf">4.2</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.2</span><span class="p">,</span><span class="w"> </span><span class="mf">1.1</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">c</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">                          </span><span class="c1">// c is explicitly size 5</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">                         </span><span class="c1">// means the same thing</span><span class="w"></span>
</pre></div>
</div>
<p>初期化される合成体の初期化子リストに含まれる初期化子の数に過不足があるとコンパイルエラーだ。つまり、配列の要素すべて、構造体のメンバーすべて、行列の列すべて、ベクトルの成分すべてには、厳密に一つの初期化子式が存在し、消費されない初期化子があってはならない。</p>
</section>
</section>
<section id="scoping">
<h3><a class="toc-backref" href="#id21">4.2. Scoping</a><a class="headerlink" href="#scoping" title="Permalink to this heading">¶</a></h3>
<p>変数のスコープは、その宣言位置によって決まる。</p>
<ul class="simple">
<li><p>すべての関数定義の外側で変数が宣言されている場合、それは大域スコープを持ち、宣言された場所から始まり、そのシェーダーの最後まで存続する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">while</span></code> 検定や <code class="docutils literal notranslate"><span class="pre">for</span></code> 文の中で宣言されている場合は、それに続く部分文の最後までスコープされる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span></code> 文や <code class="docutils literal notranslate"><span class="pre">else</span></code> 文の中で宣言されている場合は、その文の最後までスコープされる。
<a class="reference internal" href="note6.html#selection"><span class="std std-ref">6.2. Selection</span></a>, <a class="reference internal" href="note6.html#iteration"><span class="std std-ref">6.3. Iteration</span></a> を参照。</p></li>
<li><p>複文の中の文として宣言されている場合は、その複文の末尾にスコープされる。</p></li>
<li><p>関数定義の中で引数として宣言されている場合は、その関数定義の最後までスコープされる。</p></li>
<li><p>関数の引数宣言と本体は、大域スコープに入れ子になった単一のスコープを形成する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span></code> 文の式では、新しい変数を宣言することができないため、新しいスコープを形成しない。</p></li>
</ul>
<p>宣言の中では、名前のスコープは、初期化子がある場合はその直後から、ない場合は宣言されている名前の直後から始まる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>仕様書ではここに C/C++ プログラマーなら納得の行くコード例が挙げられている。</p>
</div>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> ループも <code class="docutils literal notranslate"><span class="pre">while</span></code> ループも、部分文自体は変数名の新しいスコープを導入していないので、以下は再宣言のコンパイルエラーになる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="cm">/* nested scope begins here */</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// redeclaration error</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> ループの本体では、本体が単文か複文かによらず、
<code class="docutils literal notranslate"><span class="pre">do</span></code> と <code class="docutils literal notranslate"><span class="pre">while</span></code> の間（判定式は含まない）だけ続く新しいスコープが導入される。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span><span class="w"></span>
<span class="k">do</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">  </span><span class="c1">// okay, in nested scope_</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mo">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// i is 17, scoped outside the do-while body</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">switch(...)</span></code> に続く文は、入れ子スコープを形成する。</p>
<p>あるスコープ内のすべての変数名、構造体型名、関数名は同じ名前空間を共有する。関数名は、同じスコープ内で、同じまたは異なるパラメータでエラーなしで再宣言できる。暗黙的なサイズの配列は、同じ基本型の配列と同じスコープで再宣言できる。それ以外の場合、一つのコンパイル単位内では、宣言された名前を同じスコープで再宣言することはできない。再宣言するとコンパイルエラーになる。入れ子になったスコープが外側のスコープで使用されている名前を再宣言すると、その名前の既存の使用がすべて隠される。隠された名前にアクセスしたり、隠蔽を解除したりするには、隠蔽したスコープを終了しなければならない。</p>
<p>組み込み関数のスコープは、ユーザーが大域変数を宣言する大域スコープの外側にある。つまり、シェーダーの大域スコープは、ユーザー定義関数や大域変数を使えられ、組み込み関数を含むスコープの中に入れ子になっている。入れ子になったスコープで関数名を再宣言すると、外側のスコープでその名前で宣言された関数すべてが隠蔽される。関数の宣言（プロトタイプ）は、関数の内部には記述できない。大域スコープか、組み込み関数の場合は大域スコープの外側に記述しなければならず、記述しない場合はコンパイルエラーになる。</p>
<hr class="docutils" />
<p>共有大域とは、同一言語（頂点などの同一段階）内で独立してコンパイルされた単位（シェーダー）内で同じ名前で宣言された大域変数で、単一のプログラムを作る際にリンクされるものだ（異なるシェーダー言語間のインターフェイスとなる大域については別の節で述べる）。共有大域は同じ名前空間を共有し、同じ型で宣言する必要がある。また、同じ格納域を共有する。</p>
<p>共有大域配列は、同じ基本型と同じ明示的なサイズでなければならない。あるシェーダーで暗黙的にサイズ設定された配列は、同じ段階の別のシェーダーで明示的にサイズ設定することができる。ある段階のどのシェーダーも配列の明示的なサイズを持っていない場合、その段階の最大の暗黙的なサイズ（使用されている最大のインデックスよりも 1 多い）が採用される。段階をまたいだ配列のサイズ変更はない。これは、配列が他の段階やアプリケーションと共有されるインターフェイスブロック内で宣言されている場合に関係する（他の未使用の配列は最適化により排除されてもかまわない）。</p>
<p>共有される大域スカラーは、厳密に同じ型名と型定義を持たなければならない。構造体は、同じ名前、一連の型名、型定義、およびメンバー名を持たなければ、同じ型とはみなされない。この規則は入れ子になった型や埋め込まれた型にも再帰的に適用される。共有大域に複数の初期化子がある場合、初期化子はすべて定数式であり、すべて同じ値でなければならない。そうでない場合は、リンクエラーが発生する（初期化子が一つしかない共有大域では、その初期化子を定数式にする必要はない）。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>最後の 3 パラグラフについては、仕様書を全部読んでいない段階では、シェーダーを書くときに <code class="docutils literal notranslate"><span class="pre">main</span></code> の外側に置く変数が関係しているだろうと想像する。</p>
</div>
</section>
<section id="storage-qualifiers">
<h3><a class="toc-backref" href="#id22">4.3. Storage Qualifiers</a><a class="headerlink" href="#storage-qualifiers" title="Permalink to this heading">¶</a></h3>
<p>変数宣言では、型の前に高々一つの格納修飾子を指定することができる。</p>
<dl class="glossary simple">
<dt id="term-0">（格納修飾子なし：既定値）<a class="headerlink" href="#term-0" title="Permalink to this term">¶</a></dt><dd><p>局所的な読み書き可能なメモリー、または関数の入力引数。</p>
</dd>
<dt id="term-const"><code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#term-const" title="Permalink to this term">¶</a></dt><dd><p>値を変更することができない変数。</p>
</dd>
<dt id="term-in"><code class="docutils literal notranslate"><span class="pre">in</span></code><a class="headerlink" href="#term-in" title="Permalink to this term">¶</a></dt><dd><p>前の段階のシェーダーにリンケージを持つ場合、変数が入力コピーされる。</p>
</dd>
<dt id="term-out"><code class="docutils literal notranslate"><span class="pre">out</span></code><a class="headerlink" href="#term-out" title="Permalink to this term">¶</a></dt><dd><p>シェーダの後段へにリンケージを持つ場合、変数が出力コピーされる。</p>
</dd>
<dt id="term-attribute"><code class="docutils literal notranslate"><span class="pre">attribute</span></code><a class="headerlink" href="#term-attribute" title="Permalink to this term">¶</a></dt><dd><p>互換性プロファイルおよび頂点言語のみ。頂点シェーダーの場合は <code class="docutils literal notranslate"><span class="pre">in</span></code> と同じ。</p>
</dd>
<dt id="term-uniform"><code class="docutils literal notranslate"><span class="pre">uniform</span></code><a class="headerlink" href="#term-uniform" title="Permalink to this term">¶</a></dt><dd><p>処理される基本形状間で値が変化しない、一様変数はシェーダー、API, アプリケーション間のリンクを形成する。</p>
</dd>
<dt id="term-varying"><code class="docutils literal notranslate"><span class="pre">varying</span></code><a class="headerlink" href="#term-varying" title="Permalink to this term">¶</a></dt><dd><p>互換性プロファイルのみ、頂点言語および断片言語のみ。頂点シェーダーの場合は <code class="docutils literal notranslate"><span class="pre">out</span></code> と同じ。断片シェーダーの場合は <code class="docutils literal notranslate"><span class="pre">in</span></code> と同じ。</p>
</dd>
<dt id="term-buffer"><code class="docutils literal notranslate"><span class="pre">buffer</span></code><a class="headerlink" href="#term-buffer" title="Permalink to this term">¶</a></dt><dd><p>値はバッファーオブジェクトに格納され、シェーダー呼び出しと
API の両方で読み書きできる。</p>
</dd>
<dt id="term-shared"><code class="docutils literal notranslate"><span class="pre">shared</span></code><a class="headerlink" href="#term-shared" title="Permalink to this term">¶</a></dt><dd><p>計算シェーダーのみ。変数格納は作業グループ内のすべての作業項目で共有される。</p>
</dd>
</dl>
<p>入出力修飾変数の中には、高々一つの補助格納修飾子を追加できるものがある。</p>
<dl class="glossary simple">
<dt id="term-centroid"><code class="docutils literal notranslate"><span class="pre">centroid</span></code><a class="headerlink" href="#term-centroid" title="Permalink to this term">¶</a></dt><dd><p>重心基準補間</p>
</dd>
<dt id="term-sample"><code class="docutils literal notranslate"><span class="pre">sample</span></code><a class="headerlink" href="#term-sample" title="Permalink to this term">¶</a></dt><dd><p>一標本ごとの補間</p>
</dd>
<dt id="term-patch"><code class="docutils literal notranslate"><span class="pre">patch</span></code><a class="headerlink" href="#term-patch" title="Permalink to this term">¶</a></dt><dd><p>細分化一パッチごとの属性</p>
</dd>
</dl>
<p>すべての修飾子の組み合わせが許されるわけではない。補助格納修飾子は <code class="docutils literal notranslate"><span class="pre">in</span></code> または <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子と一緒にしか使用できない。その他の修飾子の規則については、以降の節で説明。</p>
<p>局所変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子のみ使用できる（または格納修飾子を使用しない）。</p>
<p>関数の引数には <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code> を使用できるが、引数修飾子としては使用できないことに注意。引数修飾子については
<a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> を参照。</p>
<p>関数の戻り値の型や構造体のメンバーには格納修飾子を使用しない。</p>
<p>大域宣言の初期化子は、格納修飾子がないか、
<code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子があるか、または <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 修飾子がある大域変数の宣言でしか使用できない。</p>
<p>格納修飾子のない大域変数は、その宣言またはアプリケーションで初期化されないと、初期化されずに未定義の値で <code class="docutils literal notranslate"><span class="pre">main()</span></code> に入る。</p>
<p>あるシェーダー段階の出力と後続のシェーダー段階の入力を比較するとき、補助修飾子（またはその欠落）が同じでない場合、入力と出力は一致しない。</p>
<section id="default-storage-qualifier">
<h4><a class="toc-backref" href="#id23">4.3.1. Default Storage Qualifier</a><a class="headerlink" href="#default-storage-qualifier" title="Permalink to this heading">¶</a></h4>
<p>大域変数に修飾子がない場合、その変数はアプリケーションや他のパイプライン段階で実行されるシェーダーとはリンクしていない。大域変数でも局所変数でも、修飾されていない変数では、宣言は対象となる処理器に関連するメモリーが割り当てられているように見える。この変数は、この割り当てられたメモリーへの読み取り・書き込みアクセスを提供する。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>意味不明。</p>
</div>
</section>
<section id="constant-qualifier">
<h4><a class="toc-backref" href="#id24">4.3.2. Constant Qualifier</a><a class="headerlink" href="#constant-qualifier" title="Permalink to this heading">¶</a></h4>
<p>名前付きのコンパイル時定数や読み取り専用の変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子を使って宣言できる。
<code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子は、非 <code class="docutils literal notranslate"><span class="pre">void</span></code> 透過基本データ型や、それらの構造体や配列で使用できる。宣言されていない <code class="docutils literal notranslate"><span class="pre">const</span></code> 変数に書き込むコードはコンパイルエラーとなるから、宣言時に初期化する必要がある。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">zAxis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">ceiling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// a and b not necessarily constants</span><span class="w"></span>
</pre></div>
</div>
<p>構造体のメンバーは <code class="docutils literal notranslate"><span class="pre">const</span></code> で修飾することはできない。構造体変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> として宣言し、構造体のコンストラクターまたは初期化子で初期化できる。</p>
<p>大域スコープでの <code class="docutils literal notranslate"><span class="pre">const</span></code> 宣言の初期化子は、次節で定義されるように、定数式でなければならない。</p>
</section>
<section id="constant-expressions">
<h4><a class="toc-backref" href="#id25">4.3.3. Constant Expressions</a><a class="headerlink" href="#constant-expressions" title="Permalink to this heading">¶</a></h4>
<p>SPIR-V の特殊化定数は、
<a class="reference internal" href="#specialization-constant-qualifier"><span class="std std-ref">4.11. Specialization-Constant Qualifier</span></a> で記述されるように、
GLSL では <code class="docutils literal notranslate"><span class="pre">const</span></code> にレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">const_id</span></code> を付けて表現される。</p>
<p><strong>定数式</strong> (a constant expression) とは次のいずれかだ：</p>
<ul class="simple">
<li><p>リテラル値</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子と初期化子で宣言された変数で、初期化子が定数式であるもの。これは <code class="docutils literal notranslate"><span class="pre">layout(const_id</span> <span class="pre">=</span> <span class="pre">...)</span></code> のような特殊化定数レイアウト修飾子を付けて宣言された
<code class="docutils literal notranslate"><span class="pre">const</span></code> と、特殊化定数レイアウト修飾子を付けずに宣言された <code class="docutils literal notranslate"><span class="pre">const</span></code> の両方を含む。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> として修飾された組み込み変数。</p></li>
<li><p>定数配列の要素、定数構造体のメンバー、定数ベクトルの構成要素の取得など、すべて定数式であるオペランドに対して演算子で形成される式。</p></li>
<li><p>オブジェクト自体が定数であるかどうかに関わらず、明示的なサイズのオブジェクトに対する
<code class="docutils literal notranslate"><span class="pre">length()</span></code> メソッドの適切な使用（暗黙的なサイズの配列や実行時サイズの配列は定数式を返さない）。</p></li>
<li><p>引数がすべて定数式であるコンストラクター。</p></li>
<li><p>非特殊化定数の場合のみ：引数がすべて定数式である特定の組み込み関数の呼び出しの戻り値（少なくとも以下のリストを含む）。メモリーにアクセスしないその他の組み込み関数（テクスチャー探索関数、画像アクセス、不可分計数器などを除く）であって、戻り値の型が非 <code class="docutils literal notranslate"><span class="pre">void</span></code> で <code class="docutils literal notranslate"><span class="pre">out</span></code> 引数がなく、ノイズ関数ではないものも定数とみなされる場合がある。関数が特殊化定数である引数で呼び出された場合、その結果は定数式ではない。</p>
<ul>
<li><p>角度および三角関数</p></li>
<li><p>指数関数</p></li>
<li><p>普通の関数</p></li>
<li><p>幾何関数</p></li>
</ul>
</li>
<li><p>ユーザー定義関数（非組み込み関数）の関数呼び出しは、定数式には使用できない。</p></li>
</ul>
<hr class="docutils" />
<p><strong>定整数式</strong> (a constant integral expression) とは定数式であって、スカラーの符号付きまたは符号なしの整数に評価されるものだ。</p>
<p>定数式は不変的な方法で評価されるため、複数のシェーダーに同じ定数式が現れた場合、同じ値が生成される。
<a class="reference internal" href="#the-invariant-qualifier"><span class="std std-ref">4.8.1. The Invariant Qualifier</span></a>, <a class="reference internal" href="#precision-qualifiers"><span class="std std-ref">4.7.2. Precision Qualifiers</span></a> を参照。</p>
<p>定数式は <code class="docutils literal notranslate"><span class="pre">precision</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">invariant</span></code> 修飾子を尊重するが、そのような修飾子の使用とは関係なく、常に不変的に評価されるため、複数のシェーダーに同じ定数式が現れた場合には、同じ値が生成される。</p>
<p>定数式はホストプラットフォームで評価される可能性がある。それゆえ同じ式がシェーダー実行対象で評価するような値と同じものを計算する必要はない。ただし、ホストは対象が使用するのと同じか、それ以上の精度を使用しなければならない。精度修飾子が決定できない場合、式は <code class="docutils literal notranslate"><span class="pre">highp</span></code> で評価される。
<a class="reference internal" href="#default-precision-qualifiers"><span class="std std-ref">4.7.3. Default Precision Qualifiers</span></a> 参照。</p>
<p>特殊化定数式は、コンパイラーのフロントエンドでは評価されないで、代わりに、後でホスト上で評価するために必要な式の操作を留めておく。</p>
</section>
<section id="input-variables">
<h4><a class="toc-backref" href="#id26">4.3.4. Input Variables</a><a class="headerlink" href="#input-variables" title="Permalink to this heading">¶</a></h4>
<p>シェーダーの入力変数は <code class="docutils literal notranslate"><span class="pre">in</span></code> 格納修飾子で宣言される。この変数は、API パイプラインの前段階と宣言したシェーダーとの間の入力インターフェイスを形成する。入力変数は大域スコープで宣言しなければならない。前のパイプライン段階から来る値は、シェーダー実行開始時に入力変数にコピーされる。入力として宣言された変数に書き込むコードはコンパイルエラーとなる。</p>
<p>前の段階で書き込む必要があるのは、静的に読み込まれる入力変数だけであり、入力変数の宣言が余計に付いていても構わない。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>本文ではこのことをまとめた表がここに示されているが、割愛する。</p>
</div>
<p>消費エラーは静的な使用にしかよらない。未定義の値を消費する可能性のある動的な使用方法をコンパイラーが推論する場合、エラーではなく警告を発する。組み込み入力名の一覧は <a class="reference internal" href="note7.html#built-in-variables"><span class="std std-ref">7. Built-In Variables</span></a> を参照。</p>
<p>頂点シェーダーの入力変数（または属性）は、頂点ごとのデータを受け取る。頂点シェーダー入力に補助格納修飾子や補間修飾子を使用すると、コンパイルエラーとなる。コピーされた値は API またはレイアウト識別子 <code class="docutils literal notranslate"><span class="pre">location</span></code> の使用により設けられる。</p>
<p>以下の型で頂点シェーダー入力を宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
<li><p>構造体</p></li>
</ul>
<hr class="docutils" />
<p>頂点シェーダーにおける入力宣言の例を示す：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span><span class="w"></span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">texCoord</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>グラフィックスハードウェアでは、頂点入力を渡すための固定のベクトル場所が足りないことが予想される。そのため、OpenGL Shading Language では、行列以外の入力変数は、そのようなベクトル位置を一つ使用すると定義している。使用できる場所の数には実装依存の制限があり、これを超えるとリンクエラーが発生する（静的使用でないと宣言された入力変数は、この制限に含まれない）。スカラー入力は <code class="docutils literal notranslate"><span class="pre">vec4</span></code> と同じようにカウントされるので、アプリケーションでは、内在するハードウェアの性能をよりよく活用するために、関係のない 4 つの <code class="docutils literal notranslate"><span class="pre">float</span></code> 入力のグループをまとめてベクトルにすることを検討するとよいだろう。行列入力は、複数の場所を使用する。使用される場所の数は、行列の列数と同じだ。</p>
<p>細分化制御、細分化評価、幾何シェーダーの入力変数は、前のアクティブシェーダー段階で同じ名前の出力変数によって書き出された、頂点ごとの値を取得する。これらの入力では <code class="docutils literal notranslate"><span class="pre">centroid</span></code> や補間修飾子が使えるが、効果はない。細分化制御、細分化評価、幾何シェーダーは頂点集合を操作するので、各入力変数（または入力ブロック、下記のインターフェイスブロックを参照）は配列として宣言する必要がある。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">foo</span><span class="p">[];</span><span class="w"> </span><span class="c1">// geometry shader input for vertex &quot;out float foo&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>このような配列の各要素は、処理される基本形状の一つの頂点に対応する。各配列はオプションでサイズを宣言することができる。幾何シェーダーの場合、配列のサイズは、<a class="reference internal" href="#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a>
のように、入力基本形状の型を設定する入力 <code class="docutils literal notranslate"><span class="pre">layout</span></code> 宣言によって設定される。</p>
<hr class="docutils" />
<p>入力と出力は配列されているものもある。これは、シェーダー段階二つの間にあるインターフェイスでは、入力または出力の宣言を一致させるために、余分なレベルの配列インデックスが必要になることを意味する。例えば、頂点シェーダーと幾何シェーダーのインターフェイスでは、頂点シェーダーの出力変数と幾何シェーダーの入力変数の同名の変数は、型が一致していなければならない。ただし、幾何シェーダーは、頂点のインデックス付けを可能にするために、頂点シェーダーよりも 1 多い配列次元を持つことになる。このように配列されたインターフェイス変数が、必要である追加的入力・出力配列次元で宣言されていない場合、リンクエラーとなる。幾何シェーダー入力、細分化制御シェーダー入出力、細分化評価入力はすべて、他のシェーダー入出力に比べて追加的配列レベルを持っている。これらの入力と出力は、頂点ごとに配列された (per-vertex-arrayed) 入力と出力として知られている。配列されたインターフェイス (<code class="docutils literal notranslate"><span class="pre">gl_MaxTessControlInputComponents</span></code>, etc.)
の成分制限は、インターフェイス全体に対する制限ではなく、頂点ごとの制限だ。</p>
<p>非配列のインターフェイス（＝段階間配列の次元が変わらない）では、入力変数が一致する出力変数と配列の次元を含めて同じ型で宣言されていないとリンクエラーとなる。</p>
<p>リンク時の型マッチング規則は、使用されているか否かに関わらず、宣言されたすべての入力変数と出力変数に適用される。</p>
<p>さらに、細分化評価シェーダーは <code class="docutils literal notranslate"><span class="pre">patch</span></code> および <code class="docutils literal notranslate"><span class="pre">in</span></code> 修飾子で宣言された
<code class="docutils literal notranslate"><span class="pre">patch</span></code> ごとの入力変数を対処している。パッチごとの入力変数には、細分化制御シェーダーによって書き込まれたパッチごとの出力変数の値が入る。パッチごとの入力は一次元配列として宣言できるが、頂点数によるインデックスは付けられない。入力への <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子の適用は、細分化評価シェーダでしか行えない。他の入力変数と同様に、パッチごとの入力は、前の（細分化制御）シェーダー段階からのパッチごとの出力と同じ型と修飾子を使って宣言しなければならない。他の段階の入力で <code class="docutils literal notranslate"><span class="pre">patch</span></code> を使用することは、コンパイルエラーとなる。</p>
<p>細分化制御、細分化評価、幾何シェーダーの入力を、以下のいずれかの型で宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<hr class="docutils" />
<p>断片シェーダーの入力は、前の段階の出力から補間された断片ごとの値をふつうは取得する。補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code> も、補間修飾子 <code class="docutils literal notranslate"><span class="pre">flat</span></code>, <code class="docutils literal notranslate"><span class="pre">noperspective</span></code>,
<cite>smooth`</cite> と同様に適用できる。</p>
<p>断片シェーダーの入力を次のいずれかの型で宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<p>整数型または倍精度浮動小数点型であるか、またはそれを含む断片シェーダー入力には補間修飾子 <code class="docutils literal notranslate"><span class="pre">flat</span></code> が必要だ。</p>
<p>断片入力は以下の例のように宣言される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span><span class="w"></span>
<span class="k">centroid</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">TexCoord</span><span class="p">;</span><span class="w"></span>
<span class="k">invariant</span><span class="w"> </span><span class="k">centroid</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w"></span>
<span class="k">noperspective</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">temperature</span><span class="p">;</span><span class="w"></span>
<span class="k">flat</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">myColor</span><span class="p">;</span><span class="w"></span>
<span class="k">noperspective</span><span class="w"> </span><span class="k">centroid</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">myTexCoord</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>断片シェーダーの入力は、頂点処理パイプラインにおける最終アクティブシェーダーとのインターフェイスを形成する。このインターフェイスでは、最終アクティブシェーダー段階出力変数と断片シェーダーの入力変数の同名の変数は、いくつかの例外（格納修飾子の一方は <code class="docutils literal notranslate"><span class="pre">in</span></code> で他方は <code class="docutils literal notranslate"><span class="pre">out</span></code> でなければならない）を除いて、型と修飾子が一致していなければならない。また、補間修飾子や補助修飾子も異なる場合がある。これらのミスマッチは任意の段階対の間で許される。補間修飾子や補助修飾子が一致しない場合は、断片シェーダーで提供される修飾子が前段階で提供される修飾子よりも優先される。断片シェーダーにそのような修飾子が全くない場合は、前段階で宣言されていた修飾子ではなく、既定の修飾子が使用される。つまり、重要なのは断片シェーダーで何が宣言されているかであり、前段階のシェーダーで何が宣言されているかではないということだ。</p>
<hr class="docutils" />
<p>シェーダー段階間のインターフェイスが別々のプログラムオブジェクトのシェーダーを使って形成されている場合、プログラムがリンクされたときに入力と出力の間の不一致を検出することはできない。このようなインターフェイスでは、入力と出力の間に不一致があると、インターフェイスを介して渡される値は、部分的にまたは完全に未定義となる。</p>
<p>シェーダーで入出力レイアウト修飾子 (<a class="reference internal" href="#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a>,
<a class="reference internal" href="#output-layout-qualifiers"><span class="std std-ref">4.4.2. Output Layout Qualifiers</span></a>)
を使用するか、ブロックや変数の入力宣言と出力宣言を同一にすることで、このようなインターフェイス間のマッチングを担保することができる。インターフェイスのマッチングに関する完全な規則は、
OpenGL 仕様書の 7.4.1 “Shader Interface Matching” に記載されている。</p>
<hr class="docutils" />
<p>計算シェーダはユーザ定義の入力変数を許可せず、他のシェーダー段階との正式なインターフェイスを形成しない。組み込みの計算シェーダー入力変数については
<a class="reference internal" href="note7.html#compute-shader-special-variables"><span class="std std-ref">7.1.6. Compute Shader Special Variables</span></a> を参照。計算シェーダーへの他のすべての入力は、画像ロード、テクスチャー取得、一様変数または一様バッファーからのロード、または他のユーザーコードによって明示的に取得される。計算シェーダーの組み込み入力変数を再宣言することはできない。</p>
</section>
<section id="uniform-variables">
<h4><a class="toc-backref" href="#id27">4.3.5. Uniform Variables</a><a class="headerlink" href="#uniform-variables" title="Permalink to this heading">¶</a></h4>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>英単語 uniform をどう訳したらしっくり来るだろうか。数学科専攻としては「一様」にしたい。中国語の仕様書を見たら「統一」に相当する単語をあてているようだ。</p>
</div>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">uniform</span></code> は、処理される基本形状全体で値が同じになる大域変数を宣言するために用いられる。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数はすべて読み取り専用で、リンク時または API を通じて外部から初期化される。リンク時の初期値は、変数の初期化子が存在する場合はその値で、存在しない場合は 0 だ。不透明型は初期化子を持つことができず、そうでない場合はコンパイルエラーが発生する。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">;</span><span class="w"></span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">);</span><span class="w"> </span><span class="c1">// value assigned at link time</span><span class="w"></span>
</pre></div>
</div>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">uniform</span></code> は、基本的なデータ型のいずれか、または構造体を型とする変数を宣言するとき、あるいはこれらのいずれかの配列を宣言するときに使用できる。</p>
<p>シェーダーの種類ごとに使用できる <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 用変数の収容量には実装依存の制限がある。これを超えるとコンパイル時またはリンク時にエラーとなる。宣言されているが使用されていない <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数はこの制限に入らない。ユーザー定義の <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の個数と、シェーダー内で使用されている組み込みの <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の個数の和で、利用可能な収容量を超えているかどうかを判断する。</p>
<p>シェーダー内の <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数は、プログラムまたは分割可能なプログラムにリンクされている場合、すべて単一の大域名前空間を共有する。したがって、同じ名前で静的に使用される <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の型、初期化子、および任意の <code class="docutils literal notranslate"><span class="pre">location</span></code> 指定子は、単一プログラムにリンクされているすべてのシェーダーで一致しなければならない。ただし、リンクされたすべてのシェーダーで初期化子や <cite>location`</cite> 指定子を繰り返す必要はない。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数名がある段階（例：頂点シェーダー）で宣言され、別の段階（例：断片シェーダー）で宣言されていない場合、その名前は別の段階で別の用途に使用することが許される。</p>
</section>
<section id="output-variables">
<h4><a class="toc-backref" href="#id28">4.3.6. Output Variables</a><a class="headerlink" href="#output-variables" title="Permalink to this heading">¶</a></h4>
<p>シェーダー出力変数は <code class="docutils literal notranslate"><span class="pre">out</span></code> 格納修飾子で宣言される。出力変数は、宣言したシェーダーと API パイプラインの後続段階との間の出力インターフェイスを形成する。出力変数は大域スコープで宣言しなければならない。シェーダーの実行中は、修飾のない通常の大域変数として振る舞う。シェーダーの終了時にその値は後続のパイプライン段階にコピーされる。後続のパイプライン段階で読まれる出力変数だけが書き込まれる必要があり、出力変数の余計な宣言があっても構わない。</p>
<p>単一の変数名をシェーダーの入力と出力の両方として宣言するための
<code class="docutils literal notranslate"><span class="pre">inout</span></code> のような格納修飾子は存在しない。一つの変数に <code class="docutils literal notranslate"><span class="pre">in</span></code> と <code class="docutils literal notranslate"><span class="pre">out</span></code> の両方の修飾子をつけて宣言することもまたできない。コンパイル時またはリンク時にエラーとなる。出力変数は、入力変数とは異なる名前で宣言しなければならない。ただし、インスタンス名を持つインターフェイスブロックの中に入力または出力を入れ子にすると、ブロックのインスタンス名で参照されるものと同じ名前を使うことができる。</p>
<p>頂点、細分化評価、幾何の出力変数は、頂点ごとのデータを出力し、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子を用いて宣言される。出力への <code class="docutils literal notranslate"><span class="pre">patch</span></code> の適用は、細分化制御シェーダーでのみ可能だ。それ以外の段階での適用はコンパイルエラーとなる。</p>
<p>頂点、細分化評価、細分化制御、幾何それぞれのシェーダーの出力を、以下の型のいずれかで宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span><span class="w"></span>
<span class="k">centroid</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">TexCoord</span><span class="p">;</span><span class="w"></span>
<span class="k">invariant</span><span class="w"> </span><span class="k">centroid</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w"></span>
<span class="k">flat</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">myColor</span><span class="p">;</span><span class="w"></span>
<span class="k">sample</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">perSampleColor</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>これらは <a class="reference internal" href="#interface-blocks"><span class="std std-ref">4.3.9. Interface Blocks</span></a> で述べられるように、インターフェイスブロックにも出現する。インターフェイスブロックでは、頂点シェーダーから幾何シェーダーへのインターフェイスに、より単純に配列を追加することができる。また、断片シェーダーに、ある頂点シェーダーの幾何シェーダーと同じ入力インターフェイスを持たせることができる。</p>
<hr class="docutils" />
<p>細分化制御シェーダーの出力変数は、頂点ごとのデータとパッチごとのデータを出力するために用いられる。頂点ごとの出力変数は配列され (<a class="reference internal" href="#input-variables"><span class="std std-ref">4.3.4. Input Variables</span></a>)、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子なしに宣言される。パッチごとの出力変数は <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で宣言される。</p>
<p>細分化制御シェーダーは、複数の頂点からなる配列された基本形状を生成するため、各頂点ごとの出力変数（または出力ブロック）は、配列として宣言する必要がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">foo</span><span class="p">[];</span><span class="w"> </span><span class="c1">// feeds next stage input &quot;in float foo[]&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>このような配列の要素それぞれが、生成される基本形状一つの頂点に対応する。各配列はオプションでサイズを宣言することができる。配列のサイズは出力パッチの頂点の数を定める出力レイアウト宣言によって設定される
(<a class="reference internal" href="#tessellation-control-outputs"><span class="std std-ref">Tessellation Control Outputs</span></a>)（または、宣言されている場合は、それと一致しなければならない）。</p>
<p>各細分化制御シェーダー呼び出しは、対応する出力パッチの頂点を持ち、その対応する頂点に属しているときに限り、頂点ごとの出力に値を割り当てることができる。頂点ごとの出力変数を左辺値として使用する場合、頂点のインデックスを示す式が識別子 <code class="docutils literal notranslate"><span class="pre">gl_InvocationID</span></code> でないと、コンパイルエラーまたはリンクエラーになる。</p>
<p>同じ入力パッチに対する他の呼び出しに対する細分化制御シェーダー呼び出しの相対的な実行順序は、組み込み関数 <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> が使用されない限り、未定義だ。これにより、相対的な実行順序の制御が可能になる。シェーダーの呼び出しが <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を呼び出すと、他のすべての呼び出しが同じ実行箇所に到達するまでその実行は一時停止する。
<code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を呼び出す前に実行された任意の呼び出しによって実行された出力変数の割り当ては、
<code class="docutils literal notranslate"><span class="pre">barrier()</span></code> の呼び出しが戻った後、他の任意の呼び出しから見えるようになる。</p>
<p>細分化制御シェーダーの呼び出しは、障壁間で未定義の順序で実行されるので、頂点ごと、あるいはパッチごとの出力変数の値は時々未定義になる。シェーダー実行の開始と終了、および <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> の各呼び出しを同期時点と考えるといい。出力変数の値が不定になるのは、以下の三つの場合のいずれかだ：</p>
<ol class="arabic simple">
<li><p>実行の開始時</p></li>
<li><p>以下の場合を除く各同期時点：</p>
<ul class="simple">
<li><p>前回の同期時点の後に値が定義され、その後どの呼び出しによっても書き込まれなかった場合、または</p></li>
<li><p>前回の同期時点以降、厳密に一つのシェーダー呼び出しによって値が書き込まれた場合、または</p></li>
<li><p>前回の同期時点以降に複数のシェーダー呼び出しによって値が書き込まれ、そのようなすべての呼び出しによって実行された最後の書き込みが同じ値を書き込んだ場合。</p></li>
</ul>
</li>
<li><p>シェーダーの呼び出しによって読み込まれたとき、もし</p>
<ul class="simple">
<li><p>その値が前回の同期時点で未定義であり、その後同じシェーダー呼び出しによって書き込まれていない場合、または</p></li>
<li><p>前回と次回の同期時点の間に他のシェーダー呼び出しによって出力変数が書き込まれた場合（その割り当てが読み取り後のコードで発生したときでさえ）</p></li>
</ul>
</li>
</ol>
<hr class="docutils" />
<p>断片出力は、断片ごとのデータを出力し、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で宣言される。断片シェーダー出力の宣言に補助格納修飾子や補間修飾子を使用するとコンパイルエラーとなる。断片シェーダー出力を以下の型で宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>倍精度スカラーまたはベクトル (<code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec2</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec3</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec4</span></code>)</p></li>
<li><p>不透明型</p></li>
<li><p>行列型</p></li>
<li><p>構造体</p></li>
</ul>
<p>断片出力宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">FragmentColor</span><span class="p">;</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="n">Luminosity</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>計算シェーダーは組み込みの出力変数を持たず、ユーザー定義の出力変数も対処せず、他のシェーダー段階との正式なインターフェイスを形成しない。計算シェーダーからの出力はすべて、画像格納や不可分計数器の演算などの副作用の形をとる。</p>
</section>
<section id="buffer-variables">
<h4><a class="toc-backref" href="#id29">4.3.7. Buffer Variables</a><a class="headerlink" href="#buffer-variables" title="Permalink to this heading">¶</a></h4>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> はAPI を通じて束縛されたバッファーオブジェクトのデータ格納空間に値が格納される大域変数を宣言するために使用される。バッファー変数はすべてのアクティブなシェーダー呼び出しの間で内包される格納空間を共有して読み書きすることができる。単一のシェーダー呼び出し内でのバッファー変数のメモリーの読み取りと書き込みは順番に処理される。しかし、ある起動で実行される読み込みと書き込みの順序は、他の呼び出しで実行されるものと比較するとほとんど未定義だ。バッファー変数は内包されているメモリーへのアクセス方法に影響を与えるメモリー修飾子
(<a class="reference internal" href="#memory-qualifiers"><span class="std std-ref">4.10. Memory Qualifiers</span></a>) で修飾することができる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> は、インターフェイスブロック (<a class="reference internal" href="#interface-blocks"><span class="std std-ref">4.3.9. Interface Blocks</span></a>)
を宣言するために使用することができ、これらのブロックはシェーダー格納ブロックとして参照される。ブロックの外でバッファー変数を宣言するとコンパイルエラーとなる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// use buffer to create a buffer block (shader storage block)</span><span class="w"></span>
<span class="k">buffer</span><span class="w"> </span><span class="n">BufferName</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// externally visible name of buffer</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w">      </span><span class="c1">// typed, shared memory...</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w">             </span><span class="c1">// ...</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">[];</span><span class="w">       </span><span class="c1">// last member may be an array that is not sized</span><span class="w"></span>
<span class="w">                    </span><span class="c1">// until after link time (dynamically sized)</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Name</span><span class="p">;</span><span class="w">             </span><span class="c1">// name of block within the shader</span><span class="w"></span>
</pre></div>
</div>
<p>シェーダーの種類ごとに使用されるシェーダー格納ブロックの数、プログラムに使用されるシェーダー格納格納ブロックの合計数、個々のシェーダー格納ブロックが必要とする格納空間の量には、実装に依存した制限がある。これらの制限を超えた場合は、コンパイル時またはリンク時にエラーが発生する。</p>
<p>複数のシェーダーがリンクされている場合、それらのシェーダーは単に大域バッファー変数の名前空間を共有することになる。したがって、同じ名前で宣言されたバッファー変数の型は、単一のプログラムにリンクされているすべてのシェーダーで一致しなければならない。</p>
</section>
<section id="shared-variables">
<h4><a class="toc-backref" href="#id30">4.3.8. Shared Variables</a><a class="headerlink" href="#shared-variables" title="Permalink to this heading">¶</a></h4>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">shared</span></code> は、計算シェーダー作業グループ内のすべての作業項目間で共有される格納空間がある大域変数を宣言するために用いられる。
<code class="docutils literal notranslate"><span class="pre">shared</span></code> として宣言された変数は、計算シェーダーでしか使用されない
(<a class="reference internal" href="note2.html#compute-processor"><span class="std std-ref">2.6. Compute Processor</span></a>)。それ以外の共有変数の宣言は、コンパイルエラーとなる。共有変数は暗黙的に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> (<a class="reference internal" href="#memory-qualifiers"><span class="std std-ref">4.10. Memory Qualifiers</span></a>) だ。</p>
<p>共有変数として宣言された変数は初期化子を持たず、シェーダーの実行開始時にはその内容は未定義だ。共有変数に書き込まれたどんなデータも、同じ作業グループ内の他の作業項目（同じシェーダーを実行中）から見えるということになる。</p>
<p>同期が行われていない場合、シェーダーの異なる呼び出しによる同じ <code class="docutils literal notranslate"><span class="pre">shared</span></code> 変数への読み書きの順序は未定義とする。</p>
<p>共有変数への読み書きの順序を決めるためには、関数 <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を使って制御フローの障壁を設ける必要がある
(<a class="reference internal" href="note8.html#shader-invocation-control-functions"><span class="std std-ref">8.16. Shader Invocation Control Functions</span></a>)。</p>
<p>単一のプログラムで共有変数として宣言されたすべての変数の合計サイズには制限がある。
basic machine units 単位で表されるこの制限は、OpenGL API を使って
<code class="docutils literal notranslate"><span class="pre">MAX_COMPUTE_SHARED_MEMORY_SIZE</span></code> の値を照会することで決定できる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>最後のパラグラフ中の basic machine units なる用語がわからない。</p>
</div>
</section>
<section id="interface-blocks">
<h4><a class="toc-backref" href="#id31">4.3.9. Interface Blocks</a><a class="headerlink" href="#interface-blocks" title="Permalink to this heading">¶</a></h4>
<p>入力、出力、一様、バッファー変数の宣言は、名前の付いたインターフェイスブロックにまとめることができ、個別の宣言では達せられない粗い粒度の backing が可能になる。これらはオプションでインスタンス名を持つことができ、シェーダー内でそのメンバーを参照するために用いられる。あるプログラム可能段階の出力ブロックは、後続のプログラム可能段階の対応する入力ブロックによって back される。一様ブロック (a uniform block) は、アプリケーションによってバッファーオブジェクトで back される。シェーダー格納ブロック (a shader storage block) と呼ばれるバッファー変数のブロックも、アプリケーションによってバッファーオブジェクトで back される。頂点シェーダーの入力ブロックや断片シェーダーの出力ブロックを持つことは、コンパイルエラーとなる。これらの用途は将来のために予約されている。</p>
<p>インターフェイスブロックは、キーワード <code class="docutils literal notranslate"><span class="pre">in`,</span> <span class="pre">``out</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>
と、ブロック名、そして中括弧 <code class="docutils literal notranslate"><span class="pre">{</span></code> で始まる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>BNF による一覧を省略。</p>
</div>
<hr class="docutils" />
<p>次のコードは <code class="docutils literal notranslate"><span class="pre">Transform</span></code> という名前の一様ブロックを定義する。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数四つがグループ化される。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat4</span><span class="w"> </span><span class="n">ModelViewMatrix</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat4</span><span class="w"> </span><span class="n">ModelViewProjectionMatrix</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">uniform</span><span class="w"> </span><span class="kt">mat3</span><span class="w"> </span><span class="n">NormalMatrix</span><span class="p">;</span><span class="w">      </span><span class="c1">// allowed restatement of qualifier</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Deformation</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>型と宣言子は、ブロック外の他の入力、出力、一様、バッファー変数の宣言と同じだ、以下の例外がある：</p>
<ul class="simple">
<li><p>初期化子は許されない。</p></li>
<li><p>不透明型は許されない。</p></li>
<li><p>ブロック内での構造体定義の入れ子は許されない。</p></li>
</ul>
<p>これらはいずれもコンパイルエラーになる。</p>
<p>メンバー宣言にオプションの修飾子がない場合、メンバーの修飾には、
interface-qualifier で決定されるすべての <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">patch</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>,
<code class="docutils literal notranslate"><span class="pre">buffer</span></code> が含まれる。オプション修飾子を使用する場合、補間修飾子、補助格納修飾子、格納修飾子を含むことができ、ブロックのインターフェイス修飾子と一致する入力、出力、一様メンバーを宣言しなければならない。すなわち、入力変数、出力変数、一様変数、
<code class="docutils literal notranslate"><span class="pre">buffer</span></code> メンバーは、
<code class="docutils literal notranslate"><span class="pre">in</span></code> ブロック、
<code class="docutils literal notranslate"><span class="pre">out</span></code> ブロック、
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> ブロック、シェーダー格納ブロック内それぞれにしか存在しない。</p>
<p>メンバーの格納修飾子に <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">patch</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>
のいずれかのインターフェイス修飾子を繰り返すことはオプションだ。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="n">Material</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">smooth</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color1</span><span class="p">;</span><span class="w"> </span><span class="c1">// legal, input inside in block</span><span class="w"></span>
<span class="w">    </span><span class="k">smooth</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color2</span><span class="p">;</span><span class="w">    </span><span class="c1">// legal, &#39;in&#39; inherited from &#39;in Material&#39;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec2</span><span class="w"> </span><span class="n">TexCoord</span><span class="p">;</span><span class="w">         </span><span class="c1">// legal, TexCoord is an input</span><span class="w"></span>
<span class="w">    </span><span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Atten</span><span class="p">;</span><span class="w">   </span><span class="c1">// illegal, mismatched storage qualifier</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p><strong>シェーダーインターフェイス</strong> (a shader interface) とは、次のうちの一つとする：</p>
<ul class="simple">
<li><p>プログラムの中で宣言されたすべての一様変数と一様ブロック。これは、一つのプログラム内でリンクされているすべてのコンパイル単位に及ぶ。</p></li>
<li><p>プログラム内で宣言された <code class="docutils literal notranslate"><span class="pre">buffer</span></code> ブロックすべて。</p></li>
<li><p>隣接するプログラム可能パイプライン段階間の境界。最初の段階のコンパイル単位すべてで宣言された出力すべてと、次の段階のコンパイル単位すべて宣言された入力すべてに及ぶ。なお、実際には断片シェーダーに渡された値すべては、まずラスタライザーと補間器を通過するが、この定義では、断片シェーダーと先行するシェーダーは境界を共有すると考えられる。</p></li>
</ul>
<p>ブロック名 (<em>block-name</em>) は、シェーダーインターフェイス内での照合に用いられる。つまり、あるパイプライン段階の出力ブロックは、後続のパイプライン段階の同名の入力ブロックに合致する。一様ブロックやシェーダー格納ブロックの場合、アプリケーションはブロック名を使ってブロックを識別する。シェーダー内ではインターフェイスの照合以外にはブロック名を利用できない。大域スコープのブロック名をブロック名として以外に使用することはコンパイルエラーとなる（例えば、大域変数名や関数名にブロック名を使用することが現在予約されている）。ブロックの内容が同じであっても、一つのシェーダー内の同じシェーダーインターフェイスの複数のブロック宣言に同じブロック名を使用すると、コンパイルエラーとなる。</p>
<p>一つのシェーダインターフェイスの中で合致したブロック名は、同じ数の宣言と同じ型の並び、同じメンバー名の並び、そしてメンバーごとのレイアウト修飾が一致していなければならない。一致した一様ブロック名またはシェーダー格納ロック名（入力ブロック名または出力ブロック名ではない）は、すべてインスタンス名がないか、またはすべてインスタンス名があり、それらのメンバーが同じスコープレベルにあることも必要だ。合致したブロック名の上にインスタンス名がある場合、インスタンス名が違っていても構わない。さらに、合致ブロックが配列として宣言されている場合は、配列のサイズまでも一致していなければならない。（または、連続するシェーダー段階間のシェーダーインターフェイスの配列一致規則に従う）。不一致の場合、リンクタイムエラーとなる。ブロック名は、同一シェーダー内の異なるシェーダーインターフェイスで異なる定義であることが許されており、例えば、入力ブロックと出力ブロックが同じ名前であることも可能である。</p>
<p>インスタンス名 (<em>instance-name</em>) を使用しない場合、ブロック内で宣言された名前は大域レベルでスコープされ、ブロックの外で宣言されたかのようにアクセスされる。インスタンス名を使用すると、スコープ内のすべてのメンバーが独自の名前空間内に置かれ、構造体と同様の、フィールドセレクター演算子 <code class="docutils literal notranslate"><span class="pre">.</span></code> でアクセスされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="n">Light</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">LightPos</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">LightColor</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">in</span><span class="w"> </span><span class="n">ColoredTexture</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec2</span><span class="w"> </span><span class="n">TexCoord</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Material</span><span class="p">;</span><span class="w">           </span><span class="c1">// instance name</span><span class="w"></span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w">           </span><span class="c1">// different Color than Material.Color</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">LightPos</span><span class="p">;</span><span class="w">        </span><span class="c1">// illegal, already defined</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="p">...</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LightPos</span><span class="p">;</span><span class="w">       </span><span class="c1">// accessing LightPos</span><span class="w"></span>
<span class="p">...</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Material</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span><span class="w"> </span><span class="c1">// accessing Color in ColoredTexture block</span><span class="w"></span>
</pre></div>
</div>
<p>シェーディング言語の外では、メンバーは同様に識別されるが、インスタンス名の代わりにブロック名が常に使用される。API のアクセスはシェーダーではなくシェーダーインターフェイスに対して行われるのだ。インスタンス名がない場合、API はメンバーにアクセスするためにブロック名を使用せず、メンバー名だけを使用する。</p>
<p>シェーダーインターフェイス内では、同じ大域名の宣言すべては同じオブジェクトに対するものでなければならず、型や、インスタンス名のないブロックの変数やメンバーを宣言しているかどうかが一致していなければならない。また、API はシェーダーインターフェイス内のオブジェクトを一意に識別するためにこの名前を必要とする。次のどちらかが成り立つならば、どのシェーダーインターフェイスもリンクエラーになる：</p>
<ul class="simple">
<li><p>インスタンス名を持たず、同じ名前のメンバーを持つ相異なるブロックが含まれている。</p></li>
<li><p>ブロック外の変数と、インスタンス名のないブロックで、その変数がブロック内のメンバーと同じ名前である。</p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="n">Vertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Position</span><span class="p">;</span><span class="w">  </span><span class="c1">// API transform/feedback will use &quot;Vertex.Position&quot;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec2</span><span class="w"> </span><span class="n">Texture</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Coords</span><span class="p">;</span><span class="w">           </span><span class="c1">// shader will use &quot;Coords.Position&quot;</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="n">Vertex2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w">     </span><span class="c1">// API will use &quot;Color&quot;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Color2</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// in same program as Vertex2 above:</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="n">Vertex3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Intensity</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w">     </span><span class="c1">// ERROR, name collision with Color in Vertex2</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">Color2</span><span class="p">;</span><span class="w">       </span><span class="c1">// ERROR, collides with Color2 in Vertex2</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>配列として宣言されたブロックでは、メンバーにアクセスする際に配列のインデックスも含める必要がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// API uses &quot;Transform[2]&quot; to refer to instance 2</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat4</span><span class="w"> </span><span class="n">ModelViewMatrix</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat4</span><span class="w"> </span><span class="n">ModelViewProjectionMatrix</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">a</span><span class="p">[];</span><span class="w"> </span><span class="c1">// array will get implicitly sized</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Deformation</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">transforms</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="p">...</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">ModelViewMatrix</span><span class="p">;</span><span class="w"> </span><span class="c1">// shader access of instance 2</span><span class="w"></span>
<span class="c1">// API uses &quot;Transform.ModelViewMatrix&quot; to query an offset or other query</span><span class="w"></span>
<span class="n">transforms</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="c1">// same length for &#39;a&#39; for all x</span><span class="w"></span>
<span class="n">Transform</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w">             </span><span class="c1">// illegal, must use &#39;transforms&#39;</span><span class="w"></span>
<span class="n">Transform</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w">     </span><span class="c1">// illegal, must use &#39;transforms&#39;</span><span class="w"></span>
<span class="p">...</span><span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]...</span><span class="w">  </span><span class="c1">// if these are the only two dereferences of &#39;a&#39;,</span><span class="w"></span>
<span class="p">...</span><span class="n">transforms</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]...</span><span class="w">  </span><span class="c1">// then &#39;a&#39; must be size 8, for all</span><span class="w"></span>
<span class="n">transforms</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>配列として宣言された一様ブロックやシェーダー格納ブロックでは、個々の配列要素が、ブロックのインスタンス一つを back する、個別のバッファーオブジェクトの結合範囲に対応する。配列のサイズは必要なバッファーオブジェクトの数を示すため、一様ブロックやシェーダー格納ブロックの配列宣言では、配列のサイズを指定する必要がある。一様ブロックやシェーダー格納ブロックの配列は、動的一様な整数式でしかインデックスを付けることができず、それ以外の場合は結果が未定義だ。</p>
<p>OpenGL API の入場点を使用してブロックの配列内の個々のブロックの名前を特定する場合、
<code class="docutils literal notranslate"><span class="pre">Transform[2]</span></code> のようにして、名前の文字列に配列のインデックスを含めることができる。
OpenGL API の入場点を使用してブロックメンバーのオフセットやその他の性質を参照する場合、
<code class="docutils literal notranslate"><span class="pre">Transform.ModelViewMatrix</span></code> のように、配列インデックスを抜かなければならない。</p>
<p>細分化制御、細分化評価、幾何シェーダー入力ブロックは、配列として宣言されなければならず、それぞれの段階のシェーダー入力すべては配列宣言とリンク規則に従わなければならない。その他のすべての入出力ブロックの配列は、配列サイズを指定しなければならない。</p>
<p>段階ごとに使用できる一様ブロックの個数とシェーダー格納ブロックの個数は、実装依存の制限がある。いずれかの制限を超えた場合、リンクエラーとなる。</p>
</section>
</section>
<section id="layout-qualifiers">
<h3><a class="toc-backref" href="#id32">4.4. Layout Qualifiers</a><a class="headerlink" href="#layout-qualifiers" title="Permalink to this heading">¶</a></h3>
<p>レイアウト修飾子は宣言形式がいくつかある。前節の文法で示したように、インターフェイスブロックの定義やブロックメンバーの一部として現れることがある。一つの <em>layout-qualifier</em> だけで、その修飾子を使った他の宣言のレイアウトを設定することもできる。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> <em>interface-qualifier</em> ;</div>
</div>
<p>また、インターフェイス修飾子で宣言された個別の変数で出現することもある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> <em>interface-qualifier</em> <em>declaration</em> ;</div>
</div>
<p>レイアウトの宣言は、大域スコープまたはブロックメンバーでしか行えず、以下の節で示される場所でしか行えない。</p>
<p>レイアウト修飾子は次のように展開する：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">layout</span> <span class="pre">(</span></code> <em>layout-qualifier-id-list</em> <code class="docutils literal notranslate"><span class="pre">)</span></code></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-id-list</em> :</div>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em></div>
<div class="line"><em>layout-qualifier-id</em> , <em>layout-qualifier-id-list</em></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>layout-qualifier-name</em></div>
<div class="line"><em>layout-qualifier-name</em> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">shared</span></code></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-value</em> :</div>
<div class="line-block">
<div class="line"><em>integer-constant-expression</em></div>
</div>
</div>
<p><em>layout-qualifier-name</em> に使用されるトークンは、キーワードではなく識別子で、
<em>layout-qualifier-id</em> としてキーワード <strong>shared</strong> を使用することができる。一般的に、これらはどのような順序でも並べてよい。順序に依存する意味は、下で明示されている場合に限り存在する。同様に、これらの識別子は、明示的に別段の記載がない限り、大文字と小文字を区別しない。</p>
<p>単一の宣言にレイアウト修飾子を複数含めることができる。また、同じ <em>layout-qualifier-name</em> が、一つのレイアウト修飾子の中で複数回現れたり、同じ宣言の中で複数のレイアウト修飾子にまたがって現れたりすることがある。同じ <em>layout-qualifier-name</em> が単一の宣言の中で複数回出現する場合、最後に出現したものがそれ以前に出現したものよりも優先される。さらに、このような <em>layout-qualifier-name</em> が後続の宣言やその他の観察可能な挙動に影響する場合、影響を与えるのは最後に出現するものだけであり、以前に出現したものは存在しないかのように振る舞う。これは <em>layout-qualifier-name</em> を上書きする場合にも当てはまり、一方が他方を上書き場合 (e.g. <code class="docutils literal notranslate"><span class="pre">row_major</span></code> vs. <code class="docutils literal notranslate"><span class="pre">column_major</span></code>) には、最後に出現するものだけが影響を及ぼす。</p>
<p><em>integer-constant-expression</em> は <a class="reference internal" href="#constant-expressions"><span class="std std-ref">4.3.3. Constant Expressions</span></a> で
<em>constant integral expression</em> として定義されており、
<em>integer-constant-expression</em> が特殊化定数であることはコンパイルエラーになる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>仕様書本文ではレイアウト修飾子の使用法の概要が表になって掲載されている。巨大なデータなので引用は控える。</p>
</div>
<section id="input-layout-qualifiers">
<h4><a class="toc-backref" href="#id33">4.4.1. Input Layout Qualifiers</a><a class="headerlink" href="#input-layout-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>計算シェーダーを除くすべてのシェーダーでは、入力変数宣言、入力ブロック宣言、入力ブロックメンバー宣言に対してレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">location</span></code> を使うことができる。このうち、変数とブロックメンバー（ブロックは不可）には、さらにレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> が使用できる。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">component</span></code> = <em>layout-qualifier-value</em></div>
</div>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>これにより、シェーダー入力の <code class="docutils literal notranslate"><span class="pre">normal</span></code> はベクトル位置番号 3 に、
<code class="docutils literal notranslate"><span class="pre">v</span></code> は位置番号 8 に割り当てられる。頂点シェーダー入力の場合、位置を入力値を取得する頂点属性の番号で指定する。他のすべてのシェーダー型の入力では、そのシェーダーが別のプログラムオブジェクト内にあったとしても、位置を以前のシェーダー段階からの出力との照合に使用できるベクトル番号で指定する。</p>
<p>続く言語では、特定の型で消費される位置の数を記述する。ただし、幾何シェーダー入力、細分化制御シェーダー入出力、細分化評価入力はすべて、他のシェーダー入出力に対して追加の配列レベルを持っている。この外側の配列レベルは、型が消費する位置の数を考慮する前に、型から取り除かれる。</p>
<p>Vulkan を対象にしている場合を除き、頂点シェーダー入力が任意のスカラーまたはベクトル型である場合、位置を一つを消費する。非頂点シェーダーの入力や Vulkan を対象にしている場合の段階入力が
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 以外のスカラー型やベクトル型の場合は、位置を一つを消費するが、
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 型の場合は連続した二つの位置を消費する。
<code class="docutils literal notranslate"><span class="pre">double</span></code> 型や <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> 型の入力は、段階すべてで一つの位置しか消費しない。</p>
<p>上述のように外側の配列レベルを削除した後、宣言された入力がサイズ n の配列で、各要素が m 個の位置を取る場合、指定された位置から始まる m × n 個の連続した位置が割り当てられる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>これにより、シェーダーの入力色がベクトルの位置番号 6, 7, 8 に割り当てられることが確定する。</p>
<p>宣言された入力が n × m 行列の場合は、指定された位置から始まる複数の位置が割り当てられる。各行列に割り当てられる位置の数は、m 成分のベクトルの n 要素の配列と同じになる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>これにより、シェーダー入力 <code class="docutils literal notranslate"><span class="pre">transforms</span></code> がベクトルの 9～16番に割り当てられる：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transforms[0]</span></code> が 9, 10, 11, 12 番に、</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">transforms[1]</span></code> が 13, 14, 15, 16 番に</p></li>
</ul>
<p>割り当てられる。</p>
<hr class="docutils" />
<p>宣言された入力が構造体やブロックの場合、そのメンバーには宣言順に連続した位置が割り当てられ、最初のメンバーにはレイアウト修飾子で指定された位置が割り当てられる。構造体の場合、この処理は構造体全体に適用される。
<code class="docutils literal notranslate"><span class="pre">layout</span></code> 修飾子を構造体のメンバーに使用するとコンパイルエラーとなる。ブロックの場合、この処理はブロック全体に適用される。つまり <code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子を持つ最初のメンバーに到達するまで適用される。</p>
<p>ブロックのメンバーが <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子付きで宣言されている場合、そのメンバーの位置はその修飾子に由来し、メンバーの <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子がブロックレベルの宣言よりも優先される。後続のメンバーには、次の <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子が宣言されたメンバーまで、最新の位置に基づいて連続した位置が再び割り当てられる。位置に使用される値は、昇順に宣言する必要はない。</p>
<p>ブロックレベルの <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子がないブロックでは、そのメンバーのすべてが <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子を持つか、またはそれを一つも持たないことが要求される。さもないとコンパイルエラーとなる。配列として宣言されたブロックには <code class="docutils literal notranslate"><span class="pre">location</span></code> がブロックレベルでしか適用できないものがある。ブロックが配列として宣言されていて、ブロックの配列要素ごとに各メンバーに追加の位置が必要な場合、ブロックのメンバーに位置を指定するとコンパイルエラーになる。つまり、ブロックメンバー上に位置を適用することで指定不足になる場合、それは認められない。配列されたインターフェイス（一般にインターフェイスの拡張により余計な配列を持つもの）では、この規則を適用する前に外側の配列が取り除かれる。</p>
<p>ブロックや構造体のメンバーが消費する位置は、構造体のメンバーが同じ型の入力変数として宣言されているかのように、上記の規則を再帰的に適用して決定される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">S</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">                      </span><span class="c1">// gets location 3</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat2</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">                      </span><span class="c1">// gets locations 4 and 5</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">                   </span><span class="c1">// gets locations 6 and 7</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR, can&#39;t use on struct member</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">block</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">                      </span><span class="c1">// gets location 4</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w">                      </span><span class="c1">// gets location 5</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="c1">// gets location 7</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w">                      </span><span class="c1">// gets location 8</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w"> </span><span class="c1">// gets location 1</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">                      </span><span class="c1">// gets location 2</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">                      </span><span class="c1">// gets location 3</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w">                      </span><span class="c1">// ERROR, location 4 already used</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>シェーダーが利用できる入力位置の数には制限がある。頂点シェーダーでは、その制限は公示された頂点属性の数だ。その他のシェーダーでは、制限は実装に依存し、公示された最大入力成分数の
1/4 以上でなければならない。</p>
<p>取り付けられたシェーダーが対処されている個数を超える位置を使用している場合、デバイス依存最適化がプログラムに利用可能なハードウェア資源内に収まるようにさせない限り、プログラムはリンクに失敗する。</p>
<p>明示的な位置割り当てにより、リンカーが他の明示的割り当てのない変数のための空間を見つけられない場合、プログラムはリンクに失敗する。</p>
<p>非頂点入力が以前のシェーダー段階の出力と一致するかどうかを判断するためには、
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子がもしあれば一致していなければならない。</p>
<p>シェーダーテキストに位置が割り当てられていない頂点シェーダー入力変数に
OpenGL API で指定された位置がある場合は、その指定位置が使用される。そうでなければ、そのような変数はリンカーによって場所が割り当てられる。入力変数が同じ言語の複数のシェーダーで宣言されていて、位置が競合している場合、リンクエラー。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> を使用すると、スカラーやベクトルの位置をより細かく指定することができ、消費される位置内の個々の成分まで指定することができる修飾子 <code class="docutils literal notranslate"><span class="pre">location</span></code> を指定せずに <code class="docutils literal notranslate"><span class="pre">component</span></code> を使用すると、コンパイルエラーになる（順序は重要でない）。位置内の成分は 0, 1, 2, 3 だ。成分 N で始まる変数やブロックメンバーは、そのサイズまでの成分 N, N+1, N+2, …を消費する。この成分の並びが 3 より大きくなると、コンパイルエラーになる。スカラー <code class="docutils literal notranslate"><span class="pre">double</span></code> はこれらの成分のうち二つを消費し、
<code class="docutils literal notranslate"><span class="pre">dvec2</span></code> はある位置で利用可能な四つの成分全てを消費する。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> は成分指定なしでしか宣言できない。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> は一つ目の位置の四つの成分と、二つ目の位置の成分 0 と 1 をすべて消費する。これにより、成分 2 と 3 は他の成分修飾された宣言に使用できる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// a consumes components 2 and 3 of location 4</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>

<span class="c1">// b consumes component 1 of location 4</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>

<span class="c1">// ERROR: c overflows component 3</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>

<span class="c1">// d consumes components 2 and 3 of location 5</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>

<span class="c1">// ERROR: e overflows component 3 of location 6</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">dvec2</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>

<span class="c1">// ERROR: f overlaps with g</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w"></span>

<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">dvec3</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w"> </span><span class="c1">// components 0,1,2 and 3 of location 8</span><span class="w"></span>
<span class="w">                                 </span><span class="c1">// and components 0 and 1 of location 9</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// okay, compts 2 and 3</span><span class="w"></span>
</pre></div>
</div>
<p>変数が配列の場合、配列の各要素は順番に連続した位置に割り当てられるが、各位置の中ですべて同じ指定された成分になる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// component 3 in 6 locations are consumed</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>この場合、位置 2 の成分 3 は <code class="docutils literal notranslate"><span class="pre">d[0]</span></code> を、位置 3 の成分 3 は <code class="docutils literal notranslate"><span class="pre">d[1]</span></code> を、…位置 7 の成分 3 に <code class="docutils literal notranslate"><span class="pre">d[5]</span></code> を格納する。</p>
<p>これにより二つの配列を同じ位置にまとめることができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// e consumes beginning (components 0, 1 and 2) of each of 6 slots</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">e</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>

<span class="c1">// f consumes last component of the same 6 slots</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>これを配列の配列に適用する場合は、すべてのレベルの配列性が取り除かれ、指定された成分に位置ごとに割り当てられた要素になる。これらの非配列要素は <a class="reference internal" href="#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> が指定する順序で配列の配列に対する位置を埋める。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> を行列、構造体、ブロック、またはこれらを含む配列に適用するとコンパイルエラーになる。
<code class="docutils literal notranslate"><span class="pre">component</span></code> 1 または 3 を <code class="docutils literal notranslate"><span class="pre">double</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> の先頭に使用するとコンパイルエラーになる。プログラム内で同じ変数に異なる成分を指定すると、リンクエラーになる。</p>
<hr class="docutils" />
<p><strong>位置エイリアシング</strong> (location aliasing) とは、二つの変数やブロックメンバーに同じ位置番号を持たせることだ。
<strong>成分エイリアシング</strong> (component aliasing) とは、二つの位置エイリアスに同じ（つまり重複する）成分番号を割り当てることだ（
<code class="docutils literal notranslate"><span class="pre">component</span></code> を使用しない場合は 0 から始まる成分が割り当てられることを思い出せ）。一つの例外を除いて、位置エイリアシングは成分エイリアシングを起こさない場合に限り許される。さらに、位置エイリアシングを行う場合、その位置を共有するエイリアスは、内在する数値型とビット幅が同じでなければならず、補助格納修飾子と補間修飾子も同じでなければならない。成分エイリアシングが許可される例外とは、頂点シェーダーへの二つの入力変数（ブロックメンバーではない）に対して OpenGL を対象にする場合で、これらは成分エイリアシングが許されている。この頂点変数の成分エイリアシングは、各実行パスがエイリアシングされた各成分ごとに高々一つの入力にアクセスする頂点シェーダーを対処することしか目的としていない。頂点シェーダー実行形式を通るすべての実行パスが、任意の単一成分にエイリアスされた複数の入力にアクセスすることを検出した場合、実装はこれをリンクタイムエラーとすることが許されているが、必須ではない。</p>
<section id="tessellation-evaluation-inputs">
<h5><a class="toc-backref" href="#id34">Tessellation Evaluation Inputs</a><a class="headerlink" href="#tessellation-evaluation-inputs" title="Permalink to this heading">¶</a></h5>
<p>細分化評価シェーダーで使える追加的な入力レイアウト修飾子の識別子は次の通り：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>primitive-mode</em></div>
<div class="line"><em>vertex-spacing</em></div>
<div class="line"><em>ordering</em></div>
<div class="line"><em>point-mode</em></div>
</div>
</div>
<p>識別子 <em>primitive-mode</em> は細分化基本形状生成器が使用する。</p>
<div class="line-block">
<div class="line"><em>primitive-mode</em>:</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">quads</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">isolines</span></code></div>
</div>
</div>
<p><em>primitive-mode</em> がもしあれば、細分化基本形状生成器は三角形をより小さな三角形に、四角形を三角形に、四角形を線の集合体にそれぞれ細分するべきだと指定する。</p>
<p>レイアウト識別子の二番目のグループである頂点間隔は、細分化基本形状生成器が辺を細分化する際の間隔を指定するために用いられる。</p>
<div class="line-block">
<div class="line"><em>vertex-spacing</em>:</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">equal_spacing</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">fractional_even_spacing</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">fractional_odd_spacing</span></code></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">equal_spacing</span></code> は辺を同じ大きさのセグメントの集まりに分割することを指定する。</p>
<p><code class="docutils literal notranslate"><span class="pre">fractional_even_spacing</span></code> は、辺を偶数個の同じ長さのセグメントとさらに二つのより短い「小数」のセグメントに分割することを指定する。</p>
<p><code class="docutils literal notranslate"><span class="pre">fractional_odd_spacing</span></code> は、辺を奇数個の同じ長さのセグメントとさらに二つのより短い「小数」セグメントに分割することを指定する。</p>
<p>三番目のレイアウト識別子である <em>ordering</em> は、細分化基本形状生成器が、
OpenGL 仕様にある座標系に従い、時計回りまたは反時計回りのどちらの順序で三角形を生成するのかを指定する。</p>
<div class="line-block">
<div class="line"><em>ordering</em>:</div>
<div class="line-block">
<div class="line">cw</div>
<div class="line">ccw</div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">cw</span></code> と <code class="docutils literal notranslate"><span class="pre">ccw</span></code> は、それぞれ時計回りと反時計回りの三角形を示す。細分化基本形状生成器が三角形を生成しない場合、この順序は無視される。</p>
<p>最後の <em>point-mode</em> は、細分化基本形状生成器が、線や三角形を生成するのではなく、細分化された基本形状のそれぞれの紛れのない頂点に対して一点を生成するべきであることを示す。</p>
<div class="line-block">
<div class="line"><em>point-mode</em>:</div>
<div class="line-block">
<div class="line">point_mode</div>
</div>
</div>
<hr class="docutils" />
<p>これらの識別子は、単一の入力レイアウト宣言の中で、一回またはそれ以上指定することができる。プログラムの細分化評価シェーダーの中で、
<em>primitive-mode</em>, <em>vertex-spacing</em>, <em>ordering</em> が複数回宣言されている場合、そのような宣言はすべて同じ識別子を使用しなければならない。</p>
<p>プログラム内の少なくとも一つの細分化評価シェーダー（コンパイル単位）は、その入力レイアウトで <em>primitive-mode</em> を宣言しなければならない。
<em>vertex-spacing</em>, <em>ordering</em>, <em>point_mode</em> 識別子の宣言はオプションだ。プログラム内の細分化評価シェーダーすべてが <em>primitive_mode</em> を宣言するということは必須ではない。
<em>vertex-spacing</em> や <em>ordering</em> の宣言が省略された場合、細分化基本形状生成器は、それぞれ等間隔または反時計回りの頂点順序を採用する。
<em>point-mode</em> の宣言が省略された場合、細分化基本形状生成器は、
<em>primitive-mode</em> に従って線分または三角形を生成する。</p>
</section>
<section id="geometry-shader-inputs">
<h5><a class="toc-backref" href="#id35">Geometry Shader Inputs</a><a class="headerlink" href="#geometry-shader-inputs" title="Permalink to this heading">¶</a></h5>
<p>幾何シェーダー入力に対する追加のレイアウト修飾子識別子には、基本形状 (primitive) 識別子と呼び出し回数 (invocation count) 識別子がある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">points</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">lines</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">invocations</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">points</span></code>, <code class="docutils literal notranslate"><span class="pre">lines</span></code>, <code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code>, <code class="docutils literal notranslate"><span class="pre">triangles</span></code>, <code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code>
は、幾何シェーダーが受け付ける入力基本形状の種類を指定するためのもので、これらのうちただ一つを受け付ける。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、この入力基本形状のレイアウトを宣言しなければならず、プログラム内の幾何シェーダーすべての入力レイアウト宣言は同じレイアウトを宣言しなければならない。プログラム内のすべての幾何シェーダーが入力基本形状レイアウトを宣言することは必須ではない。</p>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">invocations</span></code> は、受けとった入力基本形状それぞれに対して幾何シェーダー実行形式が呼び出される回数を指定するために用いられる。回数の宣言はオプションだ。プログラム内のどの幾何シェーダーでも回数が宣言されていない場合、幾何シェーダーは入力基本形状それぞれに対して一度実行される。宣言されている場合は、すべての宣言で同じ回数を指定しなければならない。シェーダーが実装依存の最大値を超える呼び出し回数を指定したり、ゼロ以下の呼び出し回数を指定したりすると、コンパイルエラーとなる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span><span class="w"> </span><span class="n">invocations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>例えば上の宣言では、幾何シェーダーへの入力はすべて三角形であり、幾何シェーダーの実行形式は、処理される三角形ごとに 6 回実行される。</p>
<p>幾何シェーダー入力サイズなし配列宣言のすべてで、以前の入力基本形状レイアウト修飾子がある場合、サイズが変更される：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">points</span></code>: 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lines</span></code>: 2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code>: 4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangles</span></code>: 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code>: 6</p></li>
</ul>
<p>内在的に宣言された入力配列 <code class="docutils literal notranslate"><span class="pre">gl_in[]</span></code> は、任意の入力基本形状レイアウト宣言によってもサイズが決定される。そのため、式 <code class="docutils literal notranslate"><span class="pre">gl_in.length()</span></code> 式は上にある値を返す。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_in</span></code> などの内在的に宣言された入力、配列サイズを持たずに宣言された入力については、メソッド <code class="docutils literal notranslate"><span class="pre">length()</span></code> を使用する前か、配列サイズを知る必要のあるその他の配列使用の前にレイアウトを宣言しなければならない。</p>
<p>レイアウト宣言の配列サイズが、同じシェーダー内の入力変数の宣言で指定されている明示的な配列サイズすべてと一致しない場合はコンパイルエラーとなる。コンパイルエラーの例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// code sequence within one shader...</span><span class="w"></span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color1</span><span class="p">[];</span><span class="w">     </span><span class="c1">// legal, size still unknown</span><span class="w"></span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">    </span><span class="c1">// legal, size is 2</span><span class="w"></span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w">    </span><span class="c1">// illegal, input sizes are inconsistent</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w">     </span><span class="c1">// legal for Color2, input size is 2, matching Color2</span><span class="w"></span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">Color4</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w">    </span><span class="c1">// illegal, contradicts layout of lines</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w">     </span><span class="c1">// legal, matches other layout() declaration</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w"> </span><span class="c1">// illegal, does not match earlier layout() declaration</span><span class="w"></span>
</pre></div>
</div>
<p>プログラム内の幾何シェーダーすべてにおいて、提供されたサイズのすべて（サイズ付き入力配列とレイアウトサイズ）が一致しない場合は、リンクエラーとなる。</p>
</section>
<section id="fragment-shader-inputs">
<h5><a class="toc-backref" href="#id36">Fragment Shader Inputs</a><a class="headerlink" href="#fragment-shader-inputs" title="Permalink to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> には以下のような追加的断片レイアウト修飾子がある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code></div>
</div>
</div>
<p>OpenGL の <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> は既定ではウィンドウの座標は左下を原点とし、画素中心は半画素の座標にあるとしている。例えば、ウィンドウの左下端の画素に対しては <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> 座標 <code class="docutils literal notranslate"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></code> が返される。原点は <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> に <code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code> 修飾子を付けて再宣言することで変更することができ、
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の原点をウィンドウの左上に移動させ、
<code class="docutils literal notranslate"><span class="pre">y</span></code> はウィンドウの下に向かって値を大きくしていく。また、返される値は、<code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> によって、
<code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> の両方で半画素ずつずらすことができ、画素が整数のオフセットで中心に置かれているように見える。これは <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> で返される <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> の値が既定値が <code class="docutils literal notranslate"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></code> であるのに対し、
<code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> で <code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.0)</span></code> に移動する。</p>
<p>Vulkan を対象にする場合、<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の原点は左上で、画素中心は半画素座標に配置されていると仮定し、要求される。この原点を明示的に設定するには <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を <code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code>
識別子で再宣言する。</p>
<p>再宣言は次のように行う：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FragCoord</span><span class="p">;</span><span class="w"> </span><span class="c1">// redeclaration that changes nothing is allowed</span><span class="w"></span>

<span class="c1">// All the following are allowed redeclaration that change behavior</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">origin_upper_left</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FragCoord</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">pixel_center_integer</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FragCoord</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">origin_upper_left</span><span class="p">,</span><span class="w"> </span><span class="n">pixel_center_integer</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FragCoord</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> がプログラム内のいずれかの断片シェーダーで再宣言された場合、そのプログラム内で <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を静的に使用しているすべての断片シェーダーで再宣言されなければならない。単一のプログラム内にある断片シェーダーすべてにおける <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code>
の再宣言はすべてが同じ修飾子の集合でなければならない。どのシェーダー内でも <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の最初の再宣言が
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> のどの使用の前にも現れなければならない。組み込み <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> は断片シェーダーでしか事前に宣言されていないので、他のシェーダー言語で再宣言するとコンパイルエラーになる。</p>
<p><code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> 修飾子の両方とも、またはいずれか一方をつけて <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を再宣言しても
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord.x</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_FragCoord.y</span></code> にしか影響しない。ラスタライズ、座標変換、その他の API パイプラインや言語機能には影響しない。</p>
<p>断片シェーダーでは、OpenGL 仕様書の 15.2.4 “Early Fragment Tests” に記載されているように、断片シェーダーの実行前に断片検定を行うことを要求するために、
<code class="docutils literal notranslate"><span class="pre">in</span></code> のみで次のレイアウト修飾子を使用することが許される（変数宣言では不可）：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line">early_fragment_tests</div>
</div>
</div>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">early_fragment_tests</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>例えば上の宣言では、断片シェーダーの実行前に断片ごとの検定が行われるようになる。これを宣言しない場合は、断片シェーダーの実行後に断片ごとの検定が行われる。この宣言が必要となるのは、一つの断片シェーダー（コンパイル単位）だけだが、複数の断片シェーダーが宣言することもできる。少なくとも一つがこれを宣言していれば有効になる。</p>
</section>
<section id="compute-shader-inputs">
<h5><a class="toc-backref" href="#id37">Compute Shader Inputs</a><a class="headerlink" href="#compute-shader-inputs" title="Permalink to this heading">¶</a></h5>
<p>計算シェーダー入力にはレイアウト位置修飾子がない。</p>
<p>計算シェーダー入力に対するレイアウト修飾子の識別子は、作業グループサイズ修飾子だ：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_x</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_y</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">local_size_x</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_y</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> 各修飾子は、それぞれ 1, 2, 3 次元の計算シェーダーによる固定作業グループのサイズを宣言するために用いられる。シェーダーが次元のサイズをここから指定していない場合、その次元は 1 となる。</p>
<p>例えば、計算シェーダーで次のように宣言した場合、</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">local_size_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>作業グループサイズが 32×32 要素の二次元計算シェーダーを宣言するために用いられる。これは、3次元目のサイズが 1 である三次元計算シェーダーに相当する。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>上の一文は何を言っているのか。</p>
</div>
<p>もう一つ別の例として、次の宣言は、一次元の計算シェーダーがコンパイルされており、そのサイズが実質的には 8 要素であることを指定している：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>いずれかの次元におけるシェーダーの固定作業グループサイズがゼロ以下、または実装で対処される最大サイズよりも大きい場合、コンパイルエラー。また、このようなレイアウト修飾子が同一シェーダー内で複数回宣言されている場合、それらの宣言はすべて同じ作業グループサイズの集合を設定し、同じ値を設定しなければならない。さもなければコンパイルエラー。単一のプログラムオブジェクトに取り付けられた複数の計算シェーダーが固定作業グループサイズを宣言する場合、その宣言は同一でなければならない。さもなければリンクエラー。</p>
<p>さらに、プログラムオブジェクトが計算シェーダーを何か含む場合、少なくとも一つはプログラムの固定作業グループサイズを指定する入力レイアウト修飾子を含まなければならない。さもなければリンクエラー。</p>
</section>
</section>
<section id="output-layout-qualifiers">
<h4><a class="toc-backref" href="#id38">4.4.2. Output Layout Qualifiers</a><a class="headerlink" href="#output-layout-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>出力レイアウト修飾子には、シェーダー段階すべてに適用されるものと、特定の段階にしか適用されないものがある。ここでは前者を議論する。</p>
<p>入力レイアウト修飾子と同様に、計算シェーダーを除くすべてのシェーダーでは、出力変数宣言、出力ブロック宣言、出力ブロックメンバー宣言に対して <code class="docutils literal notranslate"><span class="pre">location</span></code>
レイアウト修飾子を許す。このうち、変数とブロックメンバー（ブロックは不可）には、さらに <code class="docutils literal notranslate"><span class="pre">component</span></code> レイアウト修飾子を許す。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">component</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>ブロックや構造体に <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子や <code class="docutils literal notranslate"><span class="pre">component</span></code> 修飾子を適用する際の使い方や規則は <a class="reference internal" href="#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a> のとおりだ。また、断片シェーダーの出力では、二つの変数が同じ位置に配置される場合、それらの変数の内容される型は同じでなければならない（浮動小数点・整数）。出力変数やメンバーの成分エイリアスは許されない。</p>
<p>断片シェーダーでは <code class="docutils literal notranslate"><span class="pre">index</span></code> 出力レイアウト修飾子を追加的に付けられる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">index</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらの修飾子は、それぞれ高々一度現れる。
<code class="docutils literal notranslate"><span class="pre">index</span></code> が指定された場合 <code class="docutils literal notranslate"><span class="pre">location</span></code> も指定しなければならない。
<code class="docutils literal notranslate"><span class="pre">index</span></code> が指定されていない場合は値 0 が使用される。</p>
<p>例えば次の断片シェーダーでは、断片シェーダー出力色を混合方程式の最初（インデックス 0）の入力として断片カラー 3 に割り当てる設定をする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>次の例は、断片シェーダーの出力係数が、混合方程式の 2 番目（インデックス 1）の入力として断片色 3 に割り当てる設定をする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">factor</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>断片シェーダーの出力では、位置とインデックスは、出力の値を受け取る色出力番号とインデックスを指定する。他のすべてのシェーダー段階の出力では、位置は、後続のシェーダー段階の入力と照合するために使用できるベクトル番号を指定する（シェーダーが別のプログラムオブジェクトにある場合も同様）。</p>
<p>宣言された出力が <code class="docutils literal notranslate"><span class="pre">dvec3</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 以外のスカラーまたはベクトル型である場合は、単一の位置を消費する。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 型の出力は連続した二つの場所を消費する。
<code class="docutils literal notranslate"><span class="pre">double</span></code> 型や <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> 型の出力は全ての段階で一つの位置しか消費しない。</p>
<p>宣言された出力が配列の場合は、指定された場所から連続した場所が割り当てられる。例えば、次の宣言ではベクトルの位置番号 2, 3, 4 に <code class="docutils literal notranslate"><span class="pre">colors</span></code> が割り当てられる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>宣言された出力が n×m の行列の場合、指定された位置から始まる複数の位置が割り当てられる。割り当てられる場所の数は m 成分ベクトルの n 要素の配列と同じだ。</p>
<p>宣言された出力が構造体の場合、そのメンバーには宣言された順に連続した場所が割り当てられ、構造体に指定された場所が最初のメンバーに割り当てられる。構造体のメンバーが消費する位置の個数は、その構造体のメンバーが同じ型の出力変数として宣言されているかのように、前述の規則が再帰的に適用される。</p>
<p><code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子は、構造体として宣言された出力変数に使用することができる。ただし、構造体メンバーに <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子を使用するとコンパイルエラーとなる。
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子は出力ブロックと出力ブロックメンバーに使用できる。</p>
<p>シェーダーで使用できる出力位置の数は限界がある。断片シェーダーでは、その限界は公表されたドローバッファー数だ。</p>
<p>その他のシェーダーの場合、制限は実装依存であり、公表されている最大出力成分数の
1/4 以上でなければならない（計算シェーダーには出力がない）。取り付けられたシェーダーが対処されている個数以上の位置を使用している場合、デバイス依存最適化によってプログラムが利用可能なハードウェア資源内に収まるようにしない限り、プログラムはリンクに失敗する。</p>
<p>また、コンパイル時にリンクが失敗することがわかっている場合には、コンパイルエラーがあり得る。出力位置が負の場合は、コンパイルエラーになる。断片シェーダーがレイアウトインデックスを 0 未満または 1 以上に設定した場合も、コンパイルエラーとなる。</p>
<p>次のいずれかが発生すると、コンパイルエラーまたはリンクエラー：</p>
<ul class="simple">
<li><p>断片シェーダーの出力変数の二つが両者とも同じ位置とインデックスに割り当てられている。</p></li>
<li><p>同じ（頂点｜細分化｜幾何）シェーダー段階からの出力変数二つが同じ位置に割り当てられている。</p></li>
</ul>
<p>断片シェーダー出力では <code class="docutils literal notranslate"><span class="pre">layout</span></code> 修飾子または OpenGL API を使用して位置を割り当てることができる。</p>
<p>すべてのシェーダー型において、明示的な位置の割り当てが明示的な割り当てのない他の変数のための空間をリンカーに見つけさせられなくなる場合、プログラムはリンクに失敗する。</p>
<p>シェーダーテキストで位置やインデックスが割り当てられていない出力変数が
OpenGL API を通じて位置を指定されている場合は API で指定された位置が採用される。それ以外の場合は、リンカーがそのような変数に場所を割り当てる。このような割り当てはすべて、色インデックスがゼロになる。詳細は、OpenGL 仕様書の 15.2 “Shader Execution” を参照。出力変数が同じ言語の複数のシェーダで宣言されており、位置やインデックスの値が衝突している場合、リンクエラーが発生する。</p>
<p>断片ではない出力が後続のあるシェーダー段階からの入力と一致するかどうかを判定するために、
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子が（もしあれば）一致しなければならない。</p>
<section id="transform-feedback-layout-qualifiers">
<h5><a class="toc-backref" href="#id39">Transform Feedback Layout Qualifiers</a><a class="headerlink" href="#transform-feedback-layout-qualifiers" title="Permalink to this heading">¶</a></h5>
<p>頂点、細分化、幾何各段階では、シェーダーが変換反響を制御することができる。それをするときに、シェーダーはどの変換反響バッファーを使用するか、どの出力変数をどのバッファーに書き込むか、各バッファーをどのようにレイアウトするかを決定する。これを実現するために、シェーダでは出力宣言に次のレイアウト修飾子識別子を使用できる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらの <code class="docutils literal notranslate"><span class="pre">xfb_</span></code> 修飾子を（前処理後に）静的に使用するシェーダーは、変換反響捕捉モードとなり、変換反響の設定を記述する責任が生じる。このモードでは <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で選択された出力を、直接または間接的に、変換反響バッファーに取り込むことになる。</p>
<p>Shaders in the transform feedback capturing mode have an initial global default of
<code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で選択された出力をどの変換反響バッファーに取り込むかは
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子が指定する。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子、出力変数、出力ブロック、出力ブロックメンバーのどれにでも適用できる。変換反響捕捉モードのシェーダーには次の初期の大域既定がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>この既定を変更するには、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> に <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> をつけて別のバッファーを宣言する。これが大域既定を変更する唯一の方法だ。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子を付けずに変数や出力ブロックを宣言した場合は、大域既定バッファーを継承する。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子をつけて変数や出力ブロックを宣言すると、その宣言されたバッファーを持る。あるブロックのメンバーすべてがそのブロックのバッファーを継承する。メンバーは <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> を宣言することができるが、そのバッファーはそのブロックから継承されたバッファーと一致しなければならない。そうでなければコンパイルエラー。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">xfb_offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// block&#39;s buffer is 2</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="c1">// okay, matches the inherited 2</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR, mismatched buffer</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">w</span><span class="p">;</span><span class="w"> </span><span class="c1">// inherited</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">  </span><span class="c1">// initial default is buffer 0</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w">          </span><span class="c1">// new global default of 1</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="p">{</span><span class="w">                        </span><span class="c1">// block has buffer 1</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">                        </span><span class="c1">// x has buffer 1 (not captured)</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// okay (not captured)</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR, mismatched buffer</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w">   </span><span class="c1">// g has buffer 1</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w">   </span><span class="c1">// does not change global default</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">  </span><span class="c1">// j has buffer 1</span><span class="w"></span>
</pre></div>
</div>
<p>これが意味するのは、ブロックのメンバーのうち、変換反響バッファーに行くものはすべて同じバッファーに行くということだ。</p>
<p>ブロックが配列として宣言されている場合、ブロックの配列要素 0 のメンバーすべては、前述のように、宣言または継承された <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> に取り込まれる。一般に、ブロックの大きさ N の配列は、N 個の連続したバッファに取り込まれ、ブロックの配列要素 E のメンバーすべては、バッファ B に取り込まれる。ここで、B は宣言または継承された <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> に E を加えたものに等しくなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> には、ブロックの配列を捕捉するために必要な追加のバッファーを含めて、
0 より小さいか、実装依存の定数 <code class="docutils literal notranslate"><span class="pre">gl_MaxTransformFeedbackBuffers</span></code> 以上の値を指定すると、コンパイルエラーかリンクエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> は、変換反響バッファー内のバイトオフセットを割り当てる。
<code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> をつけることができるのは、変数、ブロックメンバー、またはブロックしかない。ブロックが <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾されていれば、そのブロックのメンバーすべてに変換反響バッファー内のオフセットが割り当てられる。ブロックが <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾されていない場合、そのようなブロックのメンバーには変換反響バッファーのオフセットは割り当てられない。オフセットが割り当てられた変数やブロックメンバーだけが捕捉される（つまり、ブロックの適切な部分集合が捕捉される）。このような変数やブロックメンバーがシェーダー内で書き込まれるたびに、書き込まれた値は割り当てられたオフセットで捕捉される。シェーダーの呼び出し時の間にこのようなブロックメンバーや変数が書き込まれない場合、割り当てられたオフセットでのバッファーの内容は未定義となる。変換反響オフセットが割り当てられている変数やメンバーへの静的な書き込みがない場合でも、その空間はバッファーに割り当てられ、ストライドに影響を与える。</p>
<p><code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾された変数やブロックメンバーには、スカラー、ベクトル、行列、構造体、およびこれらの（サイズ付き）配列を指定できる。このオフセットは、最初に修飾された変数やブロックメンバーの第一成分のサイズの倍数でなければならない。そうでなければコンパイルエラー。さらに、 <code class="docutils literal notranslate"><span class="pre">double</span></code> を含む集合体に適用される場合、オフセットもバッファーに取られる空間も 8 の倍数でなければならない。与えられたオフセットは、修飾されたエンティティの最初のメンバーの最初の成分に適用される。その後、修飾された実体中で、後続の成分はそれぞれその成分のサイズの倍数に整列した、次に利用可能なオフセットに順に割り当てられる。集約型は成分レベルまで平坦化され、この成分の並びが得られる。サイズなし配列の宣言に <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を適用するとコンパイルエラー。</p>
<p>出力バッファーのエイリアシングは許されない。変換反響オフセットが重なり合っている変数を指定するとコンパイルエラーまたはリンクエラー。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> は、捕捉した各頂点が何バイト消費するかを指定する。その宣言の変換反響バッファーが継承されているか、明示的に宣言されているかに関わらず、これが適用される。この修飾子は、変数、ブロック、ブロックメンバー、あるいは単に修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> にも適用できる。バッファーが倍精度成分を持つ出力を捕捉する場合、バッファー幅は 8 の倍数であるか、そうでない場合は 4 の倍数でなければならず、そうでない場合はコンパイルエラーかリンクエラー。
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> をオーバーフローさせるような <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を持つことは、
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> の前後の宣言であろうと、異なるコンパイル単位であろうと、コンパイルエラーかリンクエラー。
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> は、同じバッファーに対して複数回宣言することができるが、異なる値のストライドを指定するとコンパイルエラーかリンクエラー。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// buffer 1 has 32-byte stride</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">xfb_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w"></span>

<span class="c1">// same as previous example; order within layout does not matter</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w"></span>

<span class="c1">// everything in this block goes to buffer 0</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="n">xfb_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">block1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">  </span><span class="c1">// a goes to byte offset 0 of buffer 0</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// b goes to offset 16 of buffer 0</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">block2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w">  </span><span class="c1">// v will be written to byte offsets 12 through 27 of buffer</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"> </span><span class="c1">// u will be written to offset 28</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">w</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// x will be written to offset 56, the next available offset</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">xfb_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">block3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR, requires stride of 36</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w">  </span><span class="c1">// okay, increasing order not required</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>バッファーに <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> が指定されていない場合、バッファー幅は、最も高いオフセットに置かれた変数を保持するのに必要な最小値となり、必要な詰め物 (padding) も含まれる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// if there no other declarations for buffer 3, it has stride 32</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">block4</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>結果のバッファー幅（暗黙的または明示的）を 4 で割って、実装依存の定数 <code class="docutils literal notranslate"><span class="pre">gl_MaxTransformFeedbackInterleavedComponents</span></code> 以下でなければならない。</p>
</section>
<section id="tessellation-control-outputs">
<h5><a class="toc-backref" href="#id40">Tessellation Control Outputs</a><a class="headerlink" href="#tessellation-control-outputs" title="Permalink to this heading">¶</a></h5>
<p>変換反響レイアウト修飾子を除き、細分化制御シェーダーでは、出力ブロック、ブロックメンバー、または変数宣言ではなく、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> 上でのみ出力レイアウト修飾子を使用することができる。細分化制御シェーダーで使用できる出力レイアウト修飾子の識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">vertices</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">vertices</span></code> は細分化制御シェーダーが生成する出力パッチの頂点数を指定し、細分化制御シェーダーの呼び出し回数も指定します。出力頂点数がゼロ以下であったり、実装依存の最大パッチサイズより大きかったりすると、コンパイルエラーやリンクエラーとなる。</p>
<p>内在的に宣言された細分化制御出力配列 <code class="docutils literal notranslate"><span class="pre">gl_out[]</span></code> は、任意の出力レイアウト宣言によってもサイズが決定される。したがって、次の式は以前の出力レイアウト修飾子で指定された出力パッチの頂点数を返す：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="nb">gl_out</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>内在的に宣言された出力を含む、配列サイズなし宣言された出力については、メソッド <code class="docutils literal notranslate"><span class="pre">length()</span></code> の使用や、サイズを知る必要のある他の配列使用の前に、レイアウトを宣言しなければならない。</p>
<p>出力レイアウト修飾子で指定された出力パッチ頂点数が、同じシェーダー内の出力変数宣言で指定された配列サイズのどれとも一致しない場合は、コンパイルエラーとなる。</p>
<p>プログラム内のすべての細分化制御シェーダーのレイアウト宣言は、同じ出力パッチ頂点数を指定しなければならない。細分化制御シェーダーを含むプログラムには、出力パッチの頂点数を指定するレイアウト修飾子が少なくとも一つ必要だが、すべての細分化制御シェーダーでそのような宣言が必要ということではない。</p>
</section>
<section id="geometry-outputs">
<h5><a class="toc-backref" href="#id41">Geometry Outputs</a><a class="headerlink" href="#geometry-outputs" title="Permalink to this heading">¶</a></h5>
<p>幾何シェーダーは、出力基本形状型、最大出力頂点数、出力ごとのストリーム番号の三種の出力レイアウト識別子を追加的に持てる。基本形状型と頂点数の識別子は、出力ブロック、ブロックメンバー、変数宣言ではなく、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code>
でしか許されない。ストリーム識別子は、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code>,
出力ブロック、変数宣言上で許される。</p>
<p>幾何シェーダー出力に対するレイアウト修飾子の識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">points</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">line_strip</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangle_strip</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">stream</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>基本形状型識別子の <code class="docutils literal notranslate"><span class="pre">points</span></code>, <code class="docutils literal notranslate"><span class="pre">line_strip</span></code>, <code class="docutils literal notranslate"><span class="pre">triangle_strip</span></code> は、幾何シェーダーが生成する出力基本形状の型を指定するために使用され、これらのうちただ一つが受け入れられる。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、出力基本形状型を宣言しなければならず、プログラム内のすべての幾何シェーダーの出力基本形状型宣言は、同じ基本形状型を宣言しなければならない。プログラム内のすべての幾何シェーダーが出力基本形状型宣言をすることは必須ではない。</p>
<p>頂点数識別子 <code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> は、シェーダーが単一の呼び出しで出力する最大の頂点数を指定するために使用される。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、最大出力頂点数を宣言しなければならず、プログラム内のすべての幾何シェーダーの出力頂点数宣言は、同じ回数を宣言しなければならない。プログラム内のすべての幾何シェーダーが回数を宣言することは必須ではありません。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span><span class="w"> </span><span class="n">max_vertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">60</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w"> </span><span class="c1">// order does not matter</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">max_vertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">60</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w">  </span><span class="c1">// redeclaration okay</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">triangle_strip</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w">     </span><span class="c1">// redeclaration okay</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w">             </span><span class="c1">// error, contradicts triangle_strip</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">max_vertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w">  </span><span class="c1">// error, contradicts 60</span><span class="w"></span>
</pre></div>
</div>
<p>この例では、幾何シェーダーからの出力はすべて三角形であって、シェーダーから出力されるのは高々 60 個の頂点だ。最大の頂点数が <code class="docutils literal notranslate"><span class="pre">gl_MaxGeometryOutputVertices</span></code> よりも大きい場合はエラーとなる。</p>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">stream</span></code> は、幾何シェーダーの出力変数またはブロックが、特定の頂点ストリーム（ゼロから始まる番号）に関連付けられていることを指定するために用いられる。ストリーム番号の既定値を、次の例のようにインターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> によって大域スコープで宣言することができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>このような宣言で指定されたストリーム番号は、それまでの既定値を置き換え、新しい既定値が設定されるまで、後続のすべてのブロックおよび変数の宣言に適用される。初期設定のストリーム番号はゼロだ。</p>
<p>各出力ブロックまたは非ブロック出力変数は、頂点ストリームに関連付けられる。ブロックまたは変数がストリーム識別子とともに宣言されている場合は、指定されたストリームに関連付けられ、そうでない場合は、現在の既定ストリームに関連付けられる。ブロックメンバーはストリーム識別子を付けて宣言することができるが、指定されたストリームは含まれるブロックに関連付けられたそれと一致しなければならない。例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w">           </span><span class="c1">// default is now stream 1</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">var1</span><span class="p">;</span><span class="w">                  </span><span class="c1">// var1 gets default stream (1)</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">Block1</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// &quot;Block1&quot; belongs to stream 2</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">var2</span><span class="p">;</span><span class="w"> </span><span class="c1">// redundant block member stream decl</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">var3</span><span class="p">;</span><span class="w"> </span><span class="c1">// ILLEGAL (must match block stream)</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">var4</span><span class="p">;</span><span class="w">                  </span><span class="c1">// belongs to stream 2</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="p">;</span><span class="w">           </span><span class="c1">// default is now stream 0</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">var5</span><span class="p">;</span><span class="w">                  </span><span class="c1">// var5 gets default stream (0)</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="n">Block2</span><span class="w"> </span><span class="p">{</span><span class="w">                    </span><span class="c1">// &quot;Block2&quot; gets default stream (0)</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">var6</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">var7</span><span class="p">;</span><span class="w"> </span><span class="c1">// var7 belongs to stream 3</span><span class="w"></span>
</pre></div>
</div>
<p>幾何シェーダーで出力された各頂点は、特定のストリームに割り当てられ、出力された頂点の属性は、対象となるストリームに割り当てられた出力ブロックと変数の集合から取得される。各頂点が放出された後、すべての出力変数の値は未定義となる。さらに、各頂点ストリームに関連する出力変数は、格納を共有してもよい。あるストリームに関連する出力変数に書き込むと、他のストリームに関連する出力変数が上書きされることがある。幾何シェーダーは、各頂点を放出する際に、その頂点が放出されるストリームに関連するすべての出力に書き込み、他のストリームに関連する出力には書き込まない。</p>
<p>幾何シェーダー出力ブロックや同変数が複数回宣言された場合、そのような宣言のすべてで、その変数は同じ頂点ストリームに関連付けられなければならない。存在しないストリーム番号を指定したストリーム宣言がある場合、シェーダーのコンパイルは失敗する。</p>
<p>組み込み幾何シェーダー出力は頂点ストリーム 0 に常に関連付けられる。</p>
<p>プログラム内のすべての幾何シェーダー出力レイアウト宣言は、同じレイアウトと同じ <code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> 値を宣言しなければならない。幾何シェーダーがプログラムに含まれている場合、そのプログラムのどこかに少なくとも一つの幾何出力レイアウト宣言がなければならないが、すべての幾何シェーダー（コンパイル単位）がそれを宣言する必要はない。</p>
</section>
<section id="fragment-outputs">
<h5><a class="toc-backref" href="#id42">Fragment Outputs</a><a class="headerlink" href="#fragment-outputs" title="Permalink to this heading">¶</a></h5>
<p>組み込み断片シェーダ変数 <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> は、次のレイアウト修飾子のいずれかを使用して再宣言することができる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_any</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_greater</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_less</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_unchanged</span></code></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> に対するレイアウト修飾子は、任意のシェーダー呼び出しによって書き込まれる
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値の意図を制約する。レイアウト修飾子に整合する <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のすべての値が不合格・合格する場合には、与えられた断片に対して奥行き検定が不合格・合格すると仮定して最適化を行うことが GL 実装はできる。これには、断片がさえぎられ、シェーダーに副作用がないために廃棄される場合に、シェーダーの実行を飛ばすことが含まれる可能性がある。
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値がそのレイアウト修飾子と整合しない場合、対応する断片の奥行き検定の結果は未定義となる。しかし、この場合にはエラーとはならない。奥行き検定が合格し、奥行き書き込みが有効な場合、奥行きバッファーに書き込まれる値は、レイアウト修飾子と整合しているか否かに関わらず、常に <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の値となる。</p>
<p>既定では <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> は <code class="docutils literal notranslate"><span class="pre">depth_any</span></code> として修飾される。
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のレイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_any</span></code> の場合、シェーダーコンパイラーは <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> への割り当てが未知の方法で変更されていることに留意し、奥行き検定は常にシェーダーの実行後に行われる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_greater</span></code> の場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値が <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の <code class="docutils literal notranslate"><span class="pre">z</span></code> 成分で与えられる断片の補間奥行き値以上であると仮定することができる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_less</span></code> の場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> を修正してもその値が減少するだけだと考えることができる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_unchanged</span></code> の場合、シェーダーコンパイラーは
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のいかなる修正も尊重するが、他の部分は <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code>
に新しい値が割り当てられていないと仮定することができる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の再宣言は以下のように行われる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// redeclaration that changes nothing is allowed +</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_FragDepth</span><span class="p">;</span><span class="w"></span>

<span class="c1">// assume it may be modified in any way</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_any</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_FragDepth</span><span class="p">;</span><span class="w"></span>

<span class="c1">// assume it may be modified such that its value will only increase</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_greater</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_FragDepth</span><span class="p">;</span><span class="w"></span>

<span class="c1">// assume it may be modified such that its value will only decrease</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_less</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_FragDepth</span><span class="p">;</span><span class="w"></span>

<span class="c1">// assume it will not be modified</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_unchanged</span><span class="p">)</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nb">gl_FragDepth</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> がプログラム内のいずれかの断片シェーダーで再宣言された場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> への静的割り当てを持つそのプログラム内の断片シェーダーすべてで再宣言されなければならない。単一プログラム内の断片シェーダーすべてにおける
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の再宣言のすべてが同じ修飾子の集合を持たなければならない。どのシェーダー内でも、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最初の再宣言がその使用よりも前に現れなければならない。組み込み <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> は断片シェーダーでのみ事前宣言されているので、他のシェーダー言語で再宣言するとコンパイルエラーになる。</p>
</section>
</section>
<section id="uniform-variable-layout-qualifiers">
<h4><a class="toc-backref" href="#id43">4.4.3. Uniform Variable Layout Qualifiers</a><a class="headerlink" href="#uniform-variable-layout-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>レイアウト修飾子は、一様変数とサブルーチン一様に使用できる。一様変数とサブルーチン一様（変数）に対するレイアウト修飾子識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>位置識別子は、既定ブロック一様変数とサブルーチン一様（変数）で使用できる。位置は、API が一様を参照し、その値を更新するための位置を指定する。一様配列の個々の要素には連続した位置が割り当てられ、最初の要素は位置 <code class="docutils literal notranslate"><span class="pre">location</span></code> だ。プログラム内でリンクされた同じ位置を共有する既定ブロック一様変数宣言は、名前、型、修飾子、配列性が一致しなければならない。配列の場合は、配列の次元と配列のサイズが一致していなければならない。構造体の場合、この規則がメンバーすべてに再帰的に適用される。サブルーチン一様変数二つが同じシェーダー段階内で同じ位置に存在することはできない。コンパイルエラーかリンクエラーとなる。既定ブロック変数の有効な位置は、0 から実装定義の一様位置の最大数から 1 を引いた範囲にある。サブルーチン一様（変数）の有効な位置は、0 から実装定義の段階ごとのサブルーチン一様（変数）の最大位置数から 1 を引いた値までの範囲にある。</p>
<p>位置は既定ブロック一様配列や構造体に割り当てることができる。最も内側にある最初のスカラー、ベクトル、行列のメンバーや要素は指定された <code class="docutils literal notranslate"><span class="pre">location</span></code> を取り、コンパイラーは次の最も内側にあるメンバーや要素に次の増分の位置値を割り当てる。それ以降の最内側のメンバーや要素は、構造体や配列全体の増分の位置を取得します。この規則は、入れ子になった構造体や配列にも適用され、最も内側にあるスカラー、ベクトル、行列の各メンバーに一意の位置を与える。明示的サイズのない配列の場合は、静的な使用量に基づいてサイズが計算される。リンカーが明示的位置のない一様（変数）の位置を生成する場合、明示的位置のある一様（変数）すべてについて、その配列要素や構造体のメンバーがすべて使用されていると仮定し、その要素やメンバーが使用されていないと判断された場合でも、リンカーは競合する位置を生成しない。</p>
<p>個々の（既定ブロック）透明一様変数を受け入れる API に対する SPIR-V を生成するとき、それらを宣言するときに位置を含めないとコンパイルエラー。</p>
<p>Vulkan を対象にしている場合、修飾子 <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> はブロック全体を宣言するために使用され、
Vulkan API で定義されているように、定数 <code class="docutils literal notranslate"><span class="pre">push</span></code> の集合を表す。これを一様ブロック宣言以外に適用したり、Vulkan を対象にしていない場合はコンパイルエラー。ブロック内の値は Vulkan API の仕様に基づいて初期化される。
<code class="docutils literal notranslate"><span class="pre">layout(push_constant)</span></code> で宣言されたブロックは、オプションで <em>instance-name</em> を含めることができる。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> ブロックは段階ごとに一つだけで、そうでない場合はコンパイルエラーやリンクエラー。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> 配列は、動的一様なインデックスでしかインデックスを付けられない。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> で宣言された一様ブロックは、宣言されていないブロックとは異なる資源を使用し、別々に計上される。</p>
</section>
<section id="subroutine-function-layout-qualifiers">
<h4><a class="toc-backref" href="#id44">4.4.4. Subroutine Function Layout Qualifiers</a><a class="headerlink" href="#subroutine-function-layout-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>レイアウト修飾子をサブルーチン関数に使用できる。サブルーチン関数のレイアウト修飾子識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">index</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>シェーダー内でインデックス修飾子を持つ各サブルーチンには、一意のインデックスが与えられなければならない。そうでない場合はコンパイルエラーまたはリンクエラー。インデックスは 0 から実装定義のサブルーチン最大数から 1 を引いた範囲でなければならない。
OpenGL サブルーチン関数列挙 API がアクティブインデックスすべてに対して空ではない名前を返すように、シェーダーは 0 から始まる飛び飛びにならないインデックス値の範囲を割り当てることを推奨するが、必須ではない。</p>
</section>
<section id="uniform-and-shader-storage-block-layout-qualifiers">
<h4><a class="toc-backref" href="#id45">4.4.5. Uniform and Shader Storage Block Layout Qualifiers</a><a class="headerlink" href="#uniform-and-shader-storage-block-layout-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>レイアウト修飾子は一様およびシェーダー格納ブロックに使用できるが、非ブロック一様宣言には使用できない。一様およびシェーダー格納ブロックのレイアウト修飾子の識別子（および <code class="docutils literal notranslate"><span class="pre">shared</span></code>
キーワード）は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">shared</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">packed</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">std140</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">std430</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">row_major</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">column_major</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">offset</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">align</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらはいずれも、宣言されている変数の使用法に意味的な影響を全く与えず、メモリー内でのデータの配置方法を示すに過ぎない。例えば、行列のセマンティクスは、どのようなレイアウト修飾子が使用されていても、この仕様の他の部分で述べられたように、常に列に基づく。</p>
<p>（一様｜シェーダー格納）ブロックレイアウト修飾子は、大域スコープ、単一の（一様｜シェーダー格納ブロック｜ブロックメンバー）宣言上で宣言することができる。</p>
<p>一様ブロックには大域スコープでの既定レイアウトが次のように設定されている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">layout</span><span class="o">-</span><span class="n">qualifier</span><span class="o">-</span><span class="n">id</span><span class="o">-</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>シェーダー格納ブロックの場合には：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">layout</span><span class="o">-</span><span class="n">qualifier</span><span class="o">-</span><span class="n">id</span><span class="o">-</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>これが行われると、直前の既定修飾がまず継承され、それから宣言にある各修飾について、以下に述べる上書き規則に従って上書きされる。その結果、後続の（一様｜シェーダー格納）ブロックの定義に適用される新しい既定修飾となる。</p>
<p>SPIR-V を生成する際のコンパイルの初期状態は、次のように宣言されたかのようなものだ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">,</span><span class="w"> </span><span class="n">column_major</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">std430</span><span class="p">,</span><span class="w"> </span><span class="n">column_major</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>ところが <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> を宣言すると、バッファーの既定レイアウトは
<code class="docutils literal notranslate"><span class="pre">std430</span></code> になる。この既定を大域的に設定する方法はない。</p>
<p>SPIR-V を生成していないときのコンパイルの初期状態は、次のように宣言されたかのようなものだ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span><span class="w"> </span><span class="n">column_major</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span><span class="w"> </span><span class="n">column_major</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>（一様｜シェーダー格納）ブロックは、オプションでレイアウト修飾子を付けて宣言することができ、その個々のメンバー宣言も同様だ。このようなブロックレイアウト修飾は、ブロックの内容にのみ適用される。大域レイアウト宣言と同様に、ブロックレイアウト修飾は、まず現在の既定の修飾を継承し、次にそれを上書きする。同様に、個々のメンバーのレイアウト修飾は、メンバー宣言だけに適用され、ブロックの修飾を継承して上書きする。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">shared</span></code> は <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>, および <code class="docutils literal notranslate"><span class="pre">packed</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。コンパイラーかリンカーは、すべての配列が明示的なサイズで宣言され、すべての行列が一致する <code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子と
<code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子の両方を、または一方を（ブロック定義外の宣言から得られる場合もある）持つ限り、この定義を含む複数のプログラムおよびプログラム可能段階が、このブロックのために同じメモリーレイアウトを共有することを保証する。これにより、異なるプログラム間で同じバッファーを使用して同じブロック定義を
back することができる。
SPIR-Vを生成する際に <code class="docutils literal notranslate"><span class="pre">shared</span></code> を使用するとコンパイルエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">packed</span></code> は <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code> のみを上書きし、その他の修飾子は継承される。
<code class="docutils literal notranslate"><span class="pre">packed</span></code> を使用した場合、共有可能なレイアウトは保証されません。コンパイラーとリンカーは、どの変数が活発的に使用されるかや、その他の条件に基づいて、メモリー使用を最適化することができる。ブロック内のどこにどの変数があるかを保証する方法が他にないため、オフセットを問い合わせる必要がある。</p>
<p>プログラム内の複数の段階で同じ充満一様ブロックやシェーダー格納ブロックにアクセスするとリンクエラー。プログラム間で同じ充満一様ブロックやシェーダー格納ブロックにアクセスしようとすると、メンバーオフセットが衝突したり、未定義の値が読み込まれたりする可能性がある。しかし、実装では充満ブロックのための標準的なレイアウトを使用することで、充満ブロックのアプリケーション管理を支援することができる。
SPIR-V の生成時に <code class="docutils literal notranslate"><span class="pre">packed</span></code> 修飾子を使用するとコンパイルエラー。</p>
<p><code class="docutils literal notranslate"><span class="pre">std140</span></code> および <code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">packed</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">std140</span></code>,
<code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。
<code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子はシェーダー格納ブロックでのみ対処されている。一様ブロックに <code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子を使用したシェーダーは、それが <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> も修飾されていない限りコンパイルエラー。</p>
<p>OpenGL 仕様書の 7.6.2.2 “Standard Uniform Block Layout” に記載されているように、レイアウトはこれによって明示的に決定される。したがって、上記の <code class="docutils literal notranslate"><span class="pre">shared</span></code> と同様に、結果となるレイアウトはプログラムをまたがって共有可能だ。</p>
<p>メンバー宣言のレイアウト修飾子には <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">packed</span></code>, <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>
の各修飾子は使用できない。これらの修飾子は、（オブジェクトなし）大域スコープまたはブロック宣言でのみ使用でき、使用しない場合はコンパイルエラー。</p>
<p><code class="docutils literal notranslate"><span class="pre">row_major</span></code> および <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子は、構造体や配列に含まれるすべての行列を含むすべての入れ子の深さの行列のレイアウトにしか影響を与えない。これらの修飾子は他の型にも適用できるが、効果はない。</p>
<p><code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。行列の行内の要素は、メモリー内で連続している。</p>
<p><code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子よりも優先されるが、その他の修飾子は継承される。行列の列内の要素は、メモリー内で連続しています。</p>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子は（一様｜シェーダ格納）ブロックに対応する一様バッファー束縛点を指定し、ブロックのメンバー変数の値を取得するのに使用される。大域スコープやブロックメンバーの宣言に束縛修飾子を指定することはコンパイルエラーとなる。
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子を指定せずに宣言された（一様｜シェーダー格納）ブロックは、最初はブロック束縛点 0 に割り当てられる。プログラムがリンクされた後、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子の有無にかかわらず宣言された（一様｜シェーダー格納）ブロックに使用される束縛点は API によって更新することができる。</p>
<p>OpenGL で使用する場合、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が配列としてインスタンス化された一様ブロックやシェーダー格納ブロックで使用されると、配列の最初の要素は指定されたブロック束縛を取り、それ以降の各要素は次の連続した束縛点を取る。配列の配列では、要素それぞれ（例えば <code class="docutils literal notranslate"><span class="pre">a[2][3]</span></code> の場合は 6 要素）が束縛点を得て、
<a class="reference internal" href="#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> で説明した配列の配列の順序に従って順序付けられる。</p>
<p>Vulkan を対象にした場合、配列としてインスタンス化された一様ブロックやバッファーブロックで <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が使用されると、配列全体が提供された束縛番号のみを受け取る。次の連続した束縛番号を別のオブジェクトで利用できる。配列の配列の場合、記述子集合アクセスに使用される記述子集合配列要素の番号は、
<a class="reference internal" href="#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> で説明した配列の配列の順序に従って順序付けられる。</p>
<p>（一様｜シェーダー格納）ブロックインスタンスの束縛点がゼロより小さい場合、または対応する実装依存のバッファー束縛の最大数以上の場合は、コンパイルエラーとなる。（一様｜シェーダー格納）ブロックのインスタンスをサイズ N の配列として <code class="docutils literal notranslate"><span class="pre">binding</span></code>
修飾子を使用する場合、
<em>binding</em> から <em>binding</em> + N - 1 までの配列のすべての要素は、この範囲内に収まらなければならない。同じ束縛番号を複数の一様ブロックや複数のバッファーブロックに使用するとコンパイルエラーまたはリンクエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">set</span></code> は Vulkan を対象にしている場合に限り使用できる。このオブジェクトが属する記述子集合を指定する。独立した修飾子、ブロックメンバー、または記述子集合を対処する API を対象にしていない場合に <code class="docutils literal notranslate"><span class="pre">set</span></code> を適用するとコンパイルエラー。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> 修飾されたブロックに <code class="docutils literal notranslate"><span class="pre">set</span></code> を適用するとコンパイルエラー。既定では <code class="docutils literal notranslate"><span class="pre">set</span></code> 識別子なしで宣言された非 <code class="docutils literal notranslate"><span class="pre">push-constant</span></code>
（一様｜シェーダー格納）ブロックは、記述子集合 0 に割り当てられる。同様に、
<code class="docutils literal notranslate"><span class="pre">set</span></code> 識別子なしで一様として宣言された採取器、テクスチャー、またはサブパス入力型も、記述子集合 0 に割り当てられる。</p>
<p>配列として宣言されたオブジェクトに適用された場合、その配列のすべての要素は、指定された <code class="docutils literal notranslate"><span class="pre">set</span></code> に属する。</p>
<p>SPIR-V を生成する際に <code class="docutils literal notranslate"><span class="pre">set</span></code> または <code class="docutils literal notranslate"><span class="pre">binding</span></code> の値がフロントエンド構成で指定された最大値を超えるとコンパイルエラーとなる。</p>
<p>一つのレイアウト宣言に複数の引数がリストされている場合、左から右の順に一つずつ宣言されたのと同じ効果が得られる。それぞれが前の修飾の結果を引き継いで上書きする。例えば、次の例は <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾になる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">row_major</span><span class="p">,</span><span class="w"> </span><span class="n">column_major</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>さらなる例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span><span class="w"> </span><span class="n">row_major</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="p">;</span><span class="w"> </span><span class="c1">// default is now shared and row_major</span><span class="w"></span>

<span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// layout of this block is std140</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat4</span><span class="w"> </span><span class="n">M1</span><span class="p">;</span><span class="w">                       </span><span class="c1">// row major</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">column_major</span><span class="p">)</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">M2</span><span class="p">;</span><span class="w">  </span><span class="c1">// column major</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat3</span><span class="w"> </span><span class="n">N1</span><span class="p">;</span><span class="w">                       </span><span class="c1">// row major</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">uniform</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="p">{</span><span class="w">                       </span><span class="c1">// layout of this block is shared</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">layout</span><span class="p">(</span><span class="n">column_major</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">T3</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// shared and column major</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat4</span><span class="w"> </span><span class="n">M3</span><span class="p">;</span><span class="w">                       </span><span class="c1">// column major</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">row_major</span><span class="p">)</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">m4</span><span class="p">;</span><span class="w">     </span><span class="c1">// row major</span><span class="w"></span>
<span class="w">    </span><span class="kt">mat3</span><span class="w"> </span><span class="n">N2</span><span class="p">;</span><span class="w">                       </span><span class="c1">// column major</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>Vulkan を対象にしている場合、ブロックおよびブロックメンバーの
<code class="docutils literal notranslate"><span class="pre">offset</span></code> および <code class="docutils literal notranslate"><span class="pre">align</span></code> 修飾子は、一様ブロックおよびバッファーブロックに限り使用できる。
Vulkan を対象にしていない場合、これらの修飾子は <code class="docutils literal notranslate"><span class="pre">std140</span></code> または <code class="docutils literal notranslate"><span class="pre">std430</span></code>
レイアウトで宣言されたブロックに限り使用できる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">offset</span></code> はブロックメンバーに限り使用できる。修飾子 <code class="docutils literal notranslate"><span class="pre">offset</span></code> は、修飾されたメンバーを指定された <em>layout-qualifier-value</em>
（バッファーの先頭からのバイトオフセット）以降に強制的に開始させる。ブロックの他のメンバー内にあるオフセットを明示的または代入的に持たせるとコンパイルエラーとなる。
SPIR-V を生成しない場合、ブロック内の直前のメンバーのオフセットよりも小さいオフセットを指定するとコンパイルエラーとなる。同じプログラム内で同じブロック名でリンクされた二つのブロックは、
<code class="docutils literal notranslate"><span class="pre">offset</span></code> で修飾されたメンバーの集合が全く同じであり、それらの <em>layout-qualifier-value</em> の値が同じでなければならず、そうでなければリンクエラーとなる。指定されたオフセットは、それが修飾するブロックメンバーの型の
base alignment の倍数でなければならず、そうでなければコンパイルエラーになる。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">align</span></code> は、各ブロックメンバーの開始点を最小の byte alignment にする。各メンバー内の内部レイアウトには影響を与えず、
<code class="docutils literal notranslate"><span class="pre">std140</span></code> または <code class="docutils literal notranslate"><span class="pre">std430</span></code> の規則に従う。指定された alignment は 0 よりも大きく、かつ 2 のべき乗でなければならず、そうでない場合はコンパイルエラー。</p>
<p>メンバーの実際の alignment は、指定された <code class="docutils literal notranslate"><span class="pre">align</span></code> alignmentと、そのメンバーの型の標準（<code class="docutils literal notranslate"><span class="pre">std140</span></code> など）base alignment のうち大きい方になる。メンバーの実際のオフセットは次のように計算される：
<code class="docutils literal notranslate"><span class="pre">offset</span></code> が宣言されている場合は、そのオフセットから開始し、そうでない場合は、宣言順で先行メンバーの直後のオフセットから開始する。結果オフセットが実際の alignment の倍数でない場合は、実際の alignment の倍数である最初のオフセットまで増やす。これにより、メンバーの実際のオフセットが得られる。</p>
<p><code class="docutils literal notranslate"><span class="pre">align</span></code> が配列に適用された場合、配列の開始点のみに影響し、配列の内部幅には影響しない。宣言では <code class="docutils literal notranslate"><span class="pre">offset</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">align</span></code> 修飾子の両方を指定できる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">align</span></code> は、ブロックで使用された場合、ブロックで宣言されたのと同じ
<code class="docutils literal notranslate"><span class="pre">align</span></code> 値で各メンバーを修飾するのと同じ効果があり、これが行われた場合と同じコンパイル結果とコンパイルエラーが得られる。前述のように、個々のメンバーは独自の <code class="docutils literal notranslate"><span class="pre">align</span></code> を指定することができ、それはブロックレベルの <code class="docutils literal notranslate"><span class="pre">align</span></code> よりも優先されるが、そのメンバーに限られる。</p>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">                         </span><span class="c1">// a takes offsets 0-15</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">     </span><span class="c1">// b takes offsets 32-43</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">     </span><span class="c1">// ERROR, lies within previous member</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">48</span><span class="p">)</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">     </span><span class="c1">// d takes offsets 48-55</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w">     </span><span class="c1">// e takes offsets 64-67</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w">     </span><span class="c1">// f takes offsets 72-79</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w">     </span><span class="c1">// ERROR, 6 is not a power of 2</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">80</span><span class="p">)</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w">    </span><span class="c1">// h takes offsets 80-83</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="kt">dvec3</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">     </span><span class="c1">// i takes offsets 128-151</span><span class="w"></span>
<span class="w">    </span><span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">164</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">                        </span><span class="c1">// j takes offsets 168-171</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="opaque-uniform-layout-qualifiers">
<h4><a class="toc-backref" href="#id46">4.4.6. Opaque Uniform Layout Qualifiers</a><a class="headerlink" href="#opaque-uniform-layout-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>不透明な一様変数は、結合のために一様レイアウト修飾子を取ることができます。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子は、その変数が束縛される点を指定する。
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子なしで宣言された不透明変数は、既定束縛 0 になる。</p>
<p>OpenGL で使用する場合、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が配列とともに使用されると、配列の最初の要素は指定された束縛点を取り、それ以降の各要素は連続した次の束縛点を取る。配列の配列の場合は先程の <code class="docutils literal notranslate"><span class="pre">a[2][3]</span></code> の例を述べた文と同じ。</p>
<p>Vulkan を対象にした場合、配列で <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が使用されると、提供された束縛番号だけを配列全体が取る。次の連続した束縛番号は、別のオブジェクトに利用できる。</p>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> が 0 より小さい場合、または実装依存の対処される束縛点の最大数以上の場合は、コンパイルエラーとなる。サイズ N の配列で <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子を使う場合、番号 <em>binding</em> から番号 <em>binding</em> + N - 1 までの配列のすべての要素は、この範囲内に収まる必要がある。同じ番号 <em>binding</em> を共有する不可分計数器のオフセットがすべて異なっていない限り、複数の不可分計数器に同じ束縛番号を使用すると、コンパイルエラーまたはリンクエラーとなる。</p>
<p>一つのプログラム内のシェーダー二つが同じ <em>opaque-uniform</em> 名に対して異なる
<em>layout-qualifier-value</em> 束縛を指定するとリンクエラーとなる。ただし、次の例のように、同じ名前の宣言の一部に <code class="docutils literal notranslate"><span class="pre">binding</span></code> を指定しても、すべての宣言に <code class="docutils literal notranslate"><span class="pre">binding</span></code> を指定してもエラーではない：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// in one shader...</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// s bound to point 3</span><span class="w"></span>

<span class="c1">// in another shader...</span><span class="w"></span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">                   </span><span class="c1">// okay, s still bound at 3</span><span class="w"></span>

<span class="c1">// in another shader...</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR: contradictory bindings</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="atomic-counter-layout-qualifiers">
<h4><a class="toc-backref" href="#id47">4.4.7. Atomic Counter Layout Qualifiers</a><a class="headerlink" href="#atomic-counter-layout-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>Vulkan を対象にした場合、不可分計数器は使用できない。</p>
<p>不可分計数器のレイアウト修飾子は、その宣言で使用できる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">offset</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>例えば下は、不可分計数器 <code class="docutils literal notranslate"><span class="pre">a</span></code> の不透明ハンドルを、不可分計数器バッファーの束縛点 2 に、そのバッファーの 4 基本マシン単位のオフセットで束縛するように設定する。束縛点 2 の既定オフセットは 4（不可分計数器のサイズ）で後置インクリメントされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>後続の不可分計数器宣言は、直前の（インクリメントされた）オフセットを継承する。例えば次の宣言では、不可分計数器 <code class="docutils literal notranslate"><span class="pre">bar</span></code> がバッファーの束縛点 2 に 8
基本マシン単位のオフセットで束縛されるように設定する。結合点 2 のオフセットは、再び 4 だけ後置インクリメントされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>一つのレイアウト宣言に複数の変数がリストされている場合、左から右の順に一つずつ宣言したのと同じ効果が得られる。</p>
<p>束縛点は継承されず、オフセットのみが継承される。各束縛点では、同じ束縛を使用する後続の変数の継承のために、それ自身の現在の既定オフセットを追跡する。コンパイルの初期状態では、すべての束縛点のオフセットが 0 になる。オフセットは、大域スコープで（変数を宣言せずに）束縛点ごとに設定できる。例えば、以下のようになる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>上記は結合点 2 に対する次の <code class="docutils literal notranslate"><span class="pre">atomic_uint</span></code> 宣言がオフセット 4 を継承するように設定する（ただし、既定束縛は設定しない）。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// offset is 4</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w">  </span><span class="c1">// error, no default binding</span><span class="w"></span>
</pre></div>
</div>
<p>不可分計数器は同じ束縛点を共有することができるが、束縛が共有されている場合、それらのオフセットは、明示的または暗黙的に一意的であり、重なり合わないことが必要だ。</p>
<p>シェーダーの先頭を想定した、有効な一様宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// offset = 4</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">           </span><span class="c1">// offset = 0</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">           </span><span class="c1">// offset = 8</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">atomic_uint</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">           </span><span class="c1">// offset = 4</span><span class="w"></span>
</pre></div>
</div>
<p>無効な一様宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w">               </span><span class="c1">// error, must include binding</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// okay</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// okay</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="c1">// error, offsets must not be shared</span><span class="w"></span>
<span class="w">                                   </span><span class="c1">// between a and c</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"> </span><span class="c1">// error, overlaps offset 0 of a</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_MaxAtomicCounterBindings</span></code> 以上の束縛値で不可分計数器を束縛するとコンパイルエラーになる。サイズなし <code class="docutils literal notranslate"><span class="pre">atomic_uint</span></code> の配列を宣言するとコンパイルエラー。</p>
</section>
<section id="format-layout-qualifiers">
<h4><a class="toc-backref" href="#id48">4.4.8. Format Layout Qualifiers</a><a class="headerlink" href="#format-layout-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>フォーマットレイアウト修飾子は、画像変数の宣言（キーワードに <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> を持つ基本型で宣言されたもの）に使用できる。画像変数宣言のためのフォーマットレイアウト修飾子の識別子は次のとおり（一部略）：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>float-image-format-qualifier</em></div>
<div class="line"><em>int-image-format-qualifier</em></div>
<div class="line"><em>uint-image-format-qualifier</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>float-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32f</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba16f</span></code></div>
<div class="line">(etc.)</div>
<div class="line"><br /></div>
</div>
<div class="line"><em>int-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32i</span></code></div>
<div class="line">(etc.)</div>
<div class="line"><br /></div>
</div>
<div class="line"><em>uint-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32ui</span></code></div>
<div class="line">(etc.)</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">format</span></code> レイアウト修飾子は、宣言された画像変数に関連する画像表現形式を指定する。画像変数宣言一個につき、フォーマット修飾子を一つだけ指定できる。浮動小数点成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> で始まるキーワード）、符号付き整数成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;iimage&quot;</span></code> で始まるキーワード）、または符号なし整数成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;uimage&quot;</span></code> で始まるキーワード）の画像変数では、使用するフォーマット修飾子は、それぞれ
<em>float-image-format-qualifier</em>,
<em>int-image-format-qualifier</em>, <em>uint-image-format-qualifier</em>
文法規則に一致しなければならない。フォーマット修飾子が画像変数の型と一致しない画像変数を宣言するとコンパイルエラーとなる。</p>
<p>画像読み込みや不可分操作に使用される画像変数は、フォーマットレイアウト修飾子を指定しなければならない。フォーマットレイアウト修飾子なしで宣言された画像一様変数や関数引数を画像読み込みや不可分関数に渡すとコンパイルエラーとなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">writeonly</span></code> で修飾されていない一様（変数）はフォーマットレイアウト修飾子を持たなければならない。読み込みアクセスのために関数に渡された画像変数を <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> として宣言することはできないので、フォーマットレイアウト修飾子を付けて宣言しなければならないことに注意を要する。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">binding</span></code> については
<a class="reference internal" href="#opaque-uniform-layout-qualifiers"><span class="std std-ref">4.4.6. Opaque Uniform Layout Qualifiers</span></a> に記述がある。</p>
</section>
<section id="subpass-input-qualifier">
<h4><a class="toc-backref" href="#id49">4.4.9. Subpass Input Qualifier</a><a class="headerlink" href="#subpass-input-qualifier" title="Permalink to this heading">¶</a></h4>
<p>サブパス入力は Vulkan を対象にしている場合に限り利用可能だ。</p>
<p>サブパス入力は、基本 <code class="docutils literal notranslate"><span class="pre">subpassInput</span></code> 型で宣言される。これらはレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> を付けて宣言しないとコンパイルエラー。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">input_attachment_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">subpassInput</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>これはどのサブパスから入力が読み込まれるかを選択する。
<code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> に割り当てられた値、たとえば i とする
(<code class="docutils literal notranslate"><span class="pre">input_attachment_index</span> <span class="pre">=</span> <span class="pre">i</span></code>) と、パスの入力リストの中のその i 番目の登場を選択する。</p>
<p>サイズ N の配列が宣言されている場合は、提供されたものから始まる N 個の連続した
<code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> 値を消費する。</p>
<p>同じ <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> を異なる変数に宣言すると、コンパイルエラーまたはリンクエラーとなる。これには、配列宣言で消費される暗黙の <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> の重複も含まれる。</p>
<p><code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> に割り当てられた値が <code class="docutils literal notranslate"><span class="pre">gl_MaxInputAttachments</span></code>
以上の場合、コンパイルエラーとなる。</p>
</section>
</section>
<section id="interpolation-qualifiers">
<h3><a class="toc-backref" href="#id50">4.5. Interpolation Qualifiers</a><a class="headerlink" href="#interpolation-qualifiers" title="Permalink to this heading">¶</a></h3>
<p>補間される可能性のある入力および出力は、以下の補間修飾子のうち高々一つによってさらに修飾される：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">smooth</span></code></p></td>
<td><p>透視図法的補正補間</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">flat</span></code></p></td>
<td><p>補間なし</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">noperspective</span></code></p></td>
<td><p>線形補間</p></td>
</tr>
</tbody>
</table>
<p>補間の有無と型は上記の補間修飾子と補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code>
によって制御される。補間修飾子がない場合は <code class="docutils literal notranslate"><span class="pre">smooth</span></code> 補間が行われる。複数の補間修飾子を使用するとコンパイルエラーとなる。補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">patch</span></code> は補間には使用されない。補間修飾子を <code class="docutils literal notranslate"><span class="pre">patch</span></code> と共に使用するとコンパイルエラーとなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">flat</span></code> と指定された変数は補間されない。代わりに、基本形状内の断片みんなに対して同じ値を持つ。この値は、API で説明されているように、単一の provoking vertex から得られる。
<code class="docutils literal notranslate"><span class="pre">flat</span></code> と修飾された変数は <code class="docutils literal notranslate"><span class="pre">centroid</span></code> や <code class="docutils literal notranslate"><span class="pre">sample</span></code> と修飾されることもあり、これは <code class="docutils literal notranslate"><span class="pre">flat</span></code> としか修飾されていないのと同じ意味になる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>この provoking vertex とは？</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">smooth</span></code> と修飾された変数は、レンダリングされている基本形状の上に、透視図法的な補正による方法で補間される。遠近法的に正しい方法での補間は、
OpenGL 仕様の式 14.7 および 14.5 “Line Segments” で規定されている。</p>
<p><code class="docutils literal notranslate"><span class="pre">nonperspective</span></code> と修飾された変数は、OpenGL 仕様書 3.5 “Line Segments” の式 3.7 で述べられているに、スクリーン空間内で線形に補間しなければならない。</p>
<p>多重採取ラスタライズが無効の場合、または <code class="docutils literal notranslate"><span class="pre">centroid</span></code> 修飾も <code class="docutils literal notranslate"><span class="pre">sample</span></code> 修飾もない断片シェーダー入力変数の場合、割り当てられた変数の値は、
OpenGL 仕様で許可されている範囲内で、画素内の任意の場所に補間することができ、画素内の各標本に単一の値を割り当てることができる。</p>
<p>多重採取ラスタライズが有効な場合、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code> を使用して、修飾された断片シェーダー入力の採取位置と頻度を制御することができる。断片シェーダー入力が
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> で修飾されている場合、その変数には画素内のすべての標本に対して単一の値を割り当てることができるが、その値は、基本形状で網羅されている画素の標本を含めて、画素とレンダリングされている基本形状の両方に位置する場所で補間されなければならない。変数が補間される位置は隣接する画素で異なる可能性があり、微係数は隣接する画素間の差を計算することで算出されるため、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> 採取された入力の微係数は、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> 以外で補間された変数のそれよりも精度が低い可能性がある。断片シェーダーの入力が <code class="docutils literal notranslate"><span class="pre">sample</span></code> で修飾されている場合、その変数には、画素内の網羅された標本ごとに個別の値が割り当てられなければならず、その値は個々の標本の位置で採取されなければならない。</p>
<p>同一段階内で同じ名前の変数の補間修飾子が一致しないとリンクエラーになる。</p>
<section id="redeclaring-built-in-interpolation-variables-in-the-compatibility-profile">
<h4><a class="toc-backref" href="#id51">4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile</a><a class="headerlink" href="#redeclaring-built-in-interpolation-variables-in-the-compatibility-profile" title="Permalink to this heading">¶</a></h4>
<p>互換性プロファイルを使用する場合、次の宣言済み変数を補間修飾子付きで再宣言できる。</p>
<ul class="simple">
<li><p>頂点、細分化制御、細分化評価、幾何の各言語</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_FrontColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_BackColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_FrontSecondaryColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_BackSecondaryColor</span></code></p></li>
</ul>
</li>
<li><p>断片言語</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_Color</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_SecondaryColor</span></code></p></li>
</ul>
</li>
</ul>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_Color</span><span class="p">;</span><span class="w">            </span><span class="c1">// predeclared by the fragment language</span><span class="w"></span>
<span class="k">flat</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_Color</span><span class="p">;</span><span class="w">       </span><span class="c1">// redeclared by user to be flat</span><span class="w"></span>
<span class="k">flat</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FrontColor</span><span class="p">;</span><span class="w">  </span><span class="c1">// input to geometry shader, no &quot;gl_in[]&quot;</span><span class="w"></span>
<span class="k">flat</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="nb">gl_FrontColor</span><span class="p">;</span><span class="w"> </span><span class="c1">// output from geometry shader</span><span class="w"></span>
</pre></div>
</div>
<p>理想的には、<a class="reference internal" href="note7.html#compatibility-profile-built-in-language-variables"><span class="std std-ref">7.1.7. Compatibility Profile Built-In Language Variables</span></a>
で記述されるように、インターフェイスブロックの再宣言の一部としてこれらを再宣言する。しかし、上記の目的のために、インターフェイスブロックの外部で、大域スコープの個々の変数として再宣言することもできる。このような再宣言をすると、出力変数に変換反響修飾子である
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code>, <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を付けることもできる。</p>
<ul class="simple">
<li><p>変数上の <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> は大域既定バッファーを変化させない。</p></li>
</ul>
<p>シェーダーが、インタフェイスブロックの再宣言と、そのインタフェイスブロックのメンバーの再宣言を、このインタフェースブロックの再宣言の外側で別々に行うと、コンパイルエラーになる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_Color</span></code> が補間修飾子で再宣言された場合、
<code class="docutils literal notranslate"><span class="pre">gl_FrontColor</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_BackColor</span></code> も同じ補間修飾子で再宣言されなければならず、その逆もまた然り。
<code class="docutils literal notranslate"><span class="pre">gl_SecondaryColor</span></code> が補間修飾子付きで再宣言されたならば、
<code class="docutils literal notranslate"><span class="pre">gl_FrontSecondaryColor</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_BackSecondaryColor</span></code> も同じ補間修飾子付きで再宣言されなければならず、その逆もまた然り。このような、宣言済みの変数に対する修飾子の符合判定は、プログラム中のシェーダー内で静的に使用される変数に対してのみ必要だ。</p>
</section>
</section>
<section id="parameter-qualifiers">
<h3><a class="toc-backref" href="#id52">4.6. Parameter Qualifiers</a><a class="headerlink" href="#parameter-qualifiers" title="Permalink to this heading">¶</a></h3>
<p>精度修飾子とメモリー修飾子に加えて、次のパラメータ修飾子を引数に付けることができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>なし（既定）</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span></code> と同じ</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">const</span></code></p></td>
<td><p>書き込めない引数</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">in</span></code></p></td>
<td><p>関数に渡される引数</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">out</span></code></p></td>
<td><p>関数に渡される引数のうち、初期化されていないもの</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">inout</span></code></p></td>
<td><p>関数の中と外の両方に渡される引数</p></td>
</tr>
</tbody>
</table>
<p>引数修飾子については <a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> に記述がある。</p>
</section>
<section id="precision-and-precision-qualifiers">
<h3><a class="toc-backref" href="#id53">4.7. Precision and Precision Qualifiers</a><a class="headerlink" href="#precision-and-precision-qualifiers" title="Permalink to this heading">¶</a></h3>
<p>Vulkan を対象にしていない場合：精度修飾子は OpenGL ES とのコードの可搬性のために追加されたものであって、機能的なものではない。精度修飾子は OpenGL ES と同じ構文を持ちますが、セマンティックな意味はなく、変数の格納や演算に使用される精度にも影響しない。拡張機能が OpenGL ES 2.0 仕様の精度修飾子と同じセマンティクスと機能を追加する場合は、その目的のために本節で記述されるキーワードを再利用することができる。</p>
<p>Vulkan を対象とする場合：インターフェイスの照合処理では、一様変数、一様ブロック、バッファーブロックメンバーは、同じ精度修飾を持たなければならない。同じシェーダー段階にリンクされていて異なるコンパイル単位で宣言された大域変数は、同じ精度修飾子で宣言されなければならない。</p>
<p>あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判断する目的では、精度修飾子が一致する必要はない。</p>
<section id="range-and-precision">
<h4><a class="toc-backref" href="#id54">4.7.1. Range and Precision</a><a class="headerlink" href="#range-and-precision" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">highp</span></code> 単精度および倍精度浮動小数点変数の精度は 32 ビットおよび 64 ビット浮動小数点数の IEEE 754 規格により定義される。</p>
<p>これには、NaN と Inf、および正と負のゼロの対処が含まれる。</p>
<p>以下の規則は、単精度と倍精度の演算の両方で <code class="docutils literal notranslate"><span class="pre">highp</span></code> に適用される。符号付きの無限大とゼロは、IEEE の規定に従って生成されるが、次の表（省略）で許可されている精度が適用される。シェーダーに入力された非正規化値、またはシェーダー内の任意の演算で潜在的に生成される値は、
0 に flush することができる。丸めモードは設定することができず、未定義だが、結果に 1ULP 以上の影響を与えてはならない。
NaN を生成する必要はない。
NaN の signaling の対処は必須ではなく、例外は決して発生しない。
NaN を操作する組み込み関数を含む操作は、結果として NaN を返す必要はない。しかし、NaN が生成された場合 <code class="docutils literal notranslate"><span class="pre">isnan()</span></code> は正しい値を返さなければならない。</p>
<p>特に断りのない限り、精度は ULP 単位で最大相対誤差で表される。</p>
<p>単精度演算の場合、精度は以下のように（略）求められる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>ちょっとした表が入るが、省略。</p>
</div>
<p>上記の操作から作られた式を持つ、仕様書で定義された組み込み関数は、上記の誤差を継承する。</p>
<p>これらには、例えば、幾何関数、共通関数、および多くの行列関数が含まれる。上記に記載されておらず、上記の方程式で定義されていない組み込み関数は、精度が未定義だ。例えば、三角関数や行列式などが該当する。</p>
<p>倍精度演算の精度は、少なくとも単精度のそれはある。</p>
</section>
<section id="precision-qualifiers">
<h4><a class="toc-backref" href="#id55">4.7.2. Precision Qualifiers</a><a class="headerlink" href="#precision-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>単精度浮動小数点型、整数型、不透明型宣言では、これらの精度修飾子の一つを型の前に付けることができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">highp</span></code></p></td>
<td><p>整数に対しては 32 ビット長 2の補数、浮動小数点数に対しては 32 ビット長 IEEE 754 浮動小数点</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mediump</span></code></p></td>
<td><p>Vulkan を対象にしている場合は SPIR-V RelaxedPrecision, それ以外の場合はなし。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lowp</span></code></p></td>
<td><p>同上</p></td>
</tr>
</tbody>
</table>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">lowp</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="k">mediump</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">P</span><span class="p">;</span><span class="w"></span>
<span class="k">lowp</span><span class="w"> </span><span class="kt">ivec2</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="k">lowp</span><span class="w"> </span><span class="kt">mat3</span><span class="p">);</span><span class="w"></span>
<span class="k">highp</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>リテラル定数には精度修飾子がない。真偽変数にもない。コンストラクターにもない。</p>
<p>この段落で言う「操作」には演算子、組み込み関数、コンストラクターを含み、「オペランド」には関数実引数とコンストラクター実引数を含むことにする。演算を内部的に評価するために使用される精度と、その後に生じる中間値に関連する精度修飾子は、演算によって消費されるオペランドの最高精度修飾子と少なくとも同じでなければならない。</p>
<p>オペランドが精度修飾子を持たない場合には、精度修飾子は他のオペランドから得られる。精度修飾子のあるオペランドがない場合は、式の中で次に消費される演算のオペランドの精度修飾子が使用される。この規則は、精度修飾されたオペランドが見つかるまで再帰的に適用することができる。必要に応じて、代入のための左辺値の精度修飾、初期化子のための被宣言変数の精度修飾、関数呼び出し実引数に対する仮引数の精度修飾、関数戻り値のための関数戻り型の精度修飾も含まれる。この方法で精度が決定できない場合、例えば、式全体が精度修飾子のないオペランドだけで構成されていて、その結果が代入されたり実引数として渡されたりしない場合は、その型の既定精度あるいはそれ以上で評価される。断片シェーダーでこのような事態が発生した場合、既定の精度を定義する必要がある。</p>
<p>例えば、次の文を考える：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="k">highp</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">h1</span><span class="p">;</span><span class="w"></span>
<span class="k">highp</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">h2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">4.7</span><span class="p">;</span><span class="w"> </span><span class="c1">// operation and result are highp precision</span><span class="w"></span>
<span class="k">mediump</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.7</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h2</span><span class="p">;</span><span class="w"> </span><span class="c1">// all operations are highp precision</span><span class="w"></span>
<span class="n">h2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h1</span><span class="p">;</span><span class="w"> </span><span class="c1">// operation is highp precision</span><span class="w"></span>
<span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h1</span><span class="p">;</span><span class="w"> </span><span class="c1">// operation is highp precision</span><span class="w"></span>
<span class="n">h2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="c1">// addition and result at mediump precision</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="k">highp</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="n">f</span><span class="p">(</span><span class="mf">3.3</span><span class="p">);</span><span class="w"> </span><span class="c1">// 3.3 will be passed in at highp precision</span><span class="w"></span>
</pre></div>
</div>
<p>精度修飾子は、他の修飾子と同様に、変数の基本型には影響しない。特に、精度変換のためのコンストラクターはない。コンストラクターは型を変換するだけだ。同様に、精度修飾子は、他の修飾子と同様に、引数型に基づく関数のオーバーロードには関与しない。
<a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> で述べられているように、関数入出力はコピーによって行われるので、修飾子は一致しなくても構わない。</p>
<p>変数の精度はその変数が宣言された時点で決定され、その後変化することはあり得ない。</p>
<p>This rule does not affect the precision qualification of the expression.
定整数式または定浮動小数点式の精度が指定されていない場合、評価は <code class="docutils literal notranslate"><span class="pre">highp</span></code> で行われる。この規則は式の精度修飾には影響しない。</p>
<p>定数式の評価は不変でなければならず、通常はコンパイル時に実行される。</p>
</section>
<section id="default-precision-qualifiers">
<h4><a class="toc-backref" href="#id56">4.7.3. Default Precision Qualifiers</a><a class="headerlink" href="#default-precision-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>精度文</p>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">precision</span></code> <em>precision-qualifier</em> <em>type</em>;</div>
</div>
<p>を既定精度修飾子を設定するために使用することができる。
<em>type</em> 欄は <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, 不透明型のいずれかであり、
<em>precision-qualifier</em> には <code class="docutils literal notranslate"><span class="pre">lowp</span></code>, <code class="docutils literal notranslate"><span class="pre">mediump</span></code>, <code class="docutils literal notranslate"><span class="pre">highp</span></code> が宣言される。</p>
<p>これ以外の型や修飾子を指定するとコンパイルエラーになる。
<code class="docutils literal notranslate"><span class="pre">type</span></code> が <code class="docutils literal notranslate"><span class="pre">float</span></code> の場合、この指令は精度修飾のない単精度浮動小数点型（スカラー、ベクトル、行列）の宣言に適用される。
<code class="docutils literal notranslate"><span class="pre">type</span></code> が <code class="docutils literal notranslate"><span class="pre">int</span></code> の場合は、精度修飾のない整数型（スカラー、ベクトルー、符号あり、符号なし）の宣言に適用される。これには、大域変数宣言、関数戻り値宣言、関数引数タ宣言、局所変数宣言が含まれる。</p>
<p>精度修飾のない宣言は、スコープ内にある直近の精度文で指定された精度修飾子を使用する。
<code class="docutils literal notranslate"><span class="pre">precision</span></code> 文には変数宣言と同じスコープ規則がある。複文の中で宣言された場合、その効果は宣言された最も内側の文の終わりで停止する。入れ子になったスコープ内の精度文は、外側のスコープ内の精度文を上書きする。同じ基本型に対する複数の精度文が同じスコープ内に現れることができ、そのスコープ内で遅れて現れる文が早く現れる文を上書きする。</p>
<p>精度修飾子を受け付ける型に対する既定精度修飾子は <code class="docutils literal notranslate"><span class="pre">highp</span></code> だ。精度修飾子を必要とする全ての型には既定精度があるので、精度修飾子の省略によるエラーはない。</p>
</section>
<section id="available-precision-qualifiers">
<h4><a class="toc-backref" href="#id57">4.7.4. Available Precision Qualifiers</a><a class="headerlink" href="#available-precision-qualifiers" title="Permalink to this heading">¶</a></h4>
<p>組み込みマクロ <code class="docutils literal notranslate"><span class="pre">GL_FRAGMENT_PRECISION_HIGH</span></code> は 1 に定義されている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GL_FRAGMENT_PRECISION_HIGH 1</span><span class="w"></span>
</pre></div>
</div>
<p>このマクロは計算以外の言語すべてで使用できる。</p>
</section>
</section>
<section id="variance-and-the-invariant-qualifier">
<h3><a class="toc-backref" href="#id58">4.8. Variance and the Invariant Qualifier</a><a class="headerlink" href="#variance-and-the-invariant-qualifier" title="Permalink to this heading">¶</a></h3>
<p>この節でいうばらつき (variance) とは、異なるプログラムにある同じ式から異なる値が得られる可能性を意味する。例えば、異なるプログラムにある二つの頂点シェーダーがそれぞれ
<code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> を同じ式で設定し、その式への入力値が両方のシェーダーの実行時に同じであるとする。シェーダー二つが独立してコンパイルされているため、これらの実行時に
<code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> に代入される値が完全に同じではないことがあり得る。この例では、多重パスアルゴリズムにおける幾何の alignment に問題が生じ得る。</p>
<p>一般的には、シェーダー間のこのようなばらつきは許容される。特定の出力変数にそのようなばらつきがない場合、その変数は不変である (invariant)
と言われる。</p>
<section id="the-invariant-qualifier">
<h4><a class="toc-backref" href="#id59">4.8.1. The Invariant Qualifier</a><a class="headerlink" href="#the-invariant-qualifier" title="Permalink to this heading">¶</a></h4>
<p>特定の出力変数が不変であることを保証するには、修飾子 <code class="docutils literal notranslate"><span class="pre">invariant</span></code> を使用する。この修飾子を以前に宣言された変数が不変であることを修飾するのに使用することもできる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span><span class="w"> </span><span class="nb">gl_Position</span><span class="p">;</span><span class="w"> </span><span class="c1">// make existing gl_Position be invariant</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w"></span>
<span class="k">invariant</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w">       </span><span class="c1">// make existing Color be invariant</span><span class="w"></span>
</pre></div>
</div>
<p>または、変数が宣言されたときにその宣言の一部とする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span><span class="w"> </span><span class="k">centroid</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>不変性の候補はシェーダーの出力変数しかない。ユーザー定義の出力変数と組み込み出力変数を含む。不変宣言できるのは出力のみなので、あるシェーダー段階の出力は、入力が不変宣言されていなくても後続段階の入力と一致します。</p>
<p>ブロック上の入力または出力インスタンス名は、組み込み変数を再宣言する際には使用されない。</p>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">invariant</span></code> の後には、以前に宣言された識別子をカンマで区切って列挙することができる。
<code class="docutils literal notranslate"><span class="pre">invariant</span></code> の使用はすべて、大域スコープまたはブロックメンバー上で、かつ <code class="docutils literal notranslate"><span class="pre">invariant</span></code> として宣言された変数が使用される前でなければならない。</p>
<p>特定の出力変数の不変性を二つのプログラムを横断して保証するには、次も成り立っていなければならない：</p>
<ul class="simple">
<li><p>出力変数が両方のプログラムで不変であると宣言されている。</p></li>
<li><p>出力変数に割り当てられた値に関与する式や制御フローで消費されるシェーダー入力変数すべてに同じ値を入力する必要がある。</p></li>
<li><p>テクスチャーフォーマット、テクセル値、およびテクスチャーフィルタリングは、出力変数の値に関与するすべてのテクスチャー関数呼び出しに対して同じ方法に設定される。</p></li>
<li><p>入力値すべてが同じ方法ですべて操作される。消費される式と中間式の操作すべてが、評価の順序が同じになるように、オペランドの順序と結合性（左結合とか右結合とかのこと）を同じにしなければならない。中間変数と関数は、同じ明示的または暗黙的精度修飾子を持つ同じ型として宣言されなければならない。出力値に影響を与えるすべての制御フローは同じでなければならず、この制御フローを決定するために消費されるどんな式も、これらの不変性規則に従わなければならない。</p></li>
<li><p>不変出力変数を設定するためのデータフローと制御フローすべては、単一のコンパイル単位に宿る。</p></li>
</ul>
<p>原則的に、不変出力に至るデータフローと制御フローのすべてで一致しなければならない。</p>
<p>初期状態では、既定で、すべての出力変数に <code class="docutils literal notranslate"><span class="pre">variant</span></code> が許されている。すべての出力変数を強制的に <code class="docutils literal notranslate"><span class="pre">invariant</span></code> にするには、プラグマ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma STDGL invariant(all)</span><span class="w"></span>
</pre></div>
</div>
<p>をシェーダー内のすべての宣言の前に使用する。このプラグマがいずれかの変数や関数の宣言の後に使用された場合、不変の動作をする出力集合は未定義となる。</p>
<p>一般に、不変性は最適化の柔軟性を犠牲にして確保されるため、不変性を使用することでパフォーマンスが低下する可能性がある。したがって、このプラグマの使用は、出力変数すべてを一つ一つ <code class="docutils literal notranslate"><span class="pre">invariant</span></code> と宣言するのを避けるためのデバッグ支援を目的としている。</p>
</section>
<section id="invariance-of-constant-expressions">
<h4><a class="toc-backref" href="#id60">4.8.2. Invariance of Constant Expressions</a><a class="headerlink" href="#invariance-of-constant-expressions" title="Permalink to this heading">¶</a></h4>
<p>定数式には不変性が保証されなければならない。特定の定数式は、それが同じシェーダーに現れようが異なるシェーダーに現れようが、同じ結果になるように評価しなければならない。これには、同じ式が同じ言語の二つのシェーダーに現れる場合と、二つの異なる言語のシェーダーに現れる場合が含まれる。</p>
<p>定数式は、前述の不変変数と同様に操作しても、同じ結果に評価しなければならない。</p>
</section>
</section>
<section id="the-precise-qualifier">
<h3><a class="toc-backref" href="#id61">4.9. The Precise Qualifier</a><a class="headerlink" href="#the-precise-qualifier" title="Permalink to this heading">¶</a></h3>
<p>アルゴリズムの中には、ほぼ同等の結果をより高いパフォーマンスで得られる最適化を対処している実装であっても、ソースコードで指定された演算順序に正確に従い、すべての演算を着実に処理することを浮動小数点計算に要求するものがある。例えば、多くの実装は、次のような浮動小数点式を計算する multiply-add 命令を対処している：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>これは三度の演算の代わりに二度で、すなわち、二度の乗算と一度の加算の代わりに、一度の乗算と一度の multiply-add 演算を行う。</p>
<p>浮動小数点の multiply-add 結果は、最初に浮動小数点の結果が得られる乗算を行ってから浮動小数点の加算を行った場合と同じになるとは限らない。したがって、この例では、二つの乗算はつじつまが合うようには扱われず、二つの乗算は事実上、異なる精度であるように見える可能性がある。</p>
<p>一貫性を持たせる必要がある重要な計算は、細分化の際に現れる。下図（注：本書には巨大な図式が掲載されている）のように、細分化のための中間点が異なる方向に合成されるが、同じ結果を得る必要がある。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>ここにあるイラストは、細分化を実装するようなプログラマーでないと理解できないものだと思う。</p>
</div>
<p>最適化されたコードが最適化されていないコードと比較してわずかに異なる結果をもたらすかもしれなくても、実装は修飾子なしで、式の評価に使用される演算の順序または数を効果的に変更する最適化を実行することが許可される。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は変数の値に与する演算が、指定された順序で、演算子の一貫性を持って行われることを保証する。演算子の順序は、
<a class="reference internal" href="note5.html#operators"><span class="std std-ref">5.1. Operators</span></a> で記述されているように、演算子の優先順位と括弧によって決定される。演算子の一貫性とは、例えば乗算演算子 <code class="docutils literal notranslate"><span class="pre">*</span></code> のような特定の演算子について、その演算が常に同じ精度で計算されることを意味する。具体的には、コンパイラーで生成されたコードで計算された値は、以下の恒等式に従わなければならない：</p>
<div class="line-block">
<div class="line">a + b = b + a</div>
<div class="line">a * b = b * a</div>
<div class="line">a * b + c * d = b * a + c* d = d * c + b * a = &lt;any other mathematically valid combination&gt;</div>
</div>
<p>次を防ぐことができる一方：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c)</span></code> が <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">+</span> <span class="pre">c</span></code> になることは許されない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">(b</span> <span class="pre">*</span> <span class="pre">c)</span></code> が <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">*</span> <span class="pre">b)</span> <span class="pre">*</span> <span class="pre">c</span></code> になることは許されません。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span></code> が単一の演算 <code class="docutils literal notranslate"><span class="pre">fma(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> になることは許されない 。</p></li>
</ul>
<p>ここで <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> ,``c`` ,``d`` は行列ではなく、スカラーまたはベクトルとする（行列は一般には可換でない）。これらの規則に基づいて計算を表現するのはシェーダー作成者の責任であり、これらの規則に従うのはコンパイラーの責任だ。細分化段階が従うべき規則については <code class="docutils literal notranslate"><span class="pre">gl_TessCoord</span></code> の説明を参照。これらの規則は、上記と合わせて、細分化する際のひび割れを避けることができる。</p>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">precise</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>は <code class="docutils literal notranslate"><span class="pre">position</span></code> の値を生成するために使用される演算が、ソースコードで指定された順序で正確に実行されなければならず、すべての演算子が着実に扱われなければならないことを宣言している。修飾子 <code class="docutils literal notranslate"><span class="pre">invariant</span></code> と同様に、修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は組み込み変数や事前に宣言されたユーザー定義変数が正確であることを修飾するために使用できる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w"></span>
<span class="k">precise</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w"> </span><span class="c1">// make existing Color be precise</span><span class="w"></span>
</pre></div>
</div>
<p>ブロック、構造体型、または構造体型の変数に <code class="docutils literal notranslate"><span class="pre">precise</span></code> を適用すると、変数のメンバーそれぞれに再帰的に <code class="docutils literal notranslate"><span class="pre">precise</span></code> を適用することになる。</p>
<p>この修飾子は、特定の関数内の右辺値の評価に影響を与えるが、それは、その結果が最終的に同じ関数内で <code class="docutils literal notranslate"><span class="pre">precise</span></code> と修飾された左辺値によって消費される場合に、かつその場合に限られる。関数内の他の式は影響を受けない。これには、
<code class="docutils literal notranslate"><span class="pre">precise</span></code> 宣言されていないが、関数の外で <code class="docutils literal notranslate"><span class="pre">precise</span></code> 修飾された変数によって最終的に消費される戻り値や出力引数も含まれる。影響を受けない式には、選択文と反復文と条件演算子の条件式とにある式を制御するものも含まれる。</p>
<p><code class="docutils literal notranslate"><span class="pre">precise</span></code> の使用例（略）。</p>
<p>あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判定する目的では、修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は入力と出力の間で一致する必要はない。</p>
<p>すべての定数式は <code class="docutils literal notranslate"><span class="pre">precise</span></code> が存在するかどうかにかかわらず、それが存在するかのように評価される。ただし、コンパイル時の定数式が対応する非定数式と同じ値に評価されるという要件はない
(<a class="reference internal" href="#constant-expressions"><span class="std std-ref">4.3.3. Constant Expressions</span></a>)。</p>
</section>
<section id="memory-qualifiers">
<h3><a class="toc-backref" href="#id62">4.10. Memory Qualifiers</a><a class="headerlink" href="#memory-qualifiers" title="Permalink to this heading">¶</a></h3>
<p>シェーダー格納ブロックとその内側で宣言された変数と画像型（キーワードに <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> を含む基本不透明型）として宣言された変数は、以下（略）の記憶修飾子の一つまたは複数を追加的に修飾することができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">coherent</span></code></p></td>
<td><p>（面倒なので本文参照）</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">volatile</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">restrict</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">readonly</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">writeonly</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">coherent</span></code> を使って宣言された画像変数へのメモリーアクセスは、他のシェーダー呼び出しからの同じ場所へのアクセスとともに密着的に実行される。特に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> 宣言された変数を読み出す場合、戻り値には、他のシェーダー呼び出しで実行された以前に完了した書き込みの結果が反映される。また、
<code class="docutils literal notranslate"><span class="pre">coherent</span></code> 宣言された変数を書き込む場合、書き込まれた値は、他のシェーダー呼び出しで実行された後の密着的読み込みに反映される。</p>
<p>OpenGL 仕様書の 7.12 “Shader Memory Access” にあるように、シェーダーメモリーの読み取りと書き込みは、ほとんど定義されていない順序で行われる。必要であれば、組み込み関数 <code class="docutils literal notranslate"><span class="pre">memoryBarrier()</span></code> を使って、単一のシェーダー呼び出しで実行されるメモリーアクセスの完了と相対的な順序を保証できる。</p>
<p><code class="docutils literal notranslate"><span class="pre">coherent</span></code> と宣言されていない変数を使ってメモリーにアクセスする場合、シェーダーがアクセスするそのメモリーは、同じアドレスへの将来のアクセスのために、実装がキャッシュすることがある。メモリー格納は、書き込まれた値が同じメモリーにアクセスする他のシェーダー呼び出しから見えないような方法でキャッシュされることがある。実装は、メモリー読みによって持ってきた値をキャッシュし、内在するメモリーが最初のメモリー読み以降に変更された場合でも、同じメモリーにアクセスするシェーダー呼び出しに同じ値を返すことができる。
<code class="docutils literal notranslate"><span class="pre">coherent</span></code> と宣言されていない変数は、シェーダー呼び出し間の通信には役立たないかもしれないが、非密着式のアクセスを使用することで、より高いパフォーマンスが得られる可能性がある。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">volatile</span></code> を使用して宣言された画像変数へのメモリーアクセスは、シェーダー実行中の任意の時点で、実行中のシェーダー呼び出し以外のソースによって読み書きされる可能性があるかのように、内在するメモリーを扱わなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数が読み取られた場合、その値は、読み取りを実行するシェーダー呼び出しが以前に同じメモリーからその値を持ってきていたとしても、内在するメモリーから再取得されなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数が書き込まれた場合、その値が後続の書き込みによって上書きされることをコンパイラーが明確に判断したとしても、その値は内在するメモリーに書き込まれなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数を読み書きする外部ソースは別のシェーダー呼び出しである可能性があるため、
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 宣言された変数は自動的に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> として扱われる。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> を使って宣言された画像変数へのメモリーアクセスは、メモリーアクセスを行うために使用される変数が、当該シェーダー段階を使って内在するメモリーにアクセスする唯一の方法であると仮定してコンパイルすることができる。これにより、コンパイラーは他のコードが内在する画像を読み書きしないと仮定できるので、非 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> 画像変数では許可されない方法で、
<code class="docutils literal notranslate"><span class="pre">restrict</span></code> 画像変数を使用してロードや格納をまとめたり、並べ替えたりすることができます。アプリケーションは <code class="docutils literal notranslate"><span class="pre">restrict</span></code> 変数が参照する画像メモリーが同じスコープの他の変数から参照されないようにする責任がある。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> を使用して宣言された画像変数へのメモリーアクセスは内在するメモリに対する読み取りのみ可能で、読み取り専用のメモリーとして扱われ、書き込みはできない。
<code class="docutils literal notranslate"><span class="pre">readonly</span></code> 画像変数を <code class="docutils literal notranslate"><span class="pre">imageStore()</span></code> やその他画像メモリーを変更する組み込み関数に渡すとコンパイルエラー。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> を使用して宣言された画像変数へのメモリーアクセスは内在するメモリーに対する書き込みのみ可能で、内在するメモリーを読み取ることはできない。
<code class="docutils literal notranslate"><span class="pre">writeonly</span></code> 画像変数を <code class="docutils literal notranslate"><span class="pre">imageLoad()</span></code> やその他画像メモリーを読み込む組み込み関数に渡すとコンパイルエラー。</p>
<hr class="docutils" />
<p>変数を <code class="docutils literal notranslate"><span class="pre">readonly</span></code> と <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> の両方で修飾して、読み込みと書き込みの両方を禁止することもできる。このような変数でも、
<code class="docutils literal notranslate"><span class="pre">imageSize()</span></code> や <code class="docutils literal notranslate"><span class="pre">.length()</span></code> など、いくつかの問い合わせで使用することができる。</p>
<p>記憶修飾子 <code class="docutils literal notranslate"><span class="pre">coherent</span></code>, <code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">restrict</span></code>, <code class="docutils literal notranslate"><span class="pre">readonly</span></code>, <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> は、バッファー変数（つまりシェーダー格納ブロックのメンバー）の宣言に使用できる。バッファー変数が記憶修飾子付きで宣言されている場合、上述の画像変数を含むメモリーアクセスに指定された動作は、そのバッファー変数を含むメモリーアクセスにも同じように適用される。
<code class="docutils literal notranslate"><span class="pre">readonly</span></code> バッファー変数への代入や <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> バッファー変数からの読み出しはコンパイルエラー。
<code class="docutils literal notranslate"><span class="pre">readonly</span> <span class="pre">writeonly</span></code> の組み合わせは可能。</p>
<p>さらに、シェーダー格納ブロックのブロックレベルの宣言では、
<code class="docutils literal notranslate"><span class="pre">readonly</span> <span class="pre">writeonly</span></code> の組み合わせを含む記憶修飾子を使用することができる。ブロック宣言が記憶修飾子で修飾されている場合、そのブロックのすべてのメンバーが同じ記憶修飾子で宣言されているかのようになる。例えば、</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">coherent</span><span class="w"> </span><span class="k">buffer</span><span class="w"> </span><span class="n">Block</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">readonly</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">member1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">vec4</span><span class="w"> </span><span class="n">member2</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>このブロック宣言は次のものに等価だ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">buffer</span><span class="w"> </span><span class="n">Block</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">coherent</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">member1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">coherent</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">member2</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>記憶修飾子は画像変数、バッファー変数、シェーダー格納ブロックの宣言でしか対処されていない。その他の宣言でこれらの修飾子を使用するとエラーとなる。</p>
<p>ユーザー定義関数を呼び出す際、
<code class="docutils literal notranslate"><span class="pre">coherent</span></code>, <code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">readonly</span></code>, <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> で修飾された変数を、そのような修飾語がない仮引数を持つ関数に渡すことはできない。仮引数に記憶修飾子を追加することは合法だが、修飾子 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> を持たない仮引数が呼び出し引数から取り去ることができるのは <code class="docutils literal notranslate"><span class="pre">restrict</span></code> だけだ。</p>
<p>組み込み関数が呼び出されたとき、生成されるコードは実引数の実際の修飾子に基づくものであり、プロトタイプの仮引数に指定された記憶修飾子のリストに基づくのではない。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">funcA</span><span class="p">(</span><span class="k">restrict</span><span class="w"> </span><span class="kt">image2D</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">funcB</span><span class="p">(</span><span class="kt">image2D</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">image2D</span><span class="w"> </span><span class="n">img1</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">)</span><span class="w"> </span><span class="k">coherent</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">image2D</span><span class="w"> </span><span class="n">img2</span><span class="p">;</span><span class="w"></span>

<span class="n">funcA</span><span class="p">(</span><span class="n">img1</span><span class="p">);</span><span class="w">        </span><span class="c1">// OK, adding &quot;restrict&quot; is allowed</span><span class="w"></span>
<span class="n">funcB</span><span class="p">(</span><span class="n">img2</span><span class="p">);</span><span class="w">        </span><span class="c1">// illegal, stripping &quot;coherent&quot; is not</span><span class="w"></span>
</pre></div>
</div>
<p>レイアウト修飾子は仮引数には使用できず、引数照合処理に含まれない。</p>
<p>画像変数の宣言で <code class="docutils literal notranslate"><span class="pre">const</span></code> を使用すると、参照する画像ではなく、宣言されている変数の <code class="docutils literal notranslate"><span class="pre">const</span></code> 性を修飾することに注意してください。修飾子 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> は（その変数を介してアクセスされる）画像メモリーを修飾し、修飾子 <code class="docutils literal notranslate"><span class="pre">const</span></code> は変数自体を修飾する。</p>
</section>
<section id="specialization-constant-qualifier">
<h3><a class="toc-backref" href="#id63">4.11. Specialization-Constant Qualifier</a><a class="headerlink" href="#specialization-constant-qualifier" title="Permalink to this heading">¶</a></h3>
<p>特殊化定数は SPIR-V でのみ使用され、レイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> を使用して宣言される。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>If it is never changed before final lowering
これは既定値が 12 である特殊化定数を作る。
17 という数字は、API や他のツールが後でこの独特な特殊化定数を参照するために、著者が選んだ例示的な ID だ。それが final lowering 前に決して変更されなければ 12 の値を維持する。スカラー <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code> の SPIR-V 生成以外で修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> を使用するとコンパイルエラー。</p>
<p>組み込み定数を特殊化定数として宣言することができる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span><span class="w"> </span><span class="nb">gl_MaxClipDistances</span><span class="p">;</span><span class="w"> </span><span class="c1">// add specialization_id</span><span class="w"></span>
</pre></div>
</div>
<p>この宣言では、先に宣言された組み込み変数の名前だけを使用し、レイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> 宣言をしている。定数が使用された後にこれを行うとコンパイルエラーとなる。定数は厳密に非特殊化定数か特殊化定数のどちらか一方であり、両方ではない。</p>
<p>組み込み定数ベクトル <code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> は、修飾子 <code class="docutils literal notranslate"><span class="pre">local_size_{xyz}_id</span></code> を使って、成分に個別に ID を与えることで特殊化できる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="n">local_size_z_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">19</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize.y</span></code> は非特殊化定数として残され、
<code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> は部分的に特殊化されたベクトルとなる。その <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> 成分は、SPIR-V を生成した後に
ID 18 および 19 を使用して、後で特殊化することができる。これらの ID は作業グループサイズの宣言とは別に宣言される。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">local_size_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w">   </span><span class="c1">// size is (32,32,1)</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">local_size_x_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w">                   </span><span class="c1">// constant_id for x</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">local_size_z_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">19</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="p">;</span><span class="w">                   </span><span class="c1">// constant_id for z</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">local_size_{xyz}</span></code> の宣言に関する既存の規則は変化しない。
<code class="docutils literal notranslate"><span class="pre">local_size_{xz}_id</span></code> については、同じ ID に異なる ID 値を与えたり、使用後に ID 値を与えたりするとコンパイルエラーとなる。それ以外では、順序、配置、文の個数、および複製はエラーにならない。</p>
<p>特殊化定数でサイズ調整された二つの配列は、同じ記号でサイズ調整され、かつ演算を伴わない場合に限り、同じ型となる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">51</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">aSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pad</span><span class="p">;</span><span class="w"> </span><span class="c1">// specialization constant</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">total</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">total</span><span class="p">];</span><span class="w">        </span><span class="c1">// a and b have the same type</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span><span class="w">                     </span><span class="c1">// different type than a or b</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">aSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pad</span><span class="p">];</span><span class="w">            </span><span class="c1">// different type than a, b, or c</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="p">[</span><span class="n">aSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w">              </span><span class="c1">// different type than a, b, c, or d</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>なぜこのようになるのか説明できるか？</p>
</div>
<p>特殊化定数でサイズ調整された配列を含む型を比較すること、集約として代入すること、初期化を使って宣言すること、初期化として使用することができない。ただし、同じ型の仮引数を持つ関数の実引数として渡すことはできる。配列の配列として宣言された変数の最も外側の次元しか特殊化定数とはならず、そうでなければコンパイルエラーとなる。</p>
<p>ブロック内の配列のサイズを特殊化定数で指定することはできるものの、ブロックは静的レイアウトを有するようになる。特殊化サイズを変化させても、ブロックは再配置されません。明示的なオフセットがない場合は、そのレイアウトは配列の既定サイズに基づいたものになる。</p>
</section>
<section id="order-and-repetition-of-qualification">
<h3><a class="toc-backref" href="#id64">4.12. Order and Repetition of Qualification</a><a class="headerlink" href="#order-and-repetition-of-qualification" title="Permalink to this heading">¶</a></h3>
<p>一つの宣言に修飾子が複数ある場合、それらの順序は何でもよいが、型の前にすべて置かなければならない。修飾子 <code class="docutils literal notranslate"><span class="pre">layout</span></code> は、一度を超えて現れることができる唯一の修飾子だ。さらに、一つの宣言は、格納修飾子、補助格納修飾子、補間修飾子を高々一つ持てる。
<code class="docutils literal notranslate"><span class="pre">inout</span></code> が使用された場合、
<code class="docutils literal notranslate"><span class="pre">in</span></code> も <code class="docutils literal notranslate"><span class="pre">out</span></code> も使用できまない。記憶修飾子を複数使用することができる。これらの規則に違反すると、コンパイルエラーとなる。</p>
</section>
<section id="empty-declarations">
<h3><a class="toc-backref" href="#id65">4.13. Empty Declarations</a><a class="headerlink" href="#empty-declarations" title="Permalink to this heading">¶</a></h3>
<p><strong>空宣言</strong> (empty declarations) とは、変数名のない宣言のことであって、その宣言によってインスタンス化されるオブジェクトがないことを意味する。一般的に、空宣言は許されている。構造体を宣言するときに便利なものもあれば、何の効果もないものもある。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">;</span><span class="w">               </span><span class="c1">// No effect</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="p">{</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;};</span><span class="w"> </span><span class="c1">// Defines a struct S</span><span class="w"></span>
</pre></div>
</div>
<p>コンパイルエラーやリンクエラーが発生する修飾子の組み合わせは、例えば、宣言が空であってもなくても同じだ。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Error. An input cannot be invariant.</span><span class="w"></span>
<span class="k">invariant</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span><span class="w">   </span><span class="c1">// Error even though no variable is declared.</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note3.html" title="Previous document">OpenGL Shading Language 4.60 Specification 読書ノート Part 3</a>
        </li>
        <li>
          <a href="note5.html" title="Next document">OpenGL Shading Language 4.60 Specification 読書ノート Part 5</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a><ul>
      <li>Previous: <a href="note3.html" title="previous chapter">OpenGL Shading Language 4.60 Specification 読書ノート Part 3</a></li>
      <li>Next: <a href="note5.html" title="next chapter">OpenGL Shading Language 4.60 Specification 読書ノート Part 5</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>