<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 2/3</title>
    
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="top" title="読書ノート" href="index.html" />
    <link rel="up" title="オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート" href="gamma95.html" />
    <link rel="next" title="オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 3/3" href="gamma95-note3.html" />
    <link rel="prev" title="オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 1/3" href="gamma95-note1.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート</a> &raquo;</li>
          <li><a href="gamma95.html" accesskey="U">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id7">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 2/3</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="gamma95-note1.html"><em>オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 1/3</em></a> からの続き。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Eric Gamma/Richard Helm/Ralph Johnson/John Vlissides</td>
</tr>
<tr class="field-even field"><th class="field-name">監訳者:</th><td class="field-body">本位田真一 吉田和樹</td>
</tr>
<tr class="field-odd field"><th class="field-name">出版社:</th><td class="field-body">ソフトバンク クリエイティブ株式会社</td>
</tr>
<tr class="field-even field"><th class="field-name">ISBN:</th><td class="field-body">ISBN4-7973-1112-6</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id2">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id7">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 2/3</a><ul>
<li><a class="reference internal" href="#id3" id="id8">第 3 章 生成に関するパターン</a><ul>
<li><a class="reference internal" href="#abstract-factory" id="id9">Abstract Factory</a></li>
<li><a class="reference internal" href="#builder" id="id10">Builder</a></li>
<li><a class="reference internal" href="#factory-method" id="id11">Factory Method</a></li>
<li><a class="reference internal" href="#prototype" id="id12">Prototype</a></li>
<li><a class="reference internal" href="#singleton" id="id13">Singleton</a></li>
<li><a class="reference internal" href="#id4" id="id14">まとめ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5" id="id15">第 4 章 構造に関するパターン</a><ul>
<li><a class="reference internal" href="#adapter" id="id16">Adapter</a></li>
<li><a class="reference internal" href="#bridge" id="id17">Bridge</a></li>
<li><a class="reference internal" href="#composite" id="id18">Composite</a></li>
<li><a class="reference internal" href="#decorator" id="id19">Decorator</a></li>
<li><a class="reference internal" href="#facade" id="id20">Facade</a></li>
<li><a class="reference internal" href="#flyweight" id="id21">Flyweight</a></li>
<li><a class="reference internal" href="#proxy" id="id22">Proxy</a></li>
<li><a class="reference internal" href="#id6" id="id23">まとめ</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id8">第 3 章 生成に関するパターン</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>&lt;クラス継承よりもオブジェクトコンポジションに頼る形でシステムを発展させていく場合に、
生成に関するパターンは重要になる&gt; (p. 89)</li>
<li><tt class="docutils literal"><span class="pre">MazeGame::CreateMaze</span></tt> についての考察が数ページ続くが、
高密度な記述ゆえに上手い形にノートにまとめられない。<ul>
<li>2 つの部屋からなる簡単な迷路を作っているだけなのに、コードが複雑 (p. 92)</li>
<li>迷路構成を変更しようとすると、メンバ関数のオーバーライド（実質再定義）か、
それと同等の仕事が必要となる (p. 92)</li>
</ul>
</li>
<li>&lt;より柔軟な設計（必ずしも、コードを短くするわけではない）&gt; (p. 93)
このカッコ内がポイント。</li>
<li>&lt;インスタンス化されるクラスがコード中に直接書かれていることが最大の問題&gt; (p. 93)</li>
</ul>
<div class="section" id="abstract-factory">
<h3><a class="toc-backref" href="#id9">Abstract Factory</a><a class="headerlink" href="#abstract-factory" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Motif とか Presentation Manager とかって何？</p>
</li>
<li><p class="first">&lt;各種の基本ウィジェットを生成するためのインタフェースを宣言した抽象クラス
WidgetFactory を定義する&gt; (p. 95)</p>
</li>
<li><p class="first">各種のウィジェットに対する抽象クラスを作成したら、
&lt;その具象クラスで特定の look-and-feel 規格のもとでの実装を与える&gt; (p. 95)</p>
</li>
<li><p class="first">&lt;たとえば Motif ではスクロールバーはボタンやテキストエディタとともに
使わなければならないといった制約が、MotifWidgetFactory クラスを利用する結果として
自動的に規定されることになる&gt; (p. 96)</p>
</li>
<li><p class="first">このパターンでは Client は AbstractFactory と AbstractProduct で宣言された
インタフェースのみを利用する (p. 97)</p>
</li>
<li><p class="first">&lt;普通、ConcreteFactory クラスのインスタンスは実行時に生成される&gt; (p. 97)
とあるが、実行時に生成されないインスタンスなど考えられる？</p>
</li>
<li><p class="first">新たな種類の部品への対応は AbstractFactory とそのすべてのサブクラスについて、
インタフェースの修正が必要となる。これが面倒。</p>
</li>
<li><p class="first">部品を実際に生成するのは ConcreteProduct クラスになるが、
各部品について factory method を定義する方法がよく用いられる (p. 98)</p>
</li>
<li><p class="first">Prototype パターンを使って ConcreteFactory クラスを実装する方法がある。
部品の集合が多数存在する場合にそうすることができる (p. 98)</p>
</li>
<li><p class="first">&lt;クラスをオブジェクトとして扱うことのできる言語では、
prototype を用いたアプローチに変化をつけることが可能になる&gt; (p. 99)</p>
</li>
<li><p class="first">生成する部品の種類を表すパラメータを取る AbstractFactory の手法は、
&lt;C++ を使うときには、すべてのオブジェクトが同じ抽象基底クラスを持つ場合か、
要求を出すクライアントにより部品オブジェクトが正しい型に変換できる場合にのみ、
適用することができる&gt; (p. 100)</p>
<p>この条件はそんなにきつくない。
&lt;サブクラスに特有のオペレーション&gt; (p. 100) をする必要がない場合は、
この手法の採用の検討に値する。</p>
</li>
</ul>
<p>サンプルコードで <tt class="docutils literal"><span class="pre">MazeGame::CreateMaze</span></tt> を Abstract Factory パターンで実装している。</p>
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">MazeFactory</span></tt> クラスは、単に factory method を集めたものになっているが、
これは Abstract Factory パターンを実装するときにもっとも一般的な方法である&gt; (p. 102)</li>
<li>AbstractFactory が ConcreteFactory を兼ねるのも一般的な実装方法 (p. 102)</li>
</ul>
</div>
<div class="section" id="builder">
<h3><a class="toc-backref" href="#id10">Builder</a><a class="headerlink" href="#builder" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">同じ作成過程で異なる表現形式の複合オブジェクトを生成できる (p. 105)</p>
</li>
<li><p class="first">&lt;変換すべきフォーマットのすべてを事前に確定できるとは限らないので、
読み取り部を修正することなく、新たに与えられたフォーマットへの変換が
容易に行えるようにしておくことが望ましい&gt; (p. 105)</p>
</li>
<li><p class="first">&lt;RTFReader オブジェクトが RTF の文書の構文解析を行い、
その結果を TextConverter オブジェクトを使って変換する&gt; (p. 105)</p>
<p>「何に」変換するかはまだ言及していないことに注意。</p>
</li>
<li><p class="first">この各変換クラスを <strong>builder</strong> と呼び、読み取り部のクラスを <strong>director</strong> と呼ぶ (p. 106)</p>
</li>
<li><p class="first">&lt;RTFReader クラスの構文解析アルゴリズムは再利用することができる&gt; (p. 106)</p>
</li>
<li><p class="first">オブジェクトの作成プロセスが、多様な表現を認めるようにしておける (p. 106)</p>
</li>
<li><p class="first">当パターンのクラス構造を見ると、Director が Builder を持っている。
面白いのは <tt class="docutils literal"><span class="pre">Director</span></tt> が <tt class="docutils literal"><span class="pre">Builder::BuildPart</span></tt> メソッドしか利用していないこと。</p>
<ul class="simple">
<li>ConcreteBuilder は &lt;Product オブジェクトを取り出すためのインターフェイスを提供する&gt; (p. 107)</li>
<li>Product クラスは &lt;多くの構成要素からなる複合オブジェクト&gt; (p. 107) である。</li>
</ul>
</li>
</ul>
<p>このパターンはトレード・オフがないのか。</p>
<ul>
<li><p class="first">&lt;別の Director オブジェクトが同じ構成要素からなる Product オブジェクトを作成する場合に、
それを再利用することができるようになる&gt; (p. 108)</p>
<p>各 ConcreteBuilder がそのまま（変更せずに）再利用できると強調している。</p>
</li>
<li><p class="first">&lt;生成要求の結果を、それまでに得られている Product
オブジェクトに単純に追加していくだけのモデルで十分な場合が多い&gt; (p. 109)</p>
</li>
<li><p class="first">&lt;異なる Product オブジェクトに共通の親クラスを作るメリットは少ない&gt; (p. 109)</p>
<p>なるほど。</p>
</li>
</ul>
<p>サンプルコードでは、MazeGame の例を Builder パターンを導入して書き直している。</p>
<ul class="simple">
<li>MazeBuilder クラスにメソッド群 BuildXXXX を定義するメリットは、
各 Product (Room, Door) の生成ロジックを隠蔽することにある。
&lt;異なる種類の迷路を作成する場合に MazeBuilder クラスを再利用できることを意味している&gt; (p. 110)</li>
<li>&lt;MazeBuilder クラスは迷路そのものを作るのではなく、
迷路作成のためのインターフェイスを定義しているにすぎない&gt; (p. 110)</li>
<li>&lt;しかし、Maze クラスを小さくしておくことで理解や修正が容易になるという利点があり、
また、StandardMazeBuilder クラスは Maze クラスから容易に分離することもできる。
もっと重要なことは、この 2 つを分離しておくことにより、
部屋、壁、ドアに対して、異なるクラスを使ってさまざまな
MazeBuilder クラスを作れるようになるという点である&gt; (p. 112)</li>
<li>Abstract Factory パターンは &lt;複合オブジェクトを作成するという点で Builder パターンに類似している&gt; (p. 114)</li>
</ul>
</div>
<div class="section" id="factory-method">
<h3><a class="toc-backref" href="#id11">Factory Method</a><a class="headerlink" href="#factory-method" title="Permalink to this headline">¶</a></h3>
<p>フレームワーク寄りのデザインパターンらしい。</p>
<ul>
<li><p class="first">フレームワークにしばしば見られる特徴 (p. 115):</p>
<ul class="simple">
<li>オブジェクト間の関係を表現するのに、抽象クラスを用いる。</li>
<li>（具象型のわからない）オブジェクトの生成を行う責任がある。</li>
</ul>
</li>
<li><p class="first">フレームワークの立場としては、&lt;Application クラスは Document
のどのサブクラスがインスタンス化されるのかを事前に知ることはできない&gt; (p. 115)
ので、Application クラスに Document を生成するオーバーライド可能な
メソッド CreateDocument を用意し、ユーザーにサブクラス型を返すような実装をさせる。</p>
<p>この CreateDocument みたいなものを一般に factory method と呼ぶ。</p>
</li>
<li><p class="first">&lt;クラス内部でオブジェクトを生成する場合、
直接生成するよりも factory method を使うほうが柔軟性を高める&gt; (p. 117)</p>
</li>
<li><p class="first">図形操作ツールの話 (pp. 118-119) が面白かったので、後でもう一回読んでみる。
Figure インタフェースに CreateManipulator (factory method) を与えておき、
各 Figure のサブクラスがそれに応じた Manipulator のサブクラスを生成する、
というトリック。</p>
</li>
<li><p class="first">Creator クラスを抽象クラスにして、factory method を空にする場合と、
Creator クラスを具象クラスにして、factory method にデフォルト実装を与える場合がある
(p. 118)</p>
</li>
<li><p class="first">Factory Method パターンの変形として、&lt;factory method が数種類の
ConcreteProduct オブジェクトを生成できるようにしておく&gt; (p. 119) ものがある。
種類を表すパラメータを取るようなメソッドにするらしい。</p>
<ul class="simple">
<li>この手法はシリアライズ実装で使うというようなことが書かれている。</li>
</ul>
</li>
<li><p class="first">言語によっては &lt;インスタンス化されるクラスを返すメソッド&gt; (p. 120) を使う。
オブジェクトではなく、クラス自体を返すということ。</p>
</li>
<li><p class="first">C++ では Creator クラスのコンストラクタ内で factory method を呼び出せない (p. 121)</p>
<p>そんなことをしたら実行時エラーが起こって即終了。</p>
</li>
<li><p class="first">C++ ではさらに &lt;テンプレートを用いてサブクラス化を避ける&gt; (p. 121) 技法も駆使したい。</p>
</li>
<li><p class="first">factory method には、見てそれとわかる名前を付けると便利 (p. 122)</p>
</li>
</ul>
<p>サンプルコードでは <tt class="docutils literal"><span class="pre">MazeGame::CreateMaze</span></tt> を factory method で実装している。</p>
<ul class="simple">
<li>&lt;factory method は、ツールキットやフレームワークの中で広く採用されている&gt; (p. 124)</li>
<li>Abstract Factory パターンは factory method を使って実装されることが多い (p. 125)</li>
</ul>
</div>
<div class="section" id="prototype">
<h3><a class="toc-backref" href="#id12">Prototype</a><a class="headerlink" href="#prototype" title="Permalink to this headline">¶</a></h3>
<p>既存インスタンスをコピーすることで新たなオブジェクトの生成を行うパターン。</p>
<ul>
<li><p class="first">「動機」に書いてあること</p>
<ul class="simple">
<li>Graphics: 音符、休止符、譜表、等々の図形オブジェクトを表現するための抽象クラス</li>
<li>Tool: ツールパレット上のツールを定義するための抽象クラス</li>
<li>GraphicTool: Graphics をドキュメントに追加するための Tool のサブクラス</li>
<li>&lt;GraphicTool クラスは、音符などのクラスのインスタンスを楽譜に加えるために
どのように生成したらよいのかを知らない&gt; (p. 127)</li>
<li>&lt;Graphic のサブクラスのインスタンスをクローン化して、
新たなオブジェクトを生成する方法&gt; (p. 127) によって得られるインスタンスのことを
<strong>prototype</strong> と呼ぶ。</li>
</ul>
</li>
<li><p class="first">&lt;Prototype パターンは、Client オブジェクトに対してインスタンス化する具象クラスを隠蔽している&gt; (p. 129)</p>
</li>
<li><p class="first">&lt;たとえば回路設計エディタでは、回路をいくつかの部分回路から作成するようになっている&gt; (p. 130)</p>
<p>つまり、部分回路が繰り返し使われる状況である可能性が高く、
そうなれば当パターンの守備範囲だ。</p>
</li>
<li><p class="first">&lt;C++ のようにクラスが first-class オブジェクトとして扱われない言語&gt; (p. 130)
にとっては、Creator のクラス階層を作らずに済む当パターンにメリットがある。</p>
</li>
<li><p class="first">&lt;prototype マネージャ&gt; (p. 130)</p>
</li>
<li><p class="first">&lt;その内部に複製をサポートしていないオブジェクトや
循環する参照を持つオブジェクトを含む場合&gt; (p. 131) 等、
prototype 各サブクラスで <tt class="docutils literal"><span class="pre">Clone</span></tt> を実装するのが困難な場合もある。</p>
</li>
</ul>
<p>実装ポイント</p>
<ul>
<li><p class="first">Prototype パターンは C++ のような静的な言語において有効なパターンである (p. 131)</p>
</li>
<li><p class="first">&lt;Client オブジェクトは prototype を直接扱うのではなく、
登録されている prototype オブジェクトを検索したり、
新たに登録したりする&gt; (p. 131)</p>
<p>prototype マネージャは連想配列ベースのデータ構造。</p>
</li>
<li><p class="first">&lt;もっとも困難な点は、Clone オペレーションを正しく実装することである&gt; (p. 131)</p>
<ul class="simple">
<li>&lt;複製を行うということを、元のインスタンス変数を共有させることにするのか、
またはインスタンス変数の複製を行うことにするのか&gt; (p. 131)</li>
<li>お手軽な Clone の実装例として、もしオブジェクトが Save/Load
オペレーションを提供しているのであれば、これで実装できると言っている (p. 132)</li>
</ul>
</li>
</ul>
<p>サンプルコードのページでは MazeFactory の Prototype パターン版を紹介。</p>
<ul class="simple">
<li>MazePrototypeFactory では
&lt;生成オブジェクトをあらかじめ prototype として持つように初期化&gt; (p. 132) する。<ul>
<li><tt class="docutils literal"><span class="pre">MazePrototypeFactory::MakeXXXX</span></tt> では XXXX 型メンバーデータの
prototype に対して <tt class="docutils literal"><span class="pre">Clone</span></tt> を呼び出し、戻り値をそのまま返す。<ul>
<li>場合によっては clone のパラメータを修正する。</li>
</ul>
</li>
<li>&lt;他の迷路を作成する場合には、MazePrototypeFactory オブジェクトを別の
prototype で初期化すればよい&gt; (p. 133)</li>
</ul>
</li>
<li>&lt;Client オブジェクトの側では、Clone オペレーションの返却値を
望む型にダウンキャストしなくてもよいようにしておくべきである&gt; (p. 135)</li>
</ul>
</div>
<div class="section" id="singleton">
<h3><a class="toc-backref" href="#id13">Singleton</a><a class="headerlink" href="#singleton" title="Permalink to this headline">¶</a></h3>
<p>ここは読まなくていいや。</p>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id14">まとめ</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>オブジェクトを生成するクラスをサブクラス化する方法<ul>
<li>Factory Method パターンを使うことに対応。</li>
</ul>
</li>
<li>生成するオブジェクトのクラスを把握しているオブジェクトを定義してから、
それをパラメータにする方法<ul>
<li>Abstract Factory, Builder, Prototype パターンの基本。
設計は柔軟だが、より複雑 (p. 146)</li>
</ul>
</li>
<li>図形エディタフレームワークを設計するのならば、
Factory Method パターンがもっとも使いやすいパターン (p. 145)
だが、GraphicTool のサブクラスが多く必要になる。</li>
<li>&lt;全般的に見て、Prototype パターンが図形エディタフレームワークにとって、
おそらく最適なパターンになるだろう&gt; (p. 146)
<tt class="docutils literal"><span class="pre">Graphic::Clone</span></tt> のオーバーライドだけでよいから。</li>
<li>&lt;Factory Method パターンを使うことで、
設計はカスタマイズが容易になると同時に若干複雑になる&gt; (p. 146)</li>
<li>設計の初期段階では Factory Method パターンを採用しておき、
様子を見て他のパターンに発展させていくやり方がよい (p. 146)</li>
</ul>
<p>どの方法も複雑であると言っている？</p>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id15">第 4 章 構造に関するパターン</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>&lt;クラスやオブジェクトを合成する方法に関係している&gt; (p. 147)
なるほど。構造イコール合成なのか。</li>
<li>構造に関するパターンも、「オブジェクトに適用するもの」と
「クラスに適用するもの」がある。
前者が動的で後者が静的な性質のものだということなのだろう。</li>
</ul>
<div class="section" id="adapter">
<h3><a class="toc-backref" href="#id16">Adapter</a><a class="headerlink" href="#adapter" title="Permalink to this headline">¶</a></h3>
<p>このセクションは他のパターンのそれに比べて妙に長く感じた。</p>
<ul class="simple">
<li>&lt;再利用を目的として設計されたツールキットクラスは、
そのインタフェースがアプリケーションの要求するドメインに特化した
インタフェースと一致しないというだけの理由で、
再利用できないことがある&gt; (p. 149) もったいない話だ。</li>
</ul>
<p>既存のツールキットクラス TextView をうまく再利用して、
LineShape や PolygonShape のテキスト版と言える
TextShape というクラスを定義できないかを議論している。</p>
<ul>
<li><p class="first">&lt;それに対して、テキストの表示と編集を行う TextShape クラスは、
基本的なテキスト編集の歳にも、複雑な画面の更新やバッファの管理などを
しなければならないため、実装はより困難であると考えられる&gt; (p. 149)</p>
</li>
<li><p class="first">&lt;しかし TextView クラスを変更するのは勧められない。
なぜならば、このツールキットが、ある 1 つのアプリケーションを動作させるため
だけに、ドメインに特化したインタフェースを採用したとすると、
このツールキット自体が汎用性を欠くものになってしまうからである&gt; (p. 149)</p>
</li>
<li><p class="first">ここでやりたいことは TextView を Shape に適合させること。</p>
<ul class="simple">
<li>方法 1: Shape のインタフェースと TextView の実装を継承したクラスを定義する。</li>
<li>方法 2: TextView を持ったクラスを定義し、それは Shape インタフェースを有する。</li>
</ul>
<p>→クラスに適用する Adapter と、オブジェクトに適用するパターン (p. 152)
があるということ。</p>
</li>
<li><p class="first">&lt;Shape のどのオブジェクトも、ユーザがインタラクティブにドラッグして
別の場所に移すことができるようになっているべきである。
ところが、TextView クラスは、それができるように設計されていない&gt; (p. 150)</p>
</li>
</ul>
<p>考慮すべき問題点を挙げている。</p>
<ul class="simple">
<li>何らかのインタフェースに一致させる作業が必要になるが、
&lt;作業の範囲は、オペレーションの名前を変えるだけの簡単なインタフェースの変更から、
まったく異なるオペレーションの集合をサポートすることまでが考えられる&gt; (p. 152)</li>
<li>&lt;インタフェースの適合機能が作りこまれているクラスを
<strong>pluggable adapter</strong> と呼んでいる&gt; (p. 153) の例として、
TreeDisplay を紹介している。<ul>
<li>異なる木構造は異なるインタフェースを持つことになるだろう。</li>
<li>言い換えると、TreeDisplay ウィジェットはインタフェース適合機能
を内部に組み込むべきなのである。</li>
</ul>
</li>
</ul>
<p>実装にも問題点が色々。</p>
<ul class="simple">
<li>C++ の場合、クラスに適合するタイプの Adapter では、
Adaptee 側クラスを private 継承する。ということは、
Adapter クラスは Adaptee クラスのサブクラスではなくなる (p. 154)</li>
<li>適合させなければならない最小限のオペレーションの集合を意識すること
(p. 154)</li>
</ul>
<p>サンプルコード。
&lt;オブジェクトを基にした adapter の方が、
コードの作成では若干の労力が必要になるが、
より柔軟なものになっている&gt; (p. 159)
ポイントは、TextView のサブクラスでも OK だというところ。</p>
<p>関連パターン。
&lt;アプリケーションにとっては、adapter よりも decorator の方が透過性が高い&gt; (p. 161)</p>
</div>
<div class="section" id="bridge">
<h3><a class="toc-backref" href="#id17">Bridge</a><a class="headerlink" href="#bridge" title="Permalink to this headline">¶</a></h3>
<p>最初に書いてある &lt;抽出したクラスと実装を分離&gt; の意味がわからない。</p>
<p>別名が Handle/Body とある。</p>
<p>動機ではクロスプラットフォームなウィンドウクラスライブラリの話を例に出している。</p>
<ul class="simple">
<li>&lt;さらに悪いことには、すべての種類のウィンドウに対して、
2 つずつ新たなクラスを定義していかなければならなくなるだろう&gt; (p. 163)</li>
<li>&lt;この Window クラスと WindowImp クラスの間の関係を <strong>bridge</strong> と呼ぶ&gt; (p. 164)</li>
</ul>
<p>適用可能性を見ると、クロスプラットフォーム以外にも使い途がある。
特に C++ で威力を発揮するケースがあるようだ。</p>
<ul>
<li><p class="first">&lt;クライアントのコードを再コンパイルしなくても済む&gt; (p. 165)</p>
</li>
<li><p class="first">&lt;クラスの実装をクライアントから完全に隠蔽したい場合。
C++ では、クラスの内部表現はクラスのインタフェイスで見ることができてしまう&gt; (p. 165)</p>
<p>Exceptional C++ とかで議論していた Pimpl パターンの話を思い出す。</p>
</li>
</ul>
<p>クラス構造を見ると一発で理解できる。</p>
<ul>
<li><p class="first">Implementor クラスが一種類しかない場合でも、
クラスの実装上の変化がクライアントに影響を与えることがあってはならない場合には、
Abstraction/Implementor 分離は有効 (p. 167)</p>
</li>
<li><p class="first">C++ の場合、Implementor の宣言を &lt;私的なヘッダファイル&gt; (p. 167) で行う。
要するにクライアントが include できないファイルで宣言する。</p>
</li>
<li><p class="first">Implementor の決定を他のオブジェクトに完全に委譲するという方法もある (p. 167)</p>
<p>例えば Implementor の決定を専用の factory が行うことにすると、
Abstraction クラスと Implementor クラスの結合も間接的になる。</p>
</li>
</ul>
<p>サンプルコードを検討すると、次のことに気付く。</p>
<ul>
<li><p class="first">Window のサブクラスのメソッドの実装は、
すべて WindowImp のメソッドで実装している。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 170</span>
<span class="kt">void</span> <span class="n">Window</span><span class="o">::</span><span class="n">DrawRect</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">){</span>
    <span class="n">WindowImp</span><span class="o">*</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">GetWindowImp</span><span class="p">();</span>
    <span class="n">imp</span><span class="o">-&gt;</span><span class="n">DeviceRect</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">X</span><span class="p">(),</span> <span class="n">p1</span><span class="p">.</span><span class="n">Y</span><span class="p">(),</span> <span class="n">p2</span><span class="p">.</span><span class="n">X</span><span class="p">(),</span> <span class="n">p2</span><span class="p">.</span><span class="n">Y</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">WindowImp のサブクラスでのメソッド実装は、そのプラットフォームの API で実装している。
例えば <tt class="docutils literal"><span class="pre">XWindowImp::DeviceRect</span></tt> は関数 <tt class="docutils literal"><span class="pre">XDrawRectanele</span></tt> で矩形を描画する、
といった具合だ。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Window::GetWindowImp</span></tt> は Abstract Factory パターンでインスタンスを取得している。</p>
</li>
</ul>
</div>
<div class="section" id="composite">
<h3><a class="toc-backref" href="#id18">Composite</a><a class="headerlink" href="#composite" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>&lt;オブジェクトを木構造に組み立てる&gt; (p. 175)</li>
<li>&lt;個々のオブジェクトとオブジェクトを合成したものを一様に扱うことができる&gt; (p. 175)</li>
<li>&lt;Composite パターンの特徴は、1 つの抽象クラスがプリミティブとコンテナの両方を表すことである&gt; (p. 175)</li>
<li>プリミティブの意味がよくわからんが、
&lt;プリミティブなオブジェクトは子を持たないため、
子オブジェクトに関するオペレーションは実装しない&gt; (p. 176)</li>
<li>&lt;Draw オペレーションをその子オブジェクトの Draw オペレーションを呼び出すように実装し、
またそれ以外にも、子オブジェクトに関連するオペレーションを実装する&gt; (p. 176)</li>
<li>&lt;Picture オブジェクトは別の Picture オブジェクトを再帰的に生成していくことができる&gt; (p. 176)</li>
<li>Component クラスにおいて、親にあたる composite にアクセスする
インタフェースを宣言するのはオプション (p. 177)</li>
<li>ある要求を composite が受け取ったとき、
&lt;通常、その要求を子にあたる component に転送し、
さらに転送の前後に付加的なオペレーションを実行することもある&gt; (p. 177)</li>
</ul>
<p>実装のセクションにある記述が濃い。</p>
<ul class="simple">
<li>親オブジェクトへの参照を持たせる場合、composite 構造の走査や管理が簡単になるが、
「ある composite のすべての子オブジェクトは、その親オブジェクトとしてそれを持つ」
という制約を壊さないように注意しないといけない (p. 178)</li>
<li>&lt;Component クラスでサポートされているが、
Leaf クラスには無意味なオペレーションも多く存在する&gt; (p. 179)</li>
<li>Add/Remove オペレーションをどのクラスで宣言するかは重要な問題。
この議論に 2 ページ近くを割いている。
普通は安全性を捨てて、透過性をとる方向に解決するのだろう。</li>
<li>多くの設計では、&lt;子オブジェクトの順番を明確にする&gt; (p. 182)</li>
<li>&lt;composite に、自身が削除されるときにその子オブジェクトの削除も
一緒に行わせるようにするのが、通常ではもっとも良い&gt; (p. 182)
が、子オブジェクトが共有されているような場合は話は別だ。</li>
</ul>
</div>
<div class="section" id="decorator">
<h3><a class="toc-backref" href="#id19">Decorator</a><a class="headerlink" href="#decorator" title="Permalink to this headline">¶</a></h3>
<p>&lt;サブクラス化よりも柔軟な機能拡張方法&gt; (p. 187) を動的に行えるようだ。</p>
<ul class="simple">
<li>&lt;クラス全体に対してではなく、個々のオブジェクトに責任を追加したくなることがある&gt; (p. 187)</li>
<li>いつぞやのスクロールバー付き枠付き TextView の例を持ちだしている。<ul>
<li>&lt;常にスクロールバーが必要とは限らない&gt;</li>
<li>&lt;必要になったときには ScrollDecorator オブジェクトを用いてスクロールバーを追加する&gt; (p. 188)</li>
</ul>
</li>
</ul>
<p>Decorator クラスの構造は、</p>
<ul class="simple">
<li>&lt;component または decorator への参照を保持する&gt;</li>
<li>&lt;Component クラスのインタフェースと一致したインタフェースを定義する&gt; (p. 189)</li>
</ul>
<p>の二点。</p>
<ul>
<li><p class="first">&lt;Decorator パターンを用いると、decorator を付けたりはずしたりして、
実行時に簡単に責任の追加や削除ができる&gt; (p. 190)</p>
<p>個人的には削除の例は見たことがない。</p>
</li>
<li><p class="first">&lt;1 つの単純なクラスを定義し、decorator を用いて機能を段階的に追加していく&gt; (p. 190)</p>
</li>
<li><p class="first">Component クラスを軽く保つことが重要。メンバーデータは極力サブクラスに持たせる (p. 191)</p>
</li>
<li><p class="first">&lt;Component クラスが本質的に重く、
そのため Decorator パターンを適用するにはコストがかかりすぎるような状況では
Strategy パターンを選択する方がよい&gt; (p. 191)</p>
</li>
</ul>
<p>サンプルコード。コンストラクタの呼び出し方にインパクトあり。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 194</span>
<span class="n">window</span><span class="o">-&gt;</span><span class="n">SetContents</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">BorderDecorator</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">ScrollDecorator</span><span class="p">(</span><span class="n">textView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>使用例。</p>
<ul class="simple">
<li>&lt;ストリームはほとんどの I/O 機構に存在する基本的な抽象概念である&gt; (p. 195)</li>
<li>decorator は adapter とは異なる。
責任を変えるだけで、インタフェースまでは変えない (p. 196)</li>
<li>オブジェクトを変化させる方法には、decorator と strategy の 2 通りが考えられる (p. 196)</li>
</ul>
</div>
<div class="section" id="facade">
<h3><a class="toc-backref" href="#id20">Facade</a><a class="headerlink" href="#facade" title="Permalink to this headline">¶</a></h3>
<p>後回し。</p>
</div>
<div class="section" id="flyweight">
<h3><a class="toc-backref" href="#id21">Flyweight</a><a class="headerlink" href="#flyweight" title="Permalink to this headline">¶</a></h3>
<p>このパターンは細かいオブジェクトの共有を目的とする。</p>
<ul class="simple">
<li>&lt;<strong>flyweight</strong> とは、複数の文脈で同時に利用され得る共有オブジェクトのことである&gt; (p. 207)<ul>
<li>文脈とは何か。</li>
<li>共有オブジェクトということは、状態の持ち方に特別な何かがありそうだ。</li>
</ul>
</li>
<li>&lt;ここでキーとなる概念は <strong>intrinsic</strong> 状態と <strong>extrinsic</strong> 状態の区別である&gt; (p. 208)<ul>
<li>intrinsic 状態は flyweight オブジェクトの内部に格納。<ul>
<li>文脈とは依存しない、独立した情報。</li>
<li>共有できる情報。</li>
</ul>
</li>
<li>extrinsic 状態は<ul>
<li>文脈に依存する情報。</li>
<li>共有できない情報。</li>
</ul>
</li>
<li>文書エディタの例で言うと、<ul>
<li>各文字が flyweight オブジェクトであり、</li>
<li>文字コードは intrinsic 状態。</li>
<li>座標位置、フォントは extrinsic 状態。</li>
</ul>
</li>
</ul>
</li>
<li>&lt;extrinsic 状態に依存する可能性のあるオペレーションは、
extrinsic 状態をパラメータとして渡される&gt; (pp. 208-209)</li>
</ul>
<p>適用可能性は、それを見極めるのがわかりやすいようだ。</p>
<ul>
<li><p class="first">非常に多くのオブジェクトを利用する。</p>
</li>
<li><p class="first">そのためにメモリ消費コストが高くつく。</p>
</li>
<li><p class="first">&lt;オブジェクトの状態を構成するほとんどの情報を extrinsic にできる&gt; (p. 209)</p>
</li>
<li><p class="first">あとはオブジェクトを共有できるかどうか。</p>
</li>
<li><p class="first">&lt;flyweight が機能するために必要な状態は、
intrinsic 状態か extrinsic 状態のどちらかに分類されなければならない&gt; (p. 211)</p>
</li>
<li><p class="first">flyweight オブジェクトは &lt;FlyweightFactory オブジェクトから入手しなければならない&gt; (p. 211)</p>
<p>便宜上 Factory という単語を使っているだけであって、
アクセスの度に常にオブジェクトを生成しているわけではない。</p>
</li>
<li><p class="first">&lt;格納コストをもっとも節約できるのは、オブジェクトが intrinsic 状態と
extrinsic 状態の両方についてかなりの量の情報を持ち、
しかも extrinsic 状態が格納されるのではなくて計算できる場合&gt; (p. 212)</p>
</li>
<li><p class="first">&lt;オブジェクトは共有されるので、クライアントがそれらを直接インスタンス化すべきではない&gt; (p. 212)</p>
</li>
<li><p class="first">&lt;オブジェクトの共有では、flyweight が不要になったときに（略）
何らかの形の参照数管理やガーベッジコレクションが必要になる&gt; (p. 213)</p>
</li>
</ul>
<p>サンプルコードの見どころは <tt class="docutils literal"><span class="pre">GlyphContext</span></tt> クラス。
一見しただけでは何を管理しているのか理解できない。</p>
<p>使用例</p>
<ul>
<li><p class="first">&lt;flyweight の概念は、InterViews 3.0 における設計テクニックとして初めて記述され、
研究された。その開発者は、この概念を立証するために、
Doc と呼ばれる強力な文書エディタを構築した&gt; (p. 218)</p>
<p>180000 文字を含む文書を 480 個の文字オブジェクトで賄えるケースがあったとか。</p>
</li>
</ul>
</div>
<div class="section" id="proxy">
<h3><a class="toc-backref" href="#id22">Proxy</a><a class="headerlink" href="#proxy" title="Permalink to this headline">¶</a></h3>
<p>&lt;オブジェクトの代理、または入れ物&gt; (p. 221)</p>
<ul>
<li><p class="first">&lt;そのオブジェクトを実際に利用する必要が生じるまで、
そのオブジェクトの生成と初期化にコストをかけるのを延期する&gt; (p. 221)</p>
</li>
<li><p class="first">&lt;生成に高いコストのかかるオブジェクトをすべて同時に生成するのは避けることにする&gt; (p. 221)</p>
</li>
<li><p class="first">&lt;文書の中には画像の代わりに何を置いておけばよいのだろうか&gt; (p. 221)</p>
</li>
<li><p class="first">&lt;要求があり次第画像が生成されるという事実を隠蔽するにはどうしたらよいのだろうか&gt; (p. 221)</p>
<p>→画像 proxy なるものを導入することで解決する。</p>
</li>
</ul>
<p>適用可能性として、4 種類の proxy を分類している。</p>
<ul>
<li><p class="first">remote proxy</p>
</li>
<li><p class="first">virtual proxy</p>
</li>
<li><p class="first">protection proxy: &lt;実オブジェクトへのアクセスを制御する&gt; (p. 223)</p>
<p>オブジェクトごとに異なるアクセス権が必要な場合に有用らしい。</p>
</li>
<li><p class="first">smart reference: &lt;通常のポインタに代わるもの&gt; (p. 223)</p>
</li>
</ul>
<p>結果の説明でコピーオンライトについて言及がある。</p>
<ul class="simple">
<li>&lt;もしコピーされたオブジェクトが変更されないのであれば、
このコストを発生させる必要はない。
コピーするプロセスを延期するために proxy を使えば、
そのオブジェクトが変更されたときにのみ、
そのオブジェクトをコピーすればよいようにできる&gt; (p. 225)</li>
</ul>
<p>実装</p>
<ul class="simple">
<li>&lt;メンバアクセスオペレータをオーバーロードする方法は、
どのような種類の proxy に対しても良い解決法になるとは限らない&gt; (p. 226)</li>
<li>&lt;Proxy クラスが RealSubject クラスをインスタンス化する場合（略）には、
Proxy クラスはその具象クラスを知っていなければならない&gt; (p. 227)</li>
</ul>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id23">まとめ</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Composite, Decorator, Proxy の比較 (p. 234) が面白かった。</p>
<ul class="simple">
<li>Decorator は退化した Composite ではない。<ul>
<li>両者は目的が異なっている。</li>
<li>ということは、相補的に利用できる。</li>
</ul>
</li>
<li>Decorator も Proxy も、クライアントに合成前のインタフェースと同じものを与えるが、
Proxy に関しては<ul>
<li>特性を動的に加えたりはずしたりしない。</li>
<li>再帰的な合成のために設計されていない。</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p><a class="reference internal" href="gamma95-note3.html"><em>オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 3/3</em></a> へ。</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート</a> &raquo;</li>
          <li><a href="gamma95.html" >オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a> &raquo;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="http://www.geocities.jp/showa_yojyo/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31"/></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br/>
        Copyright &copy; 1999-2014,
        <a href="about.html#about.feedback" title="問い合わせ先">プレハブ小屋</a>
        All rights reserved.
      </div>
      <div id="footer_spacer">
        <p>
          Last updated on 2014/08/10 (Sun) 20:57:31.
        </p>
      </div>
    </div>
  </body>
</html>