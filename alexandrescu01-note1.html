<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modern C++ Design 読書ノート 1/3 &mdash; 読書ノート v1.2.0</title>
    
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/twitter-button.js"></script>
    <link rel="top" title="読書ノート v1.2.0" href="index.html" />
    <link rel="up" title="Modern C++ Design 読書ノート" href="alexandrescu01.html" />
    <link rel="next" title="Modern C++ Design 読書ノート 2/3" href="alexandrescu01-note2.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート" href="alexandrescu01.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート v1.2.0</a> &raquo;</li>
          <li><a href="alexandrescu01.html" accesskey="U">Modern C++ Design 読書ノート</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="modern-c-design-1-3">
<h1><a class="toc-backref" href="#id7">Modern C++ Design 読書ノート 1/3</a><a class="headerlink" href="#modern-c-design-1-3" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Andrey Alexandrescu</td>
</tr>
<tr class="field-even field"><th class="field-name">訳者:</th><td class="field-body">村上雅章</td>
</tr>
<tr class="field-odd field"><th class="field-name">出版社:</th><td class="field-body">ピアソン・エデュケーション</td>
</tr>
<tr class="field-even field"><th class="field-name">ISBN:</th><td class="field-body">4-89471-435-3</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#modern-c-design-1-3" id="id7">Modern C++ Design 読書ノート 1/3</a><ul>
<li><a class="reference internal" href="#id2" id="id8">ローマ数字ページ各種</a></li>
<li><a class="reference internal" href="#id3" id="id9">第 1 章 ポリシーを基にしたクラス・デザイン</a></li>
<li><a class="reference internal" href="#id4" id="id10">第 2 章 テクニック</a></li>
<li><a class="reference internal" href="#id5" id="id11">第 3 章 タイプリスト</a></li>
<li><a class="reference internal" href="#id6" id="id12">第 4 章 小規模オブジェクトの割り当て</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id8">ローマ数字ページ各種</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>本書推薦その 1 は Scott Meyers が寄せている。
言うまでもなく Effective C++ シリーズの著者だ。<ul>
<li>&lt;パターン自身をコード化するのではなく、パターンの実装を自動的に生成させる&gt; (p. x)</li>
</ul>
</li>
<li>推薦その 2 は John Vlissides が寄せている。GoF の一人。<ul>
<li>&lt;テンプレート・パラメータによって、実行時のオーバーヘッドをまったく発生させずに、
実装上のトレード・オフを変えることもできるのです&gt; (p. xiii)</li>
</ul>
</li>
<li>著者によるまえがきで、本書の目的を明瞭に示している。<ul>
<li>対象読者タイプ 1: &lt;C++ プログラマ経験者で最新のライブラリ作成テクニックをマスターしたいと考えている方々&gt;</li>
<li>対象読者タイプ 2: &lt;忙しいプログラマで手っ取り早く作業を済ませてしまう必要がある方々&gt; (p. xviii)</li>
<li>&lt;Loki という実在する C++ ライブラリ&gt; (p. xviii) を解説する本である。</li>
<li>本書中のコード例では、Herb Sutter 式コーディング規則を採用。
もしかして Exceptional C++ Style が関係ある？</li>
</ul>
</li>
<li>訳者まえがき<ul>
<li>&lt;ある種の意思決定は実装段階でなければ行えない&gt; (p. xxiii)</li>
<li>&lt;センス・オブ・ワンダーの渦巻く C++ の新世界をお楽しみ下さい&gt;</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">第 1 章 ポリシーを基にしたクラス・デザイン</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>ポリシーとポリシー・クラスとは、重要なクラス設計技術のひとつらしい。</li>
<li><strong>ポリシー</strong> とは、&lt;特定の動作や構造上の側面を専門的に受け持った小さなクラス群&gt; (p. 3) のこと。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;プログラミングの天才が若年層に分布しているのに対して、
ソフトウェア設計の天才がより高年齢層に分布する傾向にある&gt; (p. 4)</li>
<li>&lt;システム・アーキテクチャには、「設計によってある種の公理を強制する」という
重要な目標があります&gt; (p. 4)</li>
<li>&lt;理想的には、設計によって課された制約のほとんどが、コンパイル時点で強制されるべきなのです&gt; (p. 4)</li>
<li>&lt;組み合わせ爆発と真っ向勝負を挑んではいけない&gt; (p. 5)</li>
<li>&lt;設計指向のライブラリ&gt; (p. 5)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;いくつかの吟味された基底クラスを用意しておき、
多重継承によって設計の選択における組み合わせの爆発を取り扱うというアイディアが考えられます。
（略）しかし、少しでもクラス設計の経験があれば、
こういった単純な設計がうまく機能しないことは理解できるでしょう&gt; (p. 6)</li>
<li>&lt;クラス・テンプレートは、通常のクラスではサポートされていないような方法でカスタマイズすることが可能です。
もし特殊なケースを実装したいのであれば、特定のクラス・テンプレートを生成する際に、
そのテンプレートにおける任意のメンバ関数を特殊化することができるのです。
例えば、 <tt class="docutils literal"><span class="pre">SmartPtr&lt;T&gt;</span></tt> というテンプレートがある場合、
<tt class="docutils literal"><span class="pre">Smart&lt;Widget&gt;</span></tt> における任意のメンバ関数を特殊化することができるわけです&gt; (p. 6)</li>
<li>&lt;さらに、多重パラメータのクラス・テンプレートを用いた場合、
部分的にテンプレートの特殊化を行うこともできます&gt; (p. 6)</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// こういう定義がある場合、</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">SmartPtr</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>

<span class="c1">// この定義は部分特殊化となる。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">SmartPtr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;多重継承とテンプレートには相補的なトレード・オフが存在しています&gt; (p. 7)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>ポリシーは traits と通じるものがあるが、型ではなく動作を強調する点が異なる。</li>
<li>ポリシーは「コンパイル時 Strategy パターン」と見ることもできる。</li>
<li>&lt;ポリシーは、シグネチャ指向ではなく、シンタックス指向なのです&gt; (p. 8)
&lt;例えば、 <tt class="docutils literal"><span class="pre">Creator</span></tt> ポリシーでは <tt class="docutils literal"><span class="pre">Create</span></tt> が static であるか virtual であるかを規定しません&gt; (p. 8)</li>
<li><strong>ホスト</strong> または <strong>ホスト・クラス</strong> とは、1 つ以上のポリシーを利用するクラスのことを指す。</li>
</ul>
<hr class="docutils" />
<p>テンプレート・パラメータに <tt class="docutils literal"><span class="pre">template</span></tt> を用いる技法が紹介されている。
自分ではこういうクラスを定義することはないが、利用する可能性があるので覚えておくこと。</p>
<ul class="simple">
<li>ポリシーを使用することで得られる柔軟性<ul>
<li>実体化する際のテンプレート引数を変更するだけで、簡単に外部からポリシーを変更できる。</li>
<li>アプリケーションに特化した自作ポリシーを提供できる。</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>ポリシー・クラスのデストラクタについて言及あり。</p>
<ul class="simple">
<li>ポリシーに対してデストラクタを virtual にすると、ポリシーの性質が静的ではなくなる。
効率のよい解決策としては、デストラクタを非 virtual かつ protected とする。</li>
</ul>
<hr class="docutils" />
<p>「不完全実体化」の技法について解説あり。</p>
<p>「あるクラス・テンプレートのメンバ関数が使用されない場合、
それは実体化されることがない」すなわちコンパイルエラーが起こらない。</p>
<hr class="docutils" />
<ul>
<li><p class="first">&lt;ポリシーに基づいたクラス設計を行う上で最も難しいのは、
クラスの機能を正しくポリシーへと分解することです&gt; (p. 20)</p>
</li>
<li><p class="first">&lt;極端に言えば、ホスト・クラスから固有のポリシーを完全に無くしてしまうのです&gt; (p. 20)</p>
</li>
<li><p class="first">&lt;過度に一般化されたホスト・クラスの欠点は、
テンプレート・パラメータが氾濫するということです&gt; (p. 20)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">typedef</span></tt> の使用によって、秩序だった使用と容易な保守性が保証される。</p>
</li>
<li><p class="first">&lt;クラスをポリシーに分解する際、
<strong>直交性のある</strong> (orthogonal) 切り口を見つけ出すことが大変重要になります&gt; (p. 21)</p>
<p>&lt;お互いが完全に独立した&gt; (p. 21) 役割になるように、
ポリシー分割するのがよいということだな。
あるポリシーが別のポリシーに干渉するようではまずい。</p>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id10">第 2 章 テクニック</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>静的チェックの必要性。すなわち、コンパイル時版 <tt class="docutils literal"><span class="pre">assert</span></tt> だ。
&lt;評価される式がコンパイル時の定数になるのであれば、
実行時ではなく、コンパイル時にチェックを行うことができるはずです&gt; (p. 26)</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">CompileTimeError</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">CompileTimeError</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">{};</span>

<span class="cp">#define STATIC_CHECK(expr) \</span>
<span class="cp">   (CompileTimeError&lt;(expr) != 0&gt;())</span>
</pre></div>
</div>
<ul class="simple">
<li>上記のマクロからスタートし、エラーメッセージをなるべく読み易くするように工夫を重ねていく。</li>
<li>省略記号 <tt class="docutils literal"><span class="pre">(...)</span></tt> を用いた関数宣言を利用する。</li>
</ul>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Window</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Controller</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Widget</span>
<span class="p">{</span>
   <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// テンプレート全体を明示的に特殊化する場合の例。</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">class</span> <span class="nc">Widget</span><span class="o">&lt;</span><span class="n">ModalDialog</span><span class="p">,</span> <span class="n">MyController</span><span class="o">&gt;</span>
<span class="p">{</span>
   <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// 任意の Window や MyController に対して特殊化する場合（部分特殊化）。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Window</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Widget</span><span class="o">&lt;</span><span class="n">Window</span><span class="p">,</span> <span class="n">MyController</span><span class="o">&gt;</span>
<span class="p">{</span>
   <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;クラス・テンプレートの部分的な特殊化では、テンプレート引数の一部だけを記述し、
その他の引数を元のままにしておく&gt; (p. 29)</li>
<li>&lt;テンプレートの部分的な特殊化は、メンバ関数、非メンバ関数を問わず、
関数には適用されません&gt; (p. 30) が、こういう場合は関数のオーバーロードを併用する。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>ローカルクラスの話題だが、他のプログラミング言語を知っている人間なら驚かないかも。</li>
<li>ローカルクラスの特徴<ul>
<li>ローカルクラスでは static メンバを定義できない。</li>
<li>ローカルクラスから（それを含む関数定義内にある）非 static のローカル変数にアクセスできない。</li>
<li>関数テンプレート内でローカルクラスを定義することができ、
それを囲んでいる関数のテンプレート・パラメータを用いることもできる。</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">v</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Int2Type</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span> <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>例えば &lt;<tt class="docutils literal"><span class="pre">Int2Type&lt;0&gt;</span></tt> と <tt class="docutils literal"><span class="pre">Int2Type&lt;1&gt;</span></tt> は異なった型&gt; (p. 31) となる。
このようなクラスの応用例として、p. 33 の <tt class="docutils literal"><span class="pre">NiftyContainer::DoSomething</span></tt> を覚えておくこと。</li>
</ul>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Type2Type</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">OriginalType</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Type2Type</span></tt> もオーバーロード関数の仮引数の型としてだけ利用する。
p. 35 の関数テンプレート <tt class="docutils literal"><span class="pre">Create</span></tt> のオーバーロードに注目。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;ブーリアン定数によって様々な型から特定の型を選択しなければならない場合&gt; (p. 35)</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">flag</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Select</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Select</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="n">U</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isPolymorphic</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">NiftyContainer</span>
<span class="p">{</span>
  <span class="c1">// ここでコンテナの収容型を typedef するのに</span>
  <span class="c1">// Select を利用できる。</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<ul class="simple">
<li>&lt;何も情報が与えられていない 2 つの型 <tt class="docutils literal"><span class="pre">T</span></tt> と <tt class="docutils literal"><span class="pre">U</span></tt> がある場合、
<tt class="docutils literal"><span class="pre">U</span></tt> が <tt class="docutils literal"><span class="pre">T</span></tt> を継承しているかどうか、そのようにすれば判るのでしょうか&gt; (p. 37)</li>
<li>&lt;任意の型 <tt class="docutils literal"><span class="pre">T</span></tt> が任意の型 <tt class="docutils literal"><span class="pre">U</span></tt> への自動変換をサポートしているかどうかは、
どのように検出すればよいのでしょうか&gt; (p. 37)</li>
<li>脚注にいいことが書いてある。
&lt;<tt class="docutils literal"><span class="pre">sizeof</span></tt> はいずれにしても型を検出しなければならないため、
<tt class="docutils literal"><span class="pre">typeof</span></tt> と <tt class="docutils literal"><span class="pre">sizeof</span></tt> は明らかに同じバックエンドを共有しているのです&gt; (p. 37)</li>
<li>解決策は、まず p.38 のアイディアをコードに落として、
それから p. 39 のクラステンプレート <tt class="docutils literal"><span class="pre">Conversion</span></tt> の中にすべて閉じ込めるというもの。
省略記号をとる関数オーバーロード、
定義なし関数宣言と <tt class="docutils literal"><span class="pre">sizeof</span></tt> のペアをうまく組み合わせている。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">typeid</span></tt> 演算子とは、 <tt class="docutils literal"><span class="pre">type_info</span></tt> オブジェクトへの参照を返すものです&gt; (p. 40)
個人的にはこれまでの C++ 経験で <tt class="docutils literal"><span class="pre">typeid</span></tt> を利用した記憶がない。</li>
<li><tt class="docutils literal"><span class="pre">type_info</span></tt> の特徴 (p. 41)<ul>
<li><tt class="docutils literal"><span class="pre">name</span></tt> というメンバ関数があるが、クラス名を文字列に対応づける方法は標準化されていない。</li>
<li><tt class="docutils literal"><span class="pre">before</span></tt> メンバ関数が <tt class="docutils literal"><span class="pre">type_info</span></tt> 型の順序関係を定義する。</li>
<li>コピーコンストラクタと代入演算子が無効化されている。
何が言いたいかというと、「値」を何か変数に格納できないということ。</li>
<li><tt class="docutils literal"><span class="pre">typeid</span></tt> が返すオブジェクトは静的記憶域内に存在する。</li>
</ul>
</li>
<li>つかいにくいので、ラッパークラスを定義する。</li>
</ul>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NullType</span><span class="p">{};</span>
<span class="k">struct</span> <span class="n">EmptyType</span><span class="p">{};</span> <span class="c1">// 継承を許す。</span>
</pre></div>
</div>
<hr class="docutils" />
<ul>
<li><p class="first">&lt;特性 (traits) とは、値に基づく決定が実行時に行えるのと同様に、
型に基づく決定をコンパイル時に行えるようにするジェネリックなプログラミング・テクニックです
(Alexandrescu 2000a)&gt; (p. 43)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">std::copy</span></tt> の実装にこの技法が採用されていることが多いようだ。</p>
</li>
<li><p class="first">&lt;ある型 <tt class="docutils literal"><span class="pre">T</span></tt> のオブジェクトを引数として関数間で授受する場合、（略）
一般的に最も効率の良い方法とは、複雑な型を参照で、
スカラ型は値で引き渡すことです&gt; (p. 46)</p>
</li>
<li><p class="first">&lt;ここで注意が必要なのは、C++ では参照への参照が許されないという点です&gt; (p. 47)</p>
<p><tt class="docutils literal"><span class="pre">std::bind2nd</span></tt> と <tt class="docutils literal"><span class="pre">std::mem_fun</span></tt> を組み合わせた場合に、
このエラーが発生することも言及している。</p>
</li>
<li><p class="first">&lt;型が <tt class="docutils literal"><span class="pre">enum</span></tt> かどうかを判断する方法は存在しない&gt; (p. 47)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">enum</span></tt> と言えば、p. 49 のコードを見て知ったが、
関数定義の中で <tt class="docutils literal"><span class="pre">enum</span></tt> を定義できるようだ。</p>
</li>
</ul>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id11">第 3 章 タイプリスト</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>この章を真面目に読めば読むほどつかれる。
理解できなくて構わないから、気になるところだけ書き留めておく。</p>
<hr class="docutils" />
<ul class="simple">
<li>&lt;Abstract Factory では、設計時点で確定している型毎に、1 つずつ仮想関数を定義します&gt; (p. 53)
「設計時点で確定している型毎」というのがミソ。
Abstract Factory をライブラリー化しづらいことを示唆している。</li>
<li>&lt;根幹となるコンセプトを一般化することができなければ、
そのコンセプトの具体的な実体も一般化することができません&gt; (p. 54)</li>
<li>&lt;テンプレート・パラメータの数を可変にすることはできない&gt; (p. 55)</li>
<li>&lt;仮想関数はテンプレートにできない&gt; (p. 55) 言われてみればそうだった。</li>
</ul>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Typelist</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">Head</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">U</span> <span class="n">Tail</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;テンプレート・パラメータには、同じテンプレートの別な実体化を含む任意の型を指定できる&gt; (p. 56)
ので、 <tt class="docutils literal"><span class="pre">U</span></tt> をガンガン入れ子にすることで <tt class="docutils literal"><span class="pre">Typelist</span></tt> を伸ばす。</li>
</ul>
<hr class="docutils" />
<p>&lt;タイプリストは Lisp 的&gt; (p. 57) なので、色々補助的なマクロを用意する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Typelist</span><span class="o">&lt;</span><span class="kt">signed</span> <span class="kt">char</span><span class="p">,</span>
      <span class="n">Typelist</span><span class="o">&lt;</span><span class="kt">short</span> <span class="kt">int</span><span class="p">,</span>
         <span class="n">Typelist</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Typelist</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">int</span><span class="p">,</span> <span class="n">NullType</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
   <span class="n">SignedIntegrals</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define TYPELIST_1(T1) Typelist&lt;T1, NullType&gt;</span>
<span class="cp">#define TYPELIST_2(T1, T2) Typelist&lt;T1, Typelist_1(T2) &gt;</span>
<span class="p">...</span>

<span class="k">typedef</span> <span class="n">TYPELIST_4</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">)</span>
   <span class="n">SignedIntegrals</span><span class="p">;</span>
</pre></div>
</div>
<hr class="docutils" />
<p>以下、延々と「コンパイル時に <tt class="docutils literal"><span class="pre">Typelist</span></tt> の情報を得る機能」の実装が続く。</p>
<ul class="simple">
<li>&lt;C++ でコンパイル時プログラミングに用いることができる道具は、
テンプレート、コンパイル時の整数計算、型定義 (<tt class="docutils literal"><span class="pre">typedef</span></tt>) です&gt; (p. 59)</li>
<li>&lt;C++ 自体は命令型言語に限りなく近い位置づけなのですが、
コンパイル時に行われる全ての計算処理は、
値の変更を行うことができない関数型言語を思い出させるようなテクニックに頼らなければならないわけです&gt; (p. 59)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;単純に線形化されたものとしてタイプリストにアクセスすることができれば、
タイプリスト操作が用意になるはずです&gt; (p. 60)</li>
<li>&lt;しかし、タイプリストの場合、こういった時間はコンパイル中に発生するものであり、
コンパイル時間というものはある意味「無料」なのです&gt; (p. 61) とあるが、
脚注で言い訳しているように、現場でコンパイル時間をタダとみなせるようなことはない。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;再帰を用いて古典的な線形探索を実装する&gt; (p. 61) ことで、
タイプリストから型を検索する機能を記述できる。</li>
</ul>
<hr class="docutils" />
<p>残りはザッと読み流してよいが、次のトピックは後で読み返すことになる。</p>
<ul class="simple">
<li>タイプリストを部分的に並び替える。
特に、型を継承階層の下層から順に並び替えたりする機能
(<tt class="docutils literal"><span class="pre">struct</span> <span class="pre">DerivedToFront</span></tt>, <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">MostDerived</span></tt>)</li>
<li>タイプリストを利用して、クラス階層を一気に構築する機能
(<tt class="docutils literal"><span class="pre">GenScatterHierarchy</span></tt>, <tt class="docutils literal"><span class="pre">Tuple</span></tt>, <tt class="docutils literal"><span class="pre">GenLinearHierarchy</span></tt>)</li>
</ul>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id12">第 4 章 小規模オブジェクトの割り当て</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>以下のノートでは <tt class="docutils literal"><span class="pre">std::size_t</span></tt> を単に <tt class="docutils literal"><span class="pre">size_t</span></tt> と書く。</p>
<ul class="simple">
<li>この章で言う小規模オブジェクトとは、数バイト程度のメモリーを消費するものらしい。</li>
<li><tt class="docutils literal"><span class="pre">operator</span> <span class="pre">new</span></tt> と <tt class="docutils literal"><span class="pre">operator</span> <span class="pre">delete</span></tt> は &lt;汎用目的の演算子であり、
小規模オブジェクトの割り当てには向いていない&gt; (p. 83)
本章で紹介するアロケータは、それらよりも処理速度は数段優れ、
メモリー消費も半分以下だと豪語している。</li>
</ul>
<hr class="docutils" />
<p>デフォルトのアロケータについて。</p>
<ul class="simple">
<li>&lt;通常の場合、デフォルトのアロケータというものが、C のヒープアロケータを薄い
ラッパで包み込んだ形で実装されているため&gt; (p. 84) 恐ろしく遅い。</li>
<li>遅いだけでなく、&lt;小規模オブジェクトに対するスペース効率も非常に悪い&gt; (p. 84)
管理用のメモリを余分に食うためとのこと。</li>
</ul>
<hr class="docutils" />
<p>「メモリ・アロケータの作業」に書かれているメモリレイアウトの理解が面倒。パス。</p>
<hr class="docutils" />
<ul class="simple">
<li>本章で解説している小規模オブジェクト・アロケータは 4 層構造。
下位層から上位層へ向かって <tt class="docutils literal"><span class="pre">Chunk</span></tt>, <tt class="docutils literal"><span class="pre">FixedAllocator</span></tt>,
<tt class="docutils literal"><span class="pre">SmallObjAllocator</span></tt>, <tt class="docutils literal"><span class="pre">SmallObject</span></tt> となっている。</li>
</ul>
<hr class="docutils" />
<p><tt class="docutils literal"><span class="pre">Chunk</span></tt> は「固定長ブロックを保持するメモリのチャンク」を保持・管理する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 87 より引用。細部省略。</span>
<span class="k">struct</span> <span class="n">Chunk</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Init</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">blockSize</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">blocks</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="nf">Allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">blockSize</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">blockSize</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Release</span><span class="p">();</span>

    <span class="n">unsinged</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pData_</span><span class="p">;</span>
    <span class="n">unsinged</span> <span class="kt">char</span> <span class="n">firstAvailableBlock_</span><span class="p">;</span>
    <span class="n">unsinged</span> <span class="kt">char</span> <span class="n">blocksAvailable_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>関数の引数にやたらサイズがあるのは、&lt;上位層がブロック・サイズを管理するべき&gt; (p. 88) だから。</li>
<li>&lt;効率性を考慮し、 <tt class="docutils literal"><span class="pre">Chunk</span></tt> にはコンストラクタ、デストラクタ、代入演算子を定義しません&gt; (p. 88)</li>
<li>255 (<tt class="docutils literal"><span class="pre">UCHAR_MAX</span></tt>) ブロック以上のチャンクを保持できないことに注意。</li>
<li>&lt;未使用ブロックの最初のバイトには、次の未使用ブロックのインデックスを保持します&gt; (p. 88)
例えば <tt class="docutils literal"><span class="pre">Chunk::Init</span></tt> の実装で <tt class="docutils literal"><span class="pre">pData_[i</span> <span class="pre">*</span> <span class="pre">blockSize]</span> <span class="pre">==</span> <span class="pre">(i</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">blockSize</span></tt>
となるように配列の中身を埋める。</li>
<li><tt class="docutils literal"><span class="pre">Chunk::Allocate</span></tt> の実装を見ると、処理時間は O(1) になっているようだ。
必然的に <tt class="docutils literal"><span class="pre">Chunk::Deallocate</span></tt> も O(1) になる。</li>
</ul>
<hr class="docutils" />
<p><tt class="docutils literal"><span class="pre">FixedAllocator</span></tt> は <tt class="docutils literal"><span class="pre">Chunk</span></tt> の <tt class="docutils literal"><span class="pre">vector</span></tt> として実装する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 91 より引用。</span>
<span class="k">class</span> <span class="nc">FixedAllocator</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">blockSize_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">numBlocks_</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Chunk</span><span class="o">&gt;</span> <span class="n">Chunks</span><span class="p">;</span>
    <span class="n">Chunks</span> <span class="n">chunks_</span><span class="p">;</span>
    <span class="n">Chunk</span><span class="o">*</span> <span class="n">allocChunk_</span><span class="p">;</span>
    <span class="n">Chunk</span><span class="o">*</span> <span class="n">deallocChunk_</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">allocChunk_</span></tt> は「前回の割り当てに使用したチャンク」とする。
これに余裕がまだあれば、次の割り当てでもここを使用することで効率化できる。</li>
<li><tt class="docutils literal"><span class="pre">deallocChunk_</span></tt> 「直前に開放されたチャンク」だが、扱いがちょっと難しい。</li>
</ul>
<hr class="docutils" />
<p>&lt;<tt class="docutils literal"><span class="pre">SmallObjAllocator</span></tt> は、いくつかの
<tt class="docutils literal"><span class="pre">FixedAllocator</span></tt> オブジェクトを集約することによって実現されています&gt; (p. 94)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pp. 94-95 参照。</span>
<span class="k">class</span> <span class="nc">SmallObjAllocator</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FixedAllocator</span><span class="o">&gt;</span> <span class="n">pool_</span><span class="p">;</span>
    <span class="n">FixedAllocator</span><span class="o">*</span> <span class="n">pLastAlloc_</span><span class="p">;</span>
    <span class="n">FixedAllocator</span><span class="o">*</span> <span class="n">pLastDealloc_</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">SmallObjAllocator</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">chunkSize</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">maxObjectSize</span><span class="p">);</span>

    <span class="kt">void</span><span class="o">*</span> <span class="nf">Allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">numBytes</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Deallocate</span></tt> の引数のサイズが、ここでは「解放するサイズ」を意味する。
高速に解放するため。</li>
<li>&lt;「効率的な」やり方は、常に「効率的な」やり方とは限らない&gt; (p. 95)</li>
<li>&lt;メモリ保持のために若干探索速度を犠牲にする&gt; (p. 95) ことにした。</li>
<li><tt class="docutils literal"><span class="pre">pool_</span></tt> をブロックサイズに従ってソートしておくと、バイナリ・サーチが適用できる。</li>
</ul>
<hr class="docutils" />
<p><tt class="docutils literal"><span class="pre">SmallObject</span></tt> はほぼ教科書通りのインターフェイスになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 96</span>
<span class="k">class</span> <span class="nc">SmallObject</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">SmallObject</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>デストラクタは仮想でなければならない。
理由は <tt class="docutils literal"><span class="pre">operator</span> <span class="pre">delete</span></tt> に引き渡されるサイズを正しくさせるため。</li>
<li><tt class="docutils literal"><span class="pre">operator</span> <span class="pre">new</span></tt> の実装で <tt class="docutils literal"><span class="pre">SmallObjAllocator::Allocate</span></tt> を利用する。
また <tt class="docutils literal"><span class="pre">operator</span> <span class="pre">delete</span></tt> で <tt class="docutils literal"><span class="pre">SmallObjAllocator::Deallocate</span></tt> を利用する。</li>
<li>ということは、 <tt class="docutils literal"><span class="pre">SmallObjAllocator</span></tt> はシングルトンでなければならない。</li>
</ul>
<hr class="docutils" />
<p>各種ポリシーをくっつけて <tt class="docutils literal"><span class="pre">SmallObject</span></tt> をクラステンプレートにして仕上がる。
本章ではここまでテンプレートがなかなか出てこなかった感があるが、ここでようやく登場。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 100 より引用。</span>
<span class="k">template</span>
<span class="o">&lt;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">class</span> <span class="nc">ThreadingModel</span> <span class="o">=</span> <span class="n">DEFAULT_THREADING</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">chunkSize</span> <span class="o">=</span> <span class="n">DEFAULT_CHUNK_SIZE</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">maxSmallObjectSize</span> <span class="o">=</span> <span class="n">MAX_SMALL_OBJECT_SIZE</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SmallObject</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;保守的ということは最適ではないということを意味しているのです&gt; (p. 101)</li>
</ul>
<hr class="docutils" />
<p><a class="reference internal" href="alexandrescu01-note2.html"><em>Modern C++ Design 読書ノート 2/3</em></a> へ。</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート v1.2.0</a> &raquo;</li>
          <li><a href="alexandrescu01.html" >Modern C++ Design 読書ノート</a> &raquo;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_share">
        <a href="https://twitter.com/share" class="twitter-share-button" data-size="large">Tweet</a>
        <script type="text/javascript">render_twitter_button(document, 'script', 'twitter-wjs')</script>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2014, プレハブ小屋 All rights reserved.
      </div>
      <div id="footer_spacer">
        <p>
          Last updated at 2014/11/06 (Thu) 23:22:09.
        </p>
      </div>
    </div>
  </body>
</html>