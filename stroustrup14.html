
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>C++ のエッセンス 読書ノート &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/mathjax-v3.js"></script>
    
    <link rel="next" title="その数式、プログラムできますか？ 読書ノート" href="stepanov15.html" />
    <link rel="prev" title="ハイパフォーマンス Python 読書ノート" href="gorelick14.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="stepanov15.html" title="その数式、プログラムできますか？ 読書ノート"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="gorelick14.html" title="ハイパフォーマンス Python 読書ノート"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">C++ のエッセンス 読書ノート</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="c">
<h1><a class="toc-backref" href="#id137">C++ のエッセンス 読書ノート</a><a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h1>
<p>C++ 創始者の B. Stroustrup 氏による基本書の抄録翻訳版という位置づけなのだろうか。</p>
<dl class="field-list simple">
<dt class="field-odd">著者</dt>
<dd class="field-odd"><p>Bjarne Stroustrup</p>
</dd>
<dt class="field-even">訳者</dt>
<dd class="field-even"><p>柴田 望洋</p>
</dd>
<dt class="field-odd">出版社</dt>
<dd class="field-odd"><p>SB クリエイティブ株式会社</p>
</dd>
<dt class="field-even">発行年</dt>
<dd class="field-even"><p>2015 年</p>
</dd>
<dt class="field-odd">ISBN</dt>
<dd class="field-odd"><p>978-4-7973-8477-2</p>
</dd>
<dt class="field-even">関連 URL</dt>
<dd class="field-even"><p><a class="reference external" href="https://www.sbcr.jp/product/4797384772/">C++のエッセンス | SBクリエイティブ</a></p>
</dd>
</dl>
<div class="contents topic" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c" id="id137">C++ のエッセンス 読書ノート</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id138">第 1 章 基本</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id139">1.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id140">1.2 プログラム</a></p></li>
<li><p><a class="reference internal" href="#hello-world" id="id141">1.3 Hello, World!</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id142">1.4 関数</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id143">1.5 型と変数と算術演算</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id144">1.6 スコープと生存期間</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id145">1.7 定数</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id146">1.8 ポインタと配列と参照</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id147">1.9 判定</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id148">1.10 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id12" id="id149">第 2 章 ユーザー定義型</a></p>
<ul>
<li><p><a class="reference internal" href="#id13" id="id150">2.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id151">2.2 構造体</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id152">2.3 クラス</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id153">2.4 共用体</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id154">2.5 列挙体</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id155">2.6 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id19" id="id156">第 3 章 モジュール性</a></p>
<ul>
<li><p><a class="reference internal" href="#id20" id="id157">3.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id21" id="id158">3.2 分割コンパイル</a></p></li>
<li><p><a class="reference internal" href="#id22" id="id159">3.3 名前空間</a></p></li>
<li><p><a class="reference internal" href="#id23" id="id160">3.4 エラー処理</a></p>
<ul>
<li><p><a class="reference internal" href="#id24" id="id161">3.4.1 例外処理</a></p></li>
<li><p><a class="reference internal" href="#id25" id="id162">3.4.2 不変条件</a></p></li>
<li><p><a class="reference internal" href="#id26" id="id163">3.4.3 静的アサーション</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id27" id="id164">3.5 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id28" id="id165">第 4 章 クラス</a></p>
<ul>
<li><p><a class="reference internal" href="#id29" id="id166">4.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id30" id="id167">4.2 具象型</a></p>
<ul>
<li><p><a class="reference internal" href="#id31" id="id168">4.2.1 算術型</a></p></li>
<li><p><a class="reference internal" href="#id32" id="id169">4.2.2 コンテナ</a></p></li>
<li><p><a class="reference internal" href="#id33" id="id170">4.2.3 コンテナの初期化</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id34" id="id171">4.3 抽象クラス</a></p></li>
<li><p><a class="reference internal" href="#id35" id="id172">4.4 仮想関数</a></p></li>
<li><p><a class="reference internal" href="#id36" id="id173">4.5 クラス階層</a></p>
<ul>
<li><p><a class="reference internal" href="#id37" id="id174">4.5.1 明示的なオーバーライド</a></p></li>
<li><p><a class="reference internal" href="#id38" id="id175">4.5.2 階層の利点</a></p></li>
<li><p><a class="reference internal" href="#id39" id="id176">4.5.3 階層の移動</a></p></li>
<li><p><a class="reference internal" href="#id40" id="id177">4.5.4 資源リークの回避</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id41" id="id178">4.6 コピーとムーブ</a></p>
<ul>
<li><p><a class="reference internal" href="#id42" id="id179">4.6.1 コンテナのコピー</a></p></li>
<li><p><a class="reference internal" href="#id43" id="id180">4.6.2 コンテナのムーブ</a></p></li>
<li><p><a class="reference internal" href="#id44" id="id181">4.6.3 基本演算</a></p></li>
<li><p><a class="reference internal" href="#id45" id="id182">4.6.4 資源管理</a></p></li>
<li><p><a class="reference internal" href="#id46" id="id183">4.6.5 演算子の抑制</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id47" id="id184">4.7 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id48" id="id185">第 5 章 テンプレート</a></p>
<ul>
<li><p><a class="reference internal" href="#id49" id="id186">5.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id50" id="id187">5.2 パラメーター化された型</a></p></li>
<li><p><a class="reference internal" href="#id51" id="id188">5.3 関数テンプレート</a></p></li>
<li><p><a class="reference internal" href="#id52" id="id189">5.4 コンセプトとジェネリックプログラミング</a></p></li>
<li><p><a class="reference internal" href="#id53" id="id190">5.5 関数オブジェクト</a></p></li>
<li><p><a class="reference internal" href="#id54" id="id191">5.6 可変個引数テンプレート</a></p></li>
<li><p><a class="reference internal" href="#id55" id="id192">5.7 別名</a></p></li>
<li><p><a class="reference internal" href="#id56" id="id193">5.8 テンプレートのコンパイルモデル</a></p></li>
<li><p><a class="reference internal" href="#id57" id="id194">5.9 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id58" id="id195">第 6 章 ライブラリの概要</a></p>
<ul>
<li><p><a class="reference internal" href="#id59" id="id196">6.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id60" id="id197">6.2 標準ライブラリのコンポーネント</a></p></li>
<li><p><a class="reference internal" href="#id61" id="id198">6.3 標準ライブラリヘッダと名前空間</a></p></li>
<li><p><a class="reference internal" href="#id62" id="id199">6.4 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id63" id="id200">第 7 章 文字列と正規表現</a></p>
<ul>
<li><p><a class="reference internal" href="#id64" id="id201">7.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id65" id="id202">7.2 文字列</a></p>
<ul>
<li><p><a class="reference internal" href="#string" id="id203">7.2.1 <code class="docutils literal notranslate"><span class="pre">string</span></code> の実装</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id66" id="id204">7.3 正規表現</a></p>
<ul>
<li><p><a class="reference internal" href="#id67" id="id205">7.3.1 探索</a></p></li>
<li><p><a class="reference internal" href="#id68" id="id206">7.3.2 正規表現の表記</a></p></li>
<li><p><a class="reference internal" href="#id69" id="id207">7.3.3 反復子</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id70" id="id208">7.4 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id71" id="id209">第 8 章 入出力ストリーム</a></p>
<ul>
<li><p><a class="reference internal" href="#id72" id="id210">8.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id73" id="id211">8.2 出力</a></p></li>
<li><p><a class="reference internal" href="#id74" id="id212">8.3 入力</a></p></li>
<li><p><a class="reference internal" href="#id75" id="id213">8.4 入出力の状態</a></p></li>
<li><p><a class="reference internal" href="#id76" id="id214">8.5 ユーザ定義型の入出力</a></p></li>
<li><p><a class="reference internal" href="#id77" id="id215">8.6 書式化</a></p></li>
<li><p><a class="reference internal" href="#id78" id="id216">8.7 ファイルストリーム</a></p></li>
<li><p><a class="reference internal" href="#id79" id="id217">8.8 文字列ストリーム</a></p></li>
<li><p><a class="reference internal" href="#id80" id="id218">8.9 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id81" id="id219">第 9 章 コンテナ</a></p>
<ul>
<li><p><a class="reference internal" href="#id82" id="id220">9.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#vector" id="id221">9.2 <code class="docutils literal notranslate"><span class="pre">vector</span></code></a></p>
<ul>
<li><p><a class="reference internal" href="#id83" id="id222">9.2.1 要素</a></p>
<ul>
<li><p><a class="reference internal" href="#id84" id="id223">9.2.1.1 範囲チェック</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#list" id="id224">9.3 <code class="docutils literal notranslate"><span class="pre">list</span></code></a></p></li>
<li><p><a class="reference internal" href="#map" id="id225">9.4 <code class="docutils literal notranslate"><span class="pre">map</span></code></a></p></li>
<li><p><a class="reference internal" href="#unordered-map" id="id226">9.5 <code class="docutils literal notranslate"><span class="pre">unordered_map</span></code></a></p></li>
<li><p><a class="reference internal" href="#id85" id="id227">9.6 コンテナのまとめ</a></p></li>
<li><p><a class="reference internal" href="#id86" id="id228">9.7 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id87" id="id229">第 10 章 アルゴリズム</a></p>
<ul>
<li><p><a class="reference internal" href="#id88" id="id230">10.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id89" id="id231">10.2 反復子の利用</a></p></li>
<li><p><a class="reference internal" href="#id90" id="id232">10.3 反復子の型</a></p></li>
<li><p><a class="reference internal" href="#id91" id="id233">10.4 ストリーム反復子</a></p></li>
<li><p><a class="reference internal" href="#id92" id="id234">10.5 述語</a></p></li>
<li><p><a class="reference internal" href="#id93" id="id235">10.6 アルゴリズムのまとめ</a></p></li>
<li><p><a class="reference internal" href="#id94" id="id236">10.7 コンテナアルゴリズム</a></p></li>
<li><p><a class="reference internal" href="#id95" id="id237">10.8 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id96" id="id238">第 11 章 ユーティリティ</a></p>
<ul>
<li><p><a class="reference internal" href="#id97" id="id239">11.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id98" id="id240">11.2 資源管理</a></p>
<ul>
<li><p><a class="reference internal" href="#unique-ptr-shared-ptr" id="id241">11.2.1 <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> と <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id99" id="id242">11.3 特殊化されたコンテナ</a></p>
<ul>
<li><p><a class="reference internal" href="#array" id="id243">11.3.1 <code class="docutils literal notranslate"><span class="pre">array</span></code></a></p></li>
<li><p><a class="reference internal" href="#bitset" id="id244">11.3.2 <code class="docutils literal notranslate"><span class="pre">bitset</span></code></a></p></li>
<li><p><a class="reference internal" href="#pair-tuple" id="id245">11.3.3 <code class="docutils literal notranslate"><span class="pre">pair</span></code> と <code class="docutils literal notranslate"><span class="pre">tuple</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id100" id="id246">11.4 時間</a></p></li>
<li><p><a class="reference internal" href="#id101" id="id247">11.5 関数アダプタ</a></p>
<ul>
<li><p><a class="reference internal" href="#bind" id="id248">11.5.1 <code class="docutils literal notranslate"><span class="pre">bind()</span></code></a></p></li>
<li><p><a class="reference internal" href="#mem-fn" id="id249">11.5.2 <code class="docutils literal notranslate"><span class="pre">mem_fn()</span></code></a></p></li>
<li><p><a class="reference internal" href="#function" id="id250">11.5.3 <code class="docutils literal notranslate"><span class="pre">function</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id102" id="id251">11.6 型関数</a></p>
<ul>
<li><p><a class="reference internal" href="#iterator-traits" id="id252">11.6.1 <code class="docutils literal notranslate"><span class="pre">iterator_traits</span></code></a></p></li>
<li><p><a class="reference internal" href="#id103" id="id253">11.6.2 型述語</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id104" id="id254">11.7 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id105" id="id255">第 12 章 数値演算</a></p>
<ul>
<li><p><a class="reference internal" href="#id106" id="id256">12.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#id107" id="id257">12.2 数学関数</a></p></li>
<li><p><a class="reference internal" href="#id108" id="id258">12.3 数値アルゴリズム</a></p></li>
<li><p><a class="reference internal" href="#id109" id="id259">12.4 複素数</a></p></li>
<li><p><a class="reference internal" href="#id110" id="id260">12.5 乱数</a></p></li>
<li><p><a class="reference internal" href="#id111" id="id261">12.6 ベクタの算術演算</a></p></li>
<li><p><a class="reference internal" href="#id112" id="id262">12.7 数値の限界値</a></p></li>
<li><p><a class="reference internal" href="#id113" id="id263">12.8 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id114" id="id264">第 13 章 並行処理</a></p>
<ul>
<li><p><a class="reference internal" href="#id115" id="id265">13.1 はじめに</a></p></li>
<li><p><a class="reference internal" href="#thread" id="id266">13.2 タスクと <code class="docutils literal notranslate"><span class="pre">thread</span></code></a></p></li>
<li><p><a class="reference internal" href="#id116" id="id267">13.3 引数の受渡し</a></p></li>
<li><p><a class="reference internal" href="#id117" id="id268">13.4 結果の返却</a></p></li>
<li><p><a class="reference internal" href="#id118" id="id269">13.5 データの共有</a></p></li>
<li><p><a class="reference internal" href="#id119" id="id270">13.6 イベント待ち</a></p></li>
<li><p><a class="reference internal" href="#id120" id="id271">13.7 タスク間通信</a></p>
<ul>
<li><p><a class="reference internal" href="#future-promise" id="id272">13.7.1 <code class="docutils literal notranslate"><span class="pre">future</span></code> と <code class="docutils literal notranslate"><span class="pre">promise</span></code></a></p></li>
<li><p><a class="reference internal" href="#packaged-task" id="id273">13.7.2 <code class="docutils literal notranslate"><span class="pre">packaged_task</span></code></a></p></li>
<li><p><a class="reference internal" href="#async" id="id274">13.7.3 <code class="docutils literal notranslate"><span class="pre">async()</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id121" id="id275">13.8 アドバイス</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id122" id="id276">第 14 章 歴史と互換性</a></p>
<ul>
<li><p><a class="reference internal" href="#id123" id="id277">14.1 歴史</a></p>
<ul>
<li><p><a class="reference internal" href="#id124" id="id278">14.1.1 時系列</a></p></li>
<li><p><a class="reference internal" href="#id125" id="id279">14.1.2 黎明期</a></p></li>
<li><p><a class="reference internal" href="#iso-c" id="id280">14.1.3 ISO C++ 標準</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-11" id="id281">14.2 C++11 の新機能</a></p>
<ul>
<li><p><a class="reference internal" href="#id126" id="id282">14.2.1 言語機能</a></p></li>
<li><p><a class="reference internal" href="#id127" id="id283">14.2.2 標準ライブラリコンポーネント</a></p></li>
<li><p><a class="reference internal" href="#id128" id="id284">14.2.3 非推奨とされた機能</a></p></li>
<li><p><a class="reference internal" href="#id129" id="id285">14.2.4 キャスト</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-c" id="id286">14.3 C と C++ の互換性</a></p>
<ul>
<li><p><a class="reference internal" href="#id130" id="id287">14.3.1 C 言語と C++ は兄弟</a></p></li>
<li><p><a class="reference internal" href="#id131" id="id288">14.3.2 互換性にかかわる問題</a></p>
<ul>
<li><p><a class="reference internal" href="#id132" id="id289">14.3.2.1 スタイルの問題</a></p></li>
<li><p><a class="reference internal" href="#void" id="id290">14.3.2.2 <code class="docutils literal notranslate"><span class="pre">void*</span></code></a></p></li>
<li><p><a class="reference internal" href="#id133" id="id291">14.3.2.3 C++ のキーワード</a></p></li>
<li><p><a class="reference internal" href="#id134" id="id292">14.3.2.4 結合</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#id135" id="id293">14.4 参考文献</a></p></li>
<li><p><a class="reference internal" href="#id136" id="id294">14.5 アドバイス</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id138">第 1 章 基本</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id139">1.1 はじめに</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>特に内容なし。</p>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id140">1.2 プログラム</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>従来どおり。</p>
<ul class="simple">
<li><p>C++ はコンパイル言語である。ソースファイル、オブジェクトファイル、実行ファイルなどの諸概念の理解を確認する。</p></li>
<li><p>C++ 標準が定義する実体は二つに分類できる：言語の中核機能と標準ライブラリー。</p></li>
<li><p>C++ は静的な型付けを行う言語だ。コンパイル時点でプログラム構成要素のすべての型がコンパイラーに知られる必要がある。</p></li>
</ul>
</div>
<div class="section" id="hello-world">
<h3><a class="toc-backref" href="#id141">1.3 Hello, World!</a><a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h3>
<p>従来どおり。</p>
<ul class="simple">
<li><p>最小のプログラム。波括弧、コメントなどの説明。</p></li>
<li><p>すべての C++ プログラムは <code class="docutils literal notranslate"><span class="pre">main()</span></code> を持つ。戻り値の説明など。</p></li>
<li><p>インクルード、標準出力ストリーム、特殊文字、名前空間などの簡単な説明など。</p></li>
<li><p>すべての実行コードは直接的あるいは間接的に <code class="docutils literal notranslate"><span class="pre">main()</span></code> から呼び出されることになる。</p></li>
</ul>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id142">1.4 関数</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>従来どおり。色々なことを一気に説明している。</p>
<ul class="simple">
<li><p>引数の型チェックと型変換が行われることを軽く見てはならない。</p></li>
<li><p>関数の型は、返却型と引数型とによって決定される。クラスのメンバー関数であれば（というより、名前空間の「メンバー」関数であれば）、クラス名（というより名前空間の名前）も関数の型の一部となる。</p></li>
<li><p>関数の多重定義（オーバーロード）に関する簡単な説明。</p></li>
</ul>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id143">1.5 型と変数と算術演算</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>宣言とは文であって、プログラム内に名前を新しく導入するものだ。</p>
<ul class="simple">
<li><p>型、オブジェクト、値、変数の（用語としての）定義がここに来る。</p></li>
<li><p>基本型の例とハードウェア機能との対応について。特に演算子 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> が型の大きさを返すものであることについて。</p></li>
<li><p>代入時、算術演算時に、基本型から基本型への型変換がコンパイル時に必要に応じて起こる。演算対象の中でもっとも高精度のオペランドの型に変換される。</p></li>
<li><p>初期化の記法について。C++11 から波括弧による初期化、<code class="docutils literal notranslate"><span class="pre">initializer_list</span></code> 由来の初期化ができる。著者は <code class="docutils literal notranslate"><span class="pre">{}</span></code> で囲む形式のものを推奨している。</p></li>
<li><p>縮小変換も依然として存在する。著者はやりたくないようだが、C 言語との互換性のために残した。</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">auto</span></code> が明示的に型を指定する代わりに使える場合がある。</p>
<ul>
<li><p>本書では <code class="docutils literal notranslate"><span class="pre">auto</span></code> で宣言する場合には <code class="docutils literal notranslate"><span class="pre">=</span></code> で初期化する。問題を引き起こす型変換を避ける。</p></li>
<li><p>特殊な事情がない限り <code class="docutils literal notranslate"><span class="pre">auto</span></code> を用いるとよい。</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id144">1.6 スコープと生存期間</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>名前はプログラムテキスト内の特定の範囲でしか利用できない。この範囲をスコープという。</p>
<ul class="simple">
<li><p>局所スコープ</p>
<ul>
<li><p>ラムダ式の中で宣言された名前は、そのラムダ式から決定されるスコープにいると解釈する。</p></li>
</ul>
</li>
<li><p>クラススコープ</p></li>
<li><p>名前空間スコープ</p></li>
<li><p>広域名前空間（スコープの定義上、これはスコープではない？）</p></li>
</ul>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id145">1.7 定数</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>従来の <code class="docutils literal notranslate"><span class="pre">const</span></code> と新機能の <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> の二種類の定数がある。後者の意味は《この値はコンパイル時に評価されますよ》と憶えておく。</p>
<ul class="simple">
<li><p>定数式の中でも利用できる関数は <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> として定義されなければならない。</p></li>
<li><p>関数を <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> とする場合には、それはできるだけ単純なものがよい。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> と宣言した関数でも非定数の引数を利用できる（その場合には定数式とはならないだけ）。</p></li>
</ul>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id146">1.8 ポインタと配列と参照</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>次のような構文が追加された。これらは範囲 <code class="docutils literal notranslate"><span class="pre">for</span></code> 文と呼ばれる：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> により空ポインターを指すことができる。《古い時代のコードでは <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> ではなくて <code class="docutils literal notranslate"><span class="pre">0`</span> <span class="pre">と</span> <span class="pre">``NULL</span></code> が用いられていた。しかし <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> を使えば、整数である <code class="docutils literal notranslate"><span class="pre">0</span></code> と <code class="docutils literal notranslate"><span class="pre">NULL</span></code> と、ポインタである
<code class="docutils literal notranslate"><span class="pre">nullptr</span></code> を混同してしまう潜在的な危険性が排除できる》とある。</p>
</div>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id147">1.9 判定</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">switch</span></code> 文の説明。今のところ従来どおり。</p>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id148">1.10 アドバイス</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>本章を含め、以降の章すべてのアドバイスという節が最後に来る。本ノートでは、個人的に大切にしたい項目に絞って書き留める。</p>
<ul class="simple">
<li><p>よいプログラムを書くのに、C++ のすべての詳細を知る必要はない。</p></li>
<li><p>言語機能ではなく、プログラミング技法に集中しよう。</p></li>
<li><p>コンパイル時に評価しなければならない関数は <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 宣言をしよう。</p></li>
<li><p>型名を用いた宣言には <code class="docutils literal notranslate"><span class="pre">{}</span></code> 構文の初期化子を使おう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">auto</span></code> による宣言には <code class="docutils literal notranslate"><span class="pre">=</span></code> 構文の初期化子を使おう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> や <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ではなくて <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> を使おう。</p></li>
</ul>
</div>
</div>
<div class="section" id="id12">
<h2><a class="toc-backref" href="#id149">第 2 章 ユーザー定義型</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id150">2.1 はじめに</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>従来どおり。</p>
<ul class="simple">
<li><p>組み込み型の定義に注意。基本型と <code class="docutils literal notranslate"><span class="pre">const</span></code> と宣言演算子とを組み合わせた型をそう定義する。</p></li>
<li><p>組み込み型でない型をユーザー定義型と呼ぶ。</p></li>
</ul>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id151">2.2 構造体</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>従来どおり。</p>
<ul class="simple">
<li><p>演算子 <code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">delete</span></code> と空き領域・動的メモリ・ヒープの説明がここに来る。</p></li>
<li><p>演算子 <code class="docutils literal notranslate"><span class="pre">.</span></code> と <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> の意味を知る。</p></li>
</ul>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id152">2.3 クラス</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>従来どおり。</p>
<ul class="simple">
<li><p>クラスは型のインターフェースと実装とを独立して設けられる言語機能だ。インターフェースと言われる場合には <code class="docutils literal notranslate"><span class="pre">public</span></code> メンバーであると了解する。</p></li>
<li><p>コンストラクターなどの説明がここに来る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span></code> と <code class="docutils literal notranslate"><span class="pre">class</span></code> の違いは従来どおり。</p></li>
</ul>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id153">2.4 共用体</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>従来どおり。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">union</span></code> は全メンバーが同じアドレスに割り当てられた <code class="docutils literal notranslate"><span class="pre">struct</span></code> だ。したがって</p>
<ul>
<li><p>メモリ領域の消費量は、それが最大のメンバーのそれと同じ量だ。</p></li>
<li><p>同時に一つのメンバーしか値を持たない。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">union</span></code> のどのメンバーを利用しているのかを管理する責任はプログラマーにある。</p></li>
<li><p>エラーを避けるために、メンバーへのアクセスを提供するのがよい。</p></li>
</ul>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id154">2.5 列挙体</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> が目を引く。</p>
<ul class="simple">
<li><p>列挙子のスコープが個々の <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> にあるため、別の <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> に同名の列挙子を利用できる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> は従来の <code class="docutils literal notranslate"><span class="pre">enum</span></code> と比べて型付けが強力。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> の列挙子と整数値の混同はできない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> ではデフォルトで代入、初期化、比較をサポートしている。</p></li>
<li><p>従来の <code class="docutils literal notranslate"><span class="pre">enum</span></code> も利用可能だ。しかし著者が言うには《あまりよい動作はしない》。</p></li>
</ul>
</div>
<div class="section" id="id18">
<h3><a class="toc-backref" href="#id155">2.6 アドバイス</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>予想外の動作を防ぐには、単なる <code class="docutils literal notranslate"><span class="pre">enum</span></code> ではなくて <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> を利用しよう。</p></li>
</ul>
</div>
</div>
<div class="section" id="id19">
<h2><a class="toc-backref" href="#id156">第 3 章 モジュール性</a><a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>見るべき新機能は <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> と <code class="docutils literal notranslate"><span class="pre">static_assert()</span></code> で間違いない。どちらも多用するべきものだ。</p>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id157">3.1 はじめに</a><a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>宣言と定義を分けて考える。これは従来と変わらない。</p>
</div>
<div class="section" id="id21">
<h3><a class="toc-backref" href="#id158">3.2 分割コンパイル</a><a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>従来どおり。読者が熟練者ならば飛ばしてよい。</p>
<ul class="simple">
<li><p>ライブラリーは個別にコンパイルされたコードの集合体となるのが一般的だ。</p></li>
<li><p>ヘッダーファイル（宣言）とソースファイル（定義）に分ける。</p></li>
</ul>
</div>
<div class="section" id="id22">
<h3><a class="toc-backref" href="#id159">3.3 名前空間</a><a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>C++11 の段階では従来どおり。</p>
<ul class="simple">
<li><p>最初の一行からは関数、クラス、列挙体も名前空間の一種であるととれる。</p></li>
<li><p>本物の <code class="docutils literal notranslate"><span class="pre">main()</span></code> は広域名前空間で定義されていて、明示的に定義される名前空間の所属物とはなっていない。</p></li>
<li><p>名前空間は、比較的大規模なプログラムコンポーネントの用途に向いている。</p></li>
</ul>
</div>
<div class="section" id="id23">
<h3><a class="toc-backref" href="#id160">3.4 エラー処理</a><a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>型システムそのものがエラー処理の支援手段の一つだ。</p></li>
</ul>
<div class="section" id="id24">
<h4><a class="toc-backref" href="#id161">3.4.1 例外処理</a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<p>決して例外を送出しない関数は <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> と宣言できる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">user</span><span class="p">(</span><span class="nb">int</span> <span class="n">sz</span><span class="p">)</span> <span class="n">noexcept</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>それでもこのような関数が例外を送出するならば、標準ライブラリー関数
<code class="docutils literal notranslate"><span class="pre">terminate()</span></code> が呼び出される。</p>
</div>
<div class="section" id="id25">
<h4><a class="toc-backref" href="#id162">3.4.2 不変条件</a><a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<p>面白いと思ったのが <code class="docutils literal notranslate"><span class="pre">bad_alloc</span></code> を明示的に処理するコード。プログラマーが自分で <code class="docutils literal notranslate"><span class="pre">terminate()</span></code> を呼び出せるのか。</p>
</div>
<div class="section" id="id26">
<h4><a class="toc-backref" href="#id163">3.4.3 静的アサーション</a><a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">static_assert()</span></code> はコンパイル時にエラーを検出できる。定数式を引数に取る。</p>
</div>
</div>
<div class="section" id="id27">
<h3><a class="toc-backref" href="#id164">3.5 アドバイス</a><a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>ヘッダーで非インライン関数を定義しないように。</p></li>
<li><p>ヘッダー内に <code class="docutils literal notranslate"><span class="pre">using</span></code> 指令を記述しないように。</p></li>
<li><p>エラー処理には例外を利用しよう。</p></li>
<li><p>開発初期の段階で、エラー処理方針を設計しよう。</p></li>
<li><p>例外には、組み込み型ではなくて、目的に応じたユーザー定義型を利用しよう。</p></li>
<li><p>すべての関数ですべての例外を捕捉する必要はない。</p></li>
</ul>
</div>
</div>
<div class="section" id="id28">
<h2><a class="toc-backref" href="#id165">第 4 章 クラス</a><a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h2>
<p>この章と次の章（テンプレート）はセットで読む。本章と次章はオブジェクト指向プログラミングとジェネリックプログラミングの言語仕様の記述にそれぞれ対応する。</p>
<div class="section" id="id29">
<h3><a class="toc-backref" href="#id166">4.1 はじめに</a><a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>C++ 言語機能の中核はクラスである。</p></li>
<li><p>クラスをサポートする基本機能を具象クラス、抽象クラス、クラス階層に分けて理解する。</p></li>
</ul>
</div>
<div class="section" id="id30">
<h3><a class="toc-backref" href="#id167">4.2 具象型</a><a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p>具象クラスは組み込み型のように振る舞うのが基本的だ。組み込み型のように振る舞うというのは次を意味するようだ：</p>
<ul class="simple">
<li><p>オブジェクトをスタック上にも静的メモリにも他のオブジェクト内にも置ける。</p></li>
<li><p>オブジェクトを直接利用できる。</p></li>
<li><p>オブジェクトを即座に初期化できる。</p></li>
<li><p>オブジェクトをコピーできる。</p></li>
</ul>
<div class="section" id="id31">
<h4><a class="toc-backref" href="#id168">4.2.1 算術型</a><a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h4>
<p>本節では複素数をクラスとして定義し、具象型の何たるかを解説している。標準にも <code class="docutils literal notranslate"><span class="pre">complex</span></code> があるが、説明用にその簡易版という感じになっている。</p>
<ul class="simple">
<li><p>効率化のため、単純な演算はインライン化する。つまり、関数呼び出しの機械語を生成させないように実装する。</p></li>
<li><p>デフォルトコンストラクターを定義すると、その型のオブジェクトは必ず初期化される。</p></li>
<li><p>クラスの内部データ表現に直接アクセスする必要がない演算は、クラス定義とは分離して記述できる。</p></li>
<li><p>値渡しによる引数はコピーである。したがって、呼び出し元の値に影響を与えない。</p></li>
<li><p>ユーザー定義演算子は、慣例にしたがって定義すること。</p></li>
<li><p>ちなみに、組み込み型の演算子を再定義することはできない。</p></li>
</ul>
</div>
<div class="section" id="id32">
<h4><a class="toc-backref" href="#id169">4.2.2 コンテナ</a><a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h4>
<p>要素の集合を保持するオブジェクトをとにかくコンテナと呼ぶ。</p>
<ul class="simple">
<li><p>デストラクターの記号がクラス名の直前に記号 <code class="docutils literal notranslate"><span class="pre">~</span></code> が付いたものである理由は、コンストラクターを補うものという意味合いがある。</p></li>
<li><p>コンストラクターとデストラクターの組み合わせが多くのエレガントな技法の基礎だ。特に、C++ での資源管理技法の基本だ。コンストラクターで資源を確保して、デストラクターでそれを解放する技法を
RAII と呼ぶ。これにより裸の <code class="docutils literal notranslate"><span class="pre">new</span></code> と <code class="docutils literal notranslate"><span class="pre">delete</span></code> のコード出現頻度を下げる。</p></li>
</ul>
</div>
<div class="section" id="id33">
<h4><a class="toc-backref" href="#id170">4.2.3 コンテナの初期化</a><a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<p>「コンテナ自身」の資源管理の次は、コンテナの内容物の管理を考える。ここで C++11 らしい話題が一つ出てくる。それだけ見ていく。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vector</span><span class="p">{</span>
   <span class="kt">double</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="n">Vector</span><span class="o">::</span><span class="n">Vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">elem</span><span class="p">{</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">lst</span><span class="p">.</span><span class="n">size</span><span class="p">()]},</span>
      <span class="n">sz</span><span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">size</span><span class="p">())}</span>
<span class="p">{</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">elem</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">Vector</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="n">Vector</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.23</span><span class="p">,</span> <span class="mf">3.45</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">std::initializer_list&lt;&gt;</span></code> の例として頭に入れておくと良さそうなコードだ。</p>
</div>
</div>
<div class="section" id="id34">
<h3><a class="toc-backref" href="#id171">4.3 抽象クラス</a><a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<p>抽象クラスの話題に移る。本節の内容は古典的なようなので後回し。</p>
</div>
<div class="section" id="id35">
<h3><a class="toc-backref" href="#id172">4.4 仮想関数</a><a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<p>仮想関数テーブルの話題。これも古典的なトピックだ。</p>
</div>
<div class="section" id="id36">
<h3><a class="toc-backref" href="#id173">4.5 クラス階層</a><a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h3>
<p>クラス階層とは派生によって束ねられるクラス群のことだ。いわゆる is-a 関係を表現するために階層構造を持つクラスを利用する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Shape</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="n">Point</span> <span class="n">to</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">rotate</span><span class="p">(</span><span class="kt">int</span> <span class="n">angle</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">(){}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="id37">
<h4><a class="toc-backref" href="#id174">4.5.1 明示的なオーバーライド</a><a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h4>
<p>C++11 からは、関数をオーバーライドしていることを派生クラスのプログラマーが記述することができる。キーワード <code class="docutils literal notranslate"><span class="pre">override</span></code> を関数宣言に付加する：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span><span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Smiley</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Circle</span><span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="n">Point</span> <span class="n">to</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h4><a class="toc-backref" href="#id175">4.5.2 階層の利点</a><a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h4>
<p>クラス階層の利点とはインターフェース継承と実装継承の二つだ。例えば <code class="docutils literal notranslate"><span class="pre">Smiley*</span></code> を <code class="docutils literal notranslate"><span class="pre">Shape*</span></code> として扱えるなど。</p>
</div>
<div class="section" id="id39">
<h4><a class="toc-backref" href="#id176">4.5.3 階層の移動</a><a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<p>演算子 <code class="docutils literal notranslate"><span class="pre">dynamic_cast&lt;&gt;</span></code> について。これは is-kind-of, is-instance-of と考えられる。</p>
</div>
<div class="section" id="id40">
<h4><a class="toc-backref" href="#id177">4.5.4 資源リークの回避</a><a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<p>C++11 で登場するテンプレート <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;&gt;</span></code> について。デモコードでは <code class="docutils literal notranslate"><span class="pre">vector&lt;unique_ptr&lt;Shape&gt;&gt;</span></code> の形で利用されている。</p>
</div>
</div>
<div class="section" id="id41">
<h3><a class="toc-backref" href="#id178">4.6 コピーとムーブ</a><a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h3>
<p>ここは大切なのでよく理解すること。</p>
<ul class="simple">
<li><p>コピー演算のデフォルトの意味はメンバー単位のコピーであり、つまりメンバーそれぞれに対してコピーすることだ。</p></li>
<li><p>クラスを設計するときには、次の二点を必ず検討すること：</p>
<ul>
<li><p>オブジェクトがコピーされる可能性があるか</p></li>
<li><p>コピーの方法をどうするか</p></li>
</ul>
</li>
<li><p>抽象型のコピーがメンバー単位のコピーであることはまずない。</p></li>
</ul>
<div class="section" id="id42">
<h4><a class="toc-backref" href="#id179">4.6.1 コンテナのコピー</a><a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
<p>コピーコンストラクターとコピー代入演算子の基本を解説。</p>
</div>
<div class="section" id="id43">
<h4><a class="toc-backref" href="#id180">4.6.2 コンテナのムーブ</a><a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h4>
<p>ここは C++11 らしい話題なので丁寧に読んでいく。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">Vector</span> <span class="nf">res</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上記コードの最後、局所変数 <code class="docutils literal notranslate"><span class="pre">res</span></code> のコピーが作られた上で、呼び出し元に置かれるのだが、次のような呼び出しを考えるとコピーが複数回生じることが観察できる：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="n">r</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span>
</pre></div>
</div>
<p>この問題の本質とは、<code class="docutils literal notranslate"><span class="pre">operator+()</span></code> 内の <code class="docutils literal notranslate"><span class="pre">res</span></code> がコピー後に利用されないことだ。この関数の呼び出し元がしたいことは <code class="docutils literal notranslate"><span class="pre">res</span></code> を取り出したいくらいのことだ。
C++11 ではこの問題を次のようにして解決する：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vector</span><span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">Vector</span><span class="p">(</span><span class="n">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vector</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">);</span>
    <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>

<span class="n">Vector</span><span class="p">::</span><span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">elem</span><span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">elem</span><span class="p">},</span>
      <span class="n">sz</span><span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">sz</span><span class="p">}</span>
<span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="n">elem</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">a</span><span class="o">.</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">ムーブ代入も同様の実装となる</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> は「右辺値参照」、つまり右辺値をバインドできる参照を意味する。</p>
<ul>
<li><p>右辺値とは、《少々不正確に説明すると、関数が返す整数などのような、代入できない値のことである》。</p></li>
<li><p>右辺値参照とは、《他の誰も代入を行えない何かを参照》するものと憶えておく。</p></li>
</ul>
</li>
<li><p>ムーブコンストラクターおよびムーブ代入演算子は <code class="docutils literal notranslate"><span class="pre">const</span></code> の引数を受け取らない。</p></li>
<li><p>ムーブ後に、ムーブ元オブジェクトはデストラクターが実行できる状態に移行する。したがって、ムーブの実装では、引数の中身を「抜け殻」にすること。</p></li>
<li><p>抜け殻になることを明示的にコンパイラーに教えるには <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> を呼び出す。</p></li>
</ul>
</div>
<div class="section" id="id44">
<h4><a class="toc-backref" href="#id181">4.6.3 基本演算</a><a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h4>
<p>ひじょうに大切なことを説明しているので、本書をいちいち参照するといい。</p>
<p>C++11 には、特殊メンバー関数のコンパイラーによるデフォルト実装を採用することを明示する方法がある。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Y</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Y</span><span class="p">(</span><span class="n">Sometype</span><span class="p">);</span>
    <span class="n">Y</span><span class="p">(</span><span class="k">const</span> <span class="n">Y</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Y</span><span class="p">(</span><span class="n">Y</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>クラスのメンバーにポインターか参照があるならば、コピー演算とムーブ演算について明示するのが望ましい。</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">explicit</span></code> についていちばん基本的な用途を説明している。</p></li>
</ul>
</div>
<div class="section" id="id45">
<h4><a class="toc-backref" href="#id182">4.6.4 資源管理</a><a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h4>
<p>資源はメモリだけではない。</p>
</div>
<div class="section" id="id46">
<h4><a class="toc-backref" href="#id183">4.6.5 演算子の抑制</a><a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h4>
<p>デフォルトのコピー演算、ムーブ演算を無効化する方法が一つ増えた：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Shape</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Shape</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Shape</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="n">Shape</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Shape</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">();</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>このキーワード <code class="docutils literal notranslate"><span class="pre">delete</span></code> の用途が現れる以前は、これらの特殊関数を <code class="docutils literal notranslate"><span class="pre">private</span></code> に明示的に宣言しておくという手法を採った。</p>
<ul class="simple">
<li><p>クラス階層内のオブジェクトをコピーする必要がある場合には、別途専用のインターフェースを設ける。</p></li>
<li><p>デストラクターを明示的に宣言されたクラスに対しては、コンパイラーはムーブ演算を自動生成しない。</p></li>
<li><p>クラス階層内の基底クラスは、コピー演算の対象とはしたくない。</p></li>
</ul>
</div>
</div>
<div class="section" id="id47">
<h3><a class="toc-backref" href="#id184">4.7 アドバイス</a><a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>演算子を定義する場合は、本来の動作を模倣しよう。</p></li>
<li><p>左右二つの引数に対称性がある演算子は、非メンバー関数として実装しよう。</p>
<ul>
<li><p>任意の <code class="docutils literal notranslate"><span class="pre">lhs</span></code>, <code class="docutils literal notranslate"><span class="pre">rhs</span></code> に対して <code class="docutils literal notranslate"><span class="pre">operator&#64;(lhs,</span> <span class="pre">rhs)</span> <span class="pre">==</span> <span class="pre">operator&#64;(rhs,</span> <span class="pre">lhs)</span></code> なる演算ということ。</p></li>
</ul>
</li>
<li><p>クラスがコンテナであれば、初期化子並びコンストラクターを実装しよう。</p></li>
<li><p>大規模クラス階層でのオーバーライドは <code class="docutils literal notranslate"><span class="pre">override</span></code> で明示しよう。</p></li>
<li><p>コンテナは値で返却しよう（ムーブを活用できるので効率的だ）</p></li>
<li><p>デストラクターをもつクラスには、ユーザー定義のコピー演算とムーブ演算が必要であるか、あるいは、削除されたコピー演算とムーブ演算が必要である。</p></li>
<li><p>オブジェクトの構築、コピー、ムーブ、解体を制御しよう。</p></li>
<li><p>資源とみなせるものをリークさせてはいけない。</p></li>
<li><p>クラスが資源ハンドルであれば、コンストラクター、デストラクター、非デフォルトのコピー演算が必要だ。</p></li>
</ul>
</div>
</div>
<div class="section" id="id48">
<h2><a class="toc-backref" href="#id185">第 5 章 テンプレート</a><a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id49">
<h3><a class="toc-backref" href="#id186">5.1 はじめに</a><a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h3>
<p>最初に著者はテンプレートをこう定義している。</p>
<blockquote>
<div><p>テンプレートは、一連の型や値をパラメーター化したクラスもしくは関数であり、極めて汎用的な概念を表現する。</p>
</div></blockquote>
<p>例えば</p>
<blockquote>
<div><p>テンプレートに対して要素型である
<code class="docutils literal notranslate"><span class="pre">double</span></code> などを引数として指定すると、その型に対応した関数が生成される。</p>
</div></blockquote>
</div>
<div class="section" id="id50">
<h3><a class="toc-backref" href="#id187">5.2 パラメーター化された型</a><a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>C++98 とは違って 2 個の <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> の間に空白文字を置かなくてもかまわなくなった。</p></li>
<li><p>テンプレートはコンパイル時のメカニズムであるので、実行時オーバーヘッドが増すことはない。</p></li>
<li><p>標準ライブラリー用に生成されるコードは良質であることを期待してよい。</p></li>
<li><p>値引数は有用となり得る。</p></li>
<li><p>テンプレート値引数は定数式でなければならない。</p></li>
</ul>
</div>
<div class="section" id="id51">
<h3><a class="toc-backref" href="#id188">5.3 関数テンプレート</a><a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>最初の例を見て、<code class="docutils literal notranslate"><span class="pre">sum()</span></code> に対して引数型を明示的に指定する必要がないということを理解する。</p></li>
<li><p>関数テンプレートは <code class="docutils literal notranslate"><span class="pre">virtual</span></code> なメンバー関数にはならない。その理由を理解すること。</p></li>
</ul>
</div>
<div class="section" id="id52">
<h3><a class="toc-backref" href="#id189">5.4 コンセプトとジェネリックプログラミング</a><a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h3>
<p>テンプレートが提供する機能が何であるかを考えると、テンプレートの活用法が理解できる。</p>
<p>ジェネリックプログラミングとは、汎用アルゴリズムの設計と実装と利用に集中するプログラミングを意味する。いろいろな型の何々が利用可能であるという意味に捉える。前節の <code class="docutils literal notranslate"><span class="pre">sum()</span></code> を例にとって理解する。</p>
<p>コンセプトとは、テンプレートが実体化において、そのテンプレート引数が要求する何かを表すという解釈でいいか？</p>
<blockquote>
<div><p>有用で優れたコンセプトは、基礎的なものであり、設計しなくても見つかるものだ。</p>
</div></blockquote>
<p>とあるが、例に線形空間や体を挙げているので、単に著者の設計手腕が高いだけだとも考えられる。もっとも、終盤のパラグラフの説明は平易で良い。</p>
</div>
<div class="section" id="id53">
<h3><a class="toc-backref" href="#id190">5.5 関数オブジェクト</a><a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h3>
<p>関数オブジェクト、ファンクターはテンプレートの用途で特に有用なものの一つだ。演算子
<code class="docutils literal notranslate"><span class="pre">operator()</span></code> を有するクラステンプレートの形式をとる。</p>
<p>冒頭の関数オブジェクトの形で定義しておくと、間接的な関数呼び出しよりも効率的になる。</p>
<p>ラムダ式がここで示される。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>
<span class="n">count</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
<ul class="simple">
<li><p>表記 <code class="docutils literal notranslate"><span class="pre">[&amp;](int</span> <span class="pre">a){</span> <span class="pre">return</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">x;</span> <span class="pre">}</span></code>
などをラムダ式と呼ぶ。これは <code class="docutils literal notranslate"><span class="pre">Less_than&lt;int&gt;{x}</span></code>
と同じ関数オブジェクトを生成する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code> はラムダ式内の <code class="docutils literal notranslate"><span class="pre">x</span></code>
は参照で用いるように指定するものだ。このように、参照で用いる変数を指定するものをキャプチャーリストと呼ぶ。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> だけをキャプチャーする場合には <code class="docutils literal notranslate"><span class="pre">[&amp;x]</span></code> と書く。すべてキャプチャーならば <code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code> だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> をコピー生成する場合には <code class="docutils literal notranslate"><span class="pre">[=x]</span></code> と書く。すべてコピーならば <code class="docutils literal notranslate"><span class="pre">[=]</span></code> だ。</p></li>
<li><p>何もキャプチャーしない場合には <code class="docutils literal notranslate"><span class="pre">[]</span></code> と書く。</p></li>
</ul>
</li>
</ul>
<p>ラムダ式とテンプレートをうまく組み合わせるとコレクションに対するループと収容要素に対する処理を分類しやすくなる。</p>
</div>
<div class="section" id="id54">
<h3><a class="toc-backref" href="#id191">5.6 可変個引数テンプレート</a><a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h3>
<p>いにしえの <code class="docutils literal notranslate"><span class="pre">printf()</span></code> のような感じで、任意の型、個数の引数を受け取るテンプレートを定義できる。本書の例を引用する。コード中 3 箇所に現れる省略記号 <code class="docutils literal notranslate"><span class="pre">...</span></code> に注意すること：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(){}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Tail</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">head</span><span class="p">,</span> <span class="n">Tail</span><span class="p">...</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">f</span><span class="p">(</span><span class="n">tail</span><span class="p">...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで関数 <code class="docutils literal notranslate"><span class="pre">g()</span></code> は何か適当な関数テンプレートとする。</p>
</div>
<div class="section" id="id55">
<h3><a class="toc-backref" href="#id192">5.7 別名</a><a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h3>
<p>別名機能が有用であるのは説明するまでもないはずだが、著者はこれを周囲からは不思議がられているらしい。</p>
<p>型やテンプレートに別名を付ける機能がある。それにはキーワード <code class="docutils literal notranslate"><span class="pre">using</span></code> を使う。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="kt">size_t</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>別名付けはコードの可搬性を高めるのに利用できる。</p></li>
<li><p>別名をテンプレートの引数の一部またはすべてを bind して、新しいテンプレートを定義する際にも利用できる。</p></li>
</ul>
</div>
<div class="section" id="id56">
<h3><a class="toc-backref" href="#id193">5.8 テンプレートのコンパイルモデル</a><a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h3>
<p>この節では難しいことを述べているように見えるが、わけのわからないテンプレートを書くと、わけのわからないコンパイルエラーが出ると言っているに過ぎない。</p>
</div>
<div class="section" id="id57">
<h3><a class="toc-backref" href="#id194">5.9 アドバイス</a><a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>テンプレートを活用して、コードの抽象化レベルを引き上げよう。</p></li>
<li><p>テンプレートを定義する際には、まず非テンプレートバージョンを設計、デバッグして、その後で、引数を追加して一般化しよう。</p></li>
<li><p>テンプレートは型安全だが、そのチェックはずっと後で行われる。</p></li>
<li><p>テンプレートは、情報を失うことなく、引数型を受け渡しできる。</p></li>
<li><p>テンプレートを定義する際には、テンプレート引数に想定されるコンセプト（要件）を熟慮しよう。</p></li>
<li><p>ある特定の箇所でのみ必要とされる単純な関数オブジェクトが必要であれば、ラムダを使おう。</p></li>
<li><p>同種の引数の並びに対して可変個引数テンプレートを利用しないようにしよう（初期化子並びを優先しよう）。</p></li>
<li><p>テンプレートは、コンパイル時「ダックタイピング」を提供する。</p></li>
</ul>
</div>
</div>
<div class="section" id="id58">
<h2><a class="toc-backref" href="#id195">第 6 章 ライブラリの概要</a><a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id59">
<h3><a class="toc-backref" href="#id196">6.1 はじめに</a><a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>本質に集中することが重要であって、詳細の理解が不足していることに惑わされることはない。</p></li>
<li><p>C++ 標準では 2/3 を標準ライブラリーの仕様に割いている。</p></li>
</ul>
</div>
<div class="section" id="id60">
<h3><a class="toc-backref" href="#id197">6.2 標準ライブラリのコンポーネント</a><a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h3>
<p>著者が標準ライブラリーを機能に基づいて分類した一覧が掲載されている。それから、クラスをライブラリー化する判定基準を述べている。</p>
<ul class="simple">
<li><p>クラスが C++ プログラマーの熟練度によらずに有用であること</p></li>
<li><p>特別なオーバーヘッドを必要としないこと</p></li>
<li><p>クラスの単純な利用方法が容易に学習できること</p></li>
</ul>
</div>
<div class="section" id="id61">
<h3><a class="toc-backref" href="#id198">6.3 標準ライブラリヘッダと名前空間</a><a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>標準ライブラリー機能は名前空間 <code class="docutils literal notranslate"><span class="pre">std</span></code> の中で定義されている。</p></li>
<li><p>本書では次の二点を明示することがないことがほとんどだ：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">std::</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#include</span></code></p></li>
</ul>
</li>
<li><p>ある名前空間のすべての名前を広域名前空間に持ち込むのはお粗末とされる。つまり
<code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std;</span></code> とは、一般的にはお粗末だと言っている。</p></li>
</ul>
<p>最後に名前空間 <code class="docutils literal notranslate"><span class="pre">std</span></code> 内の宣言をもつ標準ライブラリーのヘッダーファイルの一部の一覧がある。この時点で今 (C++98/03) まで見たことがないものがある。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;array&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;chrono&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;forward_list&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;future&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;random&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;regex&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;thread&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;unordered_map&gt;</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;stdlib.h&gt;</span></code> のような標準 C のライブラリーも提供されている。これの
<code class="docutils literal notranslate"><span class="pre">std</span></code> バージョンは <code class="docutils literal notranslate"><span class="pre">&lt;cstdlib&gt;</span></code> となる。他の標準 C のライブラリーにも同様の対応物がある。</p></li>
</ul>
</div>
<div class="section" id="id62">
<h3><a class="toc-backref" href="#id199">6.4 アドバイス</a><a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>標準ライブラリーが万能であると考えないように。</p></li>
</ul>
<p>これは標準以外のライブラリーも調べてくれという意味にとる。</p>
</div>
</div>
<div class="section" id="id63">
<h2><a class="toc-backref" href="#id200">第 7 章 文字列と正規表現</a><a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id64">
<h3><a class="toc-backref" href="#id201">7.1 はじめに</a><a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>C++ の正規表現は近代的な言語のほとんどと似た形式のものだ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code> オブジェクトと <code class="docutils literal notranslate"><span class="pre">regex</span></code> オブジェクトは、Unicode
を含むさまざまな文字型をサポートしている。</p></li>
</ul>
</div>
<div class="section" id="id65">
<h3><a class="toc-backref" href="#id202">7.2 文字列</a><a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>《標準の <code class="docutils literal notranslate"><span class="pre">string</span></code> はムーブコンストラクタを実装しているので、長い
<code class="docutils literal notranslate"><span class="pre">string</span></code> を値で返す処理は、効率よく行われる》</p></li>
</ul>
<div class="section" id="string">
<h4><a class="toc-backref" href="#id203">7.2.1 <code class="docutils literal notranslate"><span class="pre">string</span></code> の実装</a><a class="headerlink" href="#string" title="Permalink to this headline">¶</a></h4>
<p>《近年 、<code class="docutils literal notranslate"><span class="pre">string</span></code> は、短い文字列の最適化という手法で実装されている。これは、短い文字列の値を
<code class="docutils literal notranslate"><span class="pre">string</span></code> オブジェクト自身の中に保持しておき、長いものを空き領域に置くというものだ》</p>
</div>
</div>
<div class="section" id="id66">
<h3><a class="toc-backref" href="#id204">7.3 正規表現</a><a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>《標準ライブラリは <code class="docutils literal notranslate"><span class="pre">&lt;regex&gt;</span></code> で、<code class="docutils literal notranslate"><span class="pre">regex</span></code> クラスと、それを補助する関数とで正規表現のサポートを提供する》</p></li>
<li><p>パターンの表現には Python のように原文字列リテラルを利用するといい。
C++ では次のように文字列リテラルを定義することもできる：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">pattern</span><span class="dl">)</span><span class="s">&quot;</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;regex&gt;</span></code> が提供する主な機能：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">regex_match()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">regex_search()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">regex_replace()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">regex_iterator</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">regex_token_iterator</span></code></p></li>
</ul>
</li>
</ul>
<div class="section" id="id67">
<h4><a class="toc-backref" href="#id205">7.3.1 探索</a><a class="headerlink" href="#id67" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">regex_search()</span></code> は <code class="docutils literal notranslate"><span class="pre">bool</span></code> 値を返す。引数の <code class="docutils literal notranslate"><span class="pre">smatch</span></code>
オブジェクトに結果を格納する。このオブジェクトは《一致部分の
<code class="docutils literal notranslate"><span class="pre">string</span></code> 型を要素とする <code class="docutils literal notranslate"><span class="pre">vector</span></code> である》。</p></li>
</ul>
</div>
<div class="section" id="id68">
<h4><a class="toc-backref" href="#id206">7.3.2 正規表現の表記</a><a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h4>
<p>正規表現には「方言」がいろいろある。C++ の正規表現ライブラリでは
ECMAScript で利用されているECMA 標準の変種をデフォルトの「方言」として採用している。</p>
<p>このサブセクションは正規表現のメタキャラクターに関する説明に終始しているので省略。</p>
</div>
<div class="section" id="id69">
<h4><a class="toc-backref" href="#id207">7.3.3 反復子</a><a class="headerlink" href="#id69" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sregex_iterator</span></code> のコンストラクター呼び出しで正規表現の検索をする。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">sregex_iterator</span></code> は <code class="docutils literal notranslate"><span class="pre">regex_iterator&lt;string&gt;</span></code> のことだ。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">regex_iteartor</span></code> は双方向反復子なので、入力ストリームに対する反復処理を直接的に行うことはできない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sregex_iterator</span></code> のデフォルトコンストラクターが返す反復子が
<code class="docutils literal notranslate"><span class="pre">end()</span></code> 相当。</p></li>
</ul>
</div>
</div>
<div class="section" id="id70">
<h3><a class="toc-backref" href="#id208">7.4 アドバイス</a><a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>C 言語スタイルの文字列関数よりも、<code class="docutils literal notranslate"><span class="pre">string</span></code> 処理を優先しよう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code> を返す場合は、（ムーブセマンティクスに基づいて）値で返却しよう。</p></li>
<li><p>どうしても必要ならば（どうしても必要な場合に限り）、
<code class="docutils literal notranslate"><span class="pre">string</span></code> の C 言語スタイル文字列表現の生成に <code class="docutils literal notranslate"><span class="pre">c_str()</span></code> を利用しよう。</p></li>
<li><p>きわめて単純なパターンでなければ、正規表現の記述には原文字列を優先しよう。</p></li>
<li><p>正規表現の文法は、さまざまな標準に準拠するように細かく制御できる。</p></li>
<li><p>ストリームに対してパターンを反復して探すには <code class="docutils literal notranslate"><span class="pre">regex_iterator</span></code> を使おう。</p></li>
</ul>
</div>
</div>
<div class="section" id="id71">
<h2><a class="toc-backref" href="#id209">第 8 章 入出力ストリーム</a><a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id72">
<h3><a class="toc-backref" href="#id210">8.1 はじめに</a><a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>入出力ストリームは、テキストや数値を書式あり・なしでバッファリングする入出力機能と考えられる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ostream</span></code> はオブジェクトを文字・バイトのストリームに変換する。反対に
<code class="docutils literal notranslate"><span class="pre">istream</span></code> は文字・バイトのストリームをオブジェクトに変換する。</p></li>
<li><p>これらの処理は型安全・型付けがされているだけでなく、ユーザー定義型を処理するように拡張することも可能だ。</p></li>
<li><p>それ以外の形態の入出力は標準の範囲外だ。</p></li>
<li><p>本書では扱われないが、標準ストリームはロケール依存であり、高度なバッファリング手法を採用している。</p></li>
</ul>
</div>
<div class="section" id="id73">
<h3><a class="toc-backref" href="#id211">8.2 出力</a><a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h3>
<p>目新しいことはないようなので省略。</p>
</div>
<div class="section" id="id74">
<h3><a class="toc-backref" href="#id212">8.3 入力</a><a class="headerlink" href="#id74" title="Permalink to this headline">¶</a></h3>
<p>ここも従来と変わりはない。</p>
<ul class="simple">
<li><p>《デフォルトでは、スペースなどの空白類文字は読み取りを終了させる。（略）末尾の改行文字までの行全体を読み取る場合は <code class="docutils literal notranslate"><span class="pre">getline()</span></code> 関数を使う》</p></li>
</ul>
</div>
<div class="section" id="id75">
<h3><a class="toc-backref" href="#id213">8.4 入出力の状態</a><a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h3>
<p>ここも従来と変わりはない。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iostream</span></code> は状態を持っている。ストリームオブジェクト自身が <code class="docutils literal notranslate"><span class="pre">bool</span></code> に変換される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cin</span> <span class="pre">&gt;&gt;</span> <span class="pre">i</span></code> を <code class="docutils literal notranslate"><span class="pre">if</span></code> 文の条件部に書くこともできる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cin.eof()</span></code>, <code class="docutils literal notranslate"><span class="pre">cin.fail()</span></code> など、直接状態を問い合わせるメンバーもある。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cin.clear()</span></code> で状態を勝手にリセットできる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cin.setstate(ios_base::failbit)</span></code> などとすることで状態を勝手にセットできる。</p></li>
</ul>
</div>
<div class="section" id="id76">
<h3><a class="toc-backref" href="#id214">8.5 ユーザ定義型の入出力</a><a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h3>
<p>ここも従来と変わりはない。</p>
<ul class="simple">
<li><p>出力演算子のオーバーロードは単純に書ける。一方、《入力演算子のそれは書式の確認やエラー処理が必要なので、少し複雑になる》。</p></li>
<li><p>サンプルコードでは最終的にストリームオブジェクトのフラグを失敗にマークする場合がある。例外を送出することはできないのだろうか。</p></li>
<li><p>入力演算子は <code class="docutils literal notranslate"><span class="pre">istream</span></code> への参照を返すので、それをうまく使って入力のオーバーロードを実装する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is.get(c)</span></code> は空白文字を読み飛ばさない。</p></li>
</ul>
</div>
<div class="section" id="id77">
<h3><a class="toc-backref" href="#id215">8.6 書式化</a><a class="headerlink" href="#id77" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>もっとも単純な書式化の制御は、操作子によって行える。定義されているヘッダーファイルが複数にばらけている：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;ios&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;istream&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;ostream&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;iomanip&gt;</span></code>: 引数を受け取る操作子が定義されている。</p></li>
</ul>
</li>
<li><p>浮動小数点数値の出力書式を学ぶ。</p>
<ul>
<li><p>一般書式 <code class="docutils literal notranslate"><span class="pre">defaultfloat</span></code>: 処理系に適当な書式を選択させる。これが C++11 機能。</p></li>
<li><p>科学技術書式 <code class="docutils literal notranslate"><span class="pre">scientific</span></code></p></li>
<li><p>固定書式 <code class="docutils literal notranslate"><span class="pre">fixed</span></code></p></li>
</ul>
</li>
<li><p>浮動小数点数値は丸められる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">precision()</span></code> は整数に影響しない。</p></li>
<li><p>浮動小数点数の書式は有効性が持続する。一度出力してリセット、ではない。</p></li>
</ul>
</div>
<div class="section" id="id78">
<h3><a class="toc-backref" href="#id216">8.7 ファイルストリーム</a><a class="headerlink" href="#id78" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">&lt;fstream&gt;</span></code> の提供する機能の話題だが、ここで述べられていることは
<code class="docutils literal notranslate"><span class="pre">iostream</span></code> の機能に過ぎない。</p>
</div>
<div class="section" id="id79">
<h3><a class="toc-backref" href="#id217">8.8 文字列ストリーム</a><a class="headerlink" href="#id79" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">&lt;sstream&gt;</span></code> の提供する機能の話題だが、ここで述べられていることは
<code class="docutils literal notranslate"><span class="pre">iostream</span></code> の機能に過ぎない。</p>
</div>
<div class="section" id="id80">
<h3><a class="toc-backref" href="#id218">8.9 アドバイス</a><a class="headerlink" href="#id80" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> はデフォルトでは空白文字を読み飛ばす。</p></li>
<li><p>回復できる可能性がある入出力エラーを処理するには、ストリーム状態 <code class="docutils literal notranslate"><span class="pre">fail</span></code> を調べよう。</p></li>
<li><p>ファイルストリームのコピーを試みないようにしよう。</p></li>
<li><p>メモリ上で書式化するのであれば、<code class="docutils literal notranslate"><span class="pre">stringstream</span></code> を利用しよう。</p></li>
</ul>
</div>
</div>
<div class="section" id="id81">
<h2><a class="toc-backref" href="#id219">第 9 章 コンテナ</a><a class="headerlink" href="#id81" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id82">
<h3><a class="toc-backref" href="#id220">9.1 はじめに</a><a class="headerlink" href="#id82" title="Permalink to this headline">¶</a></h3>
<p>コンテナとは、オブジェクトを内部に保持することを目的とするクラスのことだ。</p>
</div>
<div class="section" id="vector">
<h3><a class="toc-backref" href="#id221">9.2 <code class="docutils literal notranslate"><span class="pre">vector</span></code></a><a class="headerlink" href="#vector" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>標準コンテナの中で最も有用。</p></li>
<li><p>オブジェクト初期化のコードが中括弧でなされているので注意（このクラスに限った話ではないが）。</p></li>
<li><p>範囲 <code class="docutils literal notranslate"><span class="pre">for</span></code> ループが利用できる。</p></li>
<li><p>《標準ライブラリの <code class="docutils literal notranslate"><span class="pre">vector</span></code> を使っているのは、<code class="docutils literal notranslate"><span class="pre">push_back()</span></code>
を繰り返したときの効率がよいからだ》からのメモリと要素の確保の基本についてはよく読んでおく。</p>
<ul>
<li><p>《私は <code class="docutils literal notranslate"><span class="pre">reserve()</span></code> を性能向上のために使ったことがある。しかし、無駄な努力であることが判明した》。要素の再確保を回避するときだけに使うようだ。</p></li>
</ul>
</li>
<li><p>コピーが望ましくないときは、参照やポインタ、あるいはムーブ演算を使う。</p></li>
</ul>
<div class="section" id="id83">
<h4><a class="toc-backref" href="#id222">9.2.1 要素</a><a class="headerlink" href="#id83" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>標準ライブラリーのすべてのコンテナーについて、要素の型は任意だ。</p></li>
<li><p>新しい要素をコンテナーに追加する際は、その値がコンテナー内にコピーされる。</p></li>
<li><p>仮想関数クラスを利用したクラス階層を使っているのであれば、オブジェクトを直接保持させてはならない。ポインターまたはスマートポインター（後述）を保持させる。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">*&gt;</span> <span class="n">vps</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span> <span class="n">vups</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="id84">
<h5><a class="toc-backref" href="#id223">9.2.1.1 範囲チェック</a><a class="headerlink" href="#id84" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><p>標準ライブラリーの <code class="docutils literal notranslate"><span class="pre">vector</span></code> は <code class="docutils literal notranslate"><span class="pre">operator[]()</span></code> は範囲チェックを保証しない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">at()</span></code> は引数が要素の範囲を越えている場合に <code class="docutils literal notranslate"><span class="pre">out_of_range</span></code> 例外を創出する。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">main()</span></code> を <code class="docutils literal notranslate"><span class="pre">try</span></code> ブロックとして定義する方法にも触れられている。</p>
</div>
</div>
</div>
<div class="section" id="list">
<h3><a class="toc-backref" href="#id224">9.3 <code class="docutils literal notranslate"><span class="pre">list</span></code></a><a class="headerlink" href="#list" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>要素を移動することなく、要素の挿入や削除を行う必要があるシーケンスに対して利用するものだ。</p></li>
<li><p>要素数が少ない場合は <code class="docutils literal notranslate"><span class="pre">list</span></code> よりも <code class="docutils literal notranslate"><span class="pre">vector</span></code> のほうが性能がよい。</p></li>
<li><p>走査やソートと探索などでは <code class="docutils literal notranslate"><span class="pre">vector</span></code> のほうが性能が高い。</p></li>
</ul>
</div>
<div class="section" id="map">
<h3><a class="toc-backref" href="#id225">9.4 <code class="docutils literal notranslate"><span class="pre">map</span></code></a><a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code> は連想配列や辞書などと呼ばれることもあり、平衡二分木として実装される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code> は探索に特化されている。</p></li>
<li><p>角括弧よりも <code class="docutils literal notranslate"><span class="pre">find()</span></code> や <code class="docutils literal notranslate"><span class="pre">insert()</span></code> を使うと、不意に値が追加されることを避けられる。</p></li>
</ul>
</div>
<div class="section" id="unordered-map">
<h3><a class="toc-backref" href="#id226">9.5 <code class="docutils literal notranslate"><span class="pre">unordered_map</span></code></a><a class="headerlink" href="#unordered-map" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code> の探索コストは対数オーダーであり、効率的ではあるのだが、順序判定を必要としないハッシュベースの探索のほうが効率は優る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unordered_map</span></code> のインタフェースは <code class="docutils literal notranslate"><span class="pre">map</span></code> とよく似ている。というか、同じでないとおかしい。</p></li>
<li><p>ハッシュ関数を自作することもできる。その場合にはクラステンプレートの引数に自作関数を指定する。</p></li>
</ul>
</div>
<div class="section" id="id85">
<h3><a class="toc-backref" href="#id227">9.6 コンテナのまとめ</a><a class="headerlink" href="#id85" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>非順序コンテナはキーによる探索用に最適化されている。</p></li>
<li><p>《<code class="docutils literal notranslate"><span class="pre">queue&lt;T&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">stack&lt;T&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">priority_queue&lt;T&gt;</span></code>
というコンテナアダプタを提供する》。これらの内部に標準コンテナが含まれている。</p></li>
<li><p>標準コンテナとその基本的な処理は、コンテナが異なっていても記法と意味が画一であるように設計されている。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">forward_list</span></code> は空のシーケンスに対して最適化が行われている。《意外にも便利だ》そうだ。</p></li>
</ul>
</div>
<div class="section" id="id86">
<h3><a class="toc-backref" href="#id228">9.7 アドバイス</a><a class="headerlink" href="#id86" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>デフォルトのコンテナとして <code class="docutils literal notranslate"><span class="pre">vector</span></code> を利用しよう。</p></li>
<li><p>要素数を変更した <code class="docutils literal notranslate"><span class="pre">vector</span></code> に対して、反復子を利用しないように。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code> は、一般的に、赤黒木として実装される。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unordered_map</span></code> は、ハッシュ表である。</p></li>
<li><p>コンテナは、参照渡しで与えて、値で返却しよう。</p></li>
<li><p>コンテナの要素数指定には <code class="docutils literal notranslate"><span class="pre">()</span></code> 構文の初期化子を利用して、要素の並びの指定には <code class="docutils literal notranslate"><span class="pre">{}</span></code> 構文を利用しよう。</p></li>
<li><p>メモリ上で連続するコンパクトなデータ構造を優先しよう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code> の走査は、比較的高コストである。</p></li>
<li><p>要素の型が自然な順序をもたない場合は、非順序コンテナを利用しよう。</p></li>
<li><p>標準ライブラリのコンテナを熟知して、手作りのデータ構造よりも優先させよう。</p></li>
</ul>
</div>
</div>
<div class="section" id="id87">
<h2><a class="toc-backref" href="#id229">第 10 章 アルゴリズム</a><a class="headerlink" href="#id87" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id88">
<h3><a class="toc-backref" href="#id230">10.1 はじめに</a><a class="headerlink" href="#id88" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>標準アルゴリズムは半開区間の要素のシーケンスを処理する。それは先頭要素を指す反復子と、末尾要素の直後を指す反復子とで表現される。</p></li>
<li><p>標準ライブラリの <code class="docutils literal notranslate"><span class="pre">list</span></code> はムーブコンストラクタをもっているので、このコードのような
<code class="docutils literal notranslate"><span class="pre">return</span></code> 文が効率よく行われる。</p></li>
</ul>
</div>
<div class="section" id="id89">
<h3><a class="toc-backref" href="#id231">10.2 反復子の利用</a><a class="headerlink" href="#id89" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">begin()</span></code> と <code class="docutils literal notranslate"><span class="pre">end()</span></code> がいちばん基本的な反復子だ。</p></li>
<li><p>標準ライブラリの探索アルゴリズムの多くが、見つからなかったことを伝えるために <code class="docutils literal notranslate"><span class="pre">end()</span></code>
を返す（正確に言うと、引数として渡した半開区間の終端を指す反復子を返す）。</p></li>
<li><p>反復子を使うと、アルゴリズムとコンテナが分離できる。このモデルにより汎用性と柔軟性が高まる。</p>
<ul>
<li><p>アルゴリズムはデータが格納されているコンテナについては何も知らない。</p></li>
<li><p>コンテナは、データに適用されるアルゴリズムについては何も知らない。</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id90">
<h3><a class="toc-backref" href="#id232">10.3 反復子の型</a><a class="headerlink" href="#id90" title="Permalink to this headline">¶</a></h3>
<p>特定の反復子の型をユーザーが意識しなければならない場面はほとんどない。</p>
</div>
<div class="section" id="id91">
<h3><a class="toc-backref" href="#id233">10.4 ストリーム反復子</a><a class="headerlink" href="#id91" title="Permalink to this headline">¶</a></h3>
<p>ストリームが値のシーケンスを読み書きすることから、反復子の概念をストリームに適用できる。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ostream_iterator</span></code> を作るには、出力ストリームと出力オブジェクトの型の両方の指定が必要だ。</p>
<ul>
<li><p>出力ストリームはコンストラクターの引数とする。</p></li>
<li><p>出力オブジェクトの型をテンプレート引数とする。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">istream_iterator</span></code> も同様だ。ただし終端についてはストリームの指定をできない。</p></li>
<li><p>これらの反復子を p. 118 のように直接利用することはほとんどない。アルゴリズムの引数として与えるのがふつうだ。</p></li>
</ul>
<p>デモコードの一時変数についての書き換えについて。C++11 から中括弧でコンストラクターを呼び出せるようになったことが実は大きいのでは？従来だと p. 120 のコードを丸括弧で書くとダメコンパイラーが文句を言ったと記憶している。</p>
</div>
<div class="section" id="id92">
<h3><a class="toc-backref" href="#id234">10.5 述語</a><a class="headerlink" href="#id92" title="Permalink to this headline">¶</a></h3>
<p>処理をアルゴリズムの引数とすることもできる。特に <code class="docutils literal notranslate"><span class="pre">bool</span></code> 値を返すようなものを述語という。</p>
<p>述語の形式には関数、関数オブジェクト、ラムダ式が考えられる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span>
    <span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">){</span> <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="mi">42</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="id93">
<h3><a class="toc-backref" href="#id235">10.6 アルゴリズムのまとめ</a><a class="headerlink" href="#id93" title="Permalink to this headline">¶</a></h3>
<p>《アルゴリズムの一般的な定義は、“特定の問題を解くための一連の演算を提供する有限個の規則であり、しかも五つの重要な機能である有限性、確定性、入力、出力、効率性をもっているもの”(Knuth, 1968) である。
C++ 標準ライブラリでのアルゴリズムの定義は、要素のシーケンスを処理するための関数テンプレートである》。これは諳んじられるようにしておきたい。</p>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;algorithm&gt;</span></code> に数十ものアルゴリズムが定義されている。</p></li>
<li><p>標準アルゴリズムは、入力シーケンス一つを受け取るのに半開区間で表される二つの反復子を引数に取る。</p></li>
<li><p>標準アルゴリズムの多くが、コンテナ、文字列、組み込み型の配列に適用できる。</p></li>
<li><p>コンテナ内の要素を加えたり取り除いたりするアルゴリズムはない。アルゴリズムはコンテナを知らない。</p></li>
</ul>
</div>
<div class="section" id="id94">
<h3><a class="toc-backref" href="#id236">10.7 コンテナアルゴリズム</a><a class="headerlink" href="#id94" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>シーケンスを一対の反復子で扱うことで、汎用的かつ柔軟さを得られる。</p></li>
<li><p>コンテナ全体に対してアルゴリズムを適用することが多いが、それが望みなら自作できる。</p></li>
</ul>
</div>
<div class="section" id="id95">
<h3><a class="toc-backref" href="#id237">10.8 アドバイス</a><a class="headerlink" href="#id95" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>ループを記述する際は、汎用アルゴリズムとして表現できるかどうかを検討しよう。</p></li>
<li><p>述語は、引数を更新してはならない。</p></li>
<li><p>標準アルゴリズムを理解して、手作りのループよりも優先しよう。</p></li>
</ul>
</div>
</div>
<div class="section" id="id96">
<h2><a class="toc-backref" href="#id238">第 11 章 ユーティリティ</a><a class="headerlink" href="#id96" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id97">
<h3><a class="toc-backref" href="#id239">11.1 はじめに</a><a class="headerlink" href="#id97" title="Permalink to this headline">¶</a></h3>
<p>《小規模だが幅広く有用な》標準コンポーネントを見ていく。</p>
</div>
<div class="section" id="id98">
<h3><a class="toc-backref" href="#id240">11.2 資源管理</a><a class="headerlink" href="#id98" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>本書では資源を次のように定義している：《利用するために獲得して、利用後に暗黙的あるいは明示的に解放するもの》。</p></li>
<li><p>《標準ライブラリのコンポーネントは、資源リークを発生させないように設計されている。（略）コンストラクタとデストラクタを組み合わせることで、オブジェクトが消滅した際に、資源だけが残らないことが保証される》。この技法が資源管理の基本だとある。</p></li>
</ul>
<div class="section" id="unique-ptr-shared-ptr">
<h4><a class="toc-backref" href="#id241">11.2.1 <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> と <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code></a><a class="headerlink" href="#unique-ptr-shared-ptr" title="Permalink to this headline">¶</a></h4>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;memory&gt;</span></code> が提供する二種類のスマートポインター：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>: 所有権が独占的</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>: 所有権が共有される</p></li>
</ul>
<p>関数 <code class="docutils literal notranslate"><span class="pre">make_shared()</span></code> は存在するが <code class="docutils literal notranslate"><span class="pre">make_unique()</span></code> は（本書執筆時点では）存在しない。ということで、後者の実装例を紹介している。この可変個引数テンプレートと転送参照のコードは重要なので頭に焼き付けておくこと。</p>
<p>《関数からオブジェクトの集合を返す際に、必ずしもポインタを使う必要はない。資源ハンドルであるコンテナを使えば、簡潔かつ効率的に行える》</p>
</div>
</div>
<div class="section" id="id99">
<h3><a class="toc-backref" href="#id242">11.3 特殊化されたコンテナ</a><a class="headerlink" href="#id99" title="Permalink to this headline">¶</a></h3>
<p>STL の定めるコンテナ要件と完全に合致しないようなコンテナがいくつかある。著者はこれを妥当性には欠けるものの almost container と呼んでいる。</p>
<ul class="simple">
<li><p>組み込み配列</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">array&lt;T,</span> <span class="pre">N&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bitset&lt;N&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pair&lt;T,</span> <span class="pre">U&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tuple&lt;T...&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">basic_string&lt;C&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">valarray&lt;T&gt;</span></code></p></li>
</ul>
<div class="section" id="array">
<h4><a class="toc-backref" href="#id243">11.3.1 <code class="docutils literal notranslate"><span class="pre">array</span></code></a><a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>《<code class="docutils literal notranslate"><span class="pre">array</span></code> は、要素数が固定されて、想定外にポインタ型への変換が行われることがなくて、僅かではあるものの有用な関数を提供する組み込み配列とみなすとわかりやすい。組み込み配列と比較して（時間的あるいは空間的な）オーバーヘッドもない》</p></li>
<li><p>《私が <code class="docutils literal notranslate"><span class="pre">array</span></code> を採用する主な理由は、想定外にポインタへと変換されて困ってしまう事態を避けるためだ》</p></li>
</ul>
</div>
<div class="section" id="bitset">
<h4><a class="toc-backref" href="#id244">11.3.2 <code class="docutils literal notranslate"><span class="pre">bitset</span></code></a><a class="headerlink" href="#bitset" title="Permalink to this headline">¶</a></h4>
<p>従来と変わらないようだ。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bitset&lt;N&gt;</span></code> のサイズ <code class="docutils literal notranslate"><span class="pre">N</span></code> の値がコンパイル時に既知である必要がある。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span></code> に収まらないビットセットは整数を直接利用するのはキツイ。</p></li>
<li><p>ビットに対して番号ではなく名前でアクセスしたいならば <code class="docutils literal notranslate"><span class="pre">set</span></code> や列挙体を採用するほうがよい。</p></li>
</ul>
</div>
<div class="section" id="pair-tuple">
<h4><a class="toc-backref" href="#id245">11.3.3 <code class="docutils literal notranslate"><span class="pre">pair</span></code> と <code class="docutils literal notranslate"><span class="pre">tuple</span></code></a><a class="headerlink" href="#pair-tuple" title="Permalink to this headline">¶</a></h4>
<p>前者は従来と変わらないようなのでノート略。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tuple</span></code> は異種要素のシーケンスだと言っているので Python でいう
<code class="docutils literal notranslate"><span class="pre">tuple</span></code> と同格の存在だろう。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">make_tuple()</span></code> でオブジェクトを生成するといい。</p></li>
<li><p>要素を取り出すのに例えば <code class="docutils literal notranslate"><span class="pre">get&lt;1&gt;(t)</span></code> のような《見苦しい記述》をする。</p></li>
</ul>
</div>
</div>
<div class="section" id="id100">
<h3><a class="toc-backref" href="#id246">11.4 時間</a><a class="headerlink" href="#id100" title="Permalink to this headline">¶</a></h3>
<p>《時間を処理する標準ライブラリ機能は <code class="docutils literal notranslate"><span class="pre">&lt;chrono&gt;</span></code> で、<code class="docutils literal notranslate"><span class="pre">std::chrono</span></code>
部分名前空間の中で定義されている》</p>
</div>
<div class="section" id="id101">
<h3><a class="toc-backref" href="#id247">11.5 関数アダプタ</a><a class="headerlink" href="#id101" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>関数アダプタを次のように説明している：《関数を引数として受け取って、その関数を実行する関数オブジェクトを返す》。つまり機能としては関数だ。</p></li>
<li><p>カレー化、部分評価と呼ばれるものだ。</p></li>
<li><p>《バインダは過去に多用されていたが、それらの大部分の用途では、ラムダ式を用いることで、より容易に記述できると考えられる》。そうなのか。</p></li>
</ul>
<div class="section" id="bind">
<h4><a class="toc-backref" href="#id248">11.5.1 <code class="docutils literal notranslate"><span class="pre">bind()</span></code></a><a class="headerlink" href="#bind" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">placeholders;</span></code></p></li>
<li><p>《多重定義した関数の引数をバインドするには、バインド対象がどの関数であるのかを明示する必要がある》。このコード片だと旧式キャストを適用することになる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bind()</span></code> の結果を保持するならば <code class="docutils literal notranslate"><span class="pre">auto</span></code> として宣言した変数に対して代入するのがよい。</p></li>
</ul>
</div>
<div class="section" id="mem-fn">
<h4><a class="toc-backref" href="#id249">11.5.2 <code class="docutils literal notranslate"><span class="pre">mem_fn()</span></code></a><a class="headerlink" href="#mem-fn" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mem_fn(mf)</span></code> の形でフリー関数として呼び出される関数オブジェクトを生成する。</p></li>
<li><p>標準アルゴリズムがフリー関数の呼び出しを前提としているので、こういうものが提供される。</p></li>
<li><p>《バインダの代わりに、簡潔で汎用的なラムダ式が利用できることも多い》</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Shape</span><span class="o">::</span><span class="n">draw</span><span class="p">));</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">Shape</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span> <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="function">
<h4><a class="toc-backref" href="#id250">11.5.3 <code class="docutils literal notranslate"><span class="pre">function</span></code></a><a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">round</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>《標準ライブラリの <code class="docutils literal notranslate"><span class="pre">function</span></code> は、呼出し演算子 <code class="docutils literal notranslate"><span class="pre">()</span></code>
によって呼び出せる任意のオブジェクトを保持する型だ。すなわち、<code class="docutils literal notranslate"><span class="pre">function</span></code>
型のオブジェクトは、関数オブジェクトである》</p></li>
<li><p>コールバックや処理を引数に渡す場合に有用。</p></li>
</ul>
</div>
</div>
<div class="section" id="id102">
<h3><a class="toc-backref" href="#id251">11.6 型関数</a><a class="headerlink" href="#id102" title="Permalink to this headline">¶</a></h3>
<p>型関数とは関数であって、次の条件を満たすものを指す：</p>
<ul class="simple">
<li><p>引数か返却値として型が与えられるもの</p></li>
<li><p>コンパイル時に評価されるもの</p></li>
</ul>
<div class="section" id="iterator-traits">
<h4><a class="toc-backref" href="#id252">11.6.1 <code class="docutils literal notranslate"><span class="pre">iterator_traits</span></code></a><a class="headerlink" href="#iterator-traits" title="Permalink to this headline">¶</a></h4>
<p>タグディスパッチの解説。時間がないので略。</p>
</div>
<div class="section" id="id103">
<h4><a class="toc-backref" href="#id253">11.6.2 型述語</a><a class="headerlink" href="#id103" title="Permalink to this headline">¶</a></h4>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;type_traits&gt;</span></code> に、型に関する基本的な情報を返すだけの単純な型関数が提供されている。これらの機能はテンプレートを作成する際に有用となる。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">is_class</span></code>, <code class="docutils literal notranslate"><span class="pre">is_pod</span></code>, <code class="docutils literal notranslate"><span class="pre">is_literal_type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">has_trivial_destructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_base_of</span></code></p></li>
<li><p>etc.</p></li>
</ul>
</div>
</div>
<div class="section" id="id104">
<h3><a class="toc-backref" href="#id254">11.7 アドバイス</a><a class="headerlink" href="#id104" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>取得して解放するものは、すべて資源である</p></li>
<li><p>資源管理には、資源ハンドルを使おう (RAII)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> よりも <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> を優先しよう</p></li>
<li><p>しばしば、ラムダは <code class="docutils literal notranslate"><span class="pre">bind()</span></code> や <code class="docutils literal notranslate"><span class="pre">mem_fn()</span></code> の代替となる</p></li>
</ul>
</div>
</div>
<div class="section" id="id105">
<h2><a class="toc-backref" href="#id255">第 12 章 数値演算</a><a class="headerlink" href="#id105" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id106">
<h3><a class="toc-backref" href="#id256">12.1 はじめに</a><a class="headerlink" href="#id106" title="Permalink to this headline">¶</a></h3>
<p>《より複雑なデータ処理では、C++ の強力な機能が真価を発揮する》</p>
</div>
<div class="section" id="id107">
<h3><a class="toc-backref" href="#id257">12.2 数学関数</a><a class="headerlink" href="#id107" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;cmath&gt;</span></code> に標準数学関数と呼ばれる関数がある。表によると絶対値、数値を丸める関数、平方根、三角関数、逆三角関数、双曲線関数、逆双曲線関数、指数関数、対数関数が勢ぞろいだ。</p></li>
<li><p>引数型として次の組み込み型がサポートされている。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code></p></li>
</ul>
</li>
<li><p>《エラーは、 <code class="docutils literal notranslate"><span class="pre">&lt;cerrono&gt;</span></code> が定義する <code class="docutils literal notranslate"><span class="pre">errono</span></code> への代入によって通知される。定義域エラーならば <code class="docutils literal notranslate"><span class="pre">EDOM</span></code> であり、値域エラーならば <code class="docutils literal notranslate"><span class="pre">ERANGE</span></code> である》。これは知らなかった。大域変数を見に行く必要があるとは。</p></li>
</ul>
<p>最後で触れられている特殊数学関数とは、微分方程式の教科書などで紹介されているような一群の関数のことだと思われる。</p>
</div>
<div class="section" id="id108">
<h3><a class="toc-backref" href="#id258">12.3 数値アルゴリズム</a><a class="headerlink" href="#id108" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;numeric&gt;</span></code> は汎用の数値アルゴリズムを提供している。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">accumulate()</span></code>: 和</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inner_product()</span></code>: スカラー積</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">partial_sum()</span></code>: 部分和</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjacent_difference()</span></code>: 階差数列</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iota()</span></code>: Python の <code class="docutils literal notranslate"><span class="pre">range()</span></code> のようなもの</p></li>
</ul>
<p>《シーケンスの要素に対して演算をパラメータ化して適用することも可能だ》。</p>
</div>
<div class="section" id="id109">
<h3><a class="toc-backref" href="#id259">12.4 複素数</a><a class="headerlink" href="#id109" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;complex&gt;</span></code> について。</p>
<ul class="simple">
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">complex</span></code> の実部と虚部がテンプレートになっているので、
<code class="docutils literal notranslate"><span class="pre">float</span></code> でも <code class="docutils literal notranslate"><span class="pre">double</span></code> でもサポートされる。</p></li>
<li><p>また、複素数に対する一般的な算術演算および数学関数も提供されている。</p></li>
</ul>
</div>
<div class="section" id="id110">
<h3><a class="toc-backref" href="#id260">12.5 乱数</a><a class="headerlink" href="#id110" title="Permalink to this headline">¶</a></h3>
<p>乱数機能は C++11 で変貌を遂げたようだ。</p>
<blockquote>
<div><p>標準ライブラリの <code class="docutils literal notranslate"><span class="pre">&lt;random&gt;</span></code> では、多様な乱数生成関数が提供されている。乱数生成関数は、以下の二つの要素で構成されている：</p>
<ol class="arabic simple">
<li><p><strong>エンジン</strong> ：乱数または疑似乱数を生成する。</p></li>
<li><p><strong>分布</strong> ：生成した値を一定範囲の数学的分布へとマップする。</p></li>
</ol>
</div></blockquote>
<p>まず p. 144 のコードを見ると、もうわけがわからない。しかし急所を書き換えてくれてある：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">die</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span>
    <span class="n">uniform_int_distribution</span><span class="o">&lt;&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
    <span class="n">default_random_engine</span><span class="p">{});</span>
</pre></div>
</div>
<p>こうすることで呼び出し <code class="docutils literal notranslate"><span class="pre">die()</span></code> が 1 から 6 までの出目を無作為抽出するようになる。</p>
<p>《初心者にとっては、乱数生成ライブラリのインタフェースが完全に汎用化されていることが、大きな障害となり得る。そのため、単純な一様乱数の生成から始めるとよいだろう》</p>
</div>
<div class="section" id="id111">
<h3><a class="toc-backref" href="#id261">12.6 ベクタの算術演算</a><a class="headerlink" href="#id111" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vector</span></code> には算術演算がサポートされていない。</p></li>
<li><p>《標準ライブラリ <code class="docutils literal notranslate"><span class="pre">&lt;valarray&gt;</span></code> で <code class="docutils literal notranslate"><span class="pre">vector</span></code> に似たテンプレート <code class="docutils literal notranslate"><span class="pre">valarray</span></code>
を提供している。これは汎用性を低めることによって、数値演算を最適化しやすくするものだ》</p></li>
</ul>
</div>
<div class="section" id="id112">
<h3><a class="toc-backref" href="#id262">12.7 数値の限界値</a><a class="headerlink" href="#id112" title="Permalink to this headline">¶</a></h3>
<p>ヘッダーファイル <code class="docutils literal notranslate"><span class="pre">&lt;limits&gt;</span></code> には組み込み型の性質を表すクラスが提供されていて、p. 146
のコード片のようなコンパイル時診断を可能とする。</p>
</div>
<div class="section" id="id113">
<h3><a class="toc-backref" href="#id263">12.8 アドバイス</a><a class="headerlink" href="#id113" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>数値演算は技巧的なものとなりがちだ。</p></li>
<li><p>言語機能だけで重要な数値演算を行おうとしないように。</p></li>
<li><p>乱数生成器を得るには、乱数エンジンに分布をバインドしよう。</p></li>
<li><p>数値型の性質は、<code class="docutils literal notranslate"><span class="pre">numeric_limits</span></code> から得られる。</p></li>
</ul>
</div>
</div>
<div class="section" id="id114">
<h2><a class="toc-backref" href="#id264">第 13 章 並行処理</a><a class="headerlink" href="#id114" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id115">
<h3><a class="toc-backref" href="#id265">13.1 はじめに</a><a class="headerlink" href="#id115" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>《標準ライブラリの基本的な目標は、システムレベルの並行処理のサポートであって、洗練された高レベルの並行モデルを直接提供することではない》</p></li>
<li><p>標準ライブラリは単一アドレス空間における複数スレッドの並行実行をサポートする。</p>
<ul>
<li><p>適切なメモリモデル</p></li>
<li><p>一連のアトミック処理</p></li>
</ul>
</li>
<li><p>《タスクが逐次的に実行できるのであれば、それが単純で高速になるものだ》</p></li>
</ul>
</div>
<div class="section" id="thread">
<h3><a class="toc-backref" href="#id266">13.2 タスクと <code class="docutils literal notranslate"><span class="pre">thread</span></code></a><a class="headerlink" href="#thread" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><strong>タスク</strong> とは他の処理と並行的に実行される可能性のある処理のことを言う。</p></li>
<li><p><strong>スレッド</strong> とは一つのプログラムにおけるシステムレベルのタスクを意味する。</p></li>
</ul>
<p>複数のタスクを並行的に実行するには、タスクそれぞれから <code class="docutils literal notranslate"><span class="pre">thread</span></code>
を生成することで行うことができる。pp. 150-151 のコード片参照。</p>
<ul class="simple">
<li><p>スレッド群は同一のアドレス空間を共有する。cf. プロセス</p>
<ul>
<li><p>そのためスレッド間通信が共有オブジェクトを介することで行える。ただし、データ競合を防ぐことを考えなければならない。ロックやその他のメカニズムにより何らかの同期処理を施すのがふつうだ。</p></li>
</ul>
</li>
<li><p>タスクを定義する目的は、タスク同士を完全に分離することだ。</p></li>
<li><p>共有データを一切使用しないことは、データ競合を起こさないことを意味する。</p></li>
</ul>
</div>
<div class="section" id="id116">
<h3><a class="toc-backref" href="#id267">13.3 引数の受渡し</a><a class="headerlink" href="#id116" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>タスクの入力は関数の実引数という形式でなされるのが自然だが、複数のタスクで同一のデータを参照すると困ったことになるだろう。他方、値渡しでは困ったことにはならない。</p></li>
<li><p>《<code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> が定義する型関数 <code class="docutils literal notranslate"><span class="pre">ref()</span></code> は、可変個引数テンプレートが
<code class="docutils literal notranslate"><span class="pre">some_vec</span></code> をオブジェクトではなく参照として扱えるようにするために、不本意ながら必要となるものである》</p></li>
</ul>
</div>
<div class="section" id="id117">
<h3><a class="toc-backref" href="#id268">13.4 結果の返却</a><a class="headerlink" href="#id117" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>《やや姑息なのだが、結果の返却手段として引数が使われることは、珍しくない》。すなわち、タスクを表す関数の引数の一部がポインターや非 <code class="docutils literal notranslate"><span class="pre">const</span></code> 参照などで定義されている。</p></li>
<li><p>《引数経由で結果を返す方法が特にエレガントであるとは私は思わない》。まったく同感だ。</p></li>
</ul>
</div>
<div class="section" id="id118">
<h3><a class="toc-backref" href="#id269">13.5 データの共有</a><a class="headerlink" href="#id118" title="Permalink to this headline">¶</a></h3>
<p>複数のタスクが同一のデータを共有しなければならないとき、それへアクセスするタスクを高々一つに制限する必要がある。そのための手段の一つに相互排他オブジェクト <code class="docutils literal notranslate"><span class="pre">mutex</span></code> を使える。</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code> 型のオブジェクトをより広い？スコープに定義する。これを</dt><dd><p><code class="docutils literal notranslate"><span class="pre">m</span></code> とする。</p>
</dd>
</dl>
</li>
<li><p>「制限区間」をスコープにして <code class="docutils literal notranslate"><span class="pre">unique_lock&lt;mutex&gt;</span> <span class="pre">lck{m};</span></code>
として RAII する。この RAII オブジェクトの役割は直観的に理解できる。</p></li>
<li><p>つまり、プログラマーは <code class="docutils literal notranslate"><span class="pre">mutex</span></code> オブジェクトと共有データを対応付けることになる。その管理に注意しろ。</p></li>
</ul>
<p>デッドロックを回避するための技法を p. 154 で例示している。遅延ロックとでも呼べるような技法があるようだ。これによると、どこかで関数
<code class="docutils literal notranslate"><span class="pre">lock()</span></code> が提供されていて、おそらく可変個の RAII オブジェクトを引き渡すことができる。その結果、指定されたすべての相互排他オブジェクトのロックを獲得する。</p>
<ul class="simple">
<li><p>共有データによる通信はきわめて低レベル。複数タスクのどれが完了しているのかを判断するのが厳しいから。</p></li>
<li><p>ロック・アンロックはどちらかというと高コストな処理だ。</p></li>
<li><p>《通信手段として、データ共有を選択しないようにしよう》</p></li>
</ul>
</div>
<div class="section" id="id119">
<h3><a class="toc-backref" href="#id270">13.6 イベント待ち</a><a class="headerlink" href="#id119" title="Permalink to this headline">¶</a></h3>
<p>スレッドは何らかの外部イベントの完了を待たねばならないことがある。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">this_thread</span></code> は唯一のスレッドを表す。</p></li>
<li><p>外部イベントによる通信機能は <code class="docutils literal notranslate"><span class="pre">&lt;conditional_variable&gt;</span></code> が定義する
<code class="docutils literal notranslate"><span class="pre">conditional_variable</span></code> で提供される。この概念は Python のそれと同等だと考えていいだろう。</p>
<ul>
<li><p>《<code class="docutils literal notranslate"><span class="pre">conditional_variable</span></code> を使うと、エレガントで効率のよい数多くの共有法が実現できるものの、若干トリッキーなものとなる》</p></li>
</ul>
</li>
</ul>
<p>古典的な生産者・消費者のデモコード。これも Python で書くとこういう感じになるだろう。ただし <code class="docutils literal notranslate"><span class="pre">consumer()</span></code> の <code class="docutils literal notranslate"><span class="pre">lck.unlock()</span></code> の呼び出しに注意。キューの中身を取り出した直後に解放して、それから中身を処理するという構造をよく覚えておくこと。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mcond.wait()</span></code> をするのは消費者で <code class="docutils literal notranslate"><span class="pre">mcond.notify_one()</span></code> をするのは生産者。</p>
<ul>
<li><p>消費者側のロック区間では <code class="docutils literal notranslate"><span class="pre">mcond.wait()</span></code> とキューからメッセージを取り出す。</p></li>
<li><p>生産者側のロック区間ではキューへメッセージを置くことと <code class="docutils literal notranslate"><span class="pre">mcond.notify_one()</span></code> を呼び出す。</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id120">
<h3><a class="toc-backref" href="#id271">13.7 タスク間通信</a><a class="headerlink" href="#id120" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">&lt;future&gt;</span></code> で定義されている三つのタスク処理機能を説明している。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">future</span></code> と <code class="docutils literal notranslate"><span class="pre">promise</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">packaged_task</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">async()</span></code></p></li>
</ul>
<div class="section" id="future-promise">
<h4><a class="toc-backref" href="#id272">13.7.1 <code class="docutils literal notranslate"><span class="pre">future</span></code> と <code class="docutils literal notranslate"><span class="pre">promise</span></code></a><a class="headerlink" href="#future-promise" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>ロックを明示的に使わずに、タスク間で値を転送できるようにするのが重要だ。</p></li>
<li><p>送信側のタスクが受信側のタスクに値を転送するときには、それを
<code class="docutils literal notranslate"><span class="pre">promise</span></code> の中に入れる。処理系がそれを対応する <code class="docutils literal notranslate"><span class="pre">future</span></code>
に置くので、受信者はそれを読み取れるという構造だ。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">future</span></code> の <code class="docutils literal notranslate"><span class="pre">get()</span></code> で値を取る。</p></li>
<li><p>《値がまだ置かれていなければ、そのスレッドは、値が到着するまでブロックされる》。なるほど。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">promise</span></code> には <code class="docutils literal notranslate"><span class="pre">set_value()</span></code> と <code class="docutils literal notranslate"><span class="pre">set_exception()</span></code> が提供されている。</p></li>
<li><p>送信側タスクのコードは p. 157 の関数 <code class="docutils literal notranslate"><span class="pre">f()</span></code> の構造を一般的にとるものと思われる。受信側タスクは関数 <code class="docutils literal notranslate"><span class="pre">g()</span></code> の構造になる。例外処理を必要としなければ、<code class="docutils literal notranslate"><span class="pre">try</span></code>
ブロックはないだろう。</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="packaged-task">
<h4><a class="toc-backref" href="#id273">13.7.2 <code class="docutils literal notranslate"><span class="pre">packaged_task</span></code></a><a class="headerlink" href="#packaged-task" title="Permalink to this headline">¶</a></h4>
<p>型 <code class="docutils literal notranslate"><span class="pre">packaged_task</span></code> は複数の <code class="docutils literal notranslate"><span class="pre">promise</span></code> と <code class="docutils literal notranslate"><span class="pre">future</span></code>
を連携する複数タスクの準備に利用する。p. 158 のコードによると</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">packaged_task</span></code> オブジェクトをタスクを表す関数から生成する。タスクの個数ぶん生成する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">future</span></code> オブジェクトをスレッド開始前に生成する。それは
<code class="docutils literal notranslate"><span class="pre">packaged_task::get_future()</span></code> そのものだ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread</span></code> のタスクを表す引数に <code class="docutils literal notranslate"><span class="pre">packaged_task</span></code> オブジェクトを
<code class="docutils literal notranslate"><span class="pre">move()</span></code> して渡す。</p></li>
<li><p>結果をさきほど <code class="docutils literal notranslate"><span class="pre">.get_future()</span></code> から生成しておいたオブジェクトから <code class="docutils literal notranslate"><span class="pre">.get()</span></code> する。</p></li>
<li><p>このコードが明示的なロックを含まないことに注意する。</p></li>
</ul>
<p>《なお、<code class="docutils literal notranslate"><span class="pre">move()</span></code> 処理が必要となっているのは、<code class="docutils literal notranslate"><span class="pre">packaged_task</span></code> がコピーできないからだ。
<code class="docutils literal notranslate"><span class="pre">packaged_task</span></code> がコピーできないのは、それが資源ハンドルだからである》</p>
</div>
<div class="section" id="async">
<h4><a class="toc-backref" href="#id274">13.7.3 <code class="docutils literal notranslate"><span class="pre">async()</span></code></a><a class="headerlink" href="#async" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>《非同期に実行される可能性があるタスクの起動には、<code class="docutils literal notranslate"><span class="pre">async()</span></code> が利用できる》</p></li>
<li><p>《<code class="docutils literal notranslate"><span class="pre">async()</span></code> を使うとスレッドやロックの考慮が不要となる》が、むしろ《ロックが必要な資源を共有するタスクに対しては <code class="docutils literal notranslate"><span class="pre">async()</span></code> を使ってはいけない》。</p></li>
<li><p>《<code class="docutils literal notranslate"><span class="pre">async()</span></code> では <code class="docutils literal notranslate"><span class="pre">thread</span></code> がいくつ起動されるかが分からない》</p></li>
</ul>
</div>
</div>
<div class="section" id="id121">
<h3><a class="toc-backref" href="#id275">13.8 アドバイス</a><a class="headerlink" href="#id121" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>可能な限り、高い抽象化レベルで作業しよう。</p></li>
<li><p>逐次実行のほうが、並行実行よりも簡潔かつ高速な場合もある。</p></li>
<li><p>データ競合を避けよう。</p></li>
<li><p>可能であれば、明示的なデータ共有は避けよう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread</span></code> と <code class="docutils literal notranslate"><span class="pre">mutex</span></code> を直接利用するのではなく、<code class="docutils literal notranslate"><span class="pre">packaged_task</span></code> と <code class="docutils literal notranslate"><span class="pre">future</span></code> を優先しよう。</p></li>
<li><p>単純なタスクの起動には、<code class="docutils literal notranslate"><span class="pre">async()</span></code> を利用しよう。</p></li>
</ul>
</div>
</div>
<div class="section" id="id122">
<h2><a class="toc-backref" href="#id276">第 14 章 歴史と互換性</a><a class="headerlink" href="#id122" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id123">
<h3><a class="toc-backref" href="#id277">14.1 歴史</a><a class="headerlink" href="#id123" title="Permalink to this headline">¶</a></h3>
<p>本書著者が C++ を考案、言語仕様を作成、処理系を開発した。</p>
<div class="section" id="id124">
<h4><a class="toc-backref" href="#id278">14.1.1 時系列</a><a class="headerlink" href="#id124" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>C++11 を完全に実装した最初の処理系が登場したのは 2013 年。</p></li>
<li><p>《開発中の C++11 は、C++0x という名称で知られていた》</p></li>
</ul>
</div>
<div class="section" id="id125">
<h4><a class="toc-backref" href="#id279">14.1.2 黎明期</a><a class="headerlink" href="#id125" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>C++ という名前は 1983 年夏に Rick Mascitti が発案して、これを著者が採用した。</p></li>
<li><p>C++ は ++C よりも格下（式の値からそうだと理解できる）。</p></li>
<li><p>初期の頃は文書化された設計書はなかった。設計、文書化、実装が同時進行していた。</p></li>
<li><p>例外処理が生み出されることになった原因をもっと細かく説明して欲しい。</p></li>
<li><p>《仮想関数という形で実行時多相性をサポートしたことが、もっとも議論を呼んだ》。これはかなり意外に思う。</p></li>
<li><p>例外処理設計の重点とは、多段階の伝播、エラーハンドラーに任意の情報を渡せること、
RAII との統合の三点だ。</p></li>
<li><p>STL は C++98 のもっとも重要な革新だった。</p></li>
</ul>
</div>
<div class="section" id="iso-c">
<h4><a class="toc-backref" href="#id280">14.1.3 ISO C++ 標準</a><a class="headerlink" href="#iso-c" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>《C++03 という名前を聞いたこともあるかもしれないが、本質的には C++98 と同じものだ》</p></li>
</ul>
</div>
</div>
<div class="section" id="c-11">
<h3><a class="toc-backref" href="#id281">14.2 C++11 の新機能</a><a class="headerlink" href="#c-11" title="Permalink to this headline">¶</a></h3>
<p>ここに列挙されているだけで言語機能と標準ライブラリーコンポーネントがそれぞれ
41, 27 項目ある。</p>
<div class="section" id="id126">
<h4><a class="toc-backref" href="#id282">14.2.1 言語機能</a><a class="headerlink" href="#id126" title="Permalink to this headline">¶</a></h4>
<p>これはどこかに表があるはずなので、そちらを参照する。</p>
</div>
<div class="section" id="id127">
<h4><a class="toc-backref" href="#id283">14.2.2 標準ライブラリコンポーネント</a><a class="headerlink" href="#id127" title="Permalink to this headline">¶</a></h4>
<p>これはどこかに表があるはずなので、そちらを参照する。</p>
<p>C++11 での追加内容は、新規コンポーネントと、既存コンポーネントの改善とに分類される。</p>
</div>
<div class="section" id="id128">
<h4><a class="toc-backref" href="#id284">14.2.3 非推奨とされた機能</a><a class="headerlink" href="#id128" title="Permalink to this headline">¶</a></h4>
<p>これはどこかに表があるはずなので、そちらを参照する。</p>
<ul class="simple">
<li><p>《非推奨機能は、将来的には削除されることになるはずだ》</p></li>
</ul>
</div>
<div class="section" id="id129">
<h4><a class="toc-backref" href="#id285">14.2.4 キャスト</a><a class="headerlink" href="#id129" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>《C 言語形式キャストは、名前付きキャストの導入時に非推奨とすべきだった》。自作プログラムから全廃することを真剣に検討すべきだとまで言っている。</p></li>
<li><p>すべてのキャストは設計を汚すものだと考えるようにしよう。</p></li>
</ul>
</div>
</div>
<div class="section" id="c-c">
<h3><a class="toc-backref" href="#id286">14.3 C と C++ の互換性</a><a class="headerlink" href="#c-c" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id130">
<h4><a class="toc-backref" href="#id287">14.3.1 C 言語と C++ は兄弟</a><a class="headerlink" href="#id130" title="Permalink to this headline">¶</a></h4>
<p>C89, C99, C++98, C11, C++11 の包含？関係を p. 173 のベン図で模式的に表現しているが、かなり微妙。</p>
</div>
<div class="section" id="id131">
<h4><a class="toc-backref" href="#id288">14.3.2 互換性にかかわる問題</a><a class="headerlink" href="#id131" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>C 言語のコードは、C 言語としてコンパイルした上で <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> のメカニズムによって結合できる。</p></li>
<li><p>C 言語のプログラムを C++ に変換する際に、大きな問題がある。</p></li>
</ul>
<div class="section" id="id132">
<h5><a class="toc-backref" href="#id289">14.3.2.1 スタイルの問題</a><a class="headerlink" href="#id132" title="Permalink to this headline">¶</a></h5>
<p>コードの基本構造 10 選。いくつか抜粋しておく。</p>
<ul class="simple">
<li><p>《マクロによる置換はほぼ確実に不要である》。</p>
<ul>
<li><p>定数を表すには <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>, <code class="docutils literal notranslate"><span class="pre">enum</span></code>, <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> を使う。</p></li>
<li><p>関数呼び出しのオーバーヘッド排除には <code class="docutils literal notranslate"><span class="pre">inline</span></code> を使う。</p></li>
<li><p>関数と型のファミリーを表すには <code class="docutils literal notranslate"><span class="pre">template</span></code> を使う。</p></li>
<li><p>名前の衝突を排除するのに <code class="docutils literal notranslate"><span class="pre">namespace</span></code> を使う。</p></li>
</ul>
</li>
<li><p>必要になるまでは変数を宣言しない。宣言と同時に初期化する。</p></li>
<li><p>単純に裸の <code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">delete</span></code> に置き換えないようにする。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void*</span></code>, <code class="docutils literal notranslate"><span class="pre">union</span></code>, キャストは利用しない。</p></li>
<li><p>ポインター演算は使わない。</p></li>
</ul>
</div>
<div class="section" id="void">
<h5><a class="toc-backref" href="#id290">14.3.2.2 <code class="docutils literal notranslate"><span class="pre">void*</span></code></a><a class="headerlink" href="#void" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">malloc()</span></code> を <code class="docutils literal notranslate"><span class="pre">new</span></code> で書き直したいという話題だ。</p>
</div>
<div class="section" id="id133">
<h5><a class="toc-backref" href="#id291">14.3.2.3 C++ のキーワード</a><a class="headerlink" href="#id133" title="Permalink to this headline">¶</a></h5>
<p>C 言語ではキーワードではない C++ のキーワードの一覧。本書で説明されていないものは知らなくていいということになる？</p>
</div>
<div class="section" id="id134">
<h5><a class="toc-backref" href="#id292">14.3.2.4 結合</a><a class="headerlink" href="#id134" title="Permalink to this headline">¶</a></h5>
<p>これはかつて業務でやったので理解している。</p>
</div>
</div>
</div>
<div class="section" id="id135">
<h3><a class="toc-backref" href="#id293">14.4 参考文献</a><a class="headerlink" href="#id135" title="Permalink to this headline">¶</a></h3>
<p>多過ぎる。</p>
</div>
<div class="section" id="id136">
<h3><a class="toc-backref" href="#id294">14.5 アドバイス</a><a class="headerlink" href="#id136" title="Permalink to this headline">¶</a></h3>
<p>《経験豊富な C++ プログラマが何年間も見落とすことが多いのは、新機能ではなく、むしろ、機能間の関係の変化、基礎的な新しいプログラミングテクニックを実現可能にするための機能間の関係である。換言すると、初めて C++ を学習した際に思いもよらなかったことや、当時は実現不可能と考えたことが、現在は優れた方式となっている可能性があるのだ。それを見つけるには、基本をもう一度吟味するしかない》</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="stepanov15.html" title="その数式、プログラムできますか？ 読書ノート"
             >next</a></li>
        <li class="right" >
          <a href="gorelick14.html" title="ハイパフォーマンス Python 読書ノート"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">C++ のエッセンス 読書ノート</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2021, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>