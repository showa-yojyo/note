====================
入門 bash 読書ノート
====================
何のヒネリもなく ``bash`` を Cygwin の常用シェルとして利用する人間によるノート。
第 3 版のノートとする。

訳文が妙に面白く、個人的には読み物としても大変気に入っている一冊だ。

:著者: Cameron Newham, Bill Rosenblatt
:訳者: 株式会社クイープ
:出版社: オライリー・ジャパン
:ISBN: 4-87311-254-0

.. contents:: ノートの目次

まえがき
========
* ``echo $BASH_VERSION`` で使用している ``bash`` のバージョンを確認できる。 (p. v)

  * 今手許の環境を調べたら ``3.2.48(21)-release`` と出た。

* 本書の想定読者は「初心者」の次の段階に位置する一般的な UNIX/Linux ユーザー。(p. vi)
* 本書の狙いは、実用的なシェルプログラムを作成するためにコンピュータの学位を取得する必要はないことを示すことにある。 (p. vii)
* RUBOUT: rub out を辞書で調べると、「すり消す」とある。
* <本書では、UNIX を「UNIX と Linux」の略語と捉えている。> (p. x)

1 章 bash の基礎
================
1.3 UNIX シェルの歴史
---------------------
* 歴史的な説明から。

  * Bourne シェル (``sh``) 

    * 作成者 Steven Bourne
    * 1979 年に登場した最初の普及版 UNIX である Version 7 に搭載されていた

  * C シェル (``csh``) 

    * 作者はカリフォルニア州立大学バークレー校の Bill Joy
    * Berkley Software Disribution UNIX (BSD UNIX) の一部として書かれた

  * Korn シェル (``ksh``)

    * ``sh`` と ``csh`` の優れた機能プラス多数の独自機能から構成
    * 商用製品

1.3.1 bash
~~~~~~~~~~
* ``bash`` の名前は Bourne Again Shell から来ている。
  ``sh`` へのリスペクトが込められている。
* GNU プロジェクトのために作成されたシェルなので、無償で配布されている。
* <``bash`` は、GNU システム用の標準のシェルとして、
  公式には 1988 年 1 月 10 日の日曜日に産声をあげた。> (p. 4)

1.3.2 bash の特徴
~~~~~~~~~~~~~~~~~
以下の三点を指摘している。

* コマンドライン編集モード
* ジョブ制御
* 主にシェルをカスタマイズしたりプログラミングしたりするための機能

1.4 bash の入手
---------------
* ``echo $SHELL`` で使用しているシェルを確認できる。

  * 手許の環境で試した結果、 ``/bin/bash`` と出た。

1.6 ファイル
------------
1.6.1 ディレクトリ
~~~~~~~~~~~~~~~~~~
* チルダ展開について。

  * ユーザー名の前に ``~`` を付けると、それはそのユーザーのホームディレクトリの絶対パスとなる。
  * ``~`` はユーザー自身のホームディレクトリを参照する。

1.6.2 ファイル名、ワイルドカード、パス名の展開
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ワイルドカードとは記号だと思えばよい。
  すべてのファイルの名前がわからなくても、パターンで指定できる機能を利用するときに使う特殊な記号。
* ``?``, ``*``, ``[set]``, ``[!set]``
* セット構造は初めて知った。
* <開きかっこ (``[``) の後に感嘆符 (``!``) を入れると、セットを「否定」することができる> (p. 12)

1.6.3 ブレース展開
~~~~~~~~~~~~~~~~~~
* 後で以下の入力を試してみる。

::

  echo b{ed,olt,ar}s
  echo b{ar{d,n,k},ed}s
  echo {d..h}
  ls *.{c,h,o}

1.7 入力と出力
--------------
1.7.1 標準入出力
~~~~~~~~~~~~~~~~
* 標準入力を利用してのコマンド入力終了を告げるために CTRL+D を押す。

1.7.3 パイプライン
~~~~~~~~~~~~~~~~~~
* <入出力リダイレクトとパイプラインが UNIX のブロック構造原理をどのように支援しているかが理解できたと思う。
  表記は実に簡単で強力である。
  特に重要なのは、パイプの概念によってコマンドの出力をほかのコマンドに渡すための見苦しい一時ファイルが要らなくなったことである。> (p. 18)

1.8 バックグラウンドジョブ
--------------------------
* バックグラウンドジョブの基本は

  1. コマンド ``&``
  2. ``jobs`` でバックグラウンドジョブを確認することができる。

1.9 特殊記号とクォーティング
----------------------------
* \p. 21 表 1-6 に特殊記号がまとまっている。

1.9.1 クォーティング
~~~~~~~~~~~~~~~~~~~~
* 特殊記号をリテラルで使用したいときは、それらを単一引用符で囲むことで OK だ。

1.9.2 バックスラッシュエスケープ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``find . -name`` *string* などと入力する場合、
  *string* の部分にはワイルドカードを検索対象ファイル名として指示できるが、
  これを引用符で囲むこと。

1.9.5 コントロールキー
~~~~~~~~~~~~~~~~~~~~~~
* ``stty`` コマンドを使用すると、コントロールキーの設定を確認できる。
  また必要に応じて変更できる。
  ``stty all`` か ``stty -a`` と入力してみること。

* うっかり CTRL+S を押すと画面が止まる。
  もしだしぬけに画面が止まったら、CTRL+Q を試すこと。
  <CTRL+S キーと CTRL+Q キーは基本的に迷惑な存在になっている。> (p. 26)

2 章 コマンドライン編集
=======================
* <``bash`` の編集モードでは、UNIX エディタとして最も有名な ``vi`` と ``emacs`` と同様の編集コマンドを使って、
  コマンドラインを編集することができる。> (p. 29)
* <とにかく編集モードを 1 つは覚えておきたいという場合は、 ``emacs`` モードをお勧めする。
  ``emacs`` モードのほうが、シェルそのものが提供する基本的な編集機能をより自然な形で拡張しているからだ。> (pp. 29-30)

2.3 emacs モード
----------------
* コマンドライン入力を <1 行のウィンドウからなる手軽な ``emacs``> (p. 31) と考えればよい。

2.3.1 基本コマンド
~~~~~~~~~~~~~~~~~~
* ``emacs`` を知らないユーザーにとっては、
  <基本的なキー操作は覚えやすいが、 ``emacs`` 特有の概念をひととおり身につけることが要求される。> (p. 31)

2.3.4 履歴ファイル内での移動
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``emacs`` での行単位での上下方向の移動を、コマンド履歴の移動に流用している。
* CTRL+R は ``reverse-i-search`` になる。

  * 目当てのコマンドラインが見つかったら、Enter ではなく CTRL+E を押すのがよさそう。

2.3.5 テキスト補完
~~~~~~~~~~~~~~~~~~
* <``emacs`` モードの最も強力な（そして一般に使用されている）機能の 1 つは、
  **テキスト補完** 機能である。> (p. 35)
* 最も重要なのは TAB である。
* \p. 37 の表 2-5 を見ると、いろいろな補完コマンドがあることがわかるが、
  やっぱり TAB 一丁で何とかなる。

2.3.6 その他のコマンド
~~~~~~~~~~~~~~~~~~~~~~
1. CTRL+L は ``clear`` と同じ。
2. CTRL+V は ``quote-char`` と同じ。
3. ESC+. および ESC+_ が便利で、前のコマンドラインの最後のワードをポイント位置に挿入する。

2.6 履歴の展開
--------------
* イベント指示記号

  * タイプミス直後に ``^string1^string2`` を活用できる。

* ワード指示記号

  * <``!!:0`` に続いて新しい引数を入力すれば、最後のコマンドを別の引数で実行することができる。> (p. 51)

* 修飾子

このセクション、もう少し実用的な具体例が欲しい。
と思っていたら、最後にこんなことが書いてあった。
<履歴の展開は、コマンドをすばやく再実行するのに便利だが、
前述のコマンドライン編集メカニズムでは無効になってしまう。> (p. 52)

2.7 readline
------------
* ``bash`` のコマンドライン編集インターフェイス
* テキストベースのインターフェースを有するアプリケーションが
  ``readline`` を利用している場合がある。
* キーバインドをカスタマイズすることができる。

2.7.1 readline の起動ファイル
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* <デフォルトの起動ファイルは ``.inputrc`` である。> (p. 52)
* <``readline`` を使用するアプリケーションが別にある場合は、
  ``bash`` 専用のキーバインドを別にしておいたほうがよいだろう。
  これには、（略） ``.inputrc`` ファイルに ``$if bash`` という条件文を挿入する。> (p. 54)
* <変数を設定するには、 ``.inputrc`` ファイルで ``set`` コマンドを使用する。> (p. 55)

::

  # bash を vi モードで起動するようにする
  set editing-mode vi

2.7.2 bind を使ったキーバインド
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* <``bind -P`` と入力すれば、現在のキーバインドを表示することができる> (p. 55)
  そうなので、今手許の Cygwin で試したら大量に出力された。
* <キー配列にシェルコマンドをバインドしたい場合には、
  ``bind -x`` が便利である>

::

  # CTRL+L を ls コマンドにバインドする
  bind -x '"\C-l":ls'

2.8 キー入力の習慣
------------------
* ``vi`` や ``emacs`` のエディタを使った経験がなければ、
  ``emacs`` モードのキー入力を憶えることを著者は推奨している。また、
  ``emacs`` のコマンド構造がミニバージョンを作成するのに向いていることも指摘している。

3 章 環境のカスタマイズ
=======================
冒頭で、環境という概念を、職場の机の例を挙げてわかりやすく説明している。
文房具や電話機を個人の趣向に合わせて配置することは、環境のカスタマイズの一例だ。

3.1 .bash_profile, .bash_logout, .bashrc
----------------------------------------
* ``.bash_profile`` はシステムにログインする度に読み込まれ、そこに書いてあるものを実行する。
* ``.bash_profile`` に類似するファイルとして、 ``.bash_login`` と ``.profile`` がある。

  * ``.bash_login`` は C シェルの ``.login`` に由来している。
  * ``.profile`` は Bourne シェルと Korn シェルの同名の設定ファイルに由来している。
  * ログイン時には、これらのいずれか 1 つだけが読み込まれる。
    優先度は ``.bash_profile``, ``.bash_login``, ``.profile`` の順。

* コマンドラインから ``bash`` を起動した場合（サブシェル）、
  ``.bashrc`` からコマンドを読み込もうとする。

3.2 エイリアス
--------------
* 構文は以下の通り。等号記号の前後に空白文字を入れてはならない。

::

  alias <名前>=<コマンド>

* ``bash`` はエイリアスの対象となるものにテキスト置換を実行する。
  例えば ``alias printall='pr * | lpr'`` というエイリアスに対して、
  ``*`` をワイルドカード展開する。
* エイリアスは再帰的であるが、無限ループに陥らないようにできている。

::

  # 無限ループにならない
  alias ls='ls -l'

* 等号なしで ``alias XXXX`` を実行すると ``XXXX`` の値が表示される。
* 引数なしで ``alias`` を実行すると、定義済みのエイリアスの一覧が表示される。
* エイリアルは、<シェルのスクリプトや関数では基本的に無効となる。> (p. 64)

3.3 オプション
--------------
* ``set -o <オプション名>`` と ``set +o <オプション名>`` が基本。
  前者はオプションを ON にし、後者は OFF にする。
* ``ignoreeof`` と ``nounset`` が面白そう。
* オプションの状態を確認するには、単に ``set -o`` とだけ入力する。

  * 今試してみたら、ほとんどのオプションが値が off だった。

3.3.1 shopt
~~~~~~~~~~~
* bash 2.0 で追加されたコマンドで、環境変数や ``set`` コマンドで行われていた設定に代わるもの。
* ``shopt -p`` で一覧を見てみよう。

3.4 シェル変数
--------------
* 変数を定義する構文は ``<変数名>=<値>`` であり、等号記号の左右に空白文字は入らない。
* 変数を削除するには ``unset <変数名>`` とする。
  別に便利ではないようだ。
* <変数の値を確認する最も簡単な方法は ``echo`` コマンドを使用することだ> (p. 67)

3.4.1 変数とクォーティング
~~~~~~~~~~~~~~~~~~~~~~~~~~
* <引用符で囲まれている文字列を 1 つのワードをシェルに思い込ませる> (p. 68)

3.4.2 組み込み変数
~~~~~~~~~~~~~~~~~~
* 最初にコマンドライン履歴関連の変数を紹介している。
  よく使っているのは ``HISTFILESIZE``, ``HISTSIZE``, ``HISTTIMEFORMAT`` の三つ。

  * ``HISTCONTROL`` 変数をうまく設定すると、重複するコマンドラインが履歴リストに追加されなくなる。
    例えば ``HISTCONTROL=ignoredups`` とする。

* プロンプト変数 (``PS1``, ``PS2``, ``PS3``, ``PS4``) により、プロンプトをカスタマイズできる。

  * <Bash は 4 種類のプロンプト文を使い分ける。> (p. 73) 
  * <プロンプト文を設定する最も効果的な方法は、常にカレントディレクトリが表示されるようにすることだろう> (p. 74)
    たとえば ``PS1="\u \!--> "`` のようにする。
  * <セカンダリプロンプト文は、コマンドラインを入力して RETURN キーを押したときに、
    コマンドが未完成であることを示すために使用される。> (p. 75)

* コマンド検索パス ``PATH``

  * この記法をおさえる。
    ``PATH=$PATH:"/home/user-name/bin"``
  * セキュリティ上 ``PATH`` を自分のディレクトリをほかのよりも優先されるように設定してはいけない。

* ``bash`` はコマンドハッシュなるものを管理している。
  ``hash`` コマンドでそれを確認できる。

  * <``hash`` の詳細について頭を悩ませる必要はない。> (p. 77)

* ``CDPATH`` の紹介。「Cygwin へ送る」ユーザーである私は使わない。

3.5 カスタマイズとサブプロセス
------------------------------
* <ユーザーがコマンドを入力するたびに、シェルがそのコマンドをサブプロセスで実行することを思い出そう。
  複雑なプログラムになると、サブプロセスを独自に生成することもある。> (p. 79)

3.5.1 環境変数
~~~~~~~~~~~~~~
* 環境変数は、すべてのサブプロセスが参照できる特殊なシェル変数だ。
* 以下のように処理した変数は、環境変数として使用することができる。

::

  export <変数名>
  # or
  export <変数名>=<値>

* 特定のサブプロセス環境だけで使用する環境変数を定義することもできる。

::

  TERM=trythisone emacs file-name

* 環境変数をリストするには ``export`` を引数なしで実行する。

  * 実行してみたら ``declare -x`` の嵐となった。

3.5.2 環境定義ファイル
~~~~~~~~~~~~~~~~~~~~~~
* <原則としては、 ``.bash_profile`` 内の定義をできるだけ減らし、
  環境定義ファイル (``.bashrc``) の定義をできるだけ増やす。> (p. 84)

::

  stty stop ^S intr ^C erase ^?
  date
  source .bashrc

4 章 基本的なシェルプログラミング
=================================
4.1 シェルスクリプトと変数
--------------------------
* <**スクリプト** とは、シェルコマンドが含まれたファイル、
  つまりシェルプログラムのことである。
  3 章で説明した ``.bash_profile`` や環境定義ファイルもシェルスクリプトである。> (p. 85)
* スクリプト名を入力すると、<**サブシェル** と呼ばれるシェルの新しいコピーがサブプロセスとして実行される。
  サブシェルはスクリプトからコマンドを取り出し、
  それらを実行して終了した後、制御を親シェルに戻す> (p. 86)
  という一連の処理が発生する。

4.1.1 関数
~~~~~~~~~~
* <関数とはスクリプトの中のスクリプトのようなもの> (p. 87) メモリにシェルコードが格納される。
* 定義方法は次のどちらかとなる。機能差はない。

::

  function <関数名>
  {
    <シェルコマンド>
  }
  # or
  <関数名> ()
  {
    <シェルコマンド>
  }

* ``declare -F`` で、存在する関数の名前一覧を表示できる。
* 組み込みコマンド ``type`` でコマンドの種類を確認できる。

4.2 シェル変数
--------------
* <言語の違いを特徴付ける方法として、変数の機能を比較することが重要なほどである。> (p. 90)
* ``bash`` は <文字列をことのほか重視する。> (p. 90)

4.2.1 位置パラメータ
~~~~~~~~~~~~~~~~~~~~
* **位置パラメータ** は、スクリプトが呼び出されたときに、そのコマンドライン引数を保持する。
* ``$1``, ``$2``, ``$3``, ... で参照できる。
* ``$0`` はスクリプト自身の名前を含む。
* ``$*`` は ``$1`` 以降すべての位置パラメータからなる文字列。

  * ``IFS`` の 1 文字目で区切られた文字列

* ``$@`` は ``"$1" "$2" "$3" ... "$N"`` に等しい。二重引用符とスペース文字は固定。
* ``$#`` は、位置パラメータの個数（を示す文字列）。
* 関数も独自の位置パラメータを持つ。

``$*`` と ``$@`` はよくどっちがどっちだか忘れるので注意。

4.2.2 関数のローカル変数
~~~~~~~~~~~~~~~~~~~~~~~~
* <関数の定義に ``local`` 文が含まれている場合、その関数の変数は **すべて**
  関数のローカル変数になる。> (p. 93)

4.2.3 $@ と $* での引用
~~~~~~~~~~~~~~~~~~~~~~~
* ``$*`` は出力での活躍が多いらしい。位置パラメータのリストをカンマ区切りで表示したい場合は、
  ``IFS=, echo "$*"`` とする。

4.2.4 変数の構文について
~~~~~~~~~~~~~~~~~~~~~~~~
* 正式には ``${変数名}`` のように中括弧がある。

4.3 文字列演算子
----------------
4.3.1 文字列演算子の構文
~~~~~~~~~~~~~~~~~~~~~~~~
``${variable:-word}``
  変数が未定義のときにデフォルト値を **返す**
``${variable:=word}``
  変数が未定義のときにデフォルト値を **設定する**
``${variable:+word}``
  変数が定義されているかどうかを知る。
  定義されていても ``word`` を返すので ``variable`` 自身の値は得られない。
``${variable:offset:length}``
  部分文字列を返す（スライス）

* <位置パラメータの値をわかりやすい名前の変数に代入すれば、
  変数名を改善することができる。> (p. 98)

::

  filename=$1
  howmany=${2:-10}

* <``echo`` の ``-e`` オプションは、引数を表示した後に改行しないことを示す。> (p. 100)

4.3.2 パターンとパターン照合
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``${variable#pattern}`` 等を照合演算子という。

  * ``#`` は始めの部分を照合し、 ``%`` は終わりの部分を照合する。
  * 一文字が最短一致で、二文字が最長一致。

* 置換は ``${variable/pattern/string}`` か ``${variable//pattern/string}`` で行う。

::

  outfile=${filename%.pcx}.jpg

* ``$PATH`` を読みやすくするには ``echo -e ${PATH//:/'\n'}`` がおすすめ。

4.3.4 高度なパターン照合
~~~~~~~~~~~~~~~~~~~~~~~~
* <``shopt`` の ``extglob`` オプションをオンにした場合に使用できるパターン照合演算子がいくつかある。> (p. 104)

  ===================  ====================
  ``*(pattern-list)``  0 個以上検出
  ``+(pattern-list)``  1 個以上検出
  ``?(pattern-list)``  0 or 1 個検出
  ``@(pattern-list)``  1 個検出
  ``!(pattern-list)``  一致しないものを検出
  ===================  ====================

::

  $ shopt -s extglob
  $ echo *.+(txt|html)
  <ファイル名が .txt または .html で終わるものすべて>
  $ echo !(*Makefile)
  <ファイル名が Makefile なんとか以外すべて>

4.4 コマンド置換
----------------
* ``$(<コマンド>)`` とすると、<コマンドの標準出力を変数の値として使用することができる。> (p. 105)
* 昔はバッククォートで囲んでいたようだが、読みにくいうえに入れ子にできない。
  ドルカッコのほうを使うべし。

::

  ls -l $(type -path -all command-name)

* <関数の名前に他意はない> (p. 108) とか小ネタで笑わせてくる。
* タスク 4-7 を読んでいて思うのだが、
  ``ls -l`` の結果を加工する種のスクリプトは、
  どうしても可搬性に難のあるものにはなるまいか。

5 章 フロー制御
===============
* この章では ``if/else``, ``for`` などの導入をする。
* <一から説明されることにうんざりしているプログラマの気持ちもわからないではない。> (p. 113)

5.1 if/else
-----------
::

  if <条件>
  then
      <文ブロック>
  elif <条件>
      then <文ブロック> ...
  else
      <文ブロック>
  fi

5.1.1 終了ステータス
~~~~~~~~~~~~~~~~~~~~
* コマンドや関数は終了時に呼び出し元に整数コードを返す。これを **終了ステータス** という。
* <**通常は** 0 が正常終了、それ以外 (1 から 255) が異常終了を示す。> (p. 115)

5.1.2 return
~~~~~~~~~~~~
* ``return N`` 文が含まれている関数は、終了ステータス ``N`` で終了する。
  ``N`` を省略することもでき、その場合は最後のコマンドの終了ステータスが設定される。

5.1.3 終了ステータスの組み合わせ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``bash`` の ``if`` 文において、 ``&&``, ``||`` は short-circuit rule が適用される。

5.1.4 条件の評価
~~~~~~~~~~~~~~~~
* ``[...]`` と ``[[...]]`` の二つがある。ここでは一つ目の構文を使用する。
* ``[...]`` 構文を使用すれば、次のことができる。

  * ファイルの属性をテストする
  * 二つのファイルの新しさを比較する
  * 文字列同士を比較する (``str1 = str2``, ``str1 != str2``, ``str1 < str2``, etc.)

* 文字列変数をテストする際は、二重引用符で囲むのが望ましい。
* <コード全体が ``if-then-else`` で囲まれているほうがよいプログラミング作法であるという考え方もあるが、
  エラーを確認しながらいくつかに分岐するような長いスクリプトを書くのは混乱のもとである。> (pp. 121-122)

* ファイル属性演算子。よく使いそうなのをノートしておく。
  ``-x`` 演算子の意味だけ注意がいる。

-a file  file が存在する
-d file  file が存在し、かつディレクトリである
-e file  ``-a`` と同じ
-r file  file を読み取れる
-w file  file を上書きできる
-x file  file がファイルの場合、それが実行可能である。
         file がディレクトリの場合、その中を検索できる。


file1 -nt file2  file1 が file2 よりも新しい

file1 -ot file2  file1 が file2 よりも古い

5.1.5 整数の条件式
~~~~~~~~~~~~~~~~~~
* 整数を比較する演算子が存在するが、整数値だけを扱う条件式の構文が別に存在するのでそちらを使うこと。

5.2 for
-------
* <``for`` ループはコマンドラインの引数や一連のファイルを処理するのに最適である。> (p. 129)

::

  for name [in list]
  do
      <$name を使用する文ブロック>
  done

* in *list* の部分を省略すると、デフォルトでは ``$@`` となる。
* <``for`` ループの使用法としては、コマンドライン引数を 1 つずつ処理するほうが一般的である。> (p. 130)
* タスクで紹介している再帰処理で、ディレクトリ階層を下がるたびに出力文字列をタブでインデントしている。
  ``tab=$tab$singletab`` でタブ文字を伸ばしているのが面白い。
  階層を上がるときは ``tab=${tab%"$singletab"}`` としている。

5.3 case
--------
* Pascal の ``case`` 文に相当する。
* ワイルドカードを使ったパターンと文字列の照合が可能。

::

  case <式> in
      <パターン> )
          <文ブロック> ;;
      <パターン> )
          <文ブロック> ;;
      ...
  esac

* C 言語の ``default`` のような処理をするならば ``* )`` を使える。

5.4 select
----------
使いそうにないので飛ばす。

5.5 while と until
------------------
* 構文は共に以下の通りで、 ``while`` と ``until`` は条件式を扱う方法の違いしかない。

::

  while <条件>
  do
      <文ブロック>
  done

* <本書の見解では、 ``until`` が必要になることはまれである。> (p. 143)

6 章 コマンドラインオプションと型を持つ変数
===========================================
6.1 コマンドラインオプション
----------------------------
6.1.1 shift
~~~~~~~~~~~
* ``shift`` コマンドで、位置パラメータを前にずらすことができる。

  * ``shift 3`` とすると、位置パラメータが 3 個ずれる。

* <通常の UNIX 構文では、オプションが引数の前にある> (p. 147)

6.1.2 引数付きのオプション
~~~~~~~~~~~~~~~~~~~~~~~~~~
* <多くのコマンドに **独自に** 引数をとるオプションがあることを思い出そう。> (p. 148)
  そういう場合は追加の ``shift`` が要る。

6.1.3 getopts
~~~~~~~~~~~~~
* ``shift`` の利用だけでは <``-a -b -c`` ではなく ``-abc`` のように、
  ハイフンを 1 つで組み合わされた引数には対応できない。また、
  ``-b arg`` ではなく ``-barg`` のように、スペースを要れずに引数を指定することもできない。> (p. 149)

::

  while getopts ":ab:c" opt; do
    case $opt in
      -a ) <オプション -a の処理> ;;
      -b ) <オプション -b の処理> 
           <$OPTARG はオプション固有の引数> ;;
      -c ) <オプション -c の処理> ;;
      -? ) echo 'usage: alice [-a] [-b barg] [-c] args...'
           exit 1
      esac
  done

  shift $(($OPTIND - 1))

  <通常の引数処理>

* <オプションが引数をとる場合、 ``getopts`` はそれを ``OPTARG`` 変数に設定する。> (p. 150)

6.2 型を持つ変数
----------------
* 変数には「読み取り専用」や「整数型」といった属性を設定することができる。
  それには、組み込みコマンド ``declare`` を使用する。

-a  配列
-f  関数名
-i  整数値
-r  読み取り専用
-x  変数をエクスポート

* <関数において ``declare`` で宣言された変数は、関数のローカル変数となる。> (p. 155)

6.3 整数型の変数と算術演算
--------------------------
* <``$((`` と ``)`` で囲まれた文字列は、算術演算式として評価される。> (p. 155)
* 表 6-2 によると、算術演算子は C 言語のそれとほぼ同じ。べき乗演算子があるのが面白い。
  ``**`` と書けばよいようだ。
* 関係演算子と論理演算子もある。
* 基数もサポート。例えば ``$((2#1001))`` は二進数の ``1001`` のことだ。

6.3.2 数値変数と代入
~~~~~~~~~~~~~~~~~~~~
* <``let`` 文を使用すれば、算術演算子を評価した後、
  その結果を変数に代入することができる。> (p. 158)

::

  let <整数型の変数>=<式>

6.4 配列
--------
* 配列の定義方法はいくつかある。とりあえず次の方法だけ覚える。

::

  # 方法 1
  names[2]=alice
  names[0]=hatter
  names[1]=duchess

  # 方法 2
  names=([2]=alice [0]=hatter [1]=duchess)

  # 方法 3
  names=(hatter duchess alice)

* 配列の要素を参照するには ``${names[0]}`` のようにする。
* 位置パラメータのそれと同様に、 ``${names[@]}``, ``${names[*]}`` が使用できる。

  * ``for`` ループで配列の要素を順番に参照することができる。
  * 値が設定されている要素のインデックスを知るには、 ``${!names[@]}`` とする。
  * 配列の長さを ``${#names[@]}`` とする。

* 配列の特定の要素を削除するには ``unset names[1]`` のようにする。
* 配列全体を削除するには ``unset names`` とする。
* ``/etc/passwd`` のユーザー名とユーザー ID から配列を作成する例。
  ``cut`` で切り出したコロン区切りの文字列を、文字列演算子を利用して split して、
  上述方法 1 のやり方で配列要素を順次追加している。

7 章 入出力とコマンドラインの処理
=================================
7.1 入出力リダイレクタ
----------------------
* 表 7-1 にまとまっている。
  いつも ``&`` が付くリダイレクタの意味がわからなくなるのだが、
  ``&`` はコピー、 ``&-`` は停止と憶えておけばよい？
* <``set -o noclobber`` と入力すると、
  ``> file`` によるファイルの上書きを阻止することができる。> (p. 173)

7.1.1 ヒアドキュメント
~~~~~~~~~~~~~~~~~~~~~~
* <ヒアドキュメントは、コマンドプロンプトから使用してもあまり意味がない。> (p. 173)
* <``<<`` リダイレクタは 2 種類に分かれる。
  まず、 *label* を単一引用符または二重引用符で囲むと、
  パラメータ置換とコマンド置換は実行されなくなる。> (p. 175)
* <``<<-`` リダイレクタを使用すると、
  ヒアドキュメントとラベル行からの先頭のタブを削除することができる
  （それ以外の空白は残る）> (p. 175) ので、
  ヒアドキュメントのテキストを読みやすくするためにインデントできる。

7.1.2 ファイルデスクリプタ
~~~~~~~~~~~~~~~~~~~~~~~~~~
* エラーメッセージをファイルに出力するには ``コマンド 2> file`` とする。
* かつ、標準出力も同じように処理するには ``コマンド > file1 2> file`` とする。
* 標準出力と標準エラーの両方をファイルに出力するには ``コマンド > file 2>&1`` とする。

  * パイプに出力するには ``コマンド 2>&1 |`` とする。

7.2 文字列の入出力
------------------
7.2.1 echo
~~~~~~~~~~
* ``-e``, ``-n`` オプションを憶える。
* **エスケープシーケンス** はあまり憶えなくても済む。
  使うときは ``-e`` と組み合わせることになると思う。

7.2.2 printf
~~~~~~~~~~~~
* ザッと見る限り、C 言語のそれと同じように使えるようだ。

7.2.3 read
~~~~~~~~~~
* シェル変数に値を取り込むためのコマンド。
  ``read var1 var2 ...`` のような構文をとる。
* <ワードよりも変数の方が多い場合、余分なワードは最後の変数に代入される。
  変数を 1 つも指定しないと、入力行はまとめて ``REPLY`` 変数に代入される。> (p. 183)
* ``read`` は行単位の処理を指向している。が、そういうのはパイプラインが行う仕事だろうから
  <行単位での処理を行いたいのであれば、シェルスクリプトを使用する理由はまったくない> (p. 183)。

* 関数は標準入出力デスクリプタを独自に持つ。
  関数呼び出しの右側にリダイレクタを書いたり、
  関数定義の終了直後にリダイレクタを書いたりできる。

::

  findterm () {
    <...関数定義>
  }

  findterm < /etc/terms

::

  findterm () {
    <...関数定義>
  } < /etc/terms

* ループや ``if...fi``, ``case...esac``, ``select...done`` 等の定義直後でも同様に可能。

* <コマンドを ``{`` と ``}`` で囲むと、そのコードは名前のない関数のように機能する。> (p. 186)
  本書ではこれを **コマンドブロック** と呼んでいる。このブロックの終了直後も、
  リダイレクタを置ける。

* ユーザーへのプロンプトの出し方が参考になる。
  下のコード片だが、 ``echo -n`` で改行を抑制していることと、
  ``>&2`` で標準出力を標準エラー出力に切り替えていることがポイント。

::

  echo -n 'terminal? ' >&2

7.3 コマンドラインの処理
------------------------
* 図 7-1 の「コマンドライン処理の流れ」の要点がよくわからない。
* 小ネタだが、 ``~+`` と ``~-`` はそれぞれカレントディレクトリと、
  直前のディレクトリに置換されるらしい。p. 192 の脚注より。

7.3.2 command, builtin, enable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* <コマンドは、関数、組み込みコマンド、スクリプト、実行可能ファイルの順に検索される。
  この順序は、 ``command``, ``builtin``, ``enable`` の 3 つの組み込みコマンドを使って、
  変更することができる。> (p. 194)

  * ``command`` は組み込みコマンドと検索パス上にあるコマンドだけに実行候補を絞る。
  * ``builtin`` は組み込みコマンドだけ。
    ``builtin printf`` のように使う。
  * ``enable`` は<組み込みコマンドを有効または無効にする。> (p. 195)

    * ``enable -n enable`` で ``enable`` 自身を無効にできる。元に戻せない？

* <``test`` という名前はプログラムに向いていないようだ。> (p. 196) は至言。

7.3.3 eval
~~~~~~~~~~
* <スクリプトを実行しながらコマンド文字列をその場で生成し、
  シェルにそれらを実行させることができる> (p. 197)
* <変数名の先頭のドル記号をバックスラッシュエスケープしたのは、
  変数の値に ``>`` や ``|`` といった特殊記号が含まれていると、
  思わぬ結果を招くからだ。バックスラッシュには、
  ``eval`` コマンド自体が実行されるまでの変数の評価を先送りするという働きがある。> (p. 198)

::

  eval sort -nr \$1 ${2:+"| head -\$2"}

  eval "$@" > logfile 2>&1 &

8 章 プロセスの操作
===================
Cygwin ユーザーが読んでも役に立つと信じて本章を読む。

* <UNIX は、ユーザーごとに複数のプロセスの制御を可能にした最初の小型コンピュータオペレーティングシステムとしてもよく知られている。> (p. 209)
* <プロセスを識別し、ログインセッションやシェルスクリプトでそれらを制御するための最も基本的な要素から見ていく。> (p. 209)
* <プロセスどうしを通信させる仕組みについて調べる。> (p. 209)

8.1 プロセス ID とジョブ番号
----------------------------
* <プロセスが生成されると、必ず **プロセス ID** という番号が振られる。> (p. 210)
  コマンドを ``&`` 付きで実行すると、コンソールに ``[1] 4000`` のような表示が出る。
  最初の括弧つきの番号が **ジョブ番号** を示す。
* <ジョブという言葉は、基本的に、シェルから呼び出されたコマンドラインを指す。> (p. 210)

8.2 ジョブ制御
--------------
* <ただし、ジョブ番号のほうは重要だ。
  **ジョブ制御** を行うシェルコマンドで使用するからである。> (p. 211)
* <ジョブをバックグラウンドで起動した後は、そのまま完了させるか、
  **フォアグラウンド** へ移すか、または
  **シグナル** というメッセージを送りつけることができる。> (p. 211)

8.2.1 フォアグラウントとバックグラウンド
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``jobs`` コマンドでジョブの一覧表示。オプションが色々ある。
* 引数なしで ``fg`` と入力すると、バックグランドで最後に実行されたジョブがフォアグラウンドに移る。

8.2.2 ジョブの一時停止
~~~~~~~~~~~~~~~~~~~~~~
* <一時停止するには、ジョブの実行中に CTRL+Z キーを押す。> (p. 213)
  ここで CTRL+Z は ``susp`` に設定されていることを仮定している。
* <停止したジョブを再開し、フォアグラウンドで続行したい場合には、
  ここで ``fg`` と入力すればよい。> (p. 213)
* <（いつものように）コマンドをフォアグラウンドに実行したところ、
  思ったよりも処理に時間がかかっていることに気付く。
  コマンドはきちんと終了させたいが、端末の制御を取り戻して他の作業も行いたい。
  このような場合には、CTRL+Z キーを押してから ``bg`` と入力すれば、
  ジョブをバックグラウンドに移すことができる。> (p. 214) 
  脚注のネットワーク経由での実行に関する注意も読む。

8.3 シグナル
------------
* CTRL+Z と CTRL+C は、<どちらもプロセスに **シグナル** を送信するという特殊な行動をとる> (p. 214)
* シグナルとは、あるプロセスから別のプロセスに送信されるメッセージととらえればよいようだ。
* シグナルを使用するスクリプトを書くときは、可搬性を高めるために番号ではなく名前を使用する。
  ``kill -l`` で一覧できる。

8.3.1 コントロールキーのシグナル
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* <説明しておいて何だが、この方法はお勧めできないことを付け加えておかなければならない。> (p. 216)

8.3.2 kill
~~~~~~~~~~
* デフォルトでは ``kill`` は TERM シグナルを送信する。
  ただ、効果としては INT シグナルと同じとのこと。
* <すべてを説明すると込み入った話になるので、次の説明で勘弁して欲しい。> (p. 216)
* ``kill %1`` は「ジョブ番号 1 のプロセスを（TERM シグナルで）停止する」。
* ``kill -QUIT %1`` は「ジョブ番号 1 のプロセスを（QUIT シグナルで）終了する」。
* ``kill -KILL %1`` は「ジョブ番号 1 のプロセスを（KILL シグナルで）終了する」。
* <TERM シグナルと QUIT シグナルは、プロセスを終了する前に「後始末」をする機会を設けるが、
  KILL シグナルは、たとえ計算中であったとしても、プロセスを強制終了する。
  **KILL シグナルは最後の手段として使用すること。**> (pp. 217-218)

8.3.3 ps
~~~~~~~~
* <プロセス ID は ``ps`` コマンドで取得することができる。> (p. 218)
* <``ps`` にはオプションが複数あるが、UNIX のバージョンによって異なる。> (p. 218)
  Cygwin 環境では ``ps -ax`` が怒られるから、BSD ではなく System V 系統なのだろうか。

8.4 トラップ
------------
8.4.2 プロセス ID と一時ファイル
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* <``$$`` は、現在のシェルのプロセス ID を保持する特別なシェル変数である。> (p. 224)
* <``$!`` には、最後に実行したバックグラウンドジョブのプロセス ID が含まれている。> (p. 224)
* <``trap`` コマンドに指定されたコマンド文字列が、実行されるまで **評価されない** ことに注意しよう。
  したがって、コマンド文字列の ``$msgfile`` には、必ず正しい値が含まれる。
  コマンド文字列を単一引用符で囲んだのは、そのためである。> (p. 225)

8.4.5 トラップのリセット
~~~~~~~~~~~~~~~~~~~~~~~~
* ``trap`` コマンドに引数としてハイフンだけを指定すると、
  シグナル受信時の動作がデフォルト（プロセスの中止）に戻る。

8.5 コルーチン
--------------
* <2 つ（以上）のプロセスが同時に実行されるようにプログラムされていて、
  プロセスどうしが互いにやり取りすることが可能である場合、それらを **コルーチン**
  (coroutine) という。> (p. 227)
* <パイプラインはコルーチンの一例だ。> (p. 227)

8.5.1 wait
~~~~~~~~~~
* <引数を指定しないと、
  ``wait`` はバックグラウンドジョブがすべて終了するまで待機する。> (p. 228)

8.5.2 コルーチンの利点と欠点
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
以下の用語がだいたい人に説明できる程度まで、複数プロセス同時実行のメリットに関する理解を深めたい。

* CPU 集約型
* 入出力集約型
* 対話型
* スラッシンング

8.5.3 並列化
~~~~~~~~~~~~
* <プロセスをコルーチンに分割することを、ジョブを **並列化** するとも言う。> (p. 229)
* <この場合、コルーチンの実行時間は、すべてのプロセスの実行時間を合計したものではなく、
  基本的には、実行時間が最も長いものに若干のオーバーヘッドを足したものとなる
  （ただし、すべての CPU が 1 つのディスクドライブを共有していた場合、
  I/O 関連のスラッシングの可能性はまだ消えない）。> (p. 230)
* <せっかく並列化を施して処理時間を短縮したのに、
  追加したコードの実行時間で相殺されてしまったのでは意味がない。> (p. 231)
* <複雑な並列プログラムになると、本体の目的を達成するコードよりも、
  特殊な状況に対応するコードのほうが圧倒的に多いほどである。> (p. 231)

8.6 サブシェル
--------------
8.6.2 入れ子のサブシェル
~~~~~~~~~~~~~~~~~~~~~~~~
* <シェルコードの一部を（中かっこではなく）かっこで囲むと、そのコードはサブシェルで実行される。
  これを **入れ子** の（またはネストした）サブシェルと言う。> (p. 232)

  * 通常は、コマンドブロック（中括弧）の場合よりも効率が悪い。
  * サブシェルとコマンドブロックの違いは、そのほとんどが「スコープ」に関係するもの。
    シェル変数やシグナルトラップの有効範囲が違う。

* <コードの入れ子をサポートしている言語では、入れ子のコード内で定義されるものには、
  そこだけに限定されたスコープが割り当てられることが望ましい、とされている。
  このため、変数やシグナルトラップのスコープに関しては、
  入れ子のサブシェルのほうがコマンドブロックよりも厳密な制御が可能である。
  したがって、変数の定義やシグナルトラップが必要で、
  効率を度外視できるのであれば、コマンドブロックよりもサブシェルを使用したほうがよいだろう。> (p. 233)

8.7 プロセス置換
----------------
::

  cmp <(program1) <(program2)

1. ``program1`` と ``program2`` を同時に実行して、
2. それらの出力を **名前付きパイプ** につなぎ、
3. ``cmp`` がそれぞれのパイプからデータを読み取り、比較する。

9 章 シェルプログラミングのデバッグ
===================================
9.1 基本的なデバッグ補助
------------------------
9.1.1 set のオプション
~~~~~~~~~~~~~~~~~~~~~~
* 組み込み変数 ``PS4`` は ``set -o xtrace`` の出力行の先頭の文字列。
  展開レベル次第で、出力行の先頭の文字列の先頭に ``PS4`` の 1 文字目が付加される。

9.2 bash デバッガ
-----------------
* <プログラムにおいて実行を停止する場所を指定する。
  これを **ブレークポイント** という。> (p. 245)
* <プログラムにおいて指定された数の文を実行する。
  これを **ステップ実行** という。> (p. 245)
* <``exec`` に引数としてコマンドラインを渡すと、
  それらは現在のプログラム（同じプロセス）で実行される。
  したがって、 ``exec`` を実行するとシェルが **直ちに停止し、**
  ``exec`` の引数と置換される。> (p. 247)
  ``exec`` が危険な存在であることを指摘している。

10 章 bash の管理
=================
10.1 標準シェルとしての bash のインストール
-------------------------------------------
* <1 行目では、 ``$PATH`` 環境変数を
  ``for`` ループの項目リストとして使用できるようにしている。> (p. 268)

::

  IFS=:
  for d in $PATH; do
      <何か処理>

10.1.1 POSIX モード
~~~~~~~~~~~~~~~~~~~
* POSIX は Portable Operating System Interface の略らしい。X はどこから？
* <``bash`` はデフォルトのモードでも POSIX にほぼ 100% 準拠している。
  POSIX へのこだわりがあるならば、 ``bash`` を POSIX モードで実行することができる。
  そのためには、 ``--posix`` オプションを指定するか、
  シェルで ``set -o posix`` を設定する。> (p. 269)

10.1.2 コマンドラインオプション
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* 表 10-1 より、使えそうなものをノート：

-c string    *string* からコマンドを読み取る。
-i           対話型シェル。
-l, --login   ログインシェル。
--help       使用法を示すメッセージを表示する。
--noprofile  ``/etc/profile`` やユーザーの初期設定ファイルをロードしない。
--norc       対話型シェルの場合、 ``~/.bashrc`` をロードしない。
--rcfile file  対話型シェルの場合、 ``~/.bashrc`` の代わりに *file* をロードする。
--init-file file  同上。

* <コマンドラインで複数文字のオプションを指定する場合には、
  1 文字のオプションよりも前に指定しなければならない。> (p. 270)

10.2 環境のカスタマイズ
-----------------------
* ``bash`` は ``/etc/profile`` を読み込んでから ``~/.bash_profile`` を読み込む。
  ``umask`` や ``ulimit`` コマンドを使用するのは前者。

10.2.1 umask
~~~~~~~~~~~~
* <ここでは 8 進表記を使用して ``umask`` の説明をする。
  おそらく知っていると思うが、パーミッションの数字は、（左から右に）
  所有者、所有者が属するグループ、その他のユーザーへのパーミッションを表す。
  数字はそれぞれ 3 ビットで構成され、左から右に、
  読み取り、書き込み、実行のパーミッションを指定する。
  （ファイルがディレクトリの場合、「実行」パーミッションは「検索」パーミッションとなる。
  検索パーミッションとは、ディレクトリを移動したりファイルの一覧を取得したりするためのパーミッションである。> (p. 271)

10.2.2 ulimit
~~~~~~~~~~~~~
* ``ulimit`` コマンドで、ユーザーが利用できるシステムリソースに制限を設けることができる。

11 章 シェルスクリプティング
============================
本章では、<保守可能なシェルスクリプトを作成する方法を紹介> (p. 279) するようだ。

11.1 スクリプトは何をするのか
-----------------------------
11.1.2 変数と定数
~~~~~~~~~~~~~~~~~
* <ヘッダーとコメントは、コードを文書化するための方法の 1 つにすぎない。> (p. 281)
* <よい名前とは、短くてわかりやすいものである。（略）長い名前にしてはならない。
  （略）わかりやすい名前のメリットを帳消しにするほど、
  スクリプトを煩雑にするだけである。> (p. 281)

11.2 スクリプトの起動
---------------------
* <プログラマはユーザーの操作ができるだけ楽になるように努力しなければならない。> (p. 281)
* <Free Software Foundation では、GNU ソフトウェアを作成するためのガイドラインを公開し、
  UNIX ユーティリティの標準的な使用法を提案している。> (p. 282) URL が脚注にある。
* <注意しなければならない点が 1 つある。
  それは、ユーザーの環境において特定の環境変数が設定されていることを前提とする場合である。
  環境変数が設定されていることをあてにするくらいなら、
  スクリプトの設計を見直して、その値を引数として指定できるようにしたほうがよいだろう。> (p. 283)

11.3 その他の問題点
-------------------
``bash`` スクリプトに関するものだけノート。

* 必ず ``#!/bin/bash`` とすること。
* ホワイトスペースに注意する。等号の前後、開き括弧の後ろ、閉じ括弧の前が危ない。
* 評価演算子 ``[...]`` の使用に注意。 ``=`` なのか ``-eq`` なのか等。

11.4 bash を使用しない
----------------------
* 大量の処理をすばやく実行する場合や、
  数学的な計算を要する場合は C/C++ の使用を検討したり、
  システム間の可搬性を重視する場合は、
  Python や Perl のほうが適しているといった判断をすること。
  適材適所。

12 章 bash の導入
=================
Cygwin ユーザーである記者は特に読まなくてよい？

付録 A 関連シェル
=================
A.3 Korn シェル
---------------
* <唯一の欠点は、数年起きにしかアップグレードされないことだ。> (p. 302)
  とある。今でもそうなのだろうか。

A.5 zsh
-------
* <特に「パワーユーザー」にお勧めである。> (p. 303)

付録 B リファレンス
===================
B.8 入出力リダイレクト
----------------------
* 出力・エラーリダイレクトには ``&>file`` と ``>&file`` の 2 つの形式がある。
  後者のほうが望ましい。

付録 D プログラム可能な補完
===========================
* <補完メカニズムにフックを仕掛けて、
  2 章で説明した組み込みのテキスト補完機能を拡張するものである。> (p. 333)
* TAB キーが押されたときのシェルの対応を ``complete`` コマンドで指定する。

::

  # -A file が「補完するのはファイルリストだ」ということを指示する
  #
  # -X '!*.@(Z|gz|tgz)' がファイル名パターンのフィルターを指示する
  complete -A file -X '!*.@(Z|gz|tgz)' gunzip

* ``compgen`` は補完文字列を確認するのに利用できる。

::

  complete -A file -X '!*.@(Z|gz|tgz)'
