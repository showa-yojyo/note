======================================================================
OpenGL Shading Language 4.60 Specification 読書ノート Part 4
======================================================================

`仕様書該当部分 <https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#variables-and-types>`__

.. contents:: ノート目次

4. Variables and Types
======================================================================

変数と関数はすべて使用する前に宣言する必要がある。変数や関数の名前とは識別子だ。

既定の型はない。変数と関数の宣言にはすべて、宣言された型が必要で、修飾子がオプションだ。
変数を宣言するには、型を指定した後、カンマで区切って一つ以上の名前を指定する。
多くの場合、代入演算子 ``=`` を使って、宣言の一部として変数を初期化することができる。

ユーザー定義型は、既存の型のリストを一つの名前に集約するために
``struct`` を使って定義することができる。

OpenGL Shading Language は型安全だ。型の間には暗黙の変換がある。
どのような場合にどのような変換が行われるかについては、
:ref:`4.1.10. Implicit Conversions` で述べられ、本仕様書の他の項からも参照されている。

.. admonition:: コメント

   おそらく仕様を C/C++ に寄せている。

4.1. Basic Types
----------------------------------------------------------------------

**基本型** (a basic type) とは当言語のキーワードにより定義されている型だ。

OpenGL Shading Language では、以下のように基本型を分類している：

* Transparent Types: ``void``, ``bool``, ``int``, etc.
* Floating-Point Opaque Types: ``sampler1D``, ``texture1D``, ``image1D``, etc.
* Signed Integer Opaque Types: ``isampler1D``, ``itexture1D``, ``iimage1D``, etc.
* Unsigned Integer Opaque Types: ``usampler1D``, ``utexture1D``, ``uimage1D``, etc.
* Sampler Opaque Types: ``sampler``, ``samplerShadow``.

これに加え、これらの基本型を配列や構造体を使って集約し、
より複雑な型を構築することができる。

ポインター型はない。

本仕様書では、集約型 (an aggregate) は構造体や配列を意味する。
行列やベクトルはそれ自体は集約型ではない。
集約型、行列、ベクトルを総称して **合成** (composites) と呼ぶ。

4.1.1. Void
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

値を返さない関数は ``void`` として宣言しなければならない。既定の戻り値の型はない。
キーワード ``void`` は他の宣言では使用できない（空の仮引数リストや実引数リストを除く）。
さもないとコンパイルエラーになる。

4.1.2. Booleans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**真偽型** (a boolean type) とは ``bool``, ``bvec2``, ``bvec3``, ``bvec4``
の任意のいずれかだ。

* コードの条件付き実行を表現しやすくするために、真偽型を対処している。
* ハードウェアがこの型の変数を直接対処することは想定していない。
* これは本物の真偽型であり、真か偽かの二つの値のうちただ一つを保持する。
* キーワード ``true`` と ``false`` がリテラルな定数として使用できる。
* 条件付きジャンプ (``if``, ``for``, ``? :``, ``while``, ``do``-``while``)
  に使われる式は真偽型に評価されなければならない。

4.1.3. Integers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**整数型** (an integral type) とは、符号あり、符号なし、スカラー、ベクトル整数型のことだ。
配列や構造体は含まれない。

**スカラー整数型** (a scalar integral type) とは、符号ありまたは符号なし整数型のスカラーだ。

**ベクトル整数型** (a vector integral type) とは、符号ありまたは符号なしの整数のベクトルだ。

----

* 符号ありおよび符号なしの整数変数が完全に対処されている。
  この文書では、整数という言葉は、符号あり整数と符号なし整数の両方を一般的に意味する。
* OpenGL では、符号なし整数は正確に 32 ビットの精度を持つ。
* OpenGL では、符号あり整数は、符号ビットを含む 32 ビットを 2 の補数形式で使用する。
* 加算、減算、および乗算でオーバーフローまたはアンダーフローが発生した場合は、
  正しい結果 R の低次 32 ビットが得られる。ここで R はオーバーフローまたは
  アンダーフローを回避するのに十分な精度で計算される。
  オーバーフローの結果となる除算は、未定義の値となる。

----

C 言語と同様にしてリテラル整数定数を十進数、八進数、16 進数で表すことができる。

ビットパターンが 32 ビットに収まらないリテラル整数を用意すると、コンパイルエラーになる。
リテラルのビットパターンは常に変更されずに使用される。そのため、
ビットパターンに符号ビットが設定されている符号ありリテラルは負の値を生じる。

.. admonition:: コメント

   仕様書の例をよく見ておくこと。例えば ``-1u`` はどんな値であるか言えるようになること。

4.1.4. Floats
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一般に、浮動小数点という言葉は、単精度浮動小数点と倍精度浮動小数点の両方を指す。

浮動小数点変数は、以下の例のように定義される：

.. code:: glsl

   float a, b = 1.5; // single-precision floating-point
   double c, d = 2.0LF; // double-precision floating-point

* いずれかの処理単位への入力値として、単精度または倍精度の浮動小数点変数は、
  精度とダイナミックレンジについて、対応する IEEE 754 浮動小数点定義と一致することが期待される。
  シェーダー内の浮動小数点変数も、単精度浮動小数点値の IEEE 754 仕様に従って符号化される
  （物理的には必ずしもそうではないが、論理的には）。
* 符号化は論理的には IEEE 754 だが、演算は必ずしも IEEE 754 の要求通りには行われない。
  精度や NaN, Inf の使い方の詳細については :ref:`4.7.1. Range and Precision` を参照。

----

* 指数部が存在する場合は、小数点 ``.`` は必要ない。
* 接尾辞の前も含め、浮動小数点定数の中には空白を入れてはいけない。
* トークン化の際には、仕様書の BNF による定義に合致する最大のトークンが
  認識されてから新しいトークンが開始する。
* 接尾辞 ``lf`` または ``LF`` がある場合、リテラルの型は ``double`` だ。
  それ以外の場合、リテラルは ``float`` 型だ。
* 先頭の単項マイナス記号 ``-`` は単項演算子として解釈され、浮動小数点定数の一部ではない。

.. admonition:: コメント

   浮動小数点数とダイナミックレンジの関係を別途理解しておくこと。

4.1.5. Vectors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

浮動小数点値、整数値、真偽値の 2, 3, 4 成分それぞれの汎用ベクトルのデータ型がある。

* 浮動小数点ベクトル変数は、色、法線、位置、テクスチャー座標、
  テクスチャー検索結果などを格納するのに使用できる。
* 真偽値のベクトルは、数値のベクトルの成分ごとの比較に使用できる。

.. code:: glsl

   vec2 texcoord1, texcoord2;
   vec3 position;
   vec4 myRGBA;
   ivec2 textureLookup;
   bvec3 less;

ベクトルの初期化はコンストラクターで行う。
:ref:`5.4.2. Vector and Matrix Constructors` に記述がある。

4.1.6. Matrices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2×2, 2×3, 2×4, 3×2, 3×3, 3×4, 4×2, 4×3, 4×4 の浮動小数点数の行列の型が組み込まれている。

* ``mat`` で始まる行列型は単精度成分を持ち、
* ``dmat`` で始まる行列型は倍精度成分を持つ。
* 型の最初の数字は列数、二番目の数字は行数をそれぞれ表す。数字が一つしかない場合、
  それは正方行列だ。

.. code:: glsl

   mat2 mat2D;
   mat3 optMatrix;
   mat4 view, projection;
   mat4x4 view; // an alternate way of declaring a mat4
   mat3x2 m; // a matrix with 3 columns and 2 rows
   dmat4 highPrecisionMVP;
   dmat2x4 dm;

行列の値の初期化は、コンストラクターを用いて、列優先順 (column-major order) で行われる。

.. admonition:: コメント

   行列コンストラクターには列ベクトルを渡すような書き方をする。
   ただし、テキストエディター上では列ベクトルの要素を一行で書くことになるはずだから、
   そこで混乱しないようにする。

4.1.7. Opaque Types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**不透明型** (an opaque type) とは、型であって、その内部構造が言語から隠されているものだ。

----

不透明型は他のオブジェクトへの不透明なハンドルとなる変数を宣言する。
これらのオブジェクトは、宣言された変数を直接読み書きするのではなく、
組み込み関数を通してアクセスされる。
これらのオブジェクトは、関数の引数または ``uniform`` 修飾された変数としてしか宣言できない。
メモリー修飾子を取る不透明な型は ``image`` 型だけだ。
配列の添字、構造体のメンバーの選択、括弧を除き、
不透明変数は式のオペランドになることはできず、そのような使い方をするとコンパイルエラーになる。

不透明な変数は左辺値として扱うことができない。
したがって、``out`` または ``inout`` の関数引数として使用することも、代入することもできない。
このような使い方をすると、コンパイルエラーになる。
ただし、型と記憶修飾子が一致する ``in`` 引数として渡すことは可能だ。
また、初期化子を付けて宣言することはできない。

単一の不透明型宣言ではハンドル自身と、そのハンドルとなるオブジェクトの
二つのオブジェクトが効果的に宣言されるため、
格納修飾子とメモリー修飾子の両方を使用する余地がある。
格納修飾子は不透明ハンドルを修飾し、
メモリー修飾子はハンドルであるオブジェクトを修飾する。

Texture-Combined Samplers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

テクスチャー混合採取器型 (texture-combined sampler types) とは、
:ref:`4.1. Basic Types` の表（注：仕様書の本物を参照）に記載されている、
テクスチャーにアクセスするためのハンドルとなる採取器型のことだ。

* ``sampler`` や ``samplerShadow`` は含まれない。

テクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の
各データ型ごとに、異なるテクスチャー混合採取器型がある。
テクスチャーへのアクセスは、組み込みテクスチャー関数
(:ref:`8.9. Texture Functions`) を使って行われるが、
どのテクスチャーにアクセスするか、またどのようにフィルターリングするかを指定するために、
テクスチャー混合採取器型が使われる。

テクスチャー混合採取器型は不透明型で、前述の不透明型と同様に宣言され、動作する。
シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

Images
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

画像型は不透明型で、上記の不透明型と同様に宣言され、動作する。
さらにメモリー修飾子で修飾することができる。
シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

画像変数は、画像単位に束縛されたテクスチャー画像の単一レベルのすべてまたは一部に対応する
1, 2, 3 次元のいずれかの画像のハンドルだ。

画像変数はテクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の各データ型ごとに、異なる型がある。
画像へのアクセスは、レベルが画像単位に束縛されているテクスチャーの対象に一致する
画像型を使用する必要がある。
もしくは、3D または配列画像の非レイヤー束縛の場合は、画像のレイヤーの次元に
一致する画像型を使用する必要がある。

* つまり、3D, 2DArray, Cube, CubeArray のレイヤーは ``image2D`` を使用し、
* 1DArray のレイヤーは ``image1D`` を使用し、
* 2DMSArray のレイヤーは ``image2DMS``

をそれぞれ使用する必要がある。
このように画像対象型が束縛された画像と一致しない場合、データ型が束縛された画像と一致しない場合、
フォーマットレイアウト修飾子が OpenGL 仕様 8.25 Texture Image Loads and Stores
に記載されている画像単位表現形式と一致しない場合、画像アクセスの結果は未定義となるが、
プログラムの終了を含むことはできない。

画像変数は :ref:`8.12. Image Functions` で記述されている画像のロード、格納、
不可分関数において、アクセスする画像を指定するために用いられる。

Atomic Counters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

不可分計数器型とは、計数器への不透明なハンドルであって、
前述の不透明型と同様に宣言され、動作するものだ。
宣言された変数は、:ref:`8.10. Atomic Counter Functions` で記述がある、
組み込み不可分計数器関数を使用するときに、
どの計数器にアクセスするかを指定する。
また、:ref:`4.4.7. Atomic Counter Layout Qualifiers` で記述があるように、
バッファーに束縛される。

シェーダー内の配列に集約された不可分計数器は、動的一様な整数式でしか
インデックスを付けることができない。そうでない場合、結果は未定義だ。

構造体のメンバーは不可分計数器型として宣言できない。

Texture, sampler, and samplerShadow Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

テクスチャー、採取器、samplerShadow 型は不透明型で、上記の不透明な型と同様に宣言され、
動作する。
シェーダー内で配列に集約されている場合、これらの型は動的一様な式でしか
インデックスを付けることができない。
そうしないとテクスチャー検索は未定義の値になる。

テクスチャー変数は、:ref:`4.1. Basic Types` の表に列挙されている一次元、二次元、
三次元のテクスチャー、キューブマップなどのハンドルだ。
テクスチャー型は、テクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の各データ型ごとに異なる。

テクスチャーは、採取器型または samplerShadow 型の変数と組み合わせて、
テクスチャーを混合した採取器型 (``sampler2D``, ``sampler2DShadow``, etc.)
を作ることができる。これはコンストラクターで行う。例えば、

* ``sampler2D(texture2D, sampler)``,
* ``sampler2DShadow(texture2D, sampler)``,
* ``sampler2DShadow(texture2D, samplerShadow)``,
* ``sampler2D(texture2D, samplerShadow)``

などだ。詳細は :ref:`5.4. Constructors` で述べる。

Subpass Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

サブパス入力型 (e.g. ``subpassInput``) は不透明型で、上記の不透明型と同様に宣言され、
動作するものだ。
シェーダ内ーで配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

サブパス入力型は、二次元の単一採取または複数採取された画像を扱うもので、
``float``, ``integer``, ``unsigned integer`` のデータ型ごとに異なる型がある。

サブパス入力型は、断片シェーダーでのみ利用可能だ。
他の段階での使用はコンパイルエラーとなる。

.. admonition:: コメント

   名詞 subpass の概念が（というより pass のそれが）わからないので、
   わかるまでこのままカタカナにしておく。

4.1.8. Structures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++ 言語の構造体 ``struct`` と同じようなことができる：

.. code:: glsl

   struct light {
       float intensity;
       vec3 position;
   } lightVar;

   light lightVar2;

ただし、C/C++ のそれよりは弱い：

* 構造体には少なくとも一つのメンバー宣言が必要。
* メンバー宣言には精度修飾子を付けることができるが、それ以外の修飾子を使用するとコンパイルエラー。
* ビットフィールドは対処されていない。
* メンバー型はすでに定義されている必要がある（前方参照不可）。
* メンバー宣言に初期化子が含まれているとコンパイルエラー。
* メンバー宣言には、配列を含めることができる。配列にはサイズが指定されていなければならない。
  サイズはゼロより大きい定数の整数表現でなければならない
  (:ref:`4.3.3. Constant Expressions`)。
* 各レベルの構造体は、メンバー宣言子で指定された名前に対して独自の名前空間を持つ。
  このような名前は、その名前空間内で一意であればよい。
* 匿名構造体は対処されていない。
* 埋め込み構造体の定義は対処されていない。コンパイルエラーになる。

  .. code:: glsl

     struct S { float f; };

     struct T {
         S;              // Error: anonymous structures disallowed
         struct { ... }; // Error: embedded structures disallowed
         S s;
     };

* 構造体をコンストラクターを使用して宣言時に初期化することができる
  (:ref:`5.4.3. Structure Constructors`)。
* 型や修飾子の使用に関するあらゆる制限は、その型や修飾子のメンバーを含むすべての
  構造体にも適用される。これは、構造体である構造体メンバーにも再帰的に適用される。

4.1.9. Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

細かいことが色々と仕様化されている。

* 同じ型の変数は、名前の後に大括弧 ``[ ]`` でそのサイズを囲んで宣言することで、
  配列に集約することができる。
* 宣言の中で配列のサイズを指定する場合、それはゼロより大きい定数整数式
  (:ref:`4.3.3. Constant Expressions`) でなければならない。
* シェーダー格納ブロック (:ref:`4.3.9. Interface Blocks`) の最後に宣言されたメンバーを除き、
  配列のサイズは、一定の整数式以外でインデックスを付ける前に宣言 (explicitly sized)
  しなければならない。
* 任意の配列のサイズは、それを関数の引数として渡す前に宣言しなければならない。
  これらの規則に違反すると、コンパイルエラーが発生する。
* サイズを指定しないで配列を宣言 (unsized) し、後で同じ名前の配列を同じ型の配列
  として再宣言してサイズを指定するか、
  定数整数式のみでインデックスを付ける (implicitly sized) ことは適法だ。
  ただし、特に断りのない限り、ブロックを再宣言することはできない。
* ユーザーが宣言したブロック内のサイズのない配列メンバーは、
  ブロックの再宣言によってサイズを変更することはできない。
* サイズを指定して配列を宣言し、後で（同じシェーダー内で）宣言されたサイズ以上の
  定数整数式で同じ配列をインデックスするとコンパイルエラー。
* サイズのない配列を再宣言して、その配列のインデックスとしてシェーダ内で以前に
  使用されたインデックスと同等かそれ以下のサイズにすることは、コンパイルエラー。
  また、負の定数式で配列をインデックスすることもコンパイルエラー。
* 関数宣言で仮引数として宣言された配列は、サイズを指定しなければならない。
* 配列のサイズ以上、または 0 未満の非定数式で配列をインデックスすると、
  未定義の動作となる。
* 配列は一次元しか持たないが、配列の配列を宣言することができる。
* すべての型（基本型、構造体、配列）を配列にすることができる。

----

すべての配列は本質的に同質 (homogeneous) であり、すべて同じ型とサイズの要素で構成されているが、
例外が一つある。サイズのない配列を最後のメンバーとして持つシェーダー格納ブロックだ
(runtime-sized)。このようなシェーダー格納ブロックからは、格納ブロックの最後の
メンバーの長さが異なっていたとしても、配列を形成することができる。

.. code:: glsl

   float frequencies[3];
   uniform vec4 lightPosition[4];
   light lights[];
   const int numLights = 2;
   light lights[numLights];

   // a shader storage block, introduced in section 4.3.7 "Buffer Variables"
   buffer b {
       float u[]; // an error, unless u gets statically sized by link time
       vec4 v[];  // okay, v will be sized dynamically, if not statically
   } name[3];     // when the block is arrayed, all u will be the same size,
                  // but not necessarily all v, if sized dynamically

----

配列型は、非配列型の後に配列指定子を指定することで形成できる。
このような配列指定子の次元すべてにサイズを含める必要がある。

.. code:: glsl

   float[5]    // an array of size [5] of float
   float[2][3] // an array of size [2][3] of float, not size [3] of float[2]

この型は、他の型が使用できる場所であればどこでも使用できる。関数からの戻り値であってもいい：

.. code:: glsl

   float[5] foo() { }

配列のコンストラクターとして：

.. code:: glsl

   float[5](3.4, 4.2, 5.0, 5.2, 1.1)

名前なし引数として：

.. code:: glsl

   void foo(float[5])

または変数や関数の引数パラメータを宣言する手段の代わりとしても使用できる。

.. code:: glsl

   float[5] a;

----

配列は、配列コンストラクターから形成される初期化子を持つことができる：

.. code:: glsl

   float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1);
   float a[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1);  // same thing

----

配列の配列を宣言することができる：
次の宣言はどれも ``vec4`` の長さ 2 の一次元配列の長さ 3 の一次元配列だ。

.. code:: glsl

   vec4 a[3][2]; // size-3 array of size-2 array of vec4
   vec4[2] a[3]; // size-3 array of size-2 array of vec4
   vec4[3][2] a; // size-3 array of size-2 array of vec4

透過的なメモリー（一様ブロックなど）では、最内周（宣言では右端）の次元が
外周の次元よりも速く反復されるレイアウトになっている。
上記の配列の場合、メモリー上の順序は次のようになる：

.. code:: text

   Low address : a[0][0] : a[0][1] : a[1][0] : a[1][1] : a[2][0] : a[2][1] : High address

----

コンストラクターと名前なしの引数の両方に必要な ``a`` の型は ``vec4[3][2]`` となる：

.. code:: glsl

   vec4 b[2] = vec4[2](vec4(0.0), vec4(0.1));
   vec4[3][2] a = vec4[3][2](b, b, b); // constructor
   void foo(vec4[3][2]); // prototype with unnamed parameter

初期化子リスト構文を使って配列の配列を初期化することもできる：

.. code:: glsl

   vec4 a[3][2] = { vec4[2](vec4(0.0), vec4(1.0)),
                    vec4[2](vec4(0.0), vec4(1.0)),
                    vec4[2](vec4(0.0), vec4(1.0)) };

----

サイズなし配列を宣言時に初期化子で明示的にサイズを指定することができる：

.. code:: glsl

   float a[5];
   ...
   float b[] = a;  // b is explicitly size 5
   float b[5] = a; // means the same thing
   float b[] = float[](1,2,3,4,5); // also explicitly sizes to 5

しかし、サイズなし配列に代入するのはコンパイルエラーとなる。
これは、初期化子と代入が異なるセマンティクスを持っているように見えるまれなケースだ。
配列の配列では、サイズなし次元は初期化子によってサイズが明示的に決まる：

.. code:: glsl

   vec4 a[][] = { vec4[2](vec4(0.0), vec4(1.0)), // okay, size to a[3][2]
                  vec4[2](vec4(0.0), vec4(1.0)),
                  vec4[2](vec4(0.0), vec4(1.0)) };

----

配列は ``length()`` メソッドを使って含まれる要素の数を取得できる：

.. code:: glsl

   float a[5];
   a.length(); // returns 5

* 配列のサイズが明示的に決められている場合、
  ``length()`` が返す値は定数式だ。
* 配列のサイズが明示的に設定されておらず、シェーダー格納ブロックの最後に宣言された
* メンバーである場合、戻り値は定数式ではなく、ブロックに対して格納所を用意する
  バッファーオブジェクトのサイズに基づいて実行時に決定される。
  このような配列は runtime sized だ。
  runtime sized 配列において、配列が 0 より小さいか、配列内のブロック数以上の
  非定数式でインデックス付けられたシェーダー格納ブロックの配列に含まれている場合、
  ``length()`` の戻り値は未定義だ。

``length()`` を runtime sized ではなく、かつ明示的にサイズが設定されていない
配列に対しては呼び出すことができない。コンパイルエラーとなる。

``length()`` がコンパイル時定数を返す場合、
``length()`` が適用される式は、式中の左辺値への書き込みや、
それ自体が副作用を持つ関数呼び出しなどの副作用を含めることはできない。
コンパイル時定数 ``length`` 自体しか計算する必要はない。

式に他の効果が含まれている場合、コンパイルエラー報告を含め、動作と結果は未定義だ。

.. code:: glsl

   float a, b;
   const int s = float[2](a=3.0, ++b).length(); // illegal side effects

----

``length()`` は配列の配列に対しても同様に機能する：

.. code:: glsl

   vec4 a[3][2];
   a.length()    // this is 3
   a[x].length() // this is 2

``length()`` がコンパイル時定数を返す場合、括弧 ``[ ]`` 内の式は解析され、
配列のインデックスに必要な規則に従うものの、配列を逆参照しない。
このように、式に副作用がない限り、式の実行時の値が範囲外であっても、動作はきちんと定義される。

``length()`` が（コンパイル時定数ではなく）実行時の値を返すと、配列を逆参照する。例えば、
``x`` がコンパイル時定数ではなく、範囲外の場合は、未定義の値を返す。
より一般的には、関係する式すべてが完全に評価され、実行される。

.. code:: glsl

   // for a compile time-sized array b containing a member array a:
   b[x+3].a.length(); // b is never dereferenced, x+3 is evaluated and checked
   b[++x].a.length(); // not allowed; results are undefined

   // for an array s of a shader storage object (run-time sized) containing a member array a:
   s[++x].a.length(); // s is dereferenced; ++x needs to be a valid index

----

暗黙的なサイズの配列や実行時サイズの配列では、最も外側の次元しかサイズを欠落することができない。
不明な配列サイズを含む型は、明示的なサイズが得られるまで配列を形成することができない。
ただし、シェーダー格納ブロックの場合は、唯一であるサイズなし配列メンバーが
ブロックの最後のメンバーになる。

シェーダー格納ブロックでは、最後のメンバーは明示的なサイズを指定せずに宣言することができる。
この場合、実効的な配列サイズは、インターフェイスブロックをバックアップする
データ格納場所のサイズから実行時に推論される。
このような実行時サイズの配列は、一般的な整数式でインデックスを付けることができる。
ただし、関数の引数として渡したり、負の定数式でインデックスを作成したりすると
コンパイルエラーとなる。

.. admonition:: コメント

   ゴチャゴチャした節だが、配列の理論はレンダリングの観点から明らかに重要だ。
   読み落としはいけない。

4.1.10. Implicit Conversions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

状況によっては、式とその型が暗黙的に異なる型に変換されることがある。
許されるすべての暗黙の変換が表に示されている。

暗黙の変換は、コンストラクターを使った明示的な変換と同じだ。
コンストラクターによる明示的な変換については
:ref:`5.4.1. Conversion and Scalar Constructors` にある。

二項演算子の暗黙の変換を行う場合、オペランド二つが変換できるデータ型が複数ある場合がある。
例えば ``int`` 型の値を ``uint`` 型の値に加算する場合、両方の値が ``uint``,
``float``, ``double`` に暗黙的に変換される可能性がある。

* このような場合、どちらかのオペランドが浮動小数点型であれば、浮動小数点型が採用される。
* また、どちらかのオペランドが符号なし整数型であれば、符号あり整数型が採用される。
* それ以外の場合は、符号あり整数型が採用される。
* オペランドが同じ基本データ型から派生する複数のデータ型に暗黙的に変換できる場合は、
  構成要素のサイズが最も小さいデータ型が採用される。

4.1.11. Initializers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

宣言には、変数の初期値を指定することができ、等号 ``=`` の後に初期化子を指定する。
初期化子 (an initializer) とは、
*assignment-expression* であるか、中括弧 ``{ }`` で囲まれた初期化子のリストのどちらかをいう。

.. admonition:: コメント

   仕様書の BNF によると、モダン C++ のそれと同じと考えて良さそうだ。

*assignment-expression* は通常の式であって、括弧の外にあるカンマ ``,`` は初期化子の終わりと解釈される。
これにより入れ子になった初期化子を記述することができる。
変数型型とその初期化子は、入れ子、各レベルに存在する成分・要素・メンバーの数・
型の点で正確に一致しなければならない。
大域スコープの *assignment-expression* には、ユーザー定義関数の呼び出しを含めることができる。

初期化子にある *assignment-expression* は、初期化するオブジェクトと同じ型であるか、
:ref:`4.1.10. Implicit Conversions` に従ってオブジェクトの型に変換できる型でなければならない。
コンストラクターを含むため、合成変数はコンストラクターでも初期化リストでも初期化でき、
初期化リストの要素をコンストラクターにすることもできる。

初期化子が中括弧で囲まれた初期化子リストの場合、宣言する変数はベクトル、
行列、配列、構造体のいずれかでなければならない。

.. code:: glsl

   int i = { 1 }; // illegal, i is not a composite

釣り合う中括弧で囲まれた初期化子のリストが合成体一つに適用される。
これは、宣言されている変数、または宣言されている変数に含まれる合成体であってかまわない。
初期化子リストの個々の初期化子は、合成体の要素・メンバーに対してその順に適用される。

* 合成体がベクトル型の場合、リストの初期化子は、ベクトルの成分に成分 0 から順に適用される。
  初期化子の数は成分の数と一致しなければならない。
* 合成体が行列型の場合、リストの初期化子はベクトルの初期化子でなければならず、
  行列の列に、列 0 から順に適用される。
  初期化子の数は行列の列数と一致しなければならない。
* 合成体に構造体型がある場合、リストの初期化子は、構造体で宣言されている順序で、
  最初のメンバーから順に構造体のメンバーに適用される。
  初期化子の数はメンバーの数と一致しなければならない。

これらの規則が適用されるので、次の宣言はすべて同値だ：

.. code:: glsl

   mat2x2 a = mat2(  vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) );
   mat2x2 b =      { vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) };
   mat2x2 c =      {     { 1.0, 0.0 },     { 0.0, 1.0 } };

次の宣言はすべてコンパイルエラーだ：

.. code:: glsl

   float a[2] = { 3.4, 4.2, 5.0 };         // illegal
   vec2 b = { 1.0, 2.0, 3.0 };             // illegal
   mat3x3 c = { vec3(0.0), vec3(1.0), vec3(2.0), vec3(3.0) }; // illegal
   mat2x2 d = { 1.0, 0.0, 0.0, 1.0 };      // illegal, can't flatten nesting
   struct {
       float a;
       int b;
   } e = { 1.2, 2, 3 };                    // illegal

いずれの場合も、オブジェクトに適用される最も内側の初期化子
（つまり、中括弧で囲まれた初期化子のリストではない）は、
初期化されるオブジェクトと同じ型であるか、
:ref:`4.1.10. Implicit Conversions` に従ってオブジェクトの型に変換できる型でなければならない。
後者の場合、代入が行われる前に初期化子に対して暗黙の変換が行われる。

.. code:: glsl

   struct {
       float a;
       int b;
   } e = { 1.2, 2 }; // legal, all types match
   struct {
       float a;
       int b;
   } e = { 1, 3 };   // legal, first initializer is converted

次の宣言はすべてコンパイルエラーだ：

.. code:: glsl

   int a = true;                         // illegal
   vec4 b[2] = { vec4(0.0), 1.0 };       // illegal
   mat4x2 c = { vec3(0.0), vec3(1.0) };  // illegal

   struct S1 {
       vec4 a;
       vec4 b;
   };

   struct {
       float s;
       float t;
   } d[] = { S1(vec4(0.0), vec4(1.1)) }; // illegal

サイズなし配列に初期化子（いずれかの形式）が提供されている場合、
配列のサイズは、初期化子内のトップレベルの（入れ子になっていない）初期化子の数が決定する。
以下の宣言はすべて、明示的に 5 要素を持つ配列を生成する：

.. code:: glsl

   float a[] = float[](3.4, 4.2, 5.0, 5.2, 1.1);
   float b[] = { 3.4, 4.2, 5.0, 5.2, 1.1 };
   float c[] = a;                          // c is explicitly size 5
   float d[5] = b;                         // means the same thing

初期化される合成体の初期化子リストに含まれる初期化子の数に過不足があるとコンパイルエラーだ。
つまり、配列の要素すべて、構造体のメンバーすべて、行列の列すべて、
ベクトルの成分すべてには、厳密に一つの初期化子式が存在し、消費されない初期化子があってはならない。

4.2. Scoping
----------------------------------------------------------------------

変数のスコープは、その宣言位置によって決まる。

* すべての関数定義の外側で変数が宣言されている場合、それは大域スコープを持ち、
  宣言された場所から始まり、そのシェーダーの最後まで存続する。
* ``while`` 検定や ``for`` 文の中で宣言されている場合は、それに続く部分文の最後までスコープされる。
* ``if`` 文や ``else`` 文の中で宣言されている場合は、その文の最後までスコープされる。
  :ref:`6.2. Selection`, :ref:`6.3. Iteration` を参照。
* 複文の中の文として宣言されている場合は、その複文の末尾にスコープされる。
* 関数定義の中で引数として宣言されている場合は、その関数定義の最後までスコープされる。
* 関数の引数宣言と本体は、大域スコープに入れ子になった単一のスコープを形成する。
* ``if`` 文の式では、新しい変数を宣言することができないため、新しいスコープを形成しない。

宣言の中では、名前のスコープは、初期化子がある場合はその直後から、
ない場合は宣言されている名前の直後から始まる。

.. admonition:: コメント

   仕様書ではここに C/C++ プログラマーなら納得の行くコード例が挙げられている。

----

``for`` ループも ``while`` ループも、部分文自体は変数名の新しいスコープを導入していないので、
以下は再宣言のコンパイルエラーになる：

.. code:: glsl

   for ( /* nested scope begins here */ int i = 0; i < 10; i++) {
       int i; // redeclaration error
   }

``do``-``while`` ループの本体では、本体が単文か複文かによらず、
``do`` と ``while`` の間（判定式は含まない）だけ続く新しいスコープが導入される。

.. code:: glsl

   int i = 17;
   do
       int i = 4;  // okay, in nested scope_
   while (i == 0); // i is 17, scoped outside the do-while body

``switch(...)`` に続く文は、入れ子スコープを形成する。

あるスコープ内のすべての変数名、構造体型名、関数名は同じ名前空間を共有する。
関数名は、同じスコープ内で、同じまたは異なるパラメータでエラーなしで再宣言できる。
暗黙的なサイズの配列は、同じ基本型の配列と同じスコープで再宣言できる。
それ以外の場合、一つのコンパイル単位内では、宣言された名前を同じスコープで再宣言することはできない。
再宣言するとコンパイルエラーになる。
入れ子になったスコープが外側のスコープで使用されている名前を再宣言すると、
その名前の既存の使用がすべて隠される。隠された名前にアクセスしたり、隠蔽を解除したりするには、
隠蔽したスコープを終了しなければならない。

組み込み関数のスコープは、ユーザーが大域変数を宣言する大域スコープの外側にある。
つまり、シェーダーの大域スコープは、ユーザー定義関数や大域変数を使えられ、
組み込み関数を含むスコープの中に入れ子になっている。
入れ子になったスコープで関数名を再宣言すると、外側のスコープでその名前で宣言された関数すべてが隠蔽される。
関数の宣言（プロトタイプ）は、関数の内部には記述できない。
大域スコープか、組み込み関数の場合は大域スコープの外側に記述しなければならず、
記述しない場合はコンパイルエラーになる。

----

共有大域とは、同一言語（頂点などの同一段階）内で独立してコンパイルされた単位
（シェーダー）内で同じ名前で宣言された大域変数で、
単一のプログラムを作る際にリンクされるものだ
（異なるシェーダー言語間のインターフェイスとなる大域については別の節で述べる）。
共有大域は同じ名前空間を共有し、同じ型で宣言する必要がある。
また、同じ格納域を共有する。

共有大域配列は、同じ基本型と同じ明示的なサイズでなければならない。
あるシェーダーで暗黙的にサイズ設定された配列は、同じ段階の別のシェーダーで
明示的にサイズ設定することができる。
ある段階のどのシェーダーも配列の明示的なサイズを持っていない場合、
その段階の最大の暗黙的なサイズ（使用されている最大のインデックスよりも 1 多い）が採用される。
段階をまたいだ配列のサイズ変更はない。
これは、配列が他の段階やアプリケーションと共有されるインターフェイスブロック内で
宣言されている場合に関係する（他の未使用の配列は最適化により排除されてもかまわない）。

共有される大域スカラーは、厳密に同じ型名と型定義を持たなければならない。
構造体は、同じ名前、一連の型名、型定義、およびメンバー名を持たなければ、同じ型とはみなされない。
この規則は入れ子になった型や埋め込まれた型にも再帰的に適用される。
共有大域に複数の初期化子がある場合、初期化子はすべて定数式であり、すべて同じ値でなければならない。
そうでない場合は、リンクエラーが発生する（初期化子が一つしかない共有大域では、
その初期化子を定数式にする必要はない）。

.. admonition:: コメント

   最後の 3 パラグラフについては、仕様書を全部読んでいない段階では、
   シェーダーを書くときに ``main`` の外側に置く変数が関係しているだろうと想像する。

.. include:: ./note4.3.txt
.. include:: ./note4.4.txt
.. include:: ./note4.5.txt
