4.4. Layout Qualifiers
----------------------------------------------------------------------

レイアウト修飾子は宣言形式がいくつかある。
前節の文法で示したように、インターフェイスブロックの定義やブロックメンバーの一部
として現れることがある。
一つの *layout-qualifier* だけで、その修飾子を使った他の宣言のレイアウトを
設定することもできる。

| *layout-qualifier* *interface-qualifier* ;

また、インターフェイス修飾子で宣言された個別の変数で出現することもある：

| *layout-qualifier* *interface-qualifier* *declaration* ;

レイアウトの宣言は、大域スコープまたはブロックメンバーでしか行えず、
以下の節で示される場所でしか行えない。

レイアウト修飾子は次のように展開する：

|   *layout-qualifier* :
|       ``layout (`` *layout-qualifier-id-list* ``)``
|
|   *layout-qualifier-id-list* :
|       *layout-qualifier-id*
|       *layout-qualifier-id* , *layout-qualifier-id-list*
|
|   *layout-qualifier-id* :
|       *layout-qualifier-name*
|       *layout-qualifier-name* = *layout-qualifier-value*
|       ``shared``
|
|   *layout-qualifier-value* :
|       *integer-constant-expression*

*layout-qualifier-name* に使用されるトークンは、キーワードではなく識別子で、
*layout-qualifier-id* としてキーワード **shared** を使用することができる。
一般的に、これらはどのような順序でも並べてよい。
順序に依存する意味は、下で明示されている場合に限り存在する。
同様に、これらの識別子は、明示的に別段の記載がない限り、大文字と小文字を区別しない。

単一の宣言にレイアウト修飾子を複数含めることができる。
また、同じ *layout-qualifier-name* が、一つのレイアウト修飾子の中で複数回現れたり、
同じ宣言の中で複数のレイアウト修飾子にまたがって現れたりすることがある。
同じ *layout-qualifier-name* が単一の宣言の中で複数回出現する場合、
最後に出現したものがそれ以前に出現したものよりも優先される。
さらに、このような *layout-qualifier-name* が後続の宣言やその他の観察可能な挙動
に影響する場合、影響を与えるのは最後に出現するものだけであり、
以前に出現したものは存在しないかのように振る舞う。
これは *layout-qualifier-name* を上書きする場合にも当てはまり、
一方が他方を上書き場合 (e.g. ``row_major`` vs. ``column_major``) には、
最後に出現するものだけが影響を及ぼす。

*integer-constant-expression* は :ref:`4.3.3. Constant Expressions` で
*constant integral expression* として定義されており、
*integer-constant-expression* が特殊化定数であることはコンパイルエラーになる。

.. admonition:: コメント

   仕様書本文ではレイアウト修飾子の使用法の概要が表になって掲載されている。
   巨大なデータなので引用は控える。

4.4.1. Input Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

計算シェーダーを除くすべてのシェーダーでは、入力変数宣言、入力ブロック宣言、
入力ブロックメンバー宣言に対して
レイアウト修飾子 ``location`` を使うことができる。このうち、変数とブロックメンバー
（ブロックは不可）には、さらにレイアウト修飾子 ``component`` が使用できる。

| *layout-qualifier-id* :
| ``location`` = *layout-qualifier-value*
| ``component`` = *layout-qualifier-value*

例：

.. code:: glsl

   layout(location = 3) in vec4 normal;
   const int start = 6;
   layout(location = start + 2) int vec4 v;

これにより、シェーダー入力の ``normal`` はベクトル位置番号 3 に、
``v`` は位置番号 8 に割り当てられる。
頂点シェーダー入力の場合、位置を入力値を取得する頂点属性の番号で指定する。
他のすべてのシェーダー型の入力では、そのシェーダーが別のプログラムオブジェクト内
にあったとしても、位置を以前のシェーダー段階からの出力との照合に使用できる
ベクトル番号で指定する。

続く言語では、特定の型で消費される位置の数を記述する。
ただし、幾何シェーダー入力、細分化制御シェーダー入出力、
細分化評価入力はすべて、他のシェーダー入出力に対して追加の配列レベルを持っている。
この外側の配列レベルは、型が消費する位置の数を考慮する前に、型から取り除かれる。

Vulkan を対象にしている場合を除き、頂点シェーダー入力が任意のスカラーまたは
ベクトル型である場合、位置を一つを消費する。
非頂点シェーダーの入力や Vulkan を対象にしている場合の段階入力が
``dvec3`` や ``dvec4`` 以外のスカラー型やベクトル型の場合は、
位置を一つを消費するが、
``dvec3`` や ``dvec4`` 型の場合は連続した二つの位置を消費する。
``double`` 型や ``dvec2`` 型の入力は、段階すべてで一つの位置しか消費しない。

上述のように外側の配列レベルを削除した後、宣言された入力がサイズ n の配列で、
各要素が m 個の位置を取る場合、指定された位置から始まる m × n 個の連続した位置が
割り当てられる。例えば：

.. code:: glsl

   layout(location = 6) in vec4 colors[3];

これにより、シェーダーの入力色がベクトルの位置番号 6, 7, 8 に割り当てられることが確定する。

宣言された入力が n × m 行列の場合は、指定された位置から始まる複数の位置が割り当てられる。
各行列に割り当てられる位置の数は、m 成分のベクトルの n 要素の配列と同じになる。例えば：

.. code:: glsl

   layout(location = 9) in mat4 transforms[2];

これにより、シェーダー入力 ``transforms`` がベクトルの 9～16番に割り当てられる：

* ``transforms[0]`` が 9, 10, 11, 12 番に、
* ``transforms[1]`` が 13, 14, 15, 16 番に

割り当てられる。

----

宣言された入力が構造体やブロックの場合、そのメンバーには宣言順に連続した位置が割り当てられ、
最初のメンバーにはレイアウト修飾子で指定された位置が割り当てられる。
構造体の場合、この処理は構造体全体に適用される。
``layout`` 修飾子を構造体のメンバーに使用するとコンパイルエラーとなる。
ブロックの場合、この処理はブロック全体に適用される。
つまり ``location`` レイアウト修飾子を持つ最初のメンバーに到達するまで適用される。

ブロックのメンバーが ``location`` 修飾子付きで宣言されている場合、
そのメンバーの位置はその修飾子に由来し、メンバーの ``location`` 修飾子が
ブロックレベルの宣言よりも優先される。
後続のメンバーには、次の ``location`` 修飾子が宣言されたメンバーまで、
最新の位置に基づいて連続した位置が再び割り当てられる。
位置に使用される値は、昇順に宣言する必要はない。

ブロックレベルの ``location`` 修飾子がないブロックでは、
そのメンバーのすべてが ``location`` 修飾子を持つか、またはそれを一つも持たない
ことが要求される。さもないとコンパイルエラーとなる。
配列として宣言されたブロックには ``location`` がブロックレベルでしか適用できない
ものがある。ブロックが配列として宣言されていて、ブロックの配列要素ごとに
各メンバーに追加の位置が必要な場合、ブロックのメンバーに位置を指定すると
コンパイルエラーになる。つまり、ブロックメンバー上に位置を適用することで指定不足になる場合、
それは認められない。配列されたインターフェイス（一般にインターフェイスの拡張により
余計な配列を持つもの）では、この規則を適用する前に外側の配列が取り除かれる。

ブロックや構造体のメンバーが消費する位置は、構造体のメンバーが同じ型の入力変数として
宣言されているかのように、上記の規則を再帰的に適用して決定される：

.. code:: glsl

   layout(location = 3) in struct S
   {
       vec3 a;                      // gets location 3
       mat2 b;                      // gets locations 4 and 5
       vec4 c[2];                   // gets locations 6 and 7
       layout(location = 8) vec2 A; // ERROR, can't use on struct member
   } s;
   layout(location = 4) in block
   {
       vec4 d;                      // gets location 4
       vec4 e;                      // gets location 5
       layout(location = 7) vec4 f; // gets location 7
       vec4 g;                      // gets location 8
       layout(location = 1) vec4 h; // gets location 1
       vec4 i;                      // gets location 2
       vec4 j;                      // gets location 3
       vec4 k;                      // ERROR, location 4 already used
   };

シェーダーが利用できる入力位置の数には制限がある。
頂点シェーダーでは、その制限は公示された頂点属性の数だ。
その他のシェーダーでは、制限は実装に依存し、公示された最大入力成分数の
1/4 以上でなければならない。

取り付けられたシェーダーが対処されている個数を超える位置を使用している場合、
デバイス依存最適化がプログラムに利用可能なハードウェア資源内に収まるようにさせない限り、
プログラムはリンクに失敗する。

明示的な位置割り当てにより、リンカーが他の明示的割り当てのない変数のための
空間を見つけられない場合、プログラムはリンクに失敗する。

非頂点入力が以前のシェーダー段階の出力と一致するかどうかを判断するためには、
``location`` レイアウト修飾子がもしあれば一致していなければならない。

シェーダーテキストに位置が割り当てられていない頂点シェーダー入力変数に
OpenGL API で指定された位置がある場合は、その指定位置が使用される。
そうでなければ、そのような変数はリンカーによって場所が割り当てられる。
入力変数が同じ言語の複数のシェーダーで宣言されていて、位置が競合している場合、
リンクエラー。

修飾子 ``component`` を使用すると、スカラーやベクトルの位置をより細かく指定することができ、
消費される位置内の個々の成分まで指定することができる
修飾子 ``location`` を指定せずに ``component`` を使用すると、コンパイルエラーになる
（順序は重要でない）。
位置内の成分は 0, 1, 2, 3 だ。
成分 N で始まる変数やブロックメンバーは、そのサイズまでの成分 N, N+1, N+2, ...
を消費する。この成分の並びが 3 より大きくなると、コンパイルエラーになる。
スカラー ``double`` はこれらの成分のうち二つを消費し、
``dvec2`` はある位置で利用可能な四つの成分全てを消費する。
``dvec3`` や ``dvec4`` は成分指定なしでしか宣言できない。
``dvec3`` は一つ目の位置の四つの成分と、二つ目の位置の成分 0 と 1 をすべて消費する。
これにより、成分 2 と 3 は他の成分修飾された宣言に使用できる。

.. code:: glsl

   // a consumes components 2 and 3 of location 4
   layout(location = 4, component = 2) in vec2 a;

   // b consumes component 1 of location 4
   layout(location = 4, component = 1) in float b;

   // ERROR: c overflows component 3
   layout(location = 3, component = 2) in vec3 c;

   // d consumes components 2 and 3 of location 5
   layout(location = 5, component = 2) in double d;

   // ERROR: e overflows component 3 of location 6
   layout(location = 6, component = 2) in dvec2 e;

   // ERROR: f overlaps with g
   layout(location = 7, component = 0) double f;
   layout(location = 7, component = 1) float g;

   layout(location = 8) in dvec3 h; // components 0,1,2 and 3 of location 8
                                    // and components 0 and 1 of location 9
   layout(location = 9, component = 2) in float i; // okay, compts 2 and 3

変数が配列の場合、配列の各要素は順番に連続した位置に割り当てられるが、
各位置の中ですべて同じ指定された成分になる：

.. code:: glsl

   // component 3 in 6 locations are consumed
   layout(location = 2, component = 3) in float d[6];

この場合、位置 2 の成分 3 は ``d[0]`` を、位置 3 の成分 3 は ``d[1]`` を、...
位置 7 の成分 3 に ``d[5]`` を格納する。

これにより二つの配列を同じ位置にまとめることができる：

.. code:: glsl

   // e consumes beginning (components 0, 1 and 2) of each of 6 slots
   layout(location = 0, component = 0) in vec3 e[6];

   // f consumes last component of the same 6 slots
   layout(location = 0, component = 3) in float f[6];

これを配列の配列に適用する場合は、すべてのレベルの配列性が取り除かれ、
指定された成分に位置ごとに割り当てられた要素になる。
これらの非配列要素は :ref:`4.1.9. Arrays` が指定する順序で配列の配列に対する位置を埋める。

修飾子 ``component`` を行列、構造体、ブロック、またはこれらを含む配列に適用すると
コンパイルエラーになる。
``component`` 1 または 3 を ``double`` または ``dvec2`` の先頭に使用すると
コンパイルエラーになる。
プログラム内で同じ変数に異なる成分を指定すると、リンクエラーになる。

----

**位置エイリアシング** (location aliasing) とは、二つの変数やブロックメンバーに
同じ位置番号を持たせることだ。
**成分エイリアシング** (component aliasing) とは、二つの位置エイリアスに
同じ（つまり重複する）成分番号を割り当てることだ（
``component`` を使用しない場合は 0 から始まる成分が割り当てられることを思い出せ）。
一つの例外を除いて、位置エイリアシングは成分エイリアシングを起こさない場合に限り許される。
さらに、位置エイリアシングを行う場合、その位置を共有するエイリアスは、
内在する数値型とビット幅が同じでなければならず、補助格納修飾子と補間修飾子も
同じでなければならない。
成分エイリアシングが許可される例外とは、頂点シェーダーへの二つの入力変数
（ブロックメンバーではない）に対して OpenGL を対象にする場合で、
これらは成分エイリアシングが許されている。
この頂点変数の成分エイリアシングは、各実行パスがエイリアシングされた各成分ごとに
高々一つの入力にアクセスする頂点シェーダーを対処することしか目的としていない。
頂点シェーダー実行形式を通るすべての実行パスが、
任意の単一成分にエイリアスされた複数の入力にアクセスすることを検出した場合、
実装はこれをリンクタイムエラーとすることが許されているが、必須ではない。

Tessellation Evaluation Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

細分化評価シェーダーで使える追加的な入力レイアウト修飾子の識別子は次の通り：

| *layout-qualifier-id* :
|     *primitive-mode*
|     *vertex-spacing*
|     *ordering*
|     *point-mode*

識別子 *primitive-mode* は細分化基本形状生成器が使用する。

| *primitive-mode*:
|     ``triangles``
|     ``quads``
|     ``isolines``

*primitive-mode* がもしあれば、細分化基本形状生成器は三角形をより小さな三角形に、
四角形を三角形に、四角形を線の集合体にそれぞれ細分するべきだと指定する。

レイアウト識別子の二番目のグループである頂点間隔は、
細分化基本形状生成器が辺を細分化する際の間隔を指定するために用いられる。

| *vertex-spacing*:
|     ``equal_spacing``
|     ``fractional_even_spacing``
|     ``fractional_odd_spacing``

``equal_spacing`` は辺を同じ大きさのセグメントの集まりに分割することを指定する。

``fractional_even_spacing`` は、辺を偶数個の同じ長さのセグメントとさらに二つの
より短い「小数」のセグメントに分割することを指定する。

``fractional_odd_spacing`` は、辺を奇数個の同じ長さのセグメントとさらに二つの
より短い「小数」セグメントに分割することを指定する。

三番目のレイアウト識別子である *ordering* は、細分化基本形状生成器が、
OpenGL 仕様にある座標系に従い、時計回りまたは反時計回りのどちらの順序で三角形を
生成するのかを指定する。

| *ordering*:
|     cw
|     ccw

識別子 ``cw`` と ``ccw`` は、それぞれ時計回りと反時計回りの三角形を示す。
細分化基本形状生成器が三角形を生成しない場合、この順序は無視される。

最後の *point-mode* は、細分化基本形状生成器が、線や三角形を生成するのではなく、
細分化された基本形状のそれぞれの紛れのない頂点に対して一点を生成するべきであることを示す。

| *point-mode*:
|     point_mode

----

これらの識別子は、単一の入力レイアウト宣言の中で、一回またはそれ以上指定することができる。
プログラムの細分化評価シェーダーの中で、
*primitive-mode*, *vertex-spacing*, *ordering* が複数回宣言されている場合、
そのような宣言はすべて同じ識別子を使用しなければならない。

プログラム内の少なくとも一つの細分化評価シェーダー（コンパイル単位）は、
その入力レイアウトで *primitive-mode* を宣言しなければならない。
*vertex-spacing*, *ordering*, *point_mode* 識別子の宣言はオプションだ。
プログラム内の細分化評価シェーダーすべてが *primitive_mode* を宣言する
ということは必須ではない。
*vertex-spacing* や *ordering* の宣言が省略された場合、細分化基本形状生成器は、
それぞれ等間隔または反時計回りの頂点順序を採用する。
*point-mode* の宣言が省略された場合、細分化基本形状生成器は、
*primitive-mode* に従って線分または三角形を生成する。

Geometry Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

幾何シェーダー入力に対する追加のレイアウト修飾子識別子には、基本形状 (primitive) 識別子と
呼び出し回数 (invocation count) 識別子がある：

| *layout-qualifier-id* :
|     ``points``
|     ``lines``
|     ``lines_adjacency``
|     ``triangles``
|     ``triangles_adjacency``
|     ``invocations`` = *layout-qualifier-value*

識別子 ``points``, ``lines``, ``lines_adjacency``, ``triangles``, ``triangles_adjacency``
は、幾何シェーダーが受け付ける入力基本形状の種類を指定するためのもので、
これらのうちただ一つを受け付ける。
プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、
この入力基本形状のレイアウトを宣言しなければならず、
プログラム内の幾何シェーダーすべての入力レイアウト宣言は同じレイアウトを宣言しなければならない。
プログラム内のすべての幾何シェーダーが入力基本形状レイアウトを宣言することは必須ではない。

識別子 ``invocations`` は、受けとった入力基本形状それぞれに対して幾何シェーダー実行形式が
呼び出される回数を指定するために用いられる。回数の宣言はオプションだ。
プログラム内のどの幾何シェーダーでも回数が宣言されていない場合、
幾何シェーダーは入力基本形状それぞれに対して一度実行される。
宣言されている場合は、すべての宣言で同じ回数を指定しなければならない。
シェーダーが実装依存の最大値を超える呼び出し回数を指定したり、
ゼロ以下の呼び出し回数を指定したりすると、コンパイルエラーとなる。

.. code:: glsl

   layout(triangles, invocations = 6) in;

例えば上の宣言では、幾何シェーダーへの入力はすべて三角形であり、幾何シェーダーの実行形式は、
処理される三角形ごとに 6 回実行される。

幾何シェーダー入力サイズなし配列宣言のすべてで、以前の入力基本形状レイアウト修飾子がある場合、
サイズが変更される：

* ``points``: 1
* ``lines``: 2
* ``lines_adjacency``: 4
* ``triangles``: 3
* ``triangles_adjacency``: 6

内在的に宣言された入力配列 ``gl_in[]`` は、任意の入力基本形状レイアウト宣言に
よってもサイズが決定される。そのため、式 ``gl_in.length()`` 式は上にある値を返す。

``gl_in`` などの内在的に宣言された入力、配列サイズを持たずに宣言された入力については、
メソッド ``length()`` を使用する前か、配列サイズを知る必要のあるその他の配列使用の前に
レイアウトを宣言しなければならない。

レイアウト宣言の配列サイズが、同じシェーダー内の入力変数の宣言で指定されている
明示的な配列サイズすべてと一致しない場合はコンパイルエラーとなる。
コンパイルエラーの例：

.. code:: glsl

   // code sequence within one shader...
   in vec4 Color1[];     // legal, size still unknown
   in vec4 Color2[2];    // legal, size is 2
   in vec4 Color3[3];    // illegal, input sizes are inconsistent
   layout(lines) in;     // legal for Color2, input size is 2, matching Color2
   in vec4 Color4[3];    // illegal, contradicts layout of lines
   layout(lines) in;     // legal, matches other layout() declaration
   layout(triangles) in; // illegal, does not match earlier layout() declaration

プログラム内の幾何シェーダーすべてにおいて、提供されたサイズのすべて
（サイズ付き入力配列とレイアウトサイズ）が一致しない場合は、リンクエラーとなる。

Fragment Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``gl_FragCoord`` には以下のような追加的断片レイアウト修飾子がある：

| *layout-qualifier-id* :
|     ``origin_upper_left``
|     ``pixel_center_integer``

OpenGL の ``gl_FragCoord`` は既定ではウィンドウの座標は左下を原点とし、
画素中心は半画素の座標にあるとしている。例えば、ウィンドウの左下端の
画素に対しては ``(x, y)`` 座標 ``(0.5, 0.5)`` が返される。
原点は ``gl_FragCoord`` に ``origin_upper_left`` 修飾子を付けて再宣言することで
変更することができ、
``gl_FragCoord`` の原点をウィンドウの左上に移動させ、
``y`` はウィンドウの下に向かって値を大きくしていく。
また、返される値は、``pixel_center_integer`` によって、
``x`` と ``y`` の両方で半画素ずつずらすことができ、
画素が整数のオフセットで中心に置かれているように見える。
これは ``gl_FragCoord`` で返される ``(x, y)`` の値が既定値が ``(0.5, 0.5)`` であるのに対し、
``pixel_center_integer`` で ``(0.0, 0.0)`` に移動する。

Vulkan を対象にする場合、``gl_FragCoord`` の原点は左上で、
画素中心は半画素座標に配置されていると仮定し、要求される。
この原点を明示的に設定するには ``gl_FragCoord`` を ``origin_upper_left``
識別子で再宣言する。

再宣言は次のように行う：

.. code:: glsl

   in vec4 gl_FragCoord; // redeclaration that changes nothing is allowed

   // All the following are allowed redeclaration that change behavior
   layout(origin_upper_left) in vec4 gl_FragCoord;
   layout(pixel_center_integer) in vec4 gl_FragCoord;
   layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;

``gl_FragCoord`` がプログラム内のいずれかの断片シェーダーで再宣言された場合、
そのプログラム内で ``gl_FragCoord`` を静的に使用しているすべての断片シェーダーで
再宣言されなければならない。
単一のプログラム内にある断片シェーダーすべてにおける ``gl_FragCoord``
の再宣言はすべてが同じ修飾子の集合でなければならない。
どのシェーダー内でも ``gl_FragCoord`` の最初の再宣言が
``gl_FragCoord`` のどの使用の前にも現れなければならない。
組み込み ``gl_FragCoord`` は断片シェーダーでしか事前に宣言されていないので、
他のシェーダー言語で再宣言するとコンパイルエラーになる。

``origin_upper_left`` 修飾子と ``pixel_center_integer`` 修飾子の両方とも、
またはいずれか一方をつけて ``gl_FragCoord`` を再宣言しても
``gl_FragCoord.x`` と ``gl_FragCoord.y`` にしか影響しない。
ラスタライズ、座標変換、その他の API パイプラインや言語機能には影響しない。

断片シェーダーでは、OpenGL 仕様書の 15.2.4 "Early Fragment Tests" に
記載されているように、
断片シェーダーの実行前に断片検定を行うことを要求するために、
``in`` のみで次のレイアウト修飾子を使用することが許される（変数宣言では不可）：

| *layout-qualifier-id* :
|     early_fragment_tests

.. code:: glsl

   layout(early_fragment_tests) in;

例えば上の宣言では、断片シェーダーの実行前に断片ごとの検定が
行われるようになる。
これを宣言しない場合は、断片シェーダーの実行後に断片ごとの検定
が行われる。
この宣言が必要となるのは、一つの断片シェーダー（コンパイル単位）だけだが、
複数の断片シェーダーが宣言することもできる。
少なくとも一つがこれを宣言していれば有効になる。

Compute Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

計算シェーダー入力にはレイアウト位置修飾子がない。

計算シェーダー入力に対するレイアウト修飾子の識別子は、作業グループサイズ修飾子だ：

| *layout-qualifier-id* :
|     ``local_size_x`` = *layout-qualifier-value*
|     ``local_size_y`` = *layout-qualifier-value*
|     ``local_size_z`` = *layout-qualifier-value*

``local_size_x``, ``local_size_y``, ``local_size_z`` 各修飾子は、
それぞれ 1, 2, 3 次元の計算シェーダーによる固定作業グループのサイズを宣言する
ために用いられる。
シェーダーが次元のサイズをここから指定していない場合、その次元は 1 となる。

例えば、計算シェーダーで次のように宣言した場合、

.. code:: glsl

   layout(local_size_x = 32, local_size_y = 32) in;

作業グループサイズが 32×32 要素の二次元計算シェーダーを宣言するために用いられる。
これは、3次元目のサイズが 1 である三次元計算シェーダーに相当する。

.. admonition:: コメント

   上の一文は何を言っているのか。

もう一つ別の例として、次の宣言は、一次元の計算シェーダーがコンパイルされており、
そのサイズが実質的には 8 要素であることを指定している：

.. code:: glsl

   layout(local_size_x = 8) in;

いずれかの次元におけるシェーダーの固定作業グループサイズがゼロ以下、
または実装で対処される最大サイズよりも大きい場合、コンパイルエラー。
また、このようなレイアウト修飾子が同一シェーダー内で複数回宣言されている場合、
それらの宣言はすべて同じ作業グループサイズの集合を設定し、同じ値を設定しなければ
ならない。さもなければコンパイルエラー。
単一のプログラムオブジェクトに取り付けられた複数の計算シェーダーが
固定作業グループサイズを宣言する場合、
その宣言は同一でなければならない。さもなければリンクエラー。

さらに、プログラムオブジェクトが計算シェーダーを何か含む場合、
少なくとも一つはプログラムの固定作業グループサイズを指定する入力レイアウト修飾子
を含まなければならない。さもなければリンクエラー。

4.4.2. Output Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

出力レイアウト修飾子には、シェーダー段階すべてに適用されるものと、特定の段階にしか
適用されないものがある。ここでは前者を議論する。

入力レイアウト修飾子と同様に、計算シェーダーを除くすべてのシェーダーでは、
出力変数宣言、出力ブロック宣言、出力ブロックメンバー宣言に対して ``location``
レイアウト修飾子を許す。このうち、変数とブロックメンバー（ブロックは不可）には、
さらに ``component`` レイアウト修飾子を許す。

| *layout-qualifier-id* :
|     ``location`` = *layout-qualifier-value*
|     ``component`` = *layout-qualifier-value*

ブロックや構造体に ``location`` 修飾子や ``component`` 修飾子を適用する際の使い方
や規則は :ref:`4.4.1. Input Layout Qualifiers` のとおりだ。
また、断片シェーダーの出力では、二つの変数が同じ位置に配置される場合、
それらの変数の内容される型は同じでなければならない（浮動小数点・整数）。
出力変数やメンバーの成分エイリアスは許されない。

断片シェーダーでは ``index`` 出力レイアウト修飾子を追加的に付けられる：

| *layout-qualifier-id* :
|     ``index`` = *layout-qualifier-value*

これらの修飾子は、それぞれ高々一度現れる。
``index`` が指定された場合 ``location`` も指定しなければならない。
``index`` が指定されていない場合は値 0 が使用される。

例えば次の断片シェーダーでは、断片シェーダー出力色を
混合方程式の最初（インデックス 0）の入力として断片カラー 3 に割り当てる設定をする：

.. code:: glsl

   layout(location = 3) out vec4 color;

次の例は、断片シェーダーの出力係数が、混合方程式の 2 番目（インデックス 1）
の入力として断片色 3 に割り当てる設定をする：

.. code:: glsl

   layout(location = 3, index = 1) out vec4 factor;

断片シェーダーの出力では、位置とインデックスは、出力の値を受け取る色出力番号と
インデックスを指定する。
他のすべてのシェーダー段階の出力では、位置は、後続のシェーダー段階の入力と照合するために
使用できるベクトル番号を指定する（シェーダーが別のプログラムオブジェクトにある場合も同様）。

宣言された出力が ``dvec3`` または ``dvec4`` 以外のスカラーまたはベクトル型である場合は、
単一の位置を消費する。
``dvec3`` または ``dvec4`` 型の出力は連続した二つの場所を消費する。
``double`` 型や ``dvec2`` 型の出力は全ての段階で一つの位置しか消費しない。

宣言された出力が配列の場合は、指定された場所から連続した場所が割り当てられる。
例えば、次の宣言ではベクトルの位置番号 2, 3, 4 に ``colors`` が割り当てられる。

.. code:: glsl

    layout(location = 2) out vec4 colors[3];

宣言された出力が n×m の行列の場合、指定された位置から始まる複数の位置が割り当てられる。
割り当てられる場所の数は m 成分ベクトルの n 要素の配列と同じだ。

宣言された出力が構造体の場合、そのメンバーには宣言された順に連続した場所が割り当てられ、
構造体に指定された場所が最初のメンバーに割り当てられる。
構造体のメンバーが消費する位置の個数は、その構造体のメンバーが同じ型の出力変数と
して宣言されているかのように、前述の規則が再帰的に適用される。

``location`` レイアウト修飾子は、構造体として宣言された出力変数に使用することができる。
ただし、構造体メンバーに ``location`` 修飾子を使用するとコンパイルエラーとなる。
``location`` レイアウト修飾子は出力ブロックと出力ブロックメンバーに使用できる。

シェーダーで使用できる出力位置の数は限界がある。
断片シェーダーでは、その限界は公表されたドローバッファー数だ。

その他のシェーダーの場合、制限は実装依存であり、公表されている最大出力成分数の
1/4 以上でなければならない（計算シェーダーには出力がない）。
取り付けられたシェーダーが対処されている個数以上の位置を使用している場合、
デバイス依存最適化によってプログラムが利用可能なハードウェア資源内に収まるようにしない限り、
プログラムはリンクに失敗する。

また、コンパイル時にリンクが失敗することがわかっている場合には、コンパイルエラーがあり得る。
出力位置が負の場合は、コンパイルエラーになる。
断片シェーダーがレイアウトインデックスを 0 未満または 1 以上に設定した場合も、
コンパイルエラーとなる。

次のいずれかが発生すると、コンパイルエラーまたはリンクエラー：

* 断片シェーダーの出力変数の二つが両者とも同じ位置とインデックスに
  割り当てられている。
* 同じ（頂点｜細分化｜幾何）シェーダー段階からの出力変数二つが同じ位置に
  割り当てられている。

断片シェーダー出力では ``layout`` 修飾子または OpenGL API を使用して位置
を割り当てることができる。

すべてのシェーダー型において、明示的な位置の割り当てが
明示的な割り当てのない他の変数のための空間をリンカーに見つけさせられなくなる場合、
プログラムはリンクに失敗する。

シェーダーテキストで位置やインデックスが割り当てられていない出力変数が
OpenGL API を通じて位置を指定されている場合は API で指定された位置が採用される。
それ以外の場合は、リンカーがそのような変数に場所を割り当てる。
このような割り当てはすべて、色インデックスがゼロになる。
詳細は、OpenGL 仕様書の 15.2 "Shader Execution" を参照。
出力変数が同じ言語の複数のシェーダで宣言されており、位置やインデックスの値が
衝突している場合、リンクエラーが発生する。

断片ではない出力が後続のあるシェーダー段階からの入力と一致するかどうかを
判定するために、
``location`` レイアウト修飾子が（もしあれば）一致しなければならない。

Transform Feedback Layout Qualifiers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

頂点、細分化、幾何各段階では、シェーダーが変換反響を制御することができる。
それをするときに、シェーダーはどの変換反響バッファーを使用するか、
どの出力変数をどのバッファーに書き込むか、各バッファーをどのようにレイアウトするか
を決定する。
これを実現するために、シェーダでは出力宣言に次のレイアウト修飾子識別子を使用できる：

| *layout-qualifier-id* :
|     ``xfb_buffer`` = *layout-qualifier-value*
|     ``xfb_offset`` = *layout-qualifier-value*
|     ``xfb_stride`` = *layout-qualifier-value*

これらの ``xfb_`` 修飾子を（前処理後に）静的に使用するシェーダーは、
変換反響捕捉モードとなり、変換反響の設定を記述する責任が生じる。
このモードでは ``xfb_offset`` で選択された出力を、直接または間接的に、
変換反響バッファーに取り込むことになる。

Shaders in the transform feedback capturing mode have an initial global default of
``xfb_offset`` で選択された出力をどの変換反響バッファーに取り込むかは
``xfb_buffer`` 修飾子が指定する。
``xfb_buffer`` 修飾子は ``out`` 修飾子、出力変数、出力ブロック、出力ブロックメンバー
のどれにでも適用できる。
変換反響捕捉モードのシェーダーには次の初期の大域既定がある：

.. code:: glsl

   layout(xfb_buffer = 0) out;

この既定を変更するには、インターフェイス修飾子 ``out`` に ``xfb_buffer`` をつけて
別のバッファーを宣言する。これが大域既定を変更する唯一の方法だ。
``xfb_buffer`` 修飾子を付けずに変数や出力ブロックを宣言した場合は、
大域既定バッファーを継承する。
``xfb_buffer`` 修飾子をつけて変数や出力ブロックを宣言すると、その宣言され
たバッファーを持る。
あるブロックのメンバーすべてがそのブロックのバッファーを継承する。
メンバーは ``xfb_buffer`` を宣言することができるが、
そのバッファーはそのブロックから継承されたバッファーと一致しなければならない。
そうでなければコンパイルエラー。

.. code:: glsl

   layout(xfb_buffer=2, xfb_offset=0) out block { // block's buffer is 2
       layout(xfb_buffer = 2) vec4 v; // okay, matches the inherited 2
       layout(xfb_buffer = 3) vec4 u; // ERROR, mismatched buffer
       vec4 w; // inherited
   };
   layout(xfb_offset=16) out vec4 t;  // initial default is buffer 0
   layout(xfb_buffer=1) out;          // new global default of 1
   out block {                        // block has buffer 1
       vec4 x;                        // x has buffer 1 (not captured)
       layout(xfb_buffer = 1) vec4 y; // okay (not captured)
       layout(xfb_buffer = 0) vec4 z; // ERROR, mismatched buffer
   };
   layout(xfb_offset=0) out vec4 g;   // g has buffer 1
   layout(xfb_buffer=2) out vec4 h;   // does not change global default
   layout(xfb_offset=16) out vec4 j;  // j has buffer 1

これが意味するのは、ブロックのメンバーのうち、変換反響バッファーに行くものは
すべて同じバッファーに行くということだ。

ブロックが配列として宣言されている場合、ブロックの配列要素 0 のメンバーすべては、
前述のように、宣言または継承された ``xfb_buffer`` に取り込まれる。
一般に、ブロックの大きさ N の配列は、N 個の連続したバッファに取り込まれ、
ブロックの配列要素 E のメンバーすべては、バッファ B に取り込まれる。
ここで、B は宣言または継承された ``xfb_buffer`` に E を加えたものに等しくなる。

``xfb_buffer`` には、ブロックの配列を捕捉するために必要な追加のバッファーを含めて、
0 より小さいか、実装依存の定数 ``gl_MaxTransformFeedbackBuffers`` 以上の値を指定すると、
コンパイルエラーかリンクエラーとなる。

修飾子 ``xfb_offset`` は、変換反響バッファー内のバイトオフセットを割り当てる。
``xfb_offset`` をつけることができるのは、変数、ブロックメンバー、またはブロックしかない。
ブロックが ``xfb_offset`` で修飾されていれば、そのブロックのメンバーすべてに
変換反響バッファー内のオフセットが割り当てられる。
ブロックが ``xfb_offset`` で修飾されていない場合、そのようなブロックのメンバーには
変換反響バッファーのオフセットは割り当てられない。
オフセットが割り当てられた変数やブロックメンバーだけが捕捉される（つまり、
ブロックの適切な部分集合が捕捉される）。
このような変数やブロックメンバーがシェーダー内で書き込まれるたびに、
書き込まれた値は割り当てられたオフセットで捕捉される。
シェーダーの呼び出し時の間にこのようなブロックメンバーや変数が書き込まれない場合、
割り当てられたオフセットでのバッファーの内容は未定義となる。
変換反響オフセットが割り当てられている変数やメンバーへの静的な書き込みがない場合でも、
その空間はバッファーに割り当てられ、ストライドに影響を与える。

``xfb_offset`` で修飾された変数やブロックメンバーには、スカラー、ベクトル、行列、
構造体、およびこれらの（サイズ付き）配列を指定できる。
このオフセットは、最初に修飾された変数やブロックメンバーの第一成分のサイズの倍数
でなければならない。そうでなければコンパイルエラー。
さらに、 ``double`` を含む集合体に適用される場合、オフセットもバッファーに取られる
空間も 8 の倍数でなければならない。
与えられたオフセットは、修飾されたエンティティの最初のメンバーの最初の成分に適用される。
その後、修飾された実体中で、後続の成分はそれぞれその成分のサイズの倍数に整列した、
次に利用可能なオフセットに順に割り当てられる。
集約型は成分レベルまで平坦化され、この成分の並びが得られる。
サイズなし配列の宣言に ``xfb_offset`` を適用するとコンパイルエラー。

出力バッファーのエイリアシングは許されない。
変換反響オフセットが重なり合っている変数を指定するとコンパイルエラーまたはリンクエラー。

修飾子 ``xfb_stride`` は、捕捉した各頂点が何バイト消費するかを指定する。
その宣言の変換反響バッファーが継承されているか、明示的に宣言されているかに関わらず、
これが適用される。
この修飾子は、変数、ブロック、ブロックメンバー、あるいは単に修飾子 ``out`` にも
適用できる。
バッファーが倍精度成分を持つ出力を捕捉する場合、バッファー幅は 8 の倍数であるか、
そうでない場合は 4 の倍数でなければならず、そうでない場合はコンパイルエラーか
リンクエラー。
``xfb_stride`` をオーバーフローさせるような ``xfb_offset`` を持つことは、
``xfb_stride`` の前後の宣言であろうと、異なるコンパイル単位であろうと、
コンパイルエラーかリンクエラー。
``xfb_stride`` は、同じバッファーに対して複数回宣言することができるが、
異なる値のストライドを指定するとコンパイルエラーかリンクエラー。

.. code:: glsl

   // buffer 1 has 32-byte stride
   layout(xfb_buffer = 1, xfb_stride = 32) out;

   // same as previous example; order within layout does not matter
   layout(xfb_stride = 32, xfb_buffer = 1) out;

   // everything in this block goes to buffer 0
   layout(xfb_buffer = 0, xfb_stride = 32) out block1 {
       layout(xfb_offset = 0) vec4 a;  // a goes to byte offset 0 of buffer 0
       layout(xfb_offset = 16) vec4 b; // b goes to offset 16 of buffer 0
   };

   layout(xfb_buffer = 3, xfb_offset = 12) out block2 {
       vec4 v;  // v will be written to byte offsets 12 through 27 of buffer
       float u; // u will be written to offset 28
       layout(xfb_offset = 40) vec4 w;
       vec4 x;  // x will be written to offset 56, the next available offset
   };

   layout(xfb_buffer = 2, xfb_stride = 32) out block3 {
       layout(xfb_offset = 12) vec3 c;
       layout(xfb_offset = 24) vec3 d; // ERROR, requires stride of 36
       layout(xfb_offset = 0) vec3 g;  // okay, increasing order not required
   };

バッファーに ``xfb_stride`` が指定されていない場合、バッファー幅は、
最も高いオフセットに置かれた変数を保持するのに必要な最小値となり、
必要な詰め物 (padding) も含まれる：

.. code:: glsl

   // if there no other declarations for buffer 3, it has stride 32
   layout(xfb_buffer = 3) out block4 {
       layout(xfb_offset = 0) vec4 e;
       layout(xfb_offset = 16) vec4 f;
   };

結果のバッファー幅（暗黙的または明示的）を 4 で割って、
実装依存の定数 ``gl_MaxTransformFeedbackInterleavedComponents`` 以下でなければならない。

Tessellation Control Outputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

変換反響レイアウト修飾子を除き、
細分化制御シェーダーでは、出力ブロック、ブロックメンバー、または変数宣言ではなく、
インターフェイス修飾子 ``out`` 上でのみ出力レイアウト修飾子を使用することができる。
細分化制御シェーダーで使用できる出力レイアウト修飾子の識別子は次のとおり：

| *layout-qualifier-id* :
|     ``vertices`` = *layout-qualifier-value*

識別子 ``vertices`` は細分化制御シェーダーが生成する出力パッチの頂点数を指定し、
細分化制御シェーダーの呼び出し回数も指定します。
出力頂点数がゼロ以下であったり、実装依存の最大パッチサイズより大きかったりすると、
コンパイルエラーやリンクエラーとなる。

内在的に宣言された細分化制御出力配列 ``gl_out[]`` は、
任意の出力レイアウト宣言によってもサイズが決定される。したがって、次の式は
以前の出力レイアウト修飾子で指定された出力パッチの頂点数を返す：

.. code:: glsl

   gl_out.length()

内在的に宣言された出力を含む、配列サイズなし宣言された出力については、
メソッド ``length()`` の使用や、サイズを知る必要のある他の配列使用の前に、
レイアウトを宣言しなければならない。

出力レイアウト修飾子で指定された出力パッチ頂点数が、
同じシェーダー内の出力変数宣言で指定された配列サイズのどれとも一致しない場合は、
コンパイルエラーとなる。

プログラム内のすべての細分化制御シェーダーのレイアウト宣言は、
同じ出力パッチ頂点数を指定しなければならない。
細分化制御シェーダーを含むプログラムには、出力パッチの頂点数を指定する
レイアウト修飾子が少なくとも一つ必要だが、
すべての細分化制御シェーダーでそのような宣言が必要ということではない。

Geometry Outputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

幾何シェーダーは、出力基本形状型、最大出力頂点数、出力ごとのストリーム番号の
三種の出力レイアウト識別子を追加的に持てる。基本形状型と頂点数の識別子は、
出力ブロック、ブロックメンバー、変数宣言ではなく、インターフェイス修飾子 ``out``
でしか許されない。ストリーム識別子は、インターフェイス修飾子 ``out``,
出力ブロック、変数宣言上で許される。

幾何シェーダー出力に対するレイアウト修飾子の識別子は次のとおり：

| *layout-qualifier-id* :
|     ``points``
|     ``line_strip``
|     ``triangle_strip``
|     ``max_vertices`` = *layout-qualifier-value*
|     ``stream`` = *layout-qualifier-value*

基本形状型識別子の ``points``, ``line_strip``, ``triangle_strip`` は、
幾何シェーダーが生成する出力基本形状の型を指定するために使用され、
これらのうちただ一つが受け入れられる。
プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、出力基本形状型
を宣言しなければならず、プログラム内のすべての幾何シェーダーの出力基本形状型宣言は、
同じ基本形状型を宣言しなければならない。
プログラム内のすべての幾何シェーダーが出力基本形状型宣言をすることは必須ではない。

頂点数識別子 ``max_vertices`` は、シェーダーが単一の呼び出しで出力する最大の
頂点数を指定するために使用される。
プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、
最大出力頂点数を宣言しなければならず、
プログラム内のすべての幾何シェーダーの出力頂点数宣言は、同じ回数を宣言しなければならない。
プログラム内のすべての幾何シェーダーが回数を宣言することは必須ではありません。

.. code:: glsl

   layout(triangle_strip, max_vertices = 60) out; // order does not matter
   layout(max_vertices = 60) out;  // redeclaration okay
   layout(triangle_strip) out;     // redeclaration okay
   layout(points) out;             // error, contradicts triangle_strip
   layout(max_vertices = 30) out;  // error, contradicts 60

この例では、幾何シェーダーからの出力はすべて三角形であって、
シェーダーから出力されるのは高々 60 個の頂点だ。
最大の頂点数が ``gl_MaxGeometryOutputVertices`` よりも大きい場合はエラーとなる。

識別子 ``stream`` は、幾何シェーダーの出力変数またはブロックが、
特定の頂点ストリーム（ゼロから始まる番号）に関連付けられていることを指定するため
に用いられる。
ストリーム番号の既定値を、次の例のようにインターフェイス修飾子 ``out`` によって
大域スコープで宣言することができる：

.. code:: glsl

   layout(stream = 1) out;

このような宣言で指定されたストリーム番号は、それまでの既定値を置き換え、
新しい既定値が設定されるまで、後続のすべてのブロックおよび変数の宣言に適用される。
初期設定のストリーム番号はゼロだ。

各出力ブロックまたは非ブロック出力変数は、頂点ストリームに関連付けられる。
ブロックまたは変数がストリーム識別子とともに宣言されている場合は、
指定されたストリームに関連付けられ、そうでない場合は、現在の既定ストリームに関連
付けられる。
ブロックメンバーはストリーム識別子を付けて宣言することができるが、
指定されたストリームは含まれるブロックに関連付けられたそれと一致しなければならない。例：

.. code:: glsl

   layout(stream=1) out;           // default is now stream 1
   out vec4 var1;                  // var1 gets default stream (1)
   layout(stream=2) out Block1 {   // "Block1" belongs to stream 2
       layout(stream=2) vec4 var2; // redundant block member stream decl
       layout(stream=3) vec2 var3; // ILLEGAL (must match block stream)
       vec3 var4;                  // belongs to stream 2
   };
   layout(stream=0) out;           // default is now stream 0
   out vec4 var5;                  // var5 gets default stream (0)
   out Block2 {                    // "Block2" gets default stream (0)
       vec4 var6;
   };
   layout(stream=3) out vec4 var7; // var7 belongs to stream 3

幾何シェーダーで出力された各頂点は、特定のストリームに割り当てられ、
出力された頂点の属性は、対象となるストリームに割り当てられた出力ブロックと変数の
集合から取得される。
各頂点が放出された後、すべての出力変数の値は未定義となる。
さらに、各頂点ストリームに関連する出力変数は、格納を共有してもよい。
あるストリームに関連する出力変数に書き込むと、他のストリームに関連する出力変数が
上書きされることがある。
幾何シェーダーは、各頂点を放出する際に、その頂点が放出されるストリームに関連する
すべての出力に書き込み、
他のストリームに関連する出力には書き込まない。

幾何シェーダー出力ブロックや同変数が複数回宣言された場合、
そのような宣言のすべてで、その変数は同じ頂点ストリームに関連付けられなければならない。
存在しないストリーム番号を指定したストリーム宣言がある場合、シェーダーの
コンパイルは失敗する。

組み込み幾何シェーダー出力は頂点ストリーム 0 に常に関連付けられる。

プログラム内のすべての幾何シェーダー出力レイアウト宣言は、
同じレイアウトと同じ ``max_vertices`` 値を宣言しなければならない。
幾何シェーダーがプログラムに含まれている場合、
そのプログラムのどこかに少なくとも一つの幾何出力レイアウト宣言がなければならないが、
すべての幾何シェーダー（コンパイル単位）がそれを宣言する必要はない。

Fragment Outputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

組み込み断片シェーダ変数 ``gl_FragDepth`` は、
次のレイアウト修飾子のいずれかを使用して再宣言することができる：

| *layout-qualifier-id* :
|     ``depth_any``
|     ``depth_greater``
|     ``depth_less``
|     ``depth_unchanged``

``gl_FragDepth`` に対するレイアウト修飾子は、任意のシェーダー呼び出しによって書き込まれる
``gl_FragDepth`` の最終値の意図を制約する。
レイアウト修飾子に整合する ``gl_FragDepth`` のすべての値が不合格・合格する場合には、
与えられた断片に対して奥行き検定が不合格・合格すると仮定して最適化を
行うことが GL 実装はできる。
これには、断片がさえぎられ、シェーダーに副作用がないために廃棄される場合に、
シェーダーの実行を飛ばすことが含まれる可能性がある。
``gl_FragDepth`` の最終値がそのレイアウト修飾子と整合しない場合、
対応する断片の奥行き検定の結果は未定義となる。
しかし、この場合にはエラーとはならない。
奥行き検定が合格し、奥行き書き込みが有効な場合、奥行きバッファーに書き込まれる値は、
レイアウト修飾子と整合しているか否かに関わらず、常に ``gl_FragDepth`` の値となる。

既定では ``gl_FragDepth`` は ``depth_any`` として修飾される。
``gl_FragDepth`` のレイアウト修飾子が ``depth_any`` の場合、
シェーダーコンパイラーは ``gl_FragDepth`` への割り当てが未知の方法で変更されて
いることに留意し、奥行き検定は常にシェーダーの実行後に行われる。
レイアウト修飾子が ``depth_greater`` の場合、
``gl_FragDepth`` の最終値が ``gl_FragCoord`` の ``z`` 成分で与えられる断片の
補間奥行き値以上であると仮定することができる。
レイアウト修飾子が ``depth_less`` の場合、
``gl_FragDepth`` を修正してもその値が減少するだけだと考えることができる。
レイアウト修飾子が ``depth_unchanged`` の場合、シェーダーコンパイラーは
``gl_FragDepth`` のいかなる修正も尊重するが、他の部分は ``gl_FragDepth``
に新しい値が割り当てられていないと仮定することができる。

``gl_FragDepth`` の再宣言は以下のように行われる：

.. code:: glsl

   // redeclaration that changes nothing is allowed +
   out float gl_FragDepth;

   // assume it may be modified in any way
   layout(depth_any) out float gl_FragDepth;

   // assume it may be modified such that its value will only increase
   layout(depth_greater) out float gl_FragDepth;

   // assume it may be modified such that its value will only decrease
   layout(depth_less) out float gl_FragDepth;

   // assume it will not be modified
   layout(depth_unchanged) out float gl_FragDepth;

``gl_FragDepth`` がプログラム内のいずれかの断片シェーダーで再宣言された場合、
``gl_FragDepth`` への静的割り当てを持つそのプログラム内の断片シェーダー
すべてで再宣言されなければならない。
単一プログラム内の断片シェーダーすべてにおける
``gl_FragDepth`` の再宣言のすべてが同じ修飾子の集合を持たなければならない。
どのシェーダー内でも、
``gl_FragDepth`` の最初の再宣言がその使用よりも前に現れなければならない。
組み込み ``gl_FragDepth`` は断片シェーダーでのみ事前宣言されているので、
他のシェーダー言語で再宣言するとコンパイルエラーになる。

4.4.3. Uniform Variable Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

レイアウト修飾子は、一様変数とサブルーチン一様に使用できる。
一様変数とサブルーチン一様（変数）に対するレイアウト修飾子識別子は次のとおり：

| *layout-qualifier-id* :
|     ``location`` = *layout-qualifier-value*

位置識別子は、既定ブロック一様変数とサブルーチン一様（変数）で使用できる。
位置は、API が一様を参照し、その値を更新するための位置を指定する。
一様配列の個々の要素には連続した位置が割り当てられ、最初の要素は位置 ``location`` だ。
プログラム内でリンクされた同じ位置を共有する既定ブロック一様変数宣言は、
名前、型、修飾子、配列性が一致しなければならない。
配列の場合は、配列の次元と配列のサイズが一致していなければならない。
構造体の場合、この規則がメンバーすべてに再帰的に適用される。
サブルーチン一様変数二つが同じシェーダー段階内で同じ位置に存在することはできない。
コンパイルエラーかリンクエラーとなる。
既定ブロック変数の有効な位置は、0 から実装定義の一様位置の最大数から 1 を引いた範囲にある。
サブルーチン一様（変数）の有効な位置は、0 から実装定義の段階ごとの
サブルーチン一様（変数）の最大位置数から 1 を引いた値までの範囲にある。

位置は既定ブロック一様配列や構造体に割り当てることができる。
最も内側にある最初のスカラー、ベクトル、行列のメンバーや要素は指定された ``location`` を取り、
コンパイラーは次の最も内側にあるメンバーや要素に次の増分の位置値を割り当てる。
それ以降の最内側のメンバーや要素は、構造体や配列全体の増分の位置を取得します。
この規則は、入れ子になった構造体や配列にも適用され、最も内側にある
スカラー、ベクトル、行列の各メンバーに一意の位置を与える。
明示的サイズのない配列の場合は、静的な使用量に基づいてサイズが計算される。
リンカーが明示的位置のない一様（変数）の位置を生成する場合、
明示的位置のある一様（変数）すべてについて、その配列要素や構造体のメンバーがすべて使用されていると仮定し、
その要素やメンバーが使用されていないと判断された場合でも、リンカーは競合する位置を生成しない。

個々の（既定ブロック）透明一様変数を受け入れる API に対する SPIR-V を生成するとき、
それらを宣言するときに位置を含めないとコンパイルエラー。

Vulkan を対象にしている場合、修飾子 ``push_constant`` はブロック全体を宣言するために使用され、
Vulkan API で定義されているように、定数 ``push`` の集合を表す。
これを一様ブロック宣言以外に適用したり、Vulkan を対象にしていない場合はコンパイルエラー。
ブロック内の値は Vulkan API の仕様に基づいて初期化される。
``layout(push_constant)`` で宣言されたブロックは、オプションで *instance-name* を含めることができる。
``push_constant`` ブロックは段階ごとに一つだけで、そうでない場合はコンパイルエラーやリンクエラー。
``push_constant`` 配列は、動的一様なインデックスでしかインデックスを付けられない。
``push_constant`` で宣言された一様ブロックは、
宣言されていないブロックとは異なる資源を使用し、別々に計上される。

4.4.4. Subroutine Function Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

レイアウト修飾子をサブルーチン関数に使用できる。
サブルーチン関数のレイアウト修飾子識別子は次のとおり：

| *layout-qualifier-id* :
|     ``index`` = *layout-qualifier-value*

シェーダー内でインデックス修飾子を持つ各サブルーチンには、一意のインデックスが
与えられなければならない。
そうでない場合はコンパイルエラーまたはリンクエラー。
インデックスは 0 から実装定義のサブルーチン最大数から 1 を引いた範囲でなければならない。
OpenGL サブルーチン関数列挙 API がアクティブインデックスすべてに対して空ではない
名前を返すように、シェーダーは 0 から始まる飛び飛びにならないインデックス値の
範囲を割り当てることを推奨するが、必須ではない。

4.4.5. Uniform and Shader Storage Block Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

レイアウト修飾子は一様およびシェーダー格納ブロックに使用できるが、
非ブロック一様宣言には使用できない。
一様およびシェーダー格納ブロックのレイアウト修飾子の識別子（および ``shared``
キーワード）は次のとおり：

| *layout-qualifier-id* :
|     ``shared``
|     ``packed``
|     ``std140``
|     ``std430``
|     ``row_major``
|     ``column_major``
|     ``binding`` = *layout-qualifier-value*
|     ``offset`` = *layout-qualifier-value*
|     ``align`` = *layout-qualifier-value*

これらはいずれも、宣言されている変数の使用法に意味的な影響を全く与えず、
メモリー内でのデータの配置方法を示すに過ぎない。
例えば、行列のセマンティクスは、どのようなレイアウト修飾子が使用されていても、
この仕様の他の部分で述べられたように、常に列に基づく。

（一様｜シェーダー格納）ブロックレイアウト修飾子は、大域スコープ、
単一の（一様｜シェーダー格納ブロック｜ブロックメンバー）宣言上で宣言することができる。

一様ブロックには大域スコープでの既定レイアウトが次のように設定されている：

.. code:: glsl

   layout(layout-qualifier-id-list) uniform;

シェーダー格納ブロックの場合には：

.. code:: glsl

   layout(layout-qualifier-id-list) buffer;

これが行われると、直前の既定修飾がまず継承され、それから宣言にある各修飾について、
以下に述べる上書き規則に従って上書きされる。
その結果、後続の（一様｜シェーダー格納）ブロックの定義に適用される新しい既定修飾となる。

SPIR-V を生成する際のコンパイルの初期状態は、次のように宣言されたかのようなものだ：

.. code:: glsl

   layout(std140, column_major) uniform;
   layout(std430, column_major) buffer;

ところが ``push_constant`` を宣言すると、バッファーの既定レイアウトは
``std430`` になる。この既定を大域的に設定する方法はない。

SPIR-V を生成していないときのコンパイルの初期状態は、次のように宣言されたかの
ようなものだ：

.. code:: glsl

   layout(shared, column_major) uniform;
   layout(shared, column_major) buffer;

（一様｜シェーダー格納）ブロックは、オプションでレイアウト修飾子を付けて宣言する
ことができ、その個々のメンバー宣言も同様だ。このようなブロックレイアウト修飾は、
ブロックの内容にのみ適用される。
大域レイアウト宣言と同様に、ブロックレイアウト修飾は、まず現在の既定の修飾を継承し、
次にそれを上書きする。
同様に、個々のメンバーのレイアウト修飾は、メンバー宣言だけに適用され、ブロックの
修飾を継承して上書きする。

修飾子 ``shared`` は ``std140``, ``std430``, および ``packed`` 修飾子のみを上書きし、
その他の修飾子は継承される。コンパイラーかリンカーは、
すべての配列が明示的なサイズで宣言され、すべての行列が一致する ``row_major`` 修飾子と
``column_major`` 修飾子の両方を、または一方を（ブロック定義外の宣言から得られる
場合もある）持つ限り、この定義を含む複数のプログラムおよびプログラム可能段階が、
このブロックのために同じメモリーレイアウトを共有することを保証する。
これにより、異なるプログラム間で同じバッファーを使用して同じブロック定義を
back することができる。
SPIR-Vを生成する際に ``shared`` を使用するとコンパイルエラーとなる。

修飾子 ``packed`` は ``std140``, ``std430``, ``shared`` のみを上書きし、
その他の修飾子は継承される。
``packed`` を使用した場合、共有可能なレイアウトは保証されません。
コンパイラーとリンカーは、どの変数が活発的に使用されるかや、その他の条件に基づいて、
メモリー使用を最適化することができる。
ブロック内のどこにどの変数があるかを保証する方法が他にないため、
オフセットを問い合わせる必要がある。

プログラム内の複数の段階で同じ充満一様ブロックやシェーダー格納ブロックにアクセス
するとリンクエラー。
プログラム間で同じ充満一様ブロックやシェーダー格納ブロックにアクセスしようとすると、
メンバーオフセットが衝突したり、未定義の値が読み込まれたりする可能性がある。
しかし、実装では充満ブロックのための標準的なレイアウトを使用することで、
充満ブロックのアプリケーション管理を支援することができる。
SPIR-V の生成時に ``packed`` 修飾子を使用するとコンパイルエラー。

``std140`` および ``std430`` 修飾子は ``packed``, ``shared``, ``std140``,
``std430`` 修飾子のみを上書きし、その他の修飾子は継承される。
``std430`` 修飾子はシェーダー格納ブロックでのみ対処されている。
一様ブロックに ``std430`` 修飾子を使用したシェーダーは、
それが ``push_constant`` も修飾されていない限りコンパイルエラー。

OpenGL 仕様書の 7.6.2.2 "Standard Uniform Block Layout" に記載されているように、
レイアウトはこれによって明示的に決定される。
したがって、上記の ``shared`` と同様に、結果となるレイアウトはプログラムを
またがって共有可能だ。

メンバー宣言のレイアウト修飾子には ``shared``, ``packed``, ``std140``, ``std430``
の各修飾子は使用できない。これらの修飾子は、（オブジェクトなし）大域スコープ
またはブロック宣言でのみ使用でき、使用しない場合はコンパイルエラー。

``row_major`` および ``column_major`` 修飾子は、構造体や配列に含まれるすべての行列を含む
すべての入れ子の深さの行列のレイアウトにしか影響を与えない。
これらの修飾子は他の型にも適用できるが、効果はない。

``row_major`` 修飾子は ``column_major`` 修飾子のみを上書きし、
その他の修飾子は継承される。行列の行内の要素は、メモリー内で連続している。

``column_major`` 修飾子は ``row_major`` 修飾子よりも優先されるが、
その他の修飾子は継承される。行列の列内の要素は、メモリー内で連続しています。

``binding`` 修飾子は（一様｜シェーダ格納）ブロックに対応する一様バッファー束縛点を指定し、
ブロックのメンバー変数の値を取得するのに使用される。
大域スコープやブロックメンバーの宣言に束縛修飾子を指定することはコンパイルエラーとなる。
``binding`` 修飾子を指定せずに宣言された（一様｜シェーダー格納）ブロックは、
最初はブロック束縛点 0 に割り当てられる。プログラムがリンクされた後、
``binding`` 修飾子の有無にかかわらず宣言された（一様｜シェーダー格納）ブロックに
使用される束縛点は API によって更新することができる。

OpenGL で使用する場合、
``binding`` 修飾子が配列としてインスタンス化された一様ブロックやシェーダー格納
ブロックで使用されると、配列の最初の要素は指定されたブロック束縛を取り、
それ以降の各要素は次の連続した束縛点を取る。
配列の配列では、要素それぞれ（例えば ``a[2][3]`` の場合は 6 要素）が束縛点を得て、
:ref:`4.1.9. Arrays` で説明した配列の配列の順序に従って順序付けられる。

Vulkan を対象にした場合、配列としてインスタンス化された一様ブロックやバッファー
ブロックで ``binding`` 修飾子が使用されると、
配列全体が提供された束縛番号のみを受け取る。
次の連続した束縛番号を別のオブジェクトで利用できる。
配列の配列の場合、記述子集合アクセスに使用される記述子集合配列要素の番号は、
:ref:`4.1.9. Arrays` で説明した配列の配列の順序に従って順序付けられる。

（一様｜シェーダー格納）ブロックインスタンスの束縛点がゼロより小さい場合、
または対応する実装依存のバッファー束縛の最大数以上の場合は、コンパイルエラーとなる。
（一様｜シェーダー格納）ブロックのインスタンスをサイズ N の配列として ``binding``
修飾子を使用する場合、
*binding* から *binding* + N - 1 までの配列のすべての要素は、この範囲内に
収まらなければならない。
同じ束縛番号を複数の一様ブロックや複数のバッファーブロックに使用すると
コンパイルエラーまたはリンクエラーとなる。

修飾子 ``set`` は Vulkan を対象にしている場合に限り使用できる。
このオブジェクトが属する記述子集合を指定する。
独立した修飾子、ブロックメンバー、または記述子集合を対処する API を対象に
していない場合に ``set`` を適用するとコンパイルエラー。
``push_constant`` 修飾されたブロックに ``set`` を適用するとコンパイルエラー。
既定では ``set`` 識別子なしで宣言された非 ``push-constant``
（一様｜シェーダー格納）ブロックは、記述子集合 0 に割り当てられる。同様に、
``set`` 識別子なしで一様として宣言された採取器、テクスチャー、またはサブパス入力型も、
記述子集合 0 に割り当てられる。

配列として宣言されたオブジェクトに適用された場合、その配列のすべての要素は、
指定された ``set`` に属する。

SPIR-V を生成する際に ``set`` または ``binding`` の値がフロントエンド構成で
指定された最大値を超えるとコンパイルエラーとなる。

一つのレイアウト宣言に複数の引数がリストされている場合、左から右の順に一つずつ
宣言されたのと同じ効果が得られる。それぞれが前の修飾の結果を引き継いで上書きする。
例えば、次の例は ``column_major`` 修飾になる：

.. code:: glsl

   layout(row_major, column_major)

さらなる例：

.. code:: glsl

   layout(shared, row_major) uniform; // default is now shared and row_major

   layout(std140) uniform Transform { // layout of this block is std140
       mat4 M1;                       // row major
       layout(column_major) mat4 M2;  // column major
       mat3 N1;                       // row major
   };

   uniform T2 {                       // layout of this block is shared
       ...
   };

   layout(column_major) uniform T3 {  // shared and column major
       mat4 M3;                       // column major
       layout(row_major) mat4 m4;     // row major
       mat3 N2;                       // column major
   };

----

Vulkan を対象にしている場合、ブロックおよびブロックメンバーの
``offset`` および ``align`` 修飾子は、一様ブロックおよびバッファーブロックに限り使用できる。
Vulkan を対象にしていない場合、これらの修飾子は ``std140`` または ``std430``
レイアウトで宣言されたブロックに限り使用できる。

修飾子 ``offset`` はブロックメンバーに限り使用できる。
修飾子 ``offset`` は、修飾されたメンバーを指定された *layout-qualifier-value*
（バッファーの先頭からのバイトオフセット）以降に強制的に開始させる。
ブロックの他のメンバー内にあるオフセットを明示的または代入的に持たせると
コンパイルエラーとなる。
SPIR-V を生成しない場合、ブロック内の直前のメンバーのオフセットよりも小さい
オフセットを指定するとコンパイルエラーとなる。
同じプログラム内で同じブロック名でリンクされた二つのブロックは、
``offset`` で修飾されたメンバーの集合が全く同じであり、
それらの *layout-qualifier-value* の値が同じでなければならず、
そうでなければリンクエラーとなる。
指定されたオフセットは、それが修飾するブロックメンバーの型の
base alignment の倍数でなければならず、そうでなければコンパイルエラーになる。

----

修飾子 ``align`` は、各ブロックメンバーの開始点を最小の byte alignment にする。
各メンバー内の内部レイアウトには影響を与えず、
``std140`` または ``std430`` の規則に従う。
指定された alignment は 0 よりも大きく、かつ 2 のべき乗でなければならず、
そうでない場合はコンパイルエラー。

メンバーの実際の alignment は、指定された ``align`` alignmentと、
そのメンバーの型の標準（``std140`` など）base alignment のうち大きい方になる。
メンバーの実際のオフセットは次のように計算される：
``offset`` が宣言されている場合は、そのオフセットから開始し、
そうでない場合は、宣言順で先行メンバーの直後のオフセットから開始する。
結果オフセットが実際の alignment の倍数でない場合は、
実際の alignment の倍数である最初のオフセットまで増やす。
これにより、メンバーの実際のオフセットが得られる。

``align`` が配列に適用された場合、配列の開始点のみに影響し、
配列の内部幅には影響しない。
宣言では ``offset`` 修飾子と ``align`` 修飾子の両方を指定できる。

修飾子 ``align`` は、ブロックで使用された場合、ブロックで宣言されたのと同じ
``align`` 値で各メンバーを修飾するのと同じ効果があり、
これが行われた場合と同じコンパイル結果とコンパイルエラーが得られる。
前述のように、個々のメンバーは独自の ``align`` を指定することができ、
それはブロックレベルの ``align`` よりも優先されるが、そのメンバーに限られる。

例：

.. code:: glsl

   layout(std140) uniform block {
       vec4 a;                         // a takes offsets 0-15
       layout(offset = 32) vec3 b;     // b takes offsets 32-43
       layout(offset = 40) vec2 c;     // ERROR, lies within previous member
       layout(offset = 48) vec2 d;     // d takes offsets 48-55
       layout(align = 16) float e;     // e takes offsets 64-67
       layout(align = 2) double f;     // f takes offsets 72-79
       layout(align = 6) double g;     // ERROR, 6 is not a power of 2
       layout(offset = 80) float h;    // h takes offsets 80-83
       layout(align = 64) dvec3 i;     // i takes offsets 128-151
       layout(offset = 164, align = 8)
       float j;                        // j takes offsets 168-171
   };

4.4.6. Opaque Uniform Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

不透明な一様変数は、結合のために一様レイアウト修飾子を取ることができます。

| *layout-qualifier-id* :
|     ``binding`` = *layout-qualifier-value*

``binding`` 修飾子は、その変数が束縛される点を指定する。
``binding`` 修飾子なしで宣言された不透明変数は、既定束縛 0 になる。

OpenGL で使用する場合、
``binding`` 修飾子が配列とともに使用されると、配列の最初の要素は指定された束縛点を取り、
それ以降の各要素は連続した次の束縛点を取る。
配列の配列の場合は先程の ``a[2][3]`` の例を述べた文と同じ。

Vulkan を対象にした場合、配列で ``binding`` 修飾子が使用されると、
提供された束縛番号だけを配列全体が取る。次の連続した束縛番号は、別のオブジェクト
に利用できる。

``binding`` が 0 より小さい場合、または実装依存の対処される束縛点の最大数以上の場合は、
コンパイルエラーとなる。
サイズ N の配列で ``binding`` 修飾子を使う場合、
番号 *binding* から番号 *binding* + N - 1 までの配列のすべての要素は、
この範囲内に収まる必要がある。
同じ番号 *binding* を共有する不可分計数器のオフセットがすべて異なっていない限り、
複数の不可分計数器に同じ束縛番号を使用すると、コンパイルエラーまたはリンクエラーとなる。

一つのプログラム内のシェーダー二つが同じ *opaque-uniform* 名に対して異なる
*layout-qualifier-value* 束縛を指定するとリンクエラーとなる。
ただし、次の例のように、同じ名前の宣言の一部に ``binding`` を指定しても、
すべての宣言に ``binding`` を指定してもエラーではない：

.. code:: glsl

   // in one shader...
   layout(binding=3) uniform sampler2D s; // s bound to point 3

   // in another shader...
   uniform sampler2D s;                   // okay, s still bound at 3

   // in another shader...
   layout(binding=4) uniform sampler2D s; // ERROR: contradictory bindings

4.4.7. Atomic Counter Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vulkan を対象にした場合、不可分計数器は使用できない。

不可分計数器のレイアウト修飾子は、その宣言で使用できる：

| *layout-qualifier-id* :
|     ``binding`` = *layout-qualifier-value*
|     ``offset`` = *layout-qualifier-value*

例えば下は、不可分計数器 ``a`` の不透明ハンドルを、不可分計数器バッファーの
束縛点 2 に、そのバッファーの 4 基本マシン単位のオフセットで束縛するように設定する。
束縛点 2 の既定オフセットは 4（不可分計数器のサイズ）で後置インクリメントされる：

.. code:: glsl

   layout(binding = 2, offset = 4) uniform atomic_uint a;

後続の不可分計数器宣言は、直前の（インクリメントされた）オフセットを継承する。
例えば次の宣言では、不可分計数器 ``bar`` がバッファーの束縛点 2 に 8
基本マシン単位のオフセットで束縛されるように設定する。
結合点 2 のオフセットは、再び 4 だけ後置インクリメントされる：

.. code:: glsl

   layout(binding = 2) uniform atomic_uint bar;

一つのレイアウト宣言に複数の変数がリストされている場合、左から右の順に一つずつ
宣言したのと同じ効果が得られる。

束縛点は継承されず、オフセットのみが継承される。
各束縛点では、同じ束縛を使用する後続の変数の継承のために、それ自身の現在の既定
オフセットを追跡する。
コンパイルの初期状態では、すべての束縛点のオフセットが 0 になる。
オフセットは、大域スコープで（変数を宣言せずに）束縛点ごとに設定できる。
例えば、以下のようになる：

.. code:: glsl

   layout(binding = 2, offset = 4) uniform atomic_uint;

上記は結合点 2 に対する次の ``atomic_uint`` 宣言がオフセット 4 を継承するように設定する
（ただし、既定束縛は設定しない）。

.. code:: glsl

   layout(binding = 2) uniform atomic_uint bar; // offset is 4
   layout(offset = 8) uniform atomic_uint bar;  // error, no default binding

不可分計数器は同じ束縛点を共有することができるが、
束縛が共有されている場合、それらのオフセットは、明示的または暗黙的に一意的であり、
重なり合わないことが必要だ。

シェーダーの先頭を想定した、有効な一様宣言の例：

.. code:: glsl

   layout(binding=3, offset=4) uniform atomic_uint a; // offset = 4
   layout(binding=2) uniform atomic_uint b;           // offset = 0
   layout(binding=3) uniform atomic_uint c;           // offset = 8
   layout(binding=2) uniform atomic_uint d;           // offset = 4

無効な一様宣言の例：

.. code:: glsl

   layout(offset=4) ...               // error, must include binding
   layout(binding=1, offset=0) ... a; // okay
   layout(binding=2, offset=0) ... b; // okay
   layout(binding=1, offset=0) ... c; // error, offsets must not be shared
                                      // between a and c
   layout(binding=1, offset=2) ... d; // error, overlaps offset 0 of a

``gl_MaxAtomicCounterBindings`` 以上の束縛値で不可分計数器を束縛すると
コンパイルエラーになる。
サイズなし ``atomic_uint`` の配列を宣言するとコンパイルエラー。

4.4.8. Format Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

フォーマットレイアウト修飾子は、画像変数の宣言（キーワードに ``"image"`` を持つ
基本型で宣言されたもの）に使用できる。画像変数宣言のためのフォーマットレイアウト
修飾子の識別子は次のとおり（一部略）：

| *layout-qualifier-id* :
|     *float-image-format-qualifier*
|     *int-image-format-qualifier*
|     *uint-image-format-qualifier*
|     ``binding`` = *layout-qualifier-value*
|
| *float-image-format-qualifier* :
|     ``rgba32f``
|     ``rgba16f``
|     (etc.)
|
| *int-image-format-qualifier* :
|     ``rgba32i``
|     (etc.)
|
| *uint-image-format-qualifier* :
|     ``rgba32ui``
|     (etc.)

``format`` レイアウト修飾子は、宣言された画像変数に関連する画像表現形式を指定する。
画像変数宣言一個につき、フォーマット修飾子を一つだけ指定できる。
浮動小数点成分型（ ``"image"`` で始まるキーワード）、
符号付き整数成分型（ ``"iimage"`` で始まるキーワード）、
または符号なし整数成分型（ ``"uimage"`` で始まるキーワード）の画像変数では、
使用するフォーマット修飾子は、それぞれ
*float-image-format-qualifier*,
*int-image-format-qualifier*, *uint-image-format-qualifier*
文法規則に一致しなければならない。
フォーマット修飾子が画像変数の型と一致しない画像変数を宣言するとコンパイルエラーとなる。

画像読み込みや不可分操作に使用される画像変数は、フォーマットレイアウト修飾子を
指定しなければならない。
フォーマットレイアウト修飾子なしで宣言された画像一様変数や関数引数を画像読み込みや
不可分関数に渡すとコンパイルエラーとなる。

``writeonly`` で修飾されていない一様（変数）はフォーマットレイアウト修飾子を持たなければならない。
読み込みアクセスのために関数に渡された画像変数を ``writeonly`` として宣言することはできないので、
フォーマットレイアウト修飾子を付けて宣言しなければならないことに注意を要する。

修飾子 ``binding`` については
:ref:`4.4.6. Opaque Uniform Layout Qualifiers` に記述がある。

4.4.9. Subpass Input Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

サブパス入力は Vulkan を対象にしている場合に限り利用可能だ。

サブパス入力は、基本 ``subpassInput`` 型で宣言される。
これらはレイアウト修飾子 ``input_attachment_index`` を付けて宣言しないとコンパイルエラー。
例えば：

.. code:: glsl

   layout(input_attachment_index = 2) uniform subpassInput t;

これはどのサブパスから入力が読み込まれるかを選択する。
``input_attachment_index`` に割り当てられた値、たとえば i とする
(``input_attachment_index = i``) と、パスの入力リストの中のその i 番目の登場
を選択する。

サイズ N の配列が宣言されている場合は、提供されたものから始まる N 個の連続した
``input_attachment_index`` 値を消費する。

同じ ``input_attachment_index`` を異なる変数に宣言すると、コンパイルエラーまたは
リンクエラーとなる。
これには、配列宣言で消費される暗黙の ``input_attachment_index`` の重複も含まれる。

``input_attachment_index`` に割り当てられた値が ``gl_MaxInputAttachments``
以上の場合、コンパイルエラーとなる。
