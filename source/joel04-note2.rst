======================================================================
Joel on Software 読書ノート 2/3?
======================================================================

:doc:`joel04-note1` から続く

:著者: Joel Spolsky
:訳者: 青木靖
:出版社: オーム社
:ISBN: ISBN4-274-06630-4

.. contents:: ノート目次

第 20 章
======================================================================

採用試験の流儀みたいなものを書いているようだ。

* <ずさんな履歴書はずさんな作業習慣を反映している> (p. 172)
* <もっと重要なのは、その人が選別されていることを示すものを探すということだ> (p. 172)

  過去に厳しい選別プロセスを潜り抜けているということなので、優秀な人材である蓋然性が高いということだな。

* <どっちつかずのものはすべて機械的に「ノー」に変換して差し支えない> (p. 174)

* <自由回答式の質問と問題を与える> (p. 177)

* いわゆるムチャぶりな質問を投げかけてみる。
  質のよくない志望者の反応は明らかにそれとわかるらしい。
  <間抜けのように座って救いを待つばかりで、
  あなたは彼らをずっと引っ張っていかなければならないだろう。
  そういうのは問題解決ができる人ではない> (p. 181)

* 著者は <C のポインタを理解しているというのは、
  スキルではなく素質である> (p. 182) と言い切っている。
  これは同意できる。少なくともスキルではないという主張は正しい。

* <違法な質問を避けること> (p. 185) で挙げられている例は、日本ではまずないケース。
  ちなみにこの本によくイスラエルの話題が出てくるのは、著者がイスラエル経験豊富だから。

第 21 章
======================================================================

インセンティブの話題。勤務評定はクソだという主張。

* Ship It Award はとても嫌われている。
* <実は、人間はポジティブな評価をされた場合でも、
  それが本人の思っていたほどにポジティブでなかった場合には士気にマイナスの影響があるのだ> (p. 189)
* <プラスの評価は士気や生産性に何の影響も与えない> (p. 189)

第 22 章
======================================================================

テスターを積極的に活用するべしという議論。

* ``procmail`` のインターフェイスはコテコテの Unix ファンでさえわかりにくい。(p. 191)
* <プログラマ 2 人につき 1 人のテスタが必要になるだろう> (p. 192)

* テスタを雇う金銭的な余裕がないという言い訳を次のように論破？している。

  <あなたがテスタを雇わないなら、あなたはプログラマにテストをさせることになる。
  そして、あなたがテスタを量産するのがまずいと思うなら、
  その前に、10 万ドル/年のスタープログラマを入れ替えるのがいかに高くつくか考えてみることだ> (p. 197)

  悲しいことにクズプログラマだけの職場では通じない。

第 23 章
======================================================================

人間マルチプロセッサ思考実験。

* 現実の CPU では、タスク切り替えには少し時間がかかるが、
  現実的にはほとんど無視できる。(p. 200)

* シーケンシャル処理は平均での処理終了時間がより早いというだけ。
* タスク切り替えの時間は短ければ短いほどよい。

* <人々に同時に 1 つより多くの作業をさせるべきではない> (p. 202)

第 24 章
======================================================================

<新しいコードが古いコードよりも優れているというのは、明らかに不合理だ。
古いコードは使われている。
古いコードはテストされている。
多くのバグが見つかり、修正されている。
それについて悪いことは何もない> (pp. 204-205)

第 25 章
======================================================================

* <「投機的」ソフトウェア> (p. 209)
* <もし可能なら、まだ出来ていない部分の
  UI はまだ出来ていないように見えるように作ることだ> (p. 215)

  この章のキモはこのフレーズに見事に集約されている。

第 26 章
======================================================================

* コンピューターサイエンティストたちの言う **抽象化** とは、
  <中の方ではずっと複雑なことが行われている何かを単純化するということだ> (p. 218)

* 著者曰く、抽象化は必ず「漏れ」がある。
  その例をたくさん挙げていく。
  
  * 二次元配列の要素の辿り方によってパフォーマンスが変わる。
  * SQL の WHERE 句で ``a=b and b=c and a=c`` が ``a=c`` を省いたものよりも劇的に早い。
  * 以前議論したように、リモートファイルとローカルファイルの差。
  * C++ の ``string`` クラス。組み込み型にすればよかったのにと言い切っている。
  * 自動車に装備するワイパー、ヘッドライト、屋根、ヒーター。
    雨と晴れの差を抽象化するためのものだが、カバーしきれていない。

* 高度化した開発環境が熟練プログラマになるのを難しくする。(p. 222)

第 27 章
======================================================================

* <あなたが日常使うことの 90% は 1 週間で学習できるが、
  残りの 10% を知るためには 2, 3 年かかるかもしれない> (p. 226)

* <私の Windows プログラミングのスキルは、基本的な技術だけでなく、
  それを支えるインフラ全体を知っていることから来ている> (p. 227)

* <あなたは、基本的なプログラミング──
  たとえば高度な C++ のスキル──
  が 90% を占め、API は取るに足らない 10% の部分であり、
  2, 3 週間あればキャッチアップできると思っているかもしれない。
  そういう人たちに恐れながら言わせていただくと、
  時代は変わってしまったのだ。今では比率は逆になっている> (p. 228)

* <1 つの世界しか知らない人というのは、太鼓持ちみたい> (p. 229)

* <お手軽に一般化された議論> (p. 230)

第 28 章
======================================================================

* 本書パート 2 の最後を締めくくる 2 ページからなる短い章。
* 測定機能障害
