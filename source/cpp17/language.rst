======================================================================
What's New In C++17 言語仕様
======================================================================

このノートでは C++17 で注目すべき言語仕様を学習する。
すでに cpprefjp_ がそのへんをきれいに整理している。
それを利用して、読みながら急所を記していくことにする。

タイピングの都合で訳語は cpprefjp_ のものと一部変更して記す。

.. contents::

.. include:: /_include/cpp-refs.txt

変数・データ構造関係
======================================================================

.. | [十六進浮動小数点数リテラル](cpp17/hexadecimal_floating_literals.md) | 十六進数表記で浮動小数点数リテラルを記述できるようにする |
.. | [インライン変数](cpp17/inline_variables.md) | `inline`指定をすることで翻訳単位を跨いでひとつのオブジェクトになる変数を定義する |
.. | [構造化束縛](cpp17/structured_bindings.md) | 組・タプル・配列を展開して変数定義する |
.. | [波括弧初期化の型推論の新規則](cpp17/new_rules_for_auto_deduction_from_braced-init-list.md) | 波括弧初期化子が単一要素の場合は `T` に推論，複数要素の場合は不適格 |
.. | [`[[maybe_unused]]`属性](cpp17/maybe_unused.md)       | 使用しない可能性のある変数に対する警告を抑制する |
.. | [`[[nodiscard]]`属性](cpp17/nodiscard.md)             | 戻り値を捨ててはならないことを指定する |
.. | [値のコピー省略を保証](cpp17/guaranteed_copy_elision.md) | 右辺値を変数の初期化のために使用する場合、コピーもムーブも省略することを保証 |
.. | [厳密な式の評価順](cpp17/expression_evaluation_order.md) | 式の評価順を規定する |
.. | [参照メンバをもつクラスの置き換え](cpp17/replacement_of_class_objects_containing_reference_members.md) | 参照型メンバや`const`データメンバを含むクラスについてこれまで結果は未定義とされていた配置`new`によるオブジェクトの置き換えを条件付きで可能とする |
.. | [`enum class`変数の初期値として整数を指定する際の規則を調整](cpp17/construction_enum_class_values.md) | キャストを使用することなく整数を初期値として使用し、`E e{0};`のような初期化を許可 |
.. | [アライメント指定されたデータの動的メモリ確保](cpp17/dynamic_memory_allocation_for_over-aligned_data.md) | `operator new`と`operator delete`でアライメント値を取得できるようにする |
.. | [集成体初期化の拡張](cpp17/extension_to_aggregate_initialization.md) | 集成体初期化で基底クラスも入れ子に集成体初期化可能になる |

制御構文
======================================================================

`if` 文と `switch` 文の括弧の中で変数の初期化が許される
----------------------------------------------------------------------

Python で言うところの ``:=`` のような役割を果たすのだろうか？
セミコロンを使うことになるので、書く手間は Python と同じ程度？

.. code:: c++

   if(size_t n = v.size(); n < 10){
       // ...
   }

   // 初期化コードは optional
   switch(; size_t n = v.size()){
   case 0:
       // ...
   }

属性 ``[[fallthrough]]``
----------------------------------------------------------------------

``switch`` 文で ``case`` ラベルの処理が何かあり、その処理を ``break`` せずに
次の ``case`` ラベルの処理を敢えてさせたいとする。このときまともなコンパイラーは警告を出す。
それを抑止するために、コンパイラーが ``break`` を期待している行に
``[[fallthrough]]`` と書くことが許される。

これは使わないから覚えなくていい。

``if constexpr`` 文
----------------------------------------------------------------------

コンパイル時に ``if`` 文を評価させる構文だ。
構文は ``if`` と括弧の間にキーワード ``constexpr`` を挟むだけの単純なものだ。
使い方はふつうの ``constexpr`` と同程度に難しい。

.. code:: c++

   if constexpr (condition){
       statement;
   }

範囲 ``for`` ループにおける仕様変更
----------------------------------------------------------------------

対象となる範囲の ``begin()`` と ``end()`` の型が異なっていても OK となる。

.. code:: c++

   //auto first = range.begin(), last = range.end();
   auto first = range.begin();
   auto last = range.end();
   for(; first != last; ++first){
       statement;
   }

ラムダ式
======================================================================

* ラムダ式において、捕獲リストに ``*this`` を指定すると copy capture することになる。

  * オブジェクトをコピーした上で ``const`` になる。非 ``const`` メンバー関数を呼び出せない。
    それを避けるにはラムダ式を ``mutable`` にする。
    cpprefjp_ の例ではメンバー関数 ``void F::onFinish(int)`` が非 ``const`` であることに注意。

* ``constexpr`` ラムダ式。もしラムダ式が定数式であるような場合にコンパイル時に評価させる。

  * ラムダ式関連の機能の学習は後回しにして一気にやる。

テンプレート
======================================================================

.. | [畳み込み式](cpp17/folding_expressions.md)   | パラメータパックに対する二項演算の累積処理 |
.. | [テンプレートテンプレートパラメータに`typename`キーワードの使用を許可](cpp17/allow_typename_in_a_template_template_parameter.md) | `class`キーワードしか使用できなかった部分に、`typename`を許可する |
.. | [クラステンプレートのテンプレート引数推論](cpp17/type_deduction_for_class_templates.md) | コンストラクタの引数からクラスのテンプレート引数を推論できるようにする |
.. | [非型テンプレートパラメータの`auto`宣言](cpp17/declaring_non-type_template_arguments_with_auto.md)   | `template <auto x>`とすることで、`X<3>;` `X<true>;` `X<'a'>`のように定数を受け取りやすくする |
.. | [全ての非型テンプレート引数の定数式評価を許可](cpp17/allow_constant_evaluation_for_all_non-type_template_arguments.md) | ポインタの定数式評価として、配列からポインタへの変換や、関数から関数ポインタへの変換などを許可 |
.. | [`using`宣言のパック展開](cpp17/pack_expansions_in_using.md) | パラメータパックの型を基底クラスとして指定した場合に、using宣言に基底クラスのパラメータパックを指定できるようにする |
.. | [変数テンプレートのデフォルトテンプレート引数を許可](cpp17/allow_default_template_arguments_of_variable_templates.md) | 変数テンプレートのテンプレートパラメータがデフォルト引数を持つことを許可する |

定数式
======================================================================

* ``static_assert()`` の第二引数の省略が許される。元ネタの ``assert()`` に引数が一つしかないのだから考えられる。
* 先述したように ``constexpr`` ラムダ式が使えるようになる。
* 先述したように ``if constexpr`` 文が使えるようになる。

名前空間
======================================================================

* ダブルコロンを連結した名前を書くことでスコープを入れ子にすることなく部分名前空間を定義することが許される。

  .. code:: c++

     namespace aaa::bbb::cc
     {
         // ...
     }

* 名前空間に対して属性を与えることが許される。

  .. code:: c++

     namespace [[deprecated]] aaa
     {
         // ...
     }

* ``using`` ディレクティブでパック展開が許される。

  一つ目は次のように ``using`` 宣言の行にカンマ区切りで識別子を並べる使い方。

  .. code:: c++

     using std::cout, std::endl;

  もう一つは次 cpprefjp_ より引用した例のように基底クラスのメンバーをまとめてパック展開する使い方が許される。

  .. code:: c++

     #include <iostream>

     struct ForLong {
         void operator()(long v) {
             std::cout << "ForLong:" << v << std::endl;
         }
     };

     struct ForString {
         void operator()(const std::string& v) {
             std::cout << "ForString:" << v << std::endl;
         }
     };

     template <typename... T>
     struct ForAll : T... {
         using T::operator()...;
         void operator()(int v) {
             std::cout << "ForAll:" << v << std::endl;
         }
     };

例外
======================================================================

* 関数の型に例外仕様が含まれるようになった。

  * ここで言う例外仕様とは ``noexcept()`` によるものしか差さない。旧式の ``throw()`` はもう忘れろ。
  * ``noexcept(false)`` な関数ポインターを ``noexcept(true)`` な関数ポインターにキャストすることは許されない。
    端的に言うと、``noexcept`` の違いしかない関数を多重定義することは許されない。
  * ラムダ式の型においてもこの仕様が適用される。
  * この仕様変更により、C++14 まで適法だったコードが違法になることもある。

* 旧式の例外仕様削除。つまり ``throw(xxx)`` と書けなくなる。
  代わりに ``noexcept(bool)`` を利用することができる。例外を送出するか否かが本質的なのだ。

属性
======================================================================

* 属性 ``[[fallthrough]]`` が追加。先述のとおり。
* 属性 ``[[maybe_unused]]`` が追加。コンパイラーの未使用変数の警告を抑止する。

  .. code:: c++

     [[maybe_unused]] int x = 0;
     [[maybe_unused]] void f();

     template <class T>
     [[maybe_unused]] inline void g();

* 属性 ``[[nodiscard]]`` が追加。関数の戻り値を呼び出し側が無視してはならないことを指示する。
  ユーザー定義型に与える方法と関数宣言に与える方法がある。

  .. code:: c++

     struct [[nodiscard]] error_info {};

     error_info f() { return error_info{}; }

     [[nodiscard]] int g() { return 0; }

* 名前空間に属性を与えることが許される。先述のとおり。
* 列挙型の列挙子に属性を与えることが許される。その場合には列挙子とカンマの間に属性を記す。
* 属性内の名前空間の指定をいちどにできる構文が追加。
  属性の先頭部分に ``using`` 名前空間 ``:`` の順に記述し、その後に続けて属性の名前を記述する。

  .. code:: c++

    // [[CC::opt(1), CC::debug]] void f(){} と同じ
    [[using CC: opt(1), debug]] void f(){}

* 標準が定義していない属性であり、コンパイラーにとっても不明な属性はコンパイラーは単に無視するものとする。

プリプロセッサ
======================================================================

``__has_include`` という関数型マクロが追加される。これはインクルードするファイルが存在するかを確認するのに用いられる。
従来は、欲しいヘッダーファイルに定義されている定数が定義されているか、のようなテストでその存在を確認していた。
今回追加のこのマクロにより、コンパイラー（プリプロセッサー）がヘッダーファイル自体の存在をテストすることができるようになる。

使わなそうだから習得しなくていいだろう。

削除
======================================================================

* トライグラフ削除。これは使わなかったはずなので気にしなくていい。
* キーワード ``register`` の削除。これが修飾する変数は文字通りレジスターに格納される
  という振る舞いだったはずだが、マニアックなライブラリー実装者くらいしか使うことはなかったのでは？
* 演算子 ``bool::operator++`` 前置後置どちらも削除。こんなオーバーロードがあったとは知らなかった。

  * cpprefjp_ に書いてあるテキストが面白い。

* 先述したように旧式の例外仕様は廃止。

小さな変更
======================================================================

* 定義済みマクロ

  * マクロ ``__cplusplus`` の値が ``201703L`` に更新。
  * マクロ ```__STDCPP_DEFAULT_NEW_ALIGNMENT__`` が追加。使わないので忘れていい。

* 機能テストマクロ。C++17 の機能がサポートされているかを判定するのに用いる。量が多いので割愛。
* 次の条件を満たす例外仕様のあるラムダ式から関数ポインターに変換する際に、変換後のものに同等の例外仕様を与えるものとする。

  * ラムダ式はキャプチャーを持たない。
  * ラムダ式は汎用ラムダ式ではない。

* UTF-8 文字リテラル（文字列ではなく文字）が許される。

  * ``u8'A'`` のような書き方をすればいい。
  * ただしコードポイントの範囲に制限がある。``char`` の表現できるサイズに収まらなければならない。

.. include:: /_include/cpp-refs.txt
