======================================================================
整数論
======================================================================
SymPy_ の整数論モジュールについて記す。

.. contents:: ノート目次

.. note::

   本文中のすべての IPython セッション中のサンプルコードで、
   以下のインポートおよび出力書式設定が済んでいるものとする。

   .. code-block:: python3

      init_printing(pretty_print=False)

素数
======================================================================
クラス ``Sieve``
----------------------------------------------------------------------
クラス ``Sieve`` は素数全体を表現する。または表現したい。
「エラトステネスのふるい」にちなんだクラス名は、
クラスの素数の管理方法をなんとなく示唆している。

* メソッド ``extend`` で、指定素数までの全ての素数をオブジェクトが保持するようにできる。
* メソッド ``extend_to_no`` で任意番目の素数までの以下同文。

ユーザーが自分でコンストラクター経由でオブジェクトを生成するのもよいが、
実は ``sympy`` スコープにオブジェクト ``sieve`` が存在している。
まずはこれを試すとよい。

* ``p in sieve`` で ``p`` が素数がどうかをテストできる。

  * テストまでにユーザーが ``sieve`` を大きくする必要はない。
    オブジェクト自身が必要に応じて ``extend(p)`` のようなことをする。

  * 運が悪いとメソッドが例外 ``MemoryError`` を送出する。

* ``sieve.primerange(a, b)`` で ``a`` 以上 ``b`` 未満のすべての素数を列挙するジェネレーターを生成する。
* ``sieve.search(n)`` が少しわかりづらい。
  ドキュメントによると ``i <= n < j`` なる素数列の添字 ``(i, j)`` を返すようだが、
  ``n`` が素数ならば ``(i, i)`` を返す。
  はて ``j`` は常に ``i`` または ``i + 1`` ではないのだろうか。

素数に関連する関数
----------------------------------------------------------------------
素数に関連する関数は主にモジュール ``sympy.ntheory.generate`` に定義されている。
憶測だが（コードを読めば直ちに判明するが）、
これらの関数の内部では上述のオブジェクト ``sieve`` を参照しているのではないだろうか。

関数 ``prime(i)``
  任意 ``i`` 番目の素数を得られる。

関数 ``primepi(n)``
  指定した数よりも小さい素数の個数を返す。
  引数が素数の場合はそれも含んで計上する。

  * 10 億を試したら ``MemoryError`` で失敗。
  * 関数 ``integrate`` の被積分関数として扱えない？

関数 ``nextprime(n, i=1)``, ``prevprime(n, i=1)``
  指定した数から大きい、または小さい ``i`` 番目の素数を返す。

  * キーワード引数 ``i`` に負の値を指定すると、直感に反する値が返る。
  * ``prevprime`` のほうは例外 ``ValueError`` を送出することがある。

関数 ``primorial``
  どう使おう。
  引数の意味をキーワード引数 ``nth`` で変えられることに注意。

次の素数に関連する関数はモジュール ``primetest`` に存在する。

関数 ``isprime(p)``
  指定した数が素数かどうかテストする。

  ただし、この関数が正確にテストするために ``p`` に上限があるようだ。

素因数分解と約数
======================================================================
モジュール ``sympy.ntheory.factor_`` には素因数分解や約数にまつわる関数がある。
本当は 10 個を軽く超える関数が提供されているのだが、
私が理解できるものだけをここに記す。

関数 ``factorint(n)``
  正の整数 ``n`` を素因数分解して、結果を通常は ``dict`` オブジェクトの形で返す。

  * 例えば ``factorint(2000)`` は ``{2:4, 5:3}`` を返す。キーが素因数、値が指数のペアの辞書。
  * キーワード引数がたくさんある。
  * 実装コードを見たらわけがわからない。

関数 ``primefactors(n)``
  因数のリストだけを返す。指数は捨てられる。

  内部で ``factorint`` を利用しており、キーワード引数 ``limit`` と ``verbose`` が引き継がれる。

関数 ``divisors(n, generator=False)``
  整数 ``n`` の約数を 1 から ``n`` までソートして ``list`` オブジェクトで返す。

  ただしキーワード引数で ``generator=True`` とするとき、動きが全く異なる。
  関数が約数を列挙するジェネレーターを返す。
  さらに yield する値の順番は関数のそれとは異なる。

関数 ``divisor_count(n, modulus=1)``
  整数 ``n`` の約数の個数を返す。

  実装は関数 ``factorint`` の返す各素因数の指数を利用している。

* 関数 ``udivisors``, ``udivisor_count`` というものもある。
* 関数 ``antidivisors``, ``antidivisor_count`` というものもある。

クラス ``totient``
  オイラーの totient 関数を計算するクラス。
  実装で関数 ``factorint`` の結果をフル活用している。

  * クラス ``Function`` のサブクラスなので、評価をするには ``totient(n)`` のようにする。

    .. code-block:: ipython

       In [1]: [totient(10 ** i) for i in range(10)]
       Out[1]: [1, 4, 40, 400, 4000, 40000, 400000, 4000000, 40000000, 400000000]

関数 ``digits(n, p=10)``
  任意整数 ``n`` を ``p`` 進数表現して、その各桁をリストする。
  戻り値は ``list`` オブジェクトだが、
  最初の要素は ``p`` そのものなので捨ててよい。

合同式
======================================================================
モジュール ``sympy.ntheory.modular`` は合同式に関係する機能を提供する。
使えそうなものをピックアップしていこう。

関数 ``crt(m, v, symmetric=False, check=True)``
  中国剰余定理に基づく問題を解くのに利用できる。
  例を示す。

  .. code-block:: ipython

     In [1]: crt([3, 5, 7], [2, 3, 2])
     Out[1]: (23, 105)

  23 + 105k を 3, 5, 7 でそれぞれ割ると余りが 2, 3, 2 になるという解が得られた。

  * キーワード引数 ``symmetric=True`` とすると、
    剰余が対称になるように、解が必要に応じて非負で得られる。

  * キーワード引数 ``check=False`` の使いどころが不明。

    .. code-block:: ipython

       In [1]: crt([6, 10], [1, 2], check=True)

       In [2]: crt([6, 10], [1, 2], check=False)
       Out[2]: (14, 60)

関数 ``solve_congruence(*remainder_modulus_pairs, **hint)``
  合同式を解くわけだが、前述の関数 ``crt`` と同様だと思う。
  ただし引数の順序が異なる。

  * ``solve_congruence((2, 3), (3, 5), (2, 7))``
  * ``solve_congruence(*zip((2, 3, 2), (3, 5, 7)))``
  * ``crt`` が ``solve_congruence`` を利用している。

二項係数と多項係数
======================================================================
モジュール ``sympy.ntheory.multinomial`` にある関数について記す。
モジュール名は多項係数だが、二項係数に特化した関数も存在する。

関数 ``binomial_coefficients(n)``
  パスカルの三角形の n 段目を ``dict`` で返す。

  辞書のキーは ``tuple`` オブジェクト ``(0, n)``, ``(1, n - 1)``, ... , ``(n, 0)`` である。
  分母に来る階乗ふたつの引数と覚えられる。
  辞書の値は、それぞれのキーに対応する二項係数を表す。

関数 ``binomial_coefficients_list(n)``
  パスカルの三角形の n 段目を全部得る。戻り値は ``list`` である。

  こちらは単に二項係数が一列に並んだものが得られる。

関数 ``multinomial_coefficients(m, n)``
  二項係数を得る関数 ``binomial_coefficients(n)`` の一般化版。

  二項係数は :math:`(a_1 + a_2) ^ n` の各項の係数だが、多項係数は
  :math:`(a_1 + a_2 + ... + a_k) ^ n` の各項の係数を表現する。

ジェネレーター ``multinomial_coefficients_iterator(m, n)``
  関数 ``multinomial_coefficients(m, n)`` のジェネレーター版。
  関数版よりも空間的にも時間的にも効率的であることが期待できる。

剰余
======================================================================
モジュール ``sympy.ntheory.residue_ntheory`` にある関数について記す。
ただしインポートは ``from sympy.ntheory import ...`` で可能。

関数 ``n_order(a, n)``
  乗積順序を求める。
  ``a ** k % n == 1`` を満たす最小の整数 ``k`` を返す。
  これを <the order of ``a`` modulo ``n``> と英語では言うらしい。
  日本語なら「``a`` の法 ``n`` の位数」か。

  .. code-block:: ipython

     In [1]: n_order(10**100 + 1, prime(1000))
     Out[1]: 3959

     In [2]: Pow(Pow(10, 100), 3959) % prime(1000)
     Out[2]: 1

関数 ``is_primitive_root(a, p)``
  ``a`` が ``p`` の原始根であるかをテストする。

  意味としては ``a`` と ``p`` が互いに素であり、
  かつ ``p`` が ``a ** totient(p) % p == 1`` を満たす最小の ``p`` であるかどうかをテストする。
  言い換えると ``a`` の位数が ``p - 1`` であるかどうかをテストする。

関数 ``primitive_root(p)``
  存在するときに限り ``p`` の最小の原始根を返す。
  つまり ``p`` と互いに素で、かつ ``p`` を法とする整数の乗法群の生成元を求める。

  .. code-block:: ipython

     In [1]: primitive_root(27)
     Out[1]: 2

     In [2]: any([(2**i) % 27 for i in range(30)])
     Out[2]: True

     In [3]: n_order(primitive_root(27), 27) == totient(27)
     Out[3]: True

他にも色々あるので、アレがないかコレがないかというときはドキュメントを当たるべし。

連分数
======================================================================
モジュール ``sympy.ntheory.continued_fraction`` に置いてある、
連分数を扱う関数各種について記す。

ジェネレーター ``continued_fraction_iterator(x)``
  引数 ``x`` の連分数展開（分子は全部 1 とする）を求め、その分母をひとつずつ yield する。

  一度実装を見ておいたほうがよい。

  * これは微妙に使いにくい。
    値によっては自分でループを書く必要があるだろう。

    .. code-block:: ipython

       In [1]: from itertools import islice

       In [2]: list(islice(continued_fraction_iterator(coth(1)), 20))
       Out[2]: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]

       In [3]: list(islice(continued_fraction_iterator(S.Pi), 20))
       Out[3]: [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2]

ジェネレーター ``continued_fraction_convergents(cf)``
  連分数 ``cf`` の「真の値」に収束する数列の数をひとつずつ yield する。

  * ``cf`` は連分数の各項（分母）を ``list`` オブジェクト等に収容したもの。
  * ``cf`` の各項の分子が 1 であるという条件は特に課せられていない。

関数 ``continued_fraction_periodic(p, q, d=0)``
  整数係数二次方程式の根となる無理数の循環連分数展開を返す。
  単に ``(p + sqrt(d)) / q`` の連分数を返すと覚えておいて支障はない。

  * 戻り値は入れ子の ``list`` オブジェクトで、内側のそれが循環部分を示す。
  * 根号の中 ``d`` が平方数の場合は連分数は循環しない。
    戻り値はフラットな ``list`` オブジェクトとなる。

関数 ``continued_fraction_reduce(cf)``
  連分数 ``cf`` を連分数でない形で返す。

  .. code-block:: ipython

     In [1]: from sympy.abc import a, b, c

     In [2]: continued_fraction_reduce([a, b, c])
     Out[2]: (a + c*(a*b + 1))/(b*c + 1)

.. include:: /_include/python-refs-core.txt
.. include:: /_include/python-refs-sci.txt
