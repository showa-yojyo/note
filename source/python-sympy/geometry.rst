======================================================================
Geometry
======================================================================
SymPy_ のサブパッケージ ``sympy.geometry`` に関わる覚え書きを記す。

.. contents:: ノート目次

主要クラス図
======================================================================
サブパッケージ ``sympy.geometry`` が提供する主要クラスの継承関係のみを図示するとこういう感じになる。

.. code-block:: text

   GeometryEntity
       Point
       Point3D
       LinearEntity
           Segment
           Ray
           Line
       LinearEntity3D
           Line3D
           Ray3D
           Segment3D
       Plane
       Polygon
           Triangle
           RegularPolygon
       Ellipse
           Circle
       Curve

* クラス ``GeometryEntity`` のスーパークラスはクラス ``Basic`` である。

クラス継承関係
======================================================================
* 基本的に 2 次元幾何。同じ幾何要素で次元が異なるものはクラスも別々に定義がある。
  例えば ``Point`` と ``Point3D`` が存在する。

  * ここにあるあらゆるメソッド、関数は 2D と 3D を混ぜて利用することを想定していない。

* ``RegularPolygon`` is-a ``Polygon`` だったり ``Circle`` is-a ``Ellipse`` だったりする。
  オブジェクト指向プログラミングの本からするとこういう設計はするなと言われそうだが、
  SymPy は記号数学のライブラリーなのでむしろアリということだろう。

共通機能
======================================================================
ここでは便宜上、次のものを共通機能と呼んで理解を深める。

#. クラス ``GeometryEntity`` のオブジェクトを引数に取る関数
#. クラス ``GeometryEntity`` の静的・クラスメソッド
#. クラス ``GeometryEntity`` のメソッド

クラス ``GeometryEntity`` のオブジェクトを引数に取る関数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* 関数 ``intersection``

  * 引数は複数個の ``GeometryEntity`` オブジェクト。
  * 戻り値は ``list`` で、その要素は ``Point`` や ``Segment`` になるのだろう。

* 関数 ``convex_hull``

  * 複数個の ``Point``, ``Segment``, ``Polygon`` オブジェクトを引数に取る。
  * 戻り値は基本的には凸包を表現する ``Polygon`` オブジェクトだが、
    場合によっては ``Segment`` かもしれない。

* 関数 ``are_coplanar``

  * 引数は複数個の ``GeometryEntity`` オブジェクト。
  * 引数のすべての 3D オブジェクト全部がある平面上に乗っているかどうかをテストする。
  * そのような平面が ``Plane`` オブジェクトとして返るわけではないようだ？
  * 2D のオブジェクトは一応 3D 化してから計算してくれる。計算するまでもないだろう。

* 関数 ``are_similar``

  * ふたつの ``GeometryEntity`` オブジェクトが相似かどうかをテストする。
  * 単に ``entity1.is_similar(entity2)`` よりも気が利いた処理をするに過ぎない。

* 関数 ``centroid``

  * 引数は複数個の ``GeometryEntity`` オブジェクト。
  * おそらく同型でなければならない。
  * 戻り値は ``Point`` オブジェクトで、オブジェクト全部が決定する重心の座標を表現する。

クラス ``GeometryEntity`` の静的・クラスメソッド
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
クラス ``GeometryEntity`` の静的・クラスメソッドは存在しない。

クラス ``GeometryEntity`` のメソッド
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* メソッド ``intersection`` は先述の同名関数を参照。
* メソッド ``is_similar`` は先述の関数 ``are_similar`` を参照。
* 変形系メソッド ``rotate``, ``scale``, ``translate``, ``reflect`` が提供されている。

  * ``rotate``, ``scale`` は変形の原点を指定できる。
  * ``reflect`` には ``LinearEntity`` オブジェクトを渡すようだ。

* メソッド ``encloses``

  * 自身のオブジェクトの内側に与えられたオブジェクト全体を含むかどうかをテストする。
  * 実装にはサブクラスのメソッド ``encloses_point`` を利用している。
  * 造りが美しくない。

* メソッド ``equals`` が提供されており、オーバーライドがなければ ``e1 == e2`` と同値。
* 演算子がいくつか定義されているが、これらの存在はひとまず忘れておく。

.. todo::

   * プロットは実現したい。
   * パップスの定理以外にも何かサンプルを作りたい。

.. include:: /_include/python-refs-core.txt
.. include:: /_include/python-refs-sci.txt
