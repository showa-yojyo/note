======================================================================
組合せ論と群論
======================================================================
モジュール ``sympy.combinatorics`` を見ていく。
群論に関係する機能が中心のようだ。

.. contents:: ノート目次

.. note::

   インポート文は次のものを利用した。

   .. code-block:: python3

      from sympy.combinatorics import *

置換
======================================================================
モジュール ``sympy.combinatorics.permutations`` に群論オブジェクトのための重要な構成要素がある。
クラス ``Cycle`` と ``Permutation`` がそれで、
後で見る各種有限群オブジェクトの基礎となるデータ型を表現する。
SymPy_ のドキュメントでは先に ``Permutation`` を説明しているが、
私は ``Cycle`` を先に理解するのがよいと思うので、
ここではそのようにノートを記す。

クラス ``Cycle``
----------------------------------------------------------------------
巡回置換を表現する。基本的な構成要素なので少々細かく見てきたい。

* 要素は自然数で表現する。0 から始まる。

  * したがって、恒等置換を生成するには ``Cycle(0)`` とする。位数 1 の巡回が生成する。

* 例を挙げる。``Cycle(0, 3, 7)`` は次のような巡回置換を表現する。

  * 0 → 3
  * 3 → 7
  * 7 → 0
  * 1, 2, 4, 5, 6 は固定点。

* IPython 等の Python シェルでオブジェクトをダンプする際には

  * ``c.list()`` のようにして確認できる。
  * または明示的に Python 組み込み関数 ``print`` を用いる。

* 巡回置換を合成するにはコンストラクター呼び出し直後にさらに括弧を付けて巡回置換を追加する。
  例を示す。

  .. code-block:: text

     In [7]: Cycle(0, 3, 7)(1, 2).list()
     Out[7]: [3, 2, 1, 7, 4, 5, 6, 0]

* このクラスは実は Python の ``dict`` をスーパークラスに持つだけなので、
  あまり SymPy のオブジェクトという感じがしない。

* 極端に大きい値を巡回させると ``MemoryError`` が送出される。
  例えば ``Cycle(1000000, 100)(10000, 1, 100000000)`` などとしないほうがよい。

クラス ``Permutation``
----------------------------------------------------------------------
置換を表現する。土台となる概念は上述の巡回置換なので、
要素周りの規則はそれに準じる。

ここではこのクラスの主要な機能を記す。

コンストラクター
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
コンストラクターの記法が複数ある。好きなものを使えるようにしておく。

.. code-block:: text

   In [23]: Permutation(2, 1)(0, 5, 6)
   Out[23]: Permutation(0, 5, 6)(1, 2)

   In [24]: Permutation([[2, 1], [0, 5, 6]])
   Out[24]: Permutation(0, 5, 6)(1, 2)

   In [25]: Permutation(2, 1) * Permutation(0, 5, 6)
   Out[25]: Permutation(0, 5, 6)(1, 2)

* 上のコンストラクターのみの場合では、与える巡回置換は互いに素である必要がある。

* キーワード引数 ``size`` が便利。
  要素数は多いが置換部分が少ない置換を生成するときにはこれだ。

  .. code-block:: text

     In [26]: Permutation([[44, 88],], size=100)
     Out[26]: Permutation(99)(44, 88)

* 位数 ``n`` の恒等置換群の生成法をひとつマスターしておく。
  一番楽なのは ``Permutation(size=n)`` だろう。

置換の合成・積
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
置換の合成の記法も複数あるので注意。
次のものはすべて ``i`` に対して同じ作用を示す。いずれもまず ``p`` を作用する。

* ``(p * q)(i)``
* ``q(p(i))``
* ``i^p^q``
* ``i^(p * q)``

オブジェクトの出力
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
``Permutation`` オブジェクトを出力する方法がいくつかある。

* ``array_form``: e.g. ``[5, 2, 1, 3, 4, 6, 0]``
* ``cyclic_form``: e.g. ``[[0, 5, 6], [1, 2]]``

デフォルトの出力パターンは ``Permutation.print_cyclic`` フラグで設定する。

置換による像を得る
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
オブジェクトの丸括弧演算子を用いる。

.. code-block:: text

   In [128]: p = Permutation(2, 1)(0, 5, 6)

   In [129]: p(0), p(1), p(2)
   Out[129]: (5, 2, 1)

同サイズの文字列・コレクションの像も同様に得られる。

.. code-block:: text

   In [130]: p('ABCDEFG')
   Out[130]: ['F', 'C', 'B', 'D', 'E', 'G', 'A']

   In [131]: p(symbols('a0:7'))
   Out[132]: [a5, a2, a1, a3, a4, a6, a0]

置換によって動く要素を求める
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
メソッド ``support()`` を用いる。

.. code-block:: text

   In [149]: Permutation(2, 1)(0, 5, 6).support()
   Out[149]: [0, 1, 2, 5, 6]

   In [150]: Permutation(0, 1, 2, 3).support()
   Out[150]: [0, 1, 2, 3]

   In [151]: Permutation(size=4).support()
   Out[151]: []

置換をランダムに生成する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ランダムな置換の生成にはクラスメソッド ``random(n)`` を用いる。
次数 ``n`` の対称群にある置換をランダムに一個返すと言えばよい？

.. code-block:: text

   In [153]: Permutation.random(10)
   Out[153]: Permutation(0, 5, 3, 4, 8)(1, 2, 9)(6, 7)

   In [154]: Permutation.random(10)
   Out[154]: Permutation(0, 4, 5, 8)(1, 2, 3, 6)(7, 9)

   In [155]: Permutation.random(10)
   Out[155]: Permutation(0, 7, 6, 8, 1, 9, 3, 2, 5, 4)

* どういう種類のランダムなのか Python だけが知っている。
* ちなみに ``random(0)`` と ``random(1)`` の結果は異なる。

置換のべき乗を求める
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
べき乗演算子 ``**`` を置換オブジェクトに適用することができる。
試しに適当な置換オブジェクトをその位数乗すると、恒等置換が得られることを見よう。

.. code-block:: text

   In [167]: p = Permutation(2, 1)(0, 5, 6); p
   Out[167]: Permutation(0, 5, 6)(1, 2)

   In [168]: p.order()
   Out[168]: 6

   In [169]: p ** 6
   Out[169]: Permutation(6)

逆置換を求める
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
逆置換オブジェクトを生成するにはべき乗演算子 ``**`` を援用する。
指数を -1 にすればよい。

.. code-block:: text

   In [160]: p = Permutation(2, 1)(0, 5, 6); p
   Out[160]: Permutation(0, 5, 6)(1, 2)

   In [161]: p ** -1
   Out[161]: Permutation(0, 6, 5)(1, 2)

   In [162]: p * (p**-1)
   Out[162]: Permutation(6)

置換の巡回表記を互換の積へ分解する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
メソッド ``transpositions()`` を用いることで、置換を互換の積として表現できる。
置換と同等のあみだくじの描き方がわかるということだ。

.. code-block:: text

   In [170]: p = Permutation(2, 1)(0, 5, 6); p
   Out[170]: Permutation(0, 5, 6)(1, 2)

   In [171]: p.transpositions()
   Out[171]: [(0, 6), (0, 5), (1, 2)]

と思ったら、両端の線を結ぶことになってしまった。

置換の符号、偶置換、奇置換判定
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
置換の符号を得るにはメソッド ``signature()`` を、
置換の偶置換、奇置換の判定にはプロパティー ``is_even``, ``is_odd`` をそれぞれ用いる。

先ほどの 3 つの互換の積で表せる ``p`` を再利用して動作を確認する。

.. code-block:: text

   In [173]: p.signature()
   Out[173]: -1

   In [174]: p.is_even
   Out[174]: False

   In [175]: p.is_odd
   Out[175]: True

群オブジェクトジェネレーター
======================================================================
モジュール ``sympy.combinatorics.generators`` にあるジェネレーターおよび関数は、
よく使われる群を参照するのに便利だ。下に示す表はこのモジュールが提供する機能だ。

いずれも対応する群の元を ``Permutation`` オブジェクトとして生成する。

============================== ======================================================================
ジェネレーターまたは関数       機能
============================== ======================================================================
``alternating(n)``             ``n`` 次の交代群を列挙する。
``cyclic(n)``                  ``n`` 次の巡回群を列挙する。
``dihedral(n)``                ``2 * n`` 次の二面体群を列挙する。
``rubik(n)``                   ``n * n`` 次のルービックキューブ群を生成する。
``rubik_cube_generators()``    普通のルービックキューブ群を生成する。
``symmetric(n)``               ``n`` 次の対称群を列挙する。
============================== ======================================================================

ジェネレーターの動きを見よう。

.. code-block:: text

   In [180]: for i in symmetric(4): print(i.cyclic_form)
   []
   [[2, 3]]
   [[1, 2]]
   [[1, 2, 3]]
   [[1, 3, 2]]
   [[1, 3]]
   [[0, 1]]
   [[0, 1], [2, 3]]
   [[0, 1, 2]]
   [[0, 1, 2, 3]]
   [[0, 1, 3, 2]]
   [[0, 1, 3]]
   [[0, 2, 1]]
   [[0, 2, 3, 1]]
   [[0, 2]]
   [[0, 2, 3]]
   [[0, 2], [1, 3]]
   [[0, 2, 1, 3]]
   [[0, 3, 2, 1]]
   [[0, 3, 1]]
   [[0, 3, 2]]
   [[0, 3]]
   [[0, 3, 1, 2]]
   [[0, 3], [1, 2]]

   In [181]: for i in dihedral(4): print(i.cyclic_form)
   []
   [[0, 3], [1, 2]]
   [[0, 1, 2, 3]]
   [[1, 3]]
   [[0, 2], [1, 3]]
   [[0, 1], [2, 3]]
   [[0, 3, 2, 1]]
   [[0, 2]]

   In [182]: for i in alternating(4): print(i.cyclic_form)
   []
   [[1, 2, 3]]
   [[1, 3, 2]]
   [[0, 1], [2, 3]]
   [[0, 1, 2]]
   [[0, 1, 3]]
   [[0, 2, 1]]
   [[0, 2, 3]]
   [[0, 2], [1, 3]]
   [[0, 3, 1]]
   [[0, 3, 2]]
   [[0, 3], [1, 2]]

   In [183]: for i in cyclic(4): print(i.cyclic_form)
   []
   [[0, 1, 2, 3]]
   [[0, 2], [1, 3]]
   [[0, 3, 2, 1]]

ルービックキューブについては後述する。

置換群
======================================================================
モジュール ``sympy.combinatorics.perm_groups`` に置換群を表現するクラス ``PermutationGroup`` が宣言されている。

コンストラクター
----------------------------------------------------------------------
置換群を表現するクラス ``PermutationGroup`` のコンストラクターには、
その群の生成元を表すいくつかの ``Permutation`` オブジェクトを渡す。

手作業で一つ一つオブジェクトを用意するのもよいし、
先述のジェネレーターを利用するのもよいだろう。

プロパティー
----------------------------------------------------------------------
理解している範囲で記す。

``base``
  群の基底。

  * Schreier-Sims アルゴリズムから得られる。

``basic_orbits``
  群の基底と強生成元に関する軌道。

  * Schreier-Sims アルゴリズムから得られる。
  * 上述のプロパティー ``base`` と後述のメソッド ``orbit`` とを組み合わせたものと考える。

``basic_stabilizers``
  群の基底と強生成元に関する固定群鎖。

  * Schreier-Sims アルゴリズムから得られる。

``degree``
  群が含む置換のサイズ。置換が対象とする文字数。

``generators``
  群の生成元を保持する ``list`` オブジェクトだ。

``is_abelian``
  群がアーベル群かどうかを返す。

``is_nilpotent``
  群がべき零群かどうかを返す。

  * 実装ではこの群の降中心列の末端の部分群が恒等群かどうかを（入念なやり方で）見ている。
  * べき零群は可解群である。

``is_solvable``
  群が可解群かどうかを返す。

  * 実装が上述の ``is_nilpotent`` と酷似しているので見ておくとよい。
    降中心列ではなく導来列を調べる。

``is_trivial``
  群が自明な群、恒等群かどうかを返す。

  * そのような群を得たければ何か適当な ``n`` を用いて
    ``PermutationGroup(Permutation(size=n))`` とでもしよう。

``strong_gens``
  群の強生成元。

  * Schreier-Sims アルゴリズムから得られる。

メソッド
----------------------------------------------------------------------
理解している範囲で記す。
以下、第一引数の ``self`` を省略する。

``centralizer(other)``
  この置換群と ``other`` の中心化群を返す。
  ここで ``other`` は置換の ``list`` または置換群をとる。

``contains(g, strict=True)``
  置換 ``g`` が群に含まれているかどうかを返す。

  * キーワード引数を ``strict=False`` などとした場合は、
    群と引数の置換のサイズ不整合時に適宜考慮してくれる。

``commutator(G, H)``
  群の部分群 ``G`` と ``H`` の交換子部分群を生成する。

``derived_series()``
  群の導来列を求める。日本語はこれで適切か知らないが。

  * 戻り値は ``PermutationGroup`` オブジェクトの ``list`` オブジェクト。
  * 列の先頭と末尾はそれぞれこの群自身と恒等群である。
  * 実装はメソッド ``derived_subgroup`` を反復的に利用している。

``derived_subgroup()``
  群の導来部分群（交換子部分群）を求める。

``generate(method='coset', af=False)``
  群の要素をすべて列挙する。

  * 名前の通りジェネレーターである。
  * キーワード引数 ``af=True`` とすると ``Permutation`` オブジェクトではなく ``list`` オブジェクトを列挙する。

``is_normal(gr)``
  この群が群 ``gr`` の正規部分群かどうかを返す。

``is_subgroup(G, strict=True)``
  この群が群 ``G`` の部分群であるかどうかを返す。

  * キーワード引数 ``strict`` については別のメソッドのそれと同じ意味だ。

``lower_central_series()``
  群の降中心列を返す。

  * 戻り値は ``PermutationGroup`` オブジェクトの ``list`` オブジェクト。
  * もちろん列の先頭がこの群自身だ。
  * 実装はメソッド ``commutator`` を反復的に利用している。

``orbit(alpha, action='tuples')``
  群の置換の作用による整数点 ``alpha`` の軌道を求める。

  * 整数点を複数指定することも可能。そのときは ``action='union'`` が便利だ。

``orbits(rep=False)``
  群自身の軌道を全て返す。

  * 戻り値の型は各軌道を ``set`` オブジェクトで表した ``list`` オブジェクトだ。
  * キーワード引数 ``rep`` の意味は不明。

``order()``
  群の位数を求める。

  * 全部でいくつの置換を生成できるかということ。

``pointwise_stabilizer(points, incremental=True)``
  整数点 ``points`` を動かさない、この群の置換の部分群を返す。

``stabilizer(alpha)``
  整数点 ``alpha`` を動かさない、この群の置換の部分群を返す。

直積群
======================================================================
モジュール ``sympy.combinatorics.group_constructs`` に群オブジェクトのコレクションから
直積群オブジェクトを生成する関数がある。

関数 ``DirectProduct(*groups)``
  複数の ``PermutationGroup`` オブジェクトの直積をひとつの ``PermutationGroup`` として生成する。

  * 単に ``G1 * G2 * ...`` としても同じ結果が得られる。
    効率の観点からは当関数を利用するほうが有利だそうだ。

  * この関数の恩恵をもっとも受けるのは、おそらく後述する関数 ``AbelianGroup`` である。

名前付き群
======================================================================
モジュール ``sympy.combinatorics.named_groups`` にある群オブジェクト生成関数を見ていく。
これらの関数は最終的にひとつの ``PermutationGroup`` オブジェクトを生成する。

勝手に「名前付き」と訳したが、「名前のある」「名前を持っている」くらいの意味だろう。

======================================== ======================================================================
関数                                     機能
======================================== ======================================================================
``AbelianGroup(*cyclic_orders)``         巡回群の直積群を生成する。
``AlternatingGroup(n)``                  ``n`` 次交代群を生成する。
``CyclicGroup(n)``                       ``n`` 次巡回群を生成する。
``DihedralGroup(n)``                     ``2 * n`` 次の二面体群を生成する。
``SymmetricGroup(n)``                    ``n`` 次対称群を生成する。
``RubikGroup(n)``                        ``PermutationGroup(rubik(n))`` を返す。
======================================== ======================================================================

``AbelianGroup``
----------------------------------------------------------------------
名前はアーベル群だが、実体は先ほどの ``DirectProduct`` の計算の利用による巡回群の直積群である。
引数で与えたものの和が次数、積が位数になると覚えておくとよい。

.. code-block:: text

   In [433]: G = AbelianGroup(2, 2, 3); G
   Out[433]:
       PermutationGroup([
       Permutation(6)(0, 1),
       Permutation(6)(2, 3),
       Permutation(4, 5, 6)])

   In [435]: G.order()
   Out[435]: 12

   In [440]: for i in G.generate(): print(i.cyclic_form)
   []
   [[0, 1]]
   [[2, 3]]
   [[0, 1], [2, 3]]
   [[4, 5, 6]]
   [[0, 1], [4, 5, 6]]
   [[2, 3], [4, 5, 6]]
   [[0, 1], [2, 3], [4, 5, 6]]
   [[4, 6, 5]]
   [[0, 1], [4, 6, 5]]
   [[2, 3], [4, 6, 5]]
   [[0, 1], [2, 3], [4, 6, 5]]

   In [446]: AbelianGroup(2, 5, 4, 210).order() == 2 * 5 * 4 * 210
   Out[446]: True

   In [448]: [i.order() for i in AbelianGroup(3, 3).generate()]
   Out[448]: [1, 3, 3, 3, 3, 3, 3, 3, 3]

``AlternatingGroup``
----------------------------------------------------------------------
交代群。ここでは群の要素がすべて偶置換であることを見ておく。

.. code-block:: text

   In [470]: AlternatingGroup(1) == AlternatingGroup(2)
   Out[470]: True

   In [473]: A4 = AlternatingGroup(4)

   In [480]: __builtin__.all(i.is_even for i in A4.generate())
   Out[480]: True

* 余談。私の isympy シェルのセッションでは起動時に NumPy のモジュールがインポートされているので、
  そちらの ``all`` が Python 組み込みの ``all`` を隠してしまっている。

``CyclicGroup`` 
----------------------------------------------------------------------
巡回群。

.. code-block:: text

   In [496]: CyclicGroup(0) == CyclicGroup(1)
   Out[496]: True

   In [497]: C8 = CyclicGroup(8)

   In [498]: C8.degree
   Out[498]: 8

   In [502]: C8.order()
   Out[502]: 8

   In [503]: list(C8.generate(af=True))
   Out[503]:
   [[0, 1, 2, 3, 4, 5, 6, 7],
    [1, 2, 3, 4, 5, 6, 7, 0],
    [2, 3, 4, 5, 6, 7, 0, 1],
    [3, 4, 5, 6, 7, 0, 1, 2],
    [4, 5, 6, 7, 0, 1, 2, 3],
    [5, 6, 7, 0, 1, 2, 3, 4],
    [6, 7, 0, 1, 2, 3, 4, 5],
    [7, 0, 1, 2, 3, 4, 5, 6]]

   In [504]: C8.is_abelian
   Out[504]: True

``DihedralGroup``
----------------------------------------------------------------------
二面体群。引数は次数の半分を指定する。
ここでは位数 2, 4, 6, 8 の二面体群の乗法表をそれぞれ出力する。

.. code-block:: text

   In [506]: %paste
   def group_multiplication_table(G):
       L = list(G.generate())
       size = len(L)
       return [[L.index(row * col) for col in L] for row in L]

   for i in range(1, 5):
       Di = DihedralGroup(i)
       print("D{}: degree={} order={} abelian={}".format(i, Di.degree,Di.order(), Di.is_abelian))
       print(TableForm(group_multiplication_table(Di), wipe_zeros=False))
       print()
   ## -- End pasted text --
   D1: degree=2 order=2 abelian=True
   0 1
   1 0

   D2: degree=4 order=4 abelian=True
   0 1 2 3
   1 0 3 2
   2 3 0 1
   3 2 1 0

   D3: degree=3 order=6 abelian=False
   0 1 2 3 4 5
   1 5 4 2 3 0
   2 3 0 1 5 4
   3 4 5 0 1 2
   4 2 1 5 0 3
   5 0 3 4 2 1

   D4: degree=4 order=8 abelian=False
   0 1 2 3 4 5 6 7
   1 2 7 6 3 4 5 0
   2 7 0 5 6 3 4 1
   3 4 5 0 1 2 7 6
   4 5 6 7 0 1 2 3
   5 6 3 2 7 0 1 4
   6 3 4 1 2 7 0 5
   7 0 1 4 5 6 3 2

``SymmetricGroup``
----------------------------------------------------------------------
対称群。

.. code-block:: text

   In [517]: A5, C5, S5 = AlternatingGroup(5), CyclicGroup(5), SymmetricGroup(5)

   In [510]: A5.is_subgroup(S5)
   Out[510]: True

   In [511]: A5.is_normal(S5)
   Out[511]: True

   In [513]: S5.generators
   Out[513]: [Permutation(0, 1, 2, 3, 4), Permutation(4)(0, 1)]

   In [514]: C5.is_subgroup(S5)
   Out[514]: True

   In [515]: C5.is_normal(S5)
   Out[515]: False

``RubikGroup``
----------------------------------------------------------------------
ルービックキューブ群を生成する。通常は 3x3 なので 3 を指定する。
整数点とキューブ小面との対応関係のイラストを用意しないと読み解けない。

.. code-block:: text

   In [621]: R3 = RubikGroup(3)

   In [622]: print(R3)
   PermutationGroup([
       Permutation(53)(6, 44, 47, 18)(7, 41, 46, 21)(8, 38, 45, 24)(9, 15, 17, 11)(10, 12, 16, 14),
       Permutation(53)(3, 43, 50, 19)(4, 40, 49, 22)(5, 37, 48, 25),
       Permutation(2, 11, 47, 33)(5, 14, 50, 30)(8, 17, 53, 27)(18, 24, 26, 20)(19, 21, 25, 23),
       Permutation(53)(1, 10, 46, 34)(4, 13, 49, 31)(7, 16, 52, 28),
       Permutation(15, 42, 33, 24)(16, 43, 34, 25)(17, 44, 35, 26)(45, 51, 53, 47)(46, 48, 52, 50),
       Permutation(53)(12, 39, 30, 21)(13, 40, 31, 22)(14, 41, 32, 23)])

   In [623]: R3.order()
   Out[623]: 43252003274489856000

   In [624]: R3.degree
   Out[624]: 54

そこでこの群の軌道を見る。何か違和感がある。

.. code-block:: text

   In [630]: for i in R3.orbits(): print(i, len(i))
   {0} 1
   {1, 3, 5, 7, 10, 12, 14, 16, 19, 21, 23, 25, 28, 30, 32, 34, 37, 39, 41, 43, 46, 48, 50, 52} 24
   {33, 2, 35, 6, 38, 8, 9, 42, 11, 44, 45, 15, 47, 17, 18, 51, 20, 53, 24, 26, 27} 21
   {4, 40, 13, 49, 22, 31} 6
   {29} 1
   {36} 1


正多面体
======================================================================
モジュール ``sympy.combinatorics.polyhedron`` に正多面体を表現するクラスが実装されている。
そして、各正多面体に対応するオブジェクトが生成されており、
ユーザーはこれらを参照することができる。

クラス ``Polyhedron``
----------------------------------------------------------------------
正多面体群を表現する。

* 基底クラスが ``Basic`` であることをうまく利用できるかもしれない。
* このクラスと ``PermutationGroup`` との間に has-a 関係がある。

プロパティー
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
クラス ``Polyhedron`` のプロパティーは次のものがある。

``array_form``, ``cyclic_form``
  それぞれ頂点のインデックスを先述の形式で得る。

``corners``, ``vertices``, ``size``
  最初のふたつのプロパティーは同一で、多面体の全頂点を返す。
  最後のプロパティーはこの多面体の頂点数を返す。

  例。生成済み多面体の頂点数を出力する。

  .. code-block:: text

     In [60]: solids = (tetrahedron, cube, octahedron, dodecahedron, icosahedron)

     In [61]: [s.size for s in solids]
     Out[61]: [4, 8, 6, 20, 12]

``edges``, ``faces``
  それぞれ多面体の全辺、全面を返す。
  どちらも頂点列を表す ``tuple`` の ``set`` オブジェクト。
  
  例。正四面体の辺と面を出力する。
  また、各多面体において Euler の多面体公式を確認する。

  .. code-block:: text

     In [62]: tetrahedron.edges
     Out[62]: {(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)}

     In [63]: tetrahedron.faces
     Out[63]: {(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)}

     In [64]: [s.size - len(s.edges) + len(s.faces) for s in solids]
     Out[64]: [2, 2, 2, 2, 2]

``pgroup``
  多面体群を返す。``PermutationGroup`` オブジェクト。

  例。正四面体群の位数が 12 であることと 4 次の交代群と同型であることを見る。

  .. code-block:: text

     In [81]: T4 = tetrahedron.pgroup

     In [82]: T4.order()
     Out[82]: 12

     In [83]: T4.is_abelian
     Out[83]: False

     In [84]: A4 = AlternatingGroup(4)

     In [85]: A4.is_subgroup(T4) and T4.is_subgroup(A4)
     Out[85]: True

メソッド
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
メソッドはそれほど多くない。

``reset()``
  オブジェクトを「初期状態」に復元する。

``rotate(perm)``
  この多面体に置換 ``perm`` を作用させる。

  * メソッドは引数の置換が妥当であるか判断しないので、呼び出し側で気を遣う必要がある。

テンソル
======================================================================
なぜかテンソルがこんなところにある。

.. todo::

     ノート。

.. include:: /_include/python-refs-core.txt
.. include:: /_include/python-refs-sci.txt
