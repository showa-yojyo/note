======================================================================
積分
======================================================================
本節ではモジュール ``sympy.integrals`` にある積分機能を見ていく。

SymPy_ は積分変数を含む数式の定積分および不定積分（原始関数）を評価することができる。
また、各種 Laplace 変換および各種 Fourier 変換のための機能を提供している。
例えば学生は数学の宿題を片付けるのにこの機能を利用してもよい。

計算機を利用する限り、積分といえば普通は数値計算を想定するものだ。
SymPy においても、得意とする代数的な設計・実装による積分法のほかに、
数値積分法もサポートしている。本節の最後にこれらを見ていくことにする。

.. contents:: ノート目次

基本事項
======================================================================
SymPy では、ある計算を実現するために、
それの即時評価版と遅延評価版の両方を提供し、
前者を後者で実装するという方式を多用している。
積分の場合、前者と後者がそれぞれ関数 ``integrate`` とクラス ``Integral`` になる。
本節ではこれらを簡単に記す。

関数 ``integrate``
----------------------------------------------------------------------
積分を計算するには、関数 ``integrate(f, var, ...)`` をもっとも採用することになる。

* ``integrate(f, x)`` の形式で用いれば、
  被積分関数 ``f`` の変数 ``x`` に関する不定積分（原始関数が一つ）が得られる。

* ``integrate(f, (x, a, b))`` の形式で用いれば、
  被積分関数 ``f`` の指定区間における定積分が得られる。

* 引数に積分変数あるいは積分区間を列挙することにより、
  多変数関数の重積分を計算できる。

  * 積分変数も区間もどちらも指定しない場合は、
    被積分関数 ``f`` の適当な変数に関する原始関数を返すようだ。

* ユーザーは数学公式集に掲載されている基本的な積分公式を本関数が承知していると期待してよい。

.. todo:: コンソールで動作確認をし、コードをここに貼り付ける。

クラス ``Integral``
----------------------------------------------------------------------
積分計算をオブジェクトにカプセル化するためのクラスに違いない。
前述の関数 ``integrate`` が本クラスの機能をラップしているはずだ。

メソッド ``doit(**hints)``
  実際に積分を計算する。

メソッド ``as_sum(n, method='midpoint')``
  キーワード引数 ``method`` の取りうる値が次のものなので、
  これは積分領域を矩形または台形の ``n`` 本の短冊の寄せ集めに近似して、
  その面積を計算するメソッドだろう。

  * ``left``
  * ``right``
  * ``midpoint``
  * ``trapezoid``

メソッド ``transform(x, u)``
  置換積分を行う。
  第一引数を ``x`` と書いたが、実際は元の積分変数の数式に相当する。
  これを第二引数のシンボル ``u`` に置換する。

.. todo:: コンソールで動作確認をし、コードをここに貼り付ける。

線積分
======================================================================
線積分を求めるには、先述のものとは異なる関数を用いる。

関数 ``line_integrate(field, Curve, variables)``
  線積分を求める。

  * 引数 ``field`` が被積分関数である。ベクトル場ということだろう。
  * 引数 ``Curve`` で積分区間となる曲線オブジェクトを指定する。
    これは平面曲線でなければならないようだ。
    このクラスについては :doc:`geometry` で見た。

  .. code-block:: text

     In [1]: C = Curve([cos(t), sin(t)], (t, 0, 2 * pi))

     In [2]: line_integrate((x**2 * y + y ** 2)/2, C, [x, y])
     Out[3]:
     pi
     --
     2

関数変換
======================================================================
モジュール ``sympy.integrals.transforms`` には、
ある積分を用いることにより、与えられた関数から別の関数を生成するための一連の機能がある。
ここではそのうち Laplace 変換と Fourier 変換だけを見ていく。

Laplace 変換
----------------------------------------------------------------------
Laplace 変換およびその逆変換を計算する機能は、関数として提供されている。

関数 ``laplace_transform(f, t, s, **hints)``
  関数 ``f(t)`` の Laplace 変換を計算して、結果を返す。

  * 引数 ``f`` と ``t`` は変換したい関数とその変数シンボルをそれぞれ指定する。
  * 引数 ``s`` で得られる変換関数の変数シンボルを指定する。
  * 戻り値は ``(F, a, cond)`` の形の ``tuple`` オブジェクト。

    * ``F`` は変換関数そのもの。
    * ``a`` はこの変換の収束域の境界値。
      「変数 ``s`` の実部が値 ``a`` を超えていれば、積分が収束する」と読み換えてかまわない。
    * ``cond`` はさらなる収束条件。形式不明。

  * さらに ``noconds=True`` を加えれば、戻り値は ``F`` のみになる。

関数 ``inverse_laplace_transform(F, s, t, plane=None, **hints)``
  関数 ``F(s)`` の逆 Laplace 変換を計算して、結果を返す。

  * 引数 ``F``, ``s``, ``t`` の意味は前述の関数に準ずる。
  * 引数 ``plane`` を利用する場合は、
    呼び出し側で変換関数 ``F`` が極を持たないような半平面を知っているときにそうする。

.. todo:: コンソールで動作確認をし、コードをここに貼り付ける。

Fourier 変換
----------------------------------------------------------------------
こちらも関数として提供されている。

関数 ``fourier_transform(f, x, k, **hints)``
  関数 ``f(x)`` の Fourier 変換を計算して、結果を返す。

  * 引数 ``f`` は変換したい実変数関数。
  * 引数 ``x`` は関数 ``f`` の変数シンボル。
  * 引数 ``k`` は周波数。角周波数ではない（そうだったら ``omega`` みたいなパラメーター名になっただろう）。
  * 戻り値は計算状況によって異なる。

    * 評価が成功すれば、いつものように関数を表現する数式 ``F(k)`` が得られる。
    * 微妙な場合、クラス ``FourierTransform`` のオブジェクトが返る。
      これは変換が未評価であることを意味する。

  * さらに ``noconds=False`` を加えれば、
    戻り値は ``F`` とブール値からなる ``tuple`` オブジェクトに変わる。

    ブール値の意味が文書化されていないので、後で調べたい。

関数 ``inverse_fourier_transform(F, k, x, **hints)``
  関数 ``F(k)`` の逆 Fourier 変換を計算して、結果を返す。
  各引数の意味は前述の関数に準ずる。

.. todo:: コンソールで動作確認をし、コードをここに貼り付ける。

数値積分
======================================================================
その名もモジュール ``sympy.integrals.quadrature`` に、数値積分系の関数が定義されている。

関数 ``gauss_legendre(n, n_digits)``
  TBW

関数 ``gauss_laguerre(n, n_digits)``
  TBW

関数 ``gauss_gen_laguerre(n, alpha, n_digits)``
  TBW

関数 ``gauss_hermite(n, n_digits)``
  TBW

関数 ``gauss_chebyshev_t(n, n_digits)``
  TBW

関数 ``gauss_chebyshev_u(n, n_digits)``
  TBW

関数 ``gauss_jacobi(n, alpha, beta, n_digits)``
  TBW

.. include:: /_include/python-refs-core.txt
.. include:: /_include/python-refs-sci.txt
