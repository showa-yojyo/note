======================================================================
級数
======================================================================
モジュール ``sympy.series`` には級数およびその周辺の構成要素に関係する機能が実装されている。
本稿ではそれらのうち、なんとか私の理解の範囲内にあるものについて見ていく。

.. contents:: ノート目次

極限
======================================================================
モジュール ``sympy.series.limits`` が提供する機能について記す。
チュートリアルで見たこと以上のものはないようだ。

関数 ``limit(e, z, z0, dir='+')``
  変数 ``z`` が ``z0`` に近づきときの関数 ``e(z)`` の極限値を求める。

  * 引数 ``e`` は SymPy オブジェクト
  * 引数 ``z`` は ``e`` の極限を考える変数。
  * 引数 ``z0`` は ``z`` を何に近づけるかを値で指定する。
  * キーワード引数 ``dir`` で右極限か左極限を指定する。プラスが右。

クラス ``Limit``
  関数版と同じことをするが、いわば遅延評価版。
  実際に極限を求める処理を実行するには、メソッド ``doit(**hint)`` を呼び出す。

サンプル
----------------------------------------------------------------------
よくある例を試す。

.. code-block:: text

   In [1]: limit(x * sin(1 / x), x, 0)
   Out[1]: 0

   In [2]: limit(sin(x), x, oo)
   Out[2]: sin(oo)

   In [3]: limit(gamma(x + 1 / 2)/gamma(x)/sqrt(x), x, oo)
   Out[3]: 1

   In [4]: limit(gamma(x) - 1 / (E**x - 1), x, 0)
   Out[4]: -EulerGamma + 1/2

シンボルだけの数式の極限を計算する。

.. code-block:: text

   In [1]: limit(f(x), x, 7)
   Out[1]: f(7)

   In [2]: h = symbols('h')

   In [3]: limit((f(x + h) - f(x)) / h, h, 0)
   Out[3]:
   /  d           \|
   |-----(f(xi_1))||
   \dxi_1         /|xi_1=x

数列の極限も計算できる。

.. code-block:: text

   In [1]: limit((1 + x/n)**n, n, +oo)
   Out[1]:
    x
   e

二変数関数の極限を試す。近づけ方の指定がよくわからない。

.. code-block:: text

   In [1]: limit((x * y) / (x ** 2 + y ** 2), x, 0)
   Out[1]: 0

   In [2]: limit((x * y) / (x ** 2 + y ** 2), y, 0)
   Out[2]: 0

   In [3]: limit((x * y) / (x ** 2 + y ** 2), x, y)
   Out[3]: 1/2

うまくいかない例を挙げる。これは SymPy の改良を期待できるだろうか。

.. code-block:: text

   In [1]: limit(fibonacci(k + 1)/fibonacci(k), k, oo)
   Out[1]:
        fibonacci(k + 1)
    lim ----------------
   k->oo  fibonacci(k)

べき級数展開
======================================================================
モジュール ``sympy.series.series`` が提供する機能について記す。
ここには関数 ``series`` がある。

関数 ``series(expr, x=None, x0=0, n=6, dir='+')``
  関数 ``expr`` の点 ``x = x0`` の周りでの ``n`` 次のべき級数展開を求める。
  各引数の意味は、これまで見てきた SymPy 関数での対応するものと同様。

サンプル
----------------------------------------------------------------------
だいたい想像通りに動作するようだ。

.. code-block:: text

   In [1]: series(exp(x))
   Out[1]:
            2    3    4     5
           x    x    x     x     / 6\
   1 + x + -- + -- + -- + --- + O\x /
           2    6    24   120

   In [2]: series(exp(x), n=10)
   Out[2]:
            2    3    4     5     6     7       8       9
           x    x    x     x     x     x       x       x       / 10\
   1 + x + -- + -- + -- + --- + --- + ---- + ----- + ------ + O\x  /
           2    6    24   120   720   5040   40320   362880

   In [3]: a = symbols('a')

   In [4]: series(f(x), x, a, 3)
   Out[4]:
                                                       /   2           \|
                                                     2 |  d            ||
                                             (-a + x) *|------(f(xi_1))||
                                                       |     2         ||
                   /  d           \|                   \dxi_1          /|xi_1=a
   f(a) + (-a + x)*|-----(f(xi_1))||       + ---------------------------------- +  /        3        \
                   \dxi_1         /|xi_1=a                   2                    O\(-a + x) ; x -> a/


   In [5]: series(x**x, n=4)
   Out[5]:
                   2    2       3    3
                  x *log (x)   x *log (x)    / 4    4   \
   1 + x*log(x) + ---------- + ---------- + O\x *log (x)/
                      2            6

   In [6]: series(gamma(x), n=2)
   Out[6]:
                      /          2     2\
   1                  |EulerGamma    pi |    / 2\
   - - EulerGamma + x*|----------- + ---| + O\x /
   x                  \     2         12/

* べき級数展開の性質上、出力される数式が目にやさしくない。
  上の例では ``f(x)`` の Taylor 展開の結果がひどい。
  コンソールウィンドウで対話的にコードを入出力する際には ``init_printing(pretty_print=False)`` 等の採用を検討することもあるか。

* 各出力の ``n`` 次以上の項にある ``O(x)`` については次節に記す。

ビッグオー記法
======================================================================
モジュール ``sympy.series.order`` が提供する機能について記す。

クラス ``Order``
  ビッグオー記法オブジェクトを表現するためのクラス。

  * 変数がどの値に近づくときの極限の振る舞いの評価なのかを意識するとよい。
    アルゴリズムプログラミングの議論での記法は、
    常に「ある自然数が無限大に発散する」ときの計算量なり何なりのオーダーである。

  * リファレンスの、つまり docstring の説明がよくできている。
    一読するとよい。

  * デフォルトでは変数が 0 に近づくときの極限の評価を与える。
    無限大の評価をする場合は明示的に変数と ``oo`` とのペアを与える必要がある。

  * 実はエイリアス ``O = Order`` が定義されている。
    当然これを積極的に利用する。

  * ``O(f(x), x)`` は内部で自動的に ``O(f(x).as_leading_term(x), x)`` と変形されるとのこと。
    これは一変数の場合で、それ以上の多変数の場合はこの規則がパラメーターのシンボル順に適用される。

  * ビッグオー記法オブジェクトは概念としては集合なので、
    同じ変数と関係する関数と ``Order`` オブジェクトに対しては演算子 ``in`` が適用できる。

サンプル
----------------------------------------------------------------------
何度も言うが、どこへの極限を考えているのかを常に意識するのがよい。

.. code-block:: text

   In [1]: 1 + x**10 + O(x**5)
   Out[1]:
        / 5\
   1 + O\x /

   In [2]: O((x - 1)**4, (x, oo))
   Out[2]:
    / 4         \
   O\x ; x -> oo/

   In [3]: lg = lambda x: log(x, 2)

   In [4]: O(9*lg(n) + 5 * (lg(n))**3 + 3*n**2 + 2*n**3, (n, oo))
   Out[4]:
    / 3         \
   O\n ; n -> oo/

   In [5]: from itertools import islice

   In [6]: L = (O(i, (n, oo)) for i in (1, lg(n), n, n*lg(n), n**2, factorial(n)))

   In [7]: __builtin__.all(i in j for i, j in zip(L, islice(L, 1, None)))
   Out[7]: True

* 最初の例は、高次多項式を小さい次数に省略して表示するひとつの方法を示している。

* 上の例の ``lg`` の定義はこのデモにとっては必要ない。
  ビッグオー記法の定義により、対数に関するオーダーの比較は 2 でも 10 でも自然対数の底でも同じだ。

留数
======================================================================
モジュール ``sympy.series.residues`` が提供する機能について記す。

関数 ``residue(expr, x, x0)``
  関数 ``expr`` の点 ``x = x0`` における留数を求める。
  言い換えると Laurant 展開の -1 次の項の係数。

サンプル
----------------------------------------------------------------------
留数は複素関数の積分を求めるための強力な手段なのだが、
今は SymPy で Laurant 展開や複素関数の積分計算がサポートされているかどうかわからないので、
差し当たり単体での動作を見てみよう。

.. code-block:: text

   In [1]: [residue(1/z**i, z, 0) for i in range(4)]
   Out[1]: [0, 1, 0, 0]

   In [2]: [residue(1/sin(z)**i, z, 0) for i in range(6)]
   Out[2]: [0, 1, 0, 1/2, 0, 3/8]

   In [3]: residue(f(z)/z**3, z, 0)
   Out[3]:
   /  2      \|
   | d       ||
   |---(f(x))||
   |  2      ||
   \dx       /|x=0
   ---------------
          2

   In [4]: residue(gamma(z) * gamma(z - 1) * gamma(z - 2), z, 0)
   Out[4]:
            2               2
     17   pi    9*EulerGamma    15*EulerGamma
   - -- - --- - ------------- + -------------
     8     8          4               4

   In [5]: residue(1/z, z, zoo)
   Out[5]: 0

   In [6]: residue((-1/z**2)*z, z, 0)
   Out[6]: -1

* [1] と [2] はよくある例。
* [3] のように、シンボル式のまま留数を求めることができる。
* [4] はよそのドキュメントの例をそのまま引用した。同じ結果が得られている。
* [5] の計算は誤りだ。留数として ``-1`` が出力されて欲しい。
  [6] のように式を書き換えると期待した値が得られるので、
  何かが惜しいか私がおかしいかのどちらか。

  * ちなみに ``zoo`` は ``S.ComplexInifinity`` の意。

数列
======================================================================
モジュール ``sympy.series.sequences`` が提供する機能について記す。

Fourier 級数
======================================================================
モジュール ``sympy.series.fourier`` が提供する機能について記す。

.. include:: /_include/python-refs-core.txt
.. include:: /_include/python-refs-sci.txt
