======================================================================
常微分方程式
======================================================================
モジュール ``sympy.solvers.ode`` が提供する、
常微分方程式を解くための機能に関する覚え書きを記す。

.. contents:: ノート目次

.. note::

   紙幅の都合上、出力を一部手で改行した。

   本文中のすべての IPython セッション中のサンプルコードで、
   以下のインポートおよび出力書式設定が済んでいるものとする。

   .. code-block:: python3

      init_printing(use_unicode=False, pretty_print=False)

基本機能
======================================================================
ここに記す関数は isympy シェルがデフォルトで実行するインポート ``from sympy import *`` だけで利用可能だ。

SymPy で常微分方程式を解くには、関数 ``dsolve`` を用いる。
簡単なケースではこれ一本で事足りる。
何か凝ったことをする場合に、その他の関数やデータを併用するという方針でよさそうだ。

関数 ``dsolve(eq, ...)``
  常微分方程式系を解く。

  方程式を一個解くときには、引数 ``eq`` には何か導関数を含むような数式オブジェクトを指定する。
  方程式を複数個解くときには、同様に数式オブジェクトの ``list`` オブジェクトを指定する。
  ソルバーは各方程式が 0 と等しい条件を求める。

  * キーワード引数 ``func=None`` は ``eq`` がどの一変数関数に関する微分方程式なのかを指示する。
    方程式を複数個解くときには、やはり ``list`` の形式をとる。
    普通はソルバーが自動検出するため、指定しない。

  * キーワード引数 ``hint='default'`` ではソルバーに微分方程式のタイプについてヒントを教える。
    このヒントによって方程式の解法を調整することになる。

    方程式を一個解くときには、与え得るパラメーターは次のとおり（すべて文字列だが、引用符を省略する）。

    * ``default``: 後述の関数 ``classify_ode(eq, ...)`` にて記す。

    * ``all``: 全部の解法候補を適用する。
      この場合はソルバーの戻り値がキーと値をタイプ名と解からなる ``dict`` オブジェクトになる。
      タイプ名は文字列で、解は ``Equality`` オブジェクトだと思われる。
      それに加えて、ベスト解や階数等の副次的な情報も併せて含む。

    * ``all_Integral``: ``all`` と同様に振る舞うが、
      もしタイプ ``xxx`` とタイプ ``xxx_Integral`` が候補にある場合、
      前者を省略するという点が異なる。
      後者の解法は結果オブジェクト内に ``Integral`` オブジェクトが未評価のまま残るが、
      計算処理が速いという特徴がある。

    * ``best``: 全部の候補を試して、もっとも解が単純なものを返す。

    * あるいはユーザーが別途関数 ``classify_ode(eq, ...)`` を呼び出して得たタイプのうちの一つ。

  * キーワード引数 ``simplify=True`` はソルバー内部が関数 ``odesimp`` を呼び出すかどうかを指定する。

  * キーワード引数 ``ics=None`` は境界条件を ``dict`` オブジェクトで指定できる。

    * キーの例 ``func(x0)``, ``func(x).diff(x).subs(x, x2)``
    * 利用可能になる条件は一階常微分方程式のべき級数？

  * キーワード引数 ``xi=None`` および ``eta=None`` は無限小関数。
    後述する関数 ``infinitesimals`` の項で解説する。

  * キーワード引数 ``x0=0`` は微分方程式のべき級数解をどの点周りに評価するかを指定する。
  * キーワード引数 ``n=6`` はべき級数の指数をどこまで上げてよいかを指定する。

関数 ``classify_ode(eq, ...)``
  常微分方程式 ``eq == 0`` のタイプを返す。
  微分方程式の教科書と考え方は同じで、
  ソルバーは微分方程式を解く手法を何種類かに名前をつけて分類している。
  この関数は与えられた微分方程式を解くのに相応しいであろう手法の名前を列挙するものだ。

  * キーワード引数 ``func=None`` および ``ics=None`` はソルバー関数と同じ。
  * キーワード引数 ``dict=False`` はソルバー関数が内々に利用するもの。

  * 戻り値は文字列からなる ``tuple`` オブジェクトである。

    * ソルバーが方程式を解くのにデフォルトで採用するのは、この最初のタイプである。
      特定の方法で解かせたいならば、関数 ``dsolve`` の ``hint`` として、
      この候補のいずれかのタイプを指定する。

    * タイプは基本的には「このタイプとみなせば、方程式を解きやすいだろう」という順序で列挙されている。

  * サポートするタイプは ``allhints`` という ``tuple`` オブジェクトが知っている。
    手許の環境では 34 個ある。

関数 ``checkodesol(ode, sol, ...)``
  これは微分方程式の解を求めた後に、それを検算するのに用いる。
  オブジェクト ``sol`` をソルバーに渡したものと同じ ``ode`` に代入して、
  ゼロになることを見たい。

  * 戻り値は 2 要素の ``tuple`` である。

    * [0]: 代入結果がゼロならば ``True`` であり、そうでなければ ``False`` である。
    * [1]: [0] が ``True`` ならば ``0`` である（逆は必ずしも成り立たない）。
      それ以外は代入結果が何になったのかを表現する値が入る。

  * この関数の呼び出しがなかなか返って来ないときは、
    間違いなく ``simplify`` がキツイためだろう。

関数 ``homogeneous_order(eq, *symbols)``
  同次方程式 ``eq == 0`` の次数を返す。

  * 非同次であれば ``None`` を返す。
  * シンボル関数も ``eq`` になれるが、関数のすべての変数がシンボルである必要がある。
    なおかつ、数式中のその関数の変数が ``*symbols`` にマッチしている必要がある。

関数 ``infinitesimals(eq, ...)``
  一階常微分方程式 :math:`y' = f(x, y)` に対して、
  次の条件をみたすような点変換 :math:`\xi(x, y)` と :math:`\eta(x, y)` を返す：

  これらの点変換が次のリー群について、
  元の :math:`f` を用いて変換先の各変数に関する微分方程式 :math:`(y^*)'=f(x^*, y^*)` が成り立つ。

  .. math::
     :nowrap:

     \begin{eqnarray*}
     x^* &=& X(x, y;\varepsilon) = x + \varepsilon \xi(x, y),\\
     y^* &=& Y(x, y;\varepsilon) = y + \varepsilon \eta(x, y)
     \end{eqnarray*}

  * 戻り値は ``dict`` の ``list`` の型をとる。
    内側の ``dict`` は、キーが点変換関数オブジェクトで、
    値が ``Function`` 系オブジェクトまたは定数である。

  * キーワード引数 ``hint`` を用いて、点変換関数の計算方法のヒューリスティックを調整できるもよう。

関数 ``checkinfsol(eq, infinitesimals, ...)``
  この関数は上述の関数 ``infinitesimals`` の結果を検証するのに用いられる。

  * 引数 ``infinitesimals`` の型は（というか値は）先ほどの関数の戻り値と同じようにする。
  * 戻り値は ``list`` オブジェクトである。
    この要素は各点変換のペアに対応するブーリアン値と検算結果の値とのペアである。
    検算結果とは、次の偏微分に点変換関数を代入して評価した値である。

    .. math::
       :nowrap:

       \frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
        - \frac{\partial \xi}{\partial x}\right)\frac{dy}{dx}
        - \frac{\partial \xi}{\partial y} \left(\frac{dy}{dx}\right)^{2}
        - \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y}

    すなわち、妥当な関数を与えればリストが含む要素はすべて ``(True, 0)`` となる。

下回りの機能
======================================================================
ここからはモジュール ``sympy.solvers.ode`` からの明示的なインポートを必要とする機能を記す。

関数 ``odesimp(eq, func, order, constants, hint)``
  常微分方程式の単純化処理のための関数。

  * 関数 ``dsolve`` が本関数を呼び出すので、
    これを単体で利用するケースというのは一般ユーザーにはまれだということだ。

関数 ``constant_renumber(expr, symbolname, startnumber, endnumber)``
  式に含まれる任意定数の番号付けを変更する関数。

  式 ``expr`` 中にはいくつかの ``Symbol`` オブジェクトがあるという前提。
  そのオブジェクト名が ``symbolname`` に末尾から数字のくっついたもので、
  さらにその数字が範囲 `[startnumber, endnumber)` にあれば、リネームの対象になる。
  新たに 1 から範囲の長さまでの連番が振られる。

関数 ``constantsimp(expr, constants)``
  式に含まれる任意定数に対する単純化処理のための関数。

  * ``C1 + C2`` → ``C1``
  * ``C1 * C2`` → ``C1``
  * ``exp(C1)`` → ``C1``
  * etc.

関数 ``ode_sol_simplicity(sol, func, trysolving=True)``
  TBW

演習
======================================================================
触りながらカンを鍛えることにしたい。

.. todo:: 微分方程式をひたすら解く。

.. include:: /_include/python-refs-core.txt
.. include:: /_include/python-refs-sci.txt
