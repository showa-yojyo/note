======================================================================
微分幾何
======================================================================
微分幾何に関係する機能を提供するモジュール ``sympy.diffgeom`` に関するメモを記す。

これはふたつのサブモジュール ``diffgeom`` と ``rn`` から構成されている。
理解の都合上、まず ``diffgeom`` に定義されている基礎的な諸クラスを見ていく。
次にサブモジュール ``rn`` で定義されているすべてのオブジェクトを見ていく。
最後に再度 ``diffgeom`` に戻り、残りの（さらに複雑な概念を表現する）諸機能を見ていく。

.. contents:: ノート目次

.. note::

   本文中のすべての IPython セッション中のサンプルコードで、
   以下のインポートおよび出力書式設定が済んでいるものとする。

   .. code-block:: python3

      from sympy.diffgeom import *
      from sympy.diffgeom.rn import *
      init_printing(use_unicode=False, pretty_print=False)

多様体
======================================================================
本節ではサブモジュール ``sympy.diffgeom.diffgeom`` で定義されている、
多様体を表現するための一連のクラス群について記す。

クラス ``Manifold``
----------------------------------------------------------------------
クラス ``Manifold`` は多様体をオブジェクトとして表現する。

* オブジェクトをコンストラクターから直接生成する。
  名前と多様体次元さえ用意すればよい。
  生成後にそれぞれをメンバーデータ ``name`` および ``dim`` で参照できる。

* メンバーデータ ``patches`` から構成パッチオブジェクトにアクセスできる。
  これは後述する ``Patch`` オブジェクトの ``list`` オブジェクトである。

クラス ``Patch``
----------------------------------------------------------------------
クラス ``Patch`` は多様体オブジェクトの構成要素をオブジェクトとして表現する。

* オブジェクトをコンストラクターから直接生成する。
  この際、名前と自身が所属する ``Manifold`` オブジェクトが必要となる。
  生成後にそれぞれをメンバーデータ ``name`` および ``manifold`` で参照できる。

* メンバーデータ ``coord_systems`` から座標系オブジェクトにアクセスできる。
  これは後述する ``CoordSystem`` オブジェクトの ``list`` オブジェクトである。

* 多様体次元はプロパティー ``dim`` を用いて参照可能。

クラス ``CoordSystem``
----------------------------------------------------------------------
クラス ``CoordSystem`` は多様体パッチのひとつの座標系をオブジェクトとして表現する。

* オブジェクトをコンストラクターから直接生成する。
  座標系の名前と関連付けるパッチオブジェクトが要る。

  * 他にもオプションで ``names`` というのがある。
    これは座標成分の名称を ``list`` で指定することができる。

* 多様体次元はプロパティー ``dim`` を用いて参照可能。

このクラスは特に重要なメソッドが多い。
強いて言えば、座標情報と座標変換に関係するものに分類したい。

座標情報にアクセスするメソッドは次のようなものがある。

``coord_function(coord_index)``, ``coord_functions()``
  点を取り、その点の特定の座標を返す関数オブジェクトを返す。

  * 後述のクラス ``BaseScalarField`` を参照。

  * 単数形の方は ``coord_index`` 番目の座標成分のものに関するそれを返す。
    例えば直交座標系で ``0``, ``1`` はそれぞれ x, y 座標。

  * 複数形の方は全成分を ``list`` で返す。

``base_vector(coord_index)``, ``base_vectors()``
  基底ベクトルを返す。
  後述のクラス ``BaseVectorField`` を参照。

``base_oneform(coord_index)``, ``base_oneforms()``
  基底微分 1-形式を返す。
  外積代数の生成元である。
  後述のクラス ``Differential`` を参照。

座標変換メソッドは次のようなものがある。

``connect_to(to_sys, from_coords, to_exprs, inverse=True, fill_in_gaps=False)``
  当座標系から座標系 ``to_sys`` への座標変換を定義する。

  * 利用例を知るならモジュール ``rn`` を見るのが最良。

``coord_tuple_transform_to(to_sys, coords)``
  この座標系における座標 ``coords`` を指定座標系 ``to_sys`` でのそれに変換する。

  * 戻り値は ``Matrix`` オブジェクトとなる。
    座標を表現するために便宜上この型を用いている。

``point_to_coords(point)``
  既存の（おそらくは別座標系にある）点オブジェクトから、
  この座標系での座標を得る。

  * 戻り値は ``Matrix`` オブジェクトとなる。

``jacobian(to_sys, coords)``
  当座標系から座標系 ``to_sys`` に関する Jacobi 行列を求める。
  先程から ``Matrix`` 型が頻出しているのは、このメソッドとの相性のためだろう。

利用例は後述する。

クラス ``Point``
----------------------------------------------------------------------
多様体パッチ上の一点をオブジェクトとして表現する。

* オブジェクトの生成方法はふたつある。
  このクラスのコンストラクターから直接生成する方法と、
  クラス ``CoordSystem`` のメソッド ``point`` を呼ぶ方法だ。

  * 直接生成の場合、座標系オブジェクトと座標を要する。
    前者はもちろん ``CoordSystem`` オブジェクトであり、
    後者は単に座標成分を ``list`` で渡せばよい。

  * メソッド ``CoordSystem.point`` の場合は座標成分だけあればよい。

* メソッド ``coords`` を用いれば、この点の座標系が得られる。

  * オプションとして別の座標系 ``to_sys`` を与えると、
    座標変換後の座標を得ることも可能だ。
    これには前述のクラス ``CoordSystem`` のメソッド ``coord_tuple_transform_to`` が用いられる。

スカラー場、ベクトル場、外微分
======================================================================
こちらも利用例は後述することにする。

クラス ``BaseScalarField``
----------------------------------------------------------------------
多様体上のスカラー場をオブジェクトとして表現するための基になるクラス。

* コンストラクターでオブジェクトを生成する場合、
  ``CoordSystem`` オブジェクトと座標成分番号 ``i`` を指定する。

  例えば 3 次元直交座標系の y 成分 (``i = 1``) スカラー場を生成する、
  というような構成をする。

* 丸括弧で評価するときの引数は ``Point`` オブジェクトである。
  点オブジェクトは任意の座標系で表現されていて構わない。
  戻り値はスカラーだが、座標系の第 ``i`` 成分に相当する値を示す。

* ``BaseScalarField`` オブジェクトを（算術演算等で）組み合わせて、
  単に座標成分を返すだけでない、より一般的なスカラー場を構成することもできる。

クラス ``BaseVectorField``
----------------------------------------------------------------------
このクラスが表現するのは接ベクトルの基底だと思われる。
つまり接ベクトル :math:`\sum_{i=0} a_i \left(\frac{\partial}{\partial x_i}\right)_p` の
:math:`\frac{\partial}{\partial x_i}` の部分を表現している。

このクラスはベクトル場を表現するための素材に過ぎない。
ベクトル場自体を表現するものではない。

* コンストラクターでオブジェクトを生成する方法は ``BaseScalarField`` と同じだ。
  座標系とどの座標成分に関するものなのかを指定する。

* 丸括弧で評価するときの引数と戻り値の型は両方ともスカラー的な値である。
  ある点 ``p`` における座標成分 ``i`` に関する方向微分を得るには、
  基底接ベクトル ``vi`` を生成した後、結果的に二段階評価を行う。
  すなわち ``vi(f).rcall(p)`` である。

  * 見慣れぬ ``rcall`` は丸括弧のようなものなので、気にしないでよい。

  * このクラスのオブジェクトを「線形結合」することはできでも、
    その型が単なる SymPy の ``Add`` オブジェクトに過ぎないので、
    「接ベクトル」に丸括弧をつけて評価することができない。
    丸括弧の代わりに ``rcall()`` を用いる。

クラス ``Commutator``
----------------------------------------------------------------------
ふたつのベクトル場の交換子を表現する。

* ``Commutator(v1, v2)`` は :math:`v_1(v_2(f)) - v_2(v_1(f))` で定義されるベクトル場を意味する。
  ``f`` は多様体上のスカラー場。

  * 丸括弧で ``f`` を評価する前に、交換子オブジェクトがゼロでないことを確認する必要がある。

* ドキュメントにあるように、現行の実装は少々弱いようだ。
  展開し切れないケースがままある。

クラス ``Differential``
----------------------------------------------------------------------
クラス ``Differential`` は外微分を意味する。
スカラー関数を含む微分形式の外微分をオブジェクトとして表現する。

* コンストラクターには k-形式として扱えるオブジェクトを渡す。
  ここで k はゼロ以上。

  * 既存の ``Differential`` オブジェクトでもかまわないが、結果的にゼロが返る。

  * 先述したメソッド ``CoordSystem.base_oneforms`` が返すのは
    0-形式 ``f_i = BaseScalarField(coord, i)`` の外微分となる
    1-形式 ``Differential(f_i)`` をすべての ``i`` 成分について生成したものに他ならない。

  * 実数値関数 ``f`` からは全微分 ``df`` が得られる。
    任意のベクトル ``v`` について ``df(v) == v(f)`` が成り立つ。

* 丸括弧で評価する際のオペランドはスカラー関数オブジェクトまたは「接ベクトル」でよい。
  今度は ``BaseVectorField`` オブジェクトの線形結合で通じるし、
  オブジェクトを次元個分カンマ区切りで可変個引数的に渡してもよい。
  同じ結果が得られると期待してよろしい。

* 実装に ``Commutator`` を用いる。

クラス ``TensorProduct``
----------------------------------------------------------------------
クラス ``TensorProduct`` は k-形式のテンソル積を表現するクラス。

* コンストラクターの引数は k-形式オブジェクトである。複数個渡してよい。

  * 言い忘れたが、k-形式として認められる型はだいたい次のような感じらしい。

    * 定数
    * ``Function`` オブジェクト
    * ``BaseScalarField`` オブジェクト
    * ``Differential`` オブジェクト

* 丸括弧の引数はベクトル場オブジェクトである。
* 戻り値の型もまた ``TensorProduct`` であるのだが、
  状況により ``Mul`` になったり、あるいは定数になったりする。
  このときは丸括弧は使えない。

クラス ``WedgeProduct``
----------------------------------------------------------------------
クラス ``WedgeProduct`` は微分形式オブジェクト同士の wedge 積を表現するクラス。

* スーパークラスは ``TensorProduct`` だが、混ぜて使わないこと。
  前項で注意した点がそのまま当クラスの注意点でもある。

* 積分の文脈上に限り、反対称性がまともに扱われるとのこと。
  この注意は、例えば

  * ``WedgeProduct(X, X)`` のようなオブジェクトを生成しても、直ちにゼロと評価されたりしない
  * ``WedgeProduct(X, Y)`` と ``-WedgeProduct(Y, X)`` が等しくならない

  という現象を説明するものだろうか。

定義済み多様体オブジェクト
======================================================================
本節ではサブモジュール ``sympy.diffgeom.rn`` に定義されているオブジェクトを見ていく。

前節で述べた一連の機能をすぐに試したいが、オブジェクト生成が面倒で困る。
そこで、ここにある定義済みオブジェクトをインポートすることが考えられる。
それらのオブジェクトを試して、感触を確かめるのがよいだろう。

==================== ==================== ==================== ========================================
オブジェクト         クラス               名前                 意味
==================== ==================== ==================== ========================================
``R2``               ``Manifold``         ``'R^2'``            :math:`\mathbb{R}^2`
``R2_origin``        ``Patch``            ``'origin'``         ``R2`` のパッチ
``R2_r``             ``CoordSystem``      ``'rectangular'``    ``R2_origin`` の直交座標系
``R2_p``             ``CoordSystem``      ``'polar'``          ``R2_origin`` の極座標系
``R3``               ``Manifold``         ``'R^3'``            :math:`\mathbb{R}^3`
``R3_origin``        ``Patch``            ``'origin'``         ``R3`` のパッチ
``R3_r``             ``CoordSystem``      ``'rectangular'``    ``R3_origin`` の直交座標系
``R3_c``             ``CoordSystem``      ``'cylindrical'``    ``R3_origin`` の円柱座標系
``R3_s``             ``CoordSystem``      ``'spherical'``      ``R3_origin`` の球座標系
==================== ==================== ==================== ========================================

2 次元オブジェクト
----------------------------------------------------------------------
``R2``, ``R2_origin``, ``R2_r``, ``R2_p`` には可能な限り次に示すメンバーデータが付与されている。
可能な限りというのは「座標系 A 由来のデータは座標系 B には付与しない」という意味だ。

``x``, ``y``
  ``R2_r.coord_functions()`` から値を設定。

``e_x``, ``e_y``
  ``R2_r.base_vectors()`` から値を設定。

``dx``, ``dy``
  ``R2_r.base_oneforms()`` から値を設定。

``r``, ``theta``
  ``R2_p.coord_functions()`` から値を設定。

``e_r``, ``e_theta``
  ``R2_p.base_vectors()`` から値を設定。

``dr``, ``dtheta``
  ``R2_p.base_oneforms()`` から値を設定。

座標成分 ``x``, ``y``, ``r``, ``theta`` は次の座標変換が（微妙な点もあるが）
成り立つように相互に ``connect_to`` している。
数式中の逆三角正接関数は SymPy では関数 ``atan2`` である。

.. math::

   \begin{eqnarray*}
   T_{rp}&:& (x, y) \mapsto (\sqrt{x^2 + y^2}, \tan^{-1} \frac{y}{x})\\
   T_{pr}&:& (r, \theta) \mapsto (r \cos \theta, r \sin \theta)
   \end{eqnarray*}

3 次元オブジェクト
----------------------------------------------------------------------
``R3`` 側でも同様の考えの下に、
各オブジェクトに座標成分、基底ベクトル、微分 1-形式のメンバーデータが付与されて、
関連する 3 座標系の間に相互に座標変換が定義されている。

以下、座標変換だけ記す。
直交座標系と円柱座標系間の座標変換は次のように与えられている。

.. math::

   \begin{eqnarray*}
   T_{rc}&:& (x, y, z) \mapsto (\sqrt{x^2 + y^2}, \tan^{-1} \frac{y}{x}, z)\\
   T_{cr}&:& (\rho, \psi, z) \mapsto (\rho \cos \psi, \rho \sin \psi, z)
   \end{eqnarray*}

直交座標系と球座標系間の座標変換は次のように与えられている。

.. math::

   \begin{eqnarray*}
   T_{rs}&:& (x, y, z) \mapsto (\sqrt{x^2 + y^2 + z^2}, \cos^{-1} \frac{z}{\sqrt{x^2 + y^2 + z^2}}, \tan^{-1} \frac{y}{x})\\
   T_{sr}&:& (r, \theta, \phi) \mapsto (r \sin \theta \cos \phi, r \sin \theta \sin \phi, r \cos \theta)
   \end{eqnarray*}

円柱座標系と球座標系間の座標変換は次のように与えられている。

.. math::

   \begin{eqnarray*}
   T_{cs}&:& (\rho, \psi, z) \mapsto (\sqrt{\rho^2 + z^2}, \cos^{-1} \frac{z}{\sqrt{\rho^2 + z^2}}, \psi)\\
   T_{sc}&:& (r, \theta, \phi) \mapsto (r \sin \theta, \phi, r \cos \theta)
   \end{eqnarray*}

コード例（基本編）
======================================================================
コード例を書けるだけのクラスとオブジェクトの説明が終わったところで、
基本的な用例を示したい。

以下に示す例では、出来合いの ``R2_r`` 等のオブジェクトを多用する。

局所座標系
----------------------------------------------------------------------
クラス ``CoordSystem``, ``Point``, ``BaseScalarField`` の
座標成分に関係するメソッドの簡単な例を示す。

.. code-block:: ipython

   In [1]: r, th = symbols('r th')

   In [2]: polar_coords = R2_p.point([r, th])

   In [3]: R2_r.x(polar_coords), R2_r.y(polar_coords)
   Out[3]: (r*cos(th), r*sin(th))

   In [4]: R2_r.point_to_coords(polar_coords)
   Out[4]:
   Matrix([
   [r*cos(th)],
   [r*sin(th)]])

   In [5]: R2_p.coord_tuple_transform_to(R2_r, [r, th])
   Out[5]:
   Matrix([
   [r*cos(th)],
   [r*sin(th)]])

* [1][2] 記号により 2 次元極座標系の座標 ``(r, th)`` を定義する。
* [3] ``BaseScalarField`` オブジェクト
  ``R2_r.x`` および ``R2r.y`` による座標 ``point`` の x 座標と y 座標成分の取得。
* [4] 同じことをメソッド ``CoordSystem.point_to_coords`` で。
* [5] 同じことをメソッド ``CoordSystem.coord_tuple_transform_to`` で。
  これがあるので [2] の前処理なしで済むことがある。

ドキュメントのそれとたいして変わらないが、Jacobi 行列の例を示す。

.. code-block:: ipython

   In [1]: x, y, r, th = symbols('x y r th')

   In [2]: R2_r.jacobian(R2_r, [x, y])
   Out[2]:
   Matrix([
   [1, 0],
   [0, 1]])

   In [3]: R2_r.jacobian(R2_p, [x, y])
   Out[3]:
   Matrix([
   [x/sqrt(x**2 + y**2), y/sqrt(x**2 + y**2)],
   [   -y/(x**2 + y**2),     x/(x**2 + y**2)]])

   In [4]: R2_p.jacobian(R2_r, [r, th])
   Out[4]:
   Matrix([
   [cos(th), -r*sin(th)],
   [sin(th),  r*cos(th)]])

* [2] 一応見ておくだけだが、
  自分自身の座標系で Jacobi 行列を求めると、恒等行列が得られる。
* [3] 2 次元直交座標から系極座標系への変換の Jacobi 行列。
* [4] 2 次元極座標系から直交座標系への変換の Jacobi 行列。

ベクトル場
----------------------------------------------------------------------
クラス ``BaseVectorField`` の例を示す。3 次元空間に何か適当な、
例えば原点からの距離の平方に反比例する値を返すスカラー場 ``f`` を定義し、
各座標成分について適用させて、方向微分を見よう。

.. code-block:: ipython

   In [1]: k = symbols('k')

   In [2]: f = -k * R3_s.r ** -2

   In [3]: R3_s.e_r(f), R3_s.e_theta(f), R3_s.e_phi(f)
   Out[3]: (2*k/r**3, 0, 0)

   In [4]: R3_r.e_x(f), R3_r.e_y(f), R3_r.e_z(f)
   Out[4]: (2*k*x/(sqrt(x**2 + y**2 + z**2)*r**3), 2*k*y/(sqrt(x**2 + y**2 + z**2)*r**3), 2*k*z/(sqrt(x**2 + y**2 + z**2)*r**3))

   In [5]: R3_c.e_rho(f), R3_c.e_psi(f), R3_c.e_z(f)
   Out[5]: (2*k*rho/(sqrt(rho**2 + z**2)*r**3), 0, 2*k*z/(sqrt(rho**2 + z**2)*r**3))

* [2] 球座標系でスカラー場 :math:`f(r, \theta, \phi) = -\frac{k}{r^2}` を定義する。

* [3] まず球座標系 ``R3_s`` の ``BaseVectorField`` オブジェクト
  ``e_r``, ``e_theta``, ``e_psi`` の丸括弧演算を全成分で評価する。
  つまり単に勾配を手動で求めることになる。
  前述したとおり :math:`\frac{\partial f}{\partial r}` 等が得られている。

* [4][5] 直交座標系 ``R3_r`` と 円柱座標系 ``R3_s`` で同じことをする。
  例えば ``R3_r.e_x(f)`` を見ると、
  例示したスカラー場がゼロ成分ばかりで検証しにくいが、
  これは一応次の式に合致した結果である。

  .. math::
     :nowrap:

     \frac{\partial f}{\partial x} =
     \frac{\partial f}{\partial r}\frac{\partial r}{\partial x} +
     \frac{\partial f}{\partial \theta}\frac{\partial \theta}{\partial x} +
     \frac{\partial f}{\partial \phi}\frac{\partial \phi}{\partial x}

微分形式と外微分
----------------------------------------------------------------------
クラス ``Differential`` と ``WedgeProduct`` の基本動作を見たい。
例えば次の微分形式とその外微分をこれらのクラスを用いて再現したい。
上側の数式（出典はネットで拾ってきたどこかのベクトル解析の演習問題）のほうをオブジェクトとして表現して、
それをうまく処理して下側の数式に相当するオブジェクトを得たい。

.. math::
   :nowrap:

   \begin{eqnarray*}
   \omega &=& a x y z \,dx + b x^2 z \,dy -3 x^2 y \,dz\\
   d \omega &=& (-bx^2 - 3x^2) \,dy \wedge dz + (axy + 6xy) \,dz \wedge dx + (2bxz - axz) \,dx \wedge dy
   \end{eqnarray*}

しかし考えられる二通りの方法を試したところ、どうも所望の出力にならない。
まずは ``Differential`` だけでがんばる。

.. code-block:: ipython

   In [1]: a, b, c = symbols('a b c')

   In [2]: fx = a * R3_r.x * R3_r.y * R3_r.z

   In [3]: fy = b * R3_r.x ** 2 * R3_r.z

   In [4]: fz = -3 * R3_r.x**2 * R3_r.y

   In [5]: omega = fx * R3_r.dx + fy * R3_r.dy + fz * R3_r.dz; omega
   Out[5]: a*x*y*z*dx + b*x**2*z*dy - 3*x**2*y*dz

   In [6]: domega = Differential(omega); domega
   Out[6]: d(a*x*y*z*dx + b*x**2*z*dy - 3*x**2*y*dz)

   In [7]: domega(R3_r.e_x, R3_r.e_y, R3_r.e_z)
   Out[7]: a*x*y - a*x*z - b*x**2 + 2*b*x*z - 3*x**2 + 6*x*y

* [1]-[4] :math:`\mathbb{R}^3` 上の 1-形式 ``omega`` のセットアップ。
* [5] 内容の確認。ちなみに各単項式の次数が一致していることに気付いて欲しい。
* [6] 外微分オブジェクト ``domega`` を生成する。
* [7] 丸括弧評価。ここが期待通りにならない。

期待通りにならない理由は ``Differential()`` の計算ロジックが
``Commutator`` に基づくため wedge 積が出現しないことによる。
そこで手動で ``WedgeProduct`` を適用することで ``omega`` の外微分を求めることを考える。

.. code-block:: ipython

   In [8]: domega2 = WedgeProduct(Differential(fx), R3_r.dx)\
      ...: + WedgeProduct(Differential(fy), R3_r.dy)\
      ...: + WedgeProduct(Differential(fz), R3_r.dz); domega2
   Out[8]: WedgeProduct(d(-3*x**2*y), dz) + WedgeProduct(d(b*x**2*z), dy) + WedgeProduct(d(a*x*y*z), dx)

   In [9]: domega2.rcall(R3_r.e_x, R3_r.e_y, R3_r.e_z)
   Out[9]: 2*a*x*y - 2*a*x*z - 2*b*x**2 + 4*b*x*z - 6*x**2 + 12*x*y

しかし期待は外れた。

* [8] ``omega`` と同じものを表すハズの ``omega2`` をセットアップ。
* [9] 今度は素の丸括弧は効かないので（式全体が単なる ``Add`` オブジェクトだから）、
  代わりに ``rcall`` したものの、結果は悪化している。

  * またも wedge 積オブジェクトが見当たらない。
  * 出力が本来の倍？になっている。おそらく wedge 積の反対称性が加味されていないことによる。

やや高級な機能
======================================================================
再びサブモジュール ``sympy.diffgeom.diffgeom`` に戻り、残りの機能を調べる。

.. todo:: 保留。

.. include:: /_include/python-refs-core.txt
.. include:: /_include/python-refs-sci.txt
