======================================================================
微分幾何
======================================================================
微分幾何に関係する機能を提供するモジュール ``sympy.diffgeom`` に関するメモを記す。

これはふたつのサブモジュール ``diffgeom`` と ``rn`` から構成されている。
理解の都合上、まず ``diffgeom`` に定義されている基礎的な諸クラスを見ていく。
次にサブモジュール ``rn`` で定義されているすべてのオブジェクトを見ていく。
最後に再度 ``diffgeom`` に戻り、残りの（さらに複雑な概念を表現する）諸機能を見ていく。

.. contents:: ノート目次

.. note::

   本文中のすべての IPython セッション中のサンプルコードで、
   以下のインポートが済んでいるものとする。

   .. code-block:: python3

      from sympy.diffgeom import *
      from sympy.diffgeom.rn import *

多様体
======================================================================
本節ではサブモジュール ``sympy.diffgeom.diffgeom`` で定義されている、
多様体を表現するための一連のクラス群について記す。

クラス ``Manifold``
----------------------------------------------------------------------
クラス ``Manifold`` は多様体をオブジェクトとして表現する。

* オブジェクトをコンストラクターから直接生成する。
  名前と多様体次元さえ用意すればよい。
  生成後にそれぞれをメンバーデータ ``name`` および ``dim`` で参照できる。

* メンバーデータ ``patches`` から構成パッチオブジェクトにアクセスできる。
  これは後述する ``Patch`` オブジェクトの ``list`` オブジェクトである。

クラス ``Patch``
----------------------------------------------------------------------
クラス ``Patch`` は多様体オブジェクトの構成要素をオブジェクトとして表現する。

* オブジェクトをコンストラクターから直接生成する。
  この際、名前と自身が所属する ``Manifold`` オブジェクトが必要となる。
  生成後にそれぞれをメンバーデータ ``name`` および ``manifold`` で参照できる。

* メンバーデータ ``coord_systems`` から座標系オブジェクトにアクセスできる。
  これは後述する ``CoordSystem`` オブジェクトの ``list`` オブジェクトである。

* 多様体次元はプロパティー ``dim`` を用いて参照可能。

クラス ``CoordSystem``
----------------------------------------------------------------------
クラス ``CoordSystem`` は多様体パッチのひとつの座標系をオブジェクトとして表現する。

* オブジェクトをコンストラクターから直接生成する。
  座標系の名前と関連付けるパッチオブジェクトが要る。

  * 他にもオプションで ``names`` というのがある。
    これは座標成分の名称を ``list`` で指定することができる。

* 多様体次元はプロパティー ``dim`` を用いて参照可能。

このクラスは特に重要なメソッドが多い。
強いて言えば、座標情報と座標変換に関係するものに分類したい。

座標情報にアクセスするメソッドは次のようなものがある。

``coord_function(coord_index)``, ``coord_functions()``
  点を取り、その点の特定の座標を返す関数オブジェクトを返す。

  * 後述のクラス ``BaseScalarField`` を参照。

  * 単数形の方は ``coord_index`` 番目の座標成分のものに関するそれを返す。
    例えば直交座標系で ``0``, ``1`` はそれぞれ x, y 座標。

  * 複数形の方は全成分を ``list`` で返す。

``base_vector(coord_index)``, ``base_vectors()``
  基底ベクトルを返す。
  後述のクラス ``BaseVectorField`` を参照。

``base_oneform(coord_index)``, ``base_oneforms()``
  基底微分 1-形式を返す。
  後述のクラス ``Differential`` を参照。

座標変換メソッドは次のようなものがある。

``connect_to(to_sys, from_coords, to_exprs, inverse=True, fill_in_gaps=False)``
  当座標系から座標系 ``to_sys`` への座標変換を定義する。

  * 利用例を知るならモジュール ``rn`` を見るのが最良。

``coord_tuple_transform_to(to_sys, coords)``
  この座標系における座標 ``coords`` を指定座標系 ``to_sys`` でのそれに変換する。

  * 戻り値は ``Matrix`` オブジェクトとなる。
    座標を表現するために便宜上この型を用いている。

``point_to_coords(point)``
  既存の（おそらくは別座標系にある）点オブジェクトから、
  この座標系での座標を得る。

  * 戻り値は ``Matrix`` オブジェクトとなる。

``jacobian(to_sys, coords)``
  当座標系から座標系 ``to_sys`` に関する Jacobi 行列を求める。
  先程から ``Matrix`` 型が頻出しているのは、このメソッドとの相性のためだろう。

利用例は後述する。

クラス ``Point``
----------------------------------------------------------------------
多様体パッチ上の一点をオブジェクトとして表現する。

* オブジェクトの生成方法はふたつある。
  このクラスのコンストラクターから直接生成する方法と、
  クラス ``CoordSystem`` のメソッド ``point`` を呼ぶ方法だ。

  * 直接生成の場合、座標系オブジェクトと座標を要する。
    前者はもちろん ``CoordSystem`` オブジェクトであり、
    後者は単に座標成分を ``list`` で渡せばよい。

  * メソッド ``CoordSystem.point`` の場合は座標成分だけあればよい。

* メソッド ``coords`` を用いれば、この点の座標系が得られる。

  * オプションとして別の座標系 ``to_sys`` を与えると、
    座標変換後の座標を得ることも可能だ。
    これには前述のクラス ``CoordSystem`` のメソッド ``coord_tuple_transform_to`` が用いられる。

スカラー場、ベクトル場、外微分
======================================================================
こちらも利用例は後述することにする。

クラス ``BaseScalarField``
----------------------------------------------------------------------
多様体上のスカラー場をオブジェクトとして表現するための基になるクラス。

* コンストラクターでオブジェクトを生成する場合、
  ``CoordSystem`` オブジェクトと座標成分番号 ``i`` を指定する。

  例えば 3 次元直交座標系の y 成分 (``i = 1``) スカラー場を生成する、
  というような構成をする。

* 丸括弧で評価するときの引数は ``Point`` オブジェクトである。
  点オブジェクトは任意の座標系で表現されていて構わない。
  戻り値はスカラーだが、座標系の第 ``i`` 成分に相当する値を示す。

* ``BaseScalarField`` オブジェクトを（算術演算等で）組み合わせて、
  単に座標成分を返すだけでない、より一般的なスカラー場を構成することもできる。

クラス ``BaseVectorField``
----------------------------------------------------------------------
このクラスが表現するのは接ベクトルの基底だと思われる。
つまり接ベクトル :math:`\sum_{i=0} a_i \left(\frac{\partial}{\partial x_i}\right)_p` の
:math:`\frac{\partial}{\partial x_i}` の部分を表現している。

このクラスはベクトル場を表現するための素材に過ぎない。
ベクトル場自体を表現するものではない。

* コンストラクターでオブジェクトを生成する方法は ``BaseScalarField`` と同じだ。
  座標系とどの座標成分に関するものなのかを指定する。

* 丸括弧で評価するときの引数と戻り値の型は両方ともスカラー的な値である。
  ある点 ``p`` における座標成分 ``i`` に関する方向微分を得るには、
  基底接ベクトル ``vi`` を生成した後、結果的に二段階評価を行う。
  すなわち ``vi(f).rcall(p)`` である。

  * 見慣れぬ ``rcall`` は丸括弧のようなものなので、気にしないでよい。

  * このクラスのオブジェクトを「線形結合」することはできでも、
    その型が単なる SymPy の ``Add`` オブジェクトに過ぎないので、
    「接ベクトル」に丸括弧をつけて評価することができない。
    丸括弧の代わりに ``rcall()`` を用いる。

クラス ``Commutator``
----------------------------------------------------------------------
ふたつのベクトル場の交換子を表現する。

* ``Commutator(v1, v2)`` は :math:`v_1(v_2(f)) - v_2(v_1(f))` で定義されるベクトル場を意味する。
  ``f`` は多様体上のスカラー場。

  * 丸括弧で ``f`` を評価する前に、交換子オブジェクトがゼロでないことを確認する必要がある。

* ドキュメントにあるように、現行の実装は少々弱いようだ。
  展開し切れないケースがままある。

クラス ``Differential``
----------------------------------------------------------------------
クラス ``Differential`` は k-形式を外微分したものをオブジェクトとして表現する。

* コンストラクターには k-形式として扱えるオブジェクトを渡す。

  * 既存の ``Differential`` オブジェクトでもかまわないが、結果的にゼロが返る。

  * 先述したメソッド ``CoordSystem.base_oneforms`` が返すのは
    0-形式 ``f_i = BaseScalarField(coord, i)`` の外微分となる
    1-形式 ``Differential(f_i)`` をすべての ``i`` 成分について生成したものに他ならない。

  * 実数値関数 ``f`` からは全微分 ``df`` が得られる。
    任意のベクトル ``v`` について ``df(v) == v(f)`` が成り立つ。

* 丸括弧で評価する際のオペランドはスカラー関数オブジェクトまたは「接ベクトル」でよい。
  今度は ``BaseVectorField`` オブジェクトの線形結合で通じるし、
  オブジェクトを次元個分カンマ区切りで可変個引数的に渡してもよい。
  同じ結果が得られると期待してよろしい。

* 実装に ``Commutator`` を用いる。

クラス ``TensorProduct``
----------------------------------------------------------------------
クラス ``TensorProduct`` は k-形式のテンソル積を表現するクラス。

* コンストラクターの引数は k-形式オブジェクトである。複数個渡してよい。

  * 言い忘れたが、k-形式として認められる型はだいたい次のような感じらしい。

    * 定数
    * ``Function`` オブジェクト
    * ``BaseScalarField`` オブジェクト
    * ``Differential`` オブジェクト

* 丸括弧の引数はベクトル場オブジェクトである。
* 戻り値の型もまた ``TensorProduct`` であるのだが、
  状況により ``Mul`` になったり、あるいは定数になったりする。
  このときは丸括弧は使えない。

クラス ``WedgeProduct``
----------------------------------------------------------------------
クラス ``WedgeProduct`` は k-形式の wedge 積を表現するクラス。

* スーパークラスは ``TensorProduct`` だが、混ぜて使わないこと。
  前項で注意した点がそのまま当クラスの注意点でもある。

* 積分の文脈上に限り、反対称 k-形式がまともに扱われるとのこと。
  この注意は、例えば

  * ``WedgeProduct(X, X)`` のようなオブジェクトを生成しても、直ちにゼロと評価されたりしない
  * ``WedgeProduct(X, Y)`` と ``-WedgeProduct(Y, X)`` が等しくならない

  という現象を説明するものだろうか。

定義済み多様体オブジェクト
======================================================================
本節ではサブモジュール ``sympy.diffgeom.rn`` に定義されているオブジェクトを見ていく。

前節で述べた一連の機能をすぐに試したいが、オブジェクト生成が面倒で困る。
そこで、ここにある定義済みオブジェクトをインポートすることが考えられる。
それらのオブジェクトを試して、感触を確かめるのがよいだろう。

==================== ==================== ==================== ========================================
オブジェクト         クラス               名前                 意味
==================== ==================== ==================== ========================================
``R2``               ``Manifold``         ``'R^2'``            :math:`\mathbb{R}^2`
``R2_origin``        ``Patch``            ``'origin'``         ``R2`` のパッチ
``R2_r``             ``CoordSystem``      ``'rectangular'``    ``R2_origin`` の直交座標系
``R2_p``             ``CoordSystem``      ``'polar'``          ``R2_origin`` の極座標系
``R3``               ``Manifold``         ``'R^3'``            :math:`\mathbb{R}^3`
``R3_origin``        ``Patch``            ``'origin'``         ``R3`` のパッチ
``R3_r``             ``CoordSystem``      ``'rectangular'``    ``R3_origin`` の直交座標系
``R3_c``             ``CoordSystem``      ``'cylindrical'``    ``R3_origin`` の円柱座標系
``R3_s``             ``CoordSystem``      ``'spherical'``      ``R3_origin`` の球座標系
==================== ==================== ==================== ========================================

2 次元オブジェクト
----------------------------------------------------------------------
``R2``, ``R2_origin``, ``R2_r``, ``R2_p`` には可能な限り次に示すメンバーデータが付与されている。
可能な限りというのは「座標系 A 由来のデータは座標系 B には付与しない」という意味だ。

``x``, ``y``
  ``R2_r.coord_functions()`` から値を設定。

``e_x``, ``e_y``
  ``R2_r.base_vectors()`` から値を設定。

``dx``, ``dy``
  ``R2_r.base_oneforms()`` から値を設定。

``r``, ``theta``
  ``R2_p.coord_functions()`` から値を設定。

``e_r``, ``e_theta``
  ``R2_p.base_vectors()`` から値を設定。

``dr``, ``dtheta``
  ``R2_p.base_oneforms()`` から値を設定。

座標成分 ``x``, ``y``, ``r``, ``theta`` は次の座標変換が（微妙な点もあるが）
成り立つように相互に ``connect_to`` している。
数式中の逆三角正接関数は SymPy では関数 ``atan2`` である。

.. math::

   \begin{eqnarray*}
   T_{rp}&:& (x, y) \mapsto (\sqrt{x^2 + y^2}, \tan^{-1} \frac{y}{x})\\
   T_{pr}&:& (r, \theta) \mapsto (r \cos \theta, r \sin \theta)
   \end{eqnarray*}

3 次元オブジェクト
----------------------------------------------------------------------
``R3`` 側でも同様の考えの下に、
各オブジェクトに座標成分、基底ベクトル、微分 1-形式のメンバーデータが付与されて、
関連する 3 座標系の間に相互に座標変換が定義されている。

以下、座標変換だけ記す。
直交座標系と円柱座標系間の座標変換は次のように与えられている。

.. math::

   \begin{eqnarray*}
   T_{rc}&:& (x, y, z) \mapsto (\sqrt{x^2 + y^2}, \tan^{-1} \frac{y}{x}, z)\\
   T_{cr}&:& (\rho, \psi, z) \mapsto (\rho \cos \psi, \rho \sin \psi, z)
   \end{eqnarray*}

直交座標系と球座標系間の座標変換は次のように与えられている。

.. math::

   \begin{eqnarray*}
   T_{rs}&:& (x, y, z) \mapsto (\sqrt{x^2 + y^2 + z^2}, \cos^{-1} \frac{z}{\sqrt{x^2 + y^2 + z^2}}, \tan^{-1} \frac{y}{x})\\
   T_{sr}&:& (r, \theta, \phi) \mapsto (r \sin \theta \cos \phi, r \sin \theta \sin \phi, r \cos \theta)
   \end{eqnarray*}

円柱座標系と球座標系間の座標変換は次のように与えられている。

.. math::

   \begin{eqnarray*}
   T_{cs}&:& (\rho, \psi, z) \mapsto (\sqrt{\rho^2 + z^2}, \cos^{-1} \frac{z}{\sqrt{\rho^2 + z^2}}, \psi)\\
   T_{sc}&:& (r, \theta, \phi) \mapsto (r \sin \theta, \phi, r \cos \theta)
   \end{eqnarray*}

.. todo:: 各オブジェクトで色々なメソッドを試す。

   * coord_tuple_transform_to/point_to_coords  による座標変換の例（つまらない）
   * jacobian の例。これは欲しい。
   * coord_functions による座標変換の一成分のみ。
   * base_vector(i)(coord_function(j)) の例
   * base_vector(i)(base_vector(i)(coord_function(j))) の例
   * base_oneform(i)(base_vector(j)) の例

やや高級な機能
======================================================================
再びサブモジュール ``sympy.diffgeom.diffgeom`` に戻り、残りの機能を調べる。

.. todo:: ここは難しい。しかし進める。

.. include:: /_include/python-refs-core.txt
.. include:: /_include/python-refs-sci.txt
