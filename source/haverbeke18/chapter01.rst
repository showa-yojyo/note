======================================================================
Values, Types, and Operators
======================================================================

他の高級言語と JavaScript の違いに注目すればいいだろう。

.. contents::

* 計算機はデータではないものは言及できない。
* どんな離散的な情報でも、0 と 1 の列に還元することができる。

Values
======================================================================

この章では、JavaScriptのプログラムを構成する要素、つまり
つまり、単純な値の型と、そのような値に作用する演算子を紹介する。

* 大量のビットを迷うことなく扱うためには、ビットを情報の断片を表すチャンクに分けなければならない。
  それを値と呼ぶことにする。
* 値を作成するには、単にその名前を呼び出すだけでよい。

Numbers
======================================================================

本文の記述によると、整数も浮動小数点数も同じ型で表されるらしい。

* JavaScript では、一つの数値を格納するのに 64 ビットを使う。
* 古い時代の計算機では、与えられたビット数に収まらない数字が誤ってオーバーフローさせてしまうことがあった。
* オーバーフローを心配する必要があるのは、本当に天文学的な数字を扱うときだけだ。
* 64 ビットのうち 1 ビットが数字の符号（正負）を表すのに使われる。
* さらに大きな問題は、整数ではない数字も表現しなければならないことです。
* 64 ビットの一部を使って小数点の位置が保持される。
* 実際に格納できる最大の整数は、:math:`10^{15}` 程度だ。
* 絶対値がひじょうに大きいか小さい数には、他の言語のように科学的記数法を使用することもできる。
  ``e`` を付け、その後に指数を付ける。
* 小数を使った計算は一般的に正確ではない。
* 多くの数字は精度が落ちる。

Arithmetic
----------------------------------------------------------------------

* 記号 ``+``, ``*`` は演算子と呼ばれている。掛け算が先に行われます。
* 数学の記法のように、丸括弧で優先度を明示することができる。
* 同じ優先順位を持つ複数の演算子が隣り合っている場合、それらは左結合的に作用する。
* 余剰演算子 ``%`` の優先順位は、乗算 ``*`` や除算 ``/`` の優先順位と同じ。

Special numbers
----------------------------------------------------------------------

JavaScript には特別な「数」が三つある。

* ``Infinity`` と ``-Infinity`` で、正と負の無限大を表す。
* ``NaN`` とは not a number の略で、数値型の値であるにもかかわらず、「数字ではない」というものだ。
  例えば ``0 / 0``, ``Infinity - Infinity`` を評価すると生じる。

Strings
======================================================================

バッククォートの仕様だけ注意。他の引用符ではダメらしい。

.. code:: javascript

    `half of 100 is ${100 / 2}`
    // → "half of 100 is 50"

* 文字列は、その内容を引用符で囲んで記述する。
  文字列の最初と最後の引用符が一致していれば、文字列をマークするのに

  * シングルクォート、
  * ダブルクォート、
  * バッククォートを使うことができる。

* 他言語のように文字をエスケープするという考え方がある。方法も同じ。
* Unicode 標準に基づいて文字列をモデル化している。
  すべての文字に番号がついていれば、文字列は番号の列で表現できる。
* 文字列は分割、乗算、減算することはできないが、二項演算子 ``＋``
  を使うことができます。これは足し算ではなく、二つの文字列を連結する。
* バッククォートで囲まれた文字列は、通常、テンプレートリテラルと呼ばれる。
  テンプレートリテラルの ``${}`` 内に何かを書くと、その結果が計算され、文字列に変換されて、その位置に置かれる。

Unary operators
======================================================================

サンプルコードでは ``console.log()`` を使って、何かを評価した結果を示す。

* 演算子 ``typeof`` は、与えられた値の型を示す文字列を返す。
* マイナス演算子は、二項演算子としても一項演算子としても使用できる。

  * プラスは？

Boolean values
======================================================================

JavaScript にはブール型が用意されており、``true`` と ``false`` の二つの値しか持たない。

Comparison
----------------------------------------------------------------------

* 文字を比較する際、文字を左から右へと並べ、Unicode におけるコードポイントを一つずつ比較していく。
* JavaScript では、自分自身と等しくない値が一つだけあり、それが ``NaN`` だ。
* ``NaN`` は意味のない計算の結果を表すことになっており、したがって普通の計算結果とは等しくならない。

Logical operators
----------------------------------------------------------------------

論理演算子はブール値に作用する演算子だ。

* これまで見てきた演算子の中で、``||`` が最も優先順位が低く、次に
  ``&&``, 比較演算子、そしてその他の演算子が続くことを知っていれば、たいていの場合は大丈夫。
* C/C++ と同様の三項演算子がある。

Empty values
======================================================================

* ``null`` と ``undefined`` という二つの特別な値がある。どちらも意味のある値がないことを表す。
* 意味のある値を生成しない言語の操作の多くは何らかの値を生成しなければならないという理由で ``undefined`` を返す。
* これらをほとんど交換可能なものとして扱うことをお勧めする。

Automatic type conversion
======================================================================

* 演算子が「間違った」型の値に適用された場合、JavaScript はその値を必要とする型に暗黙的に変換するが、
  これを「型強制」という。多くの場合は、期待されるものにはならない。
* 二項演算子 ``+`` は数値の加算よりも文字列の連結を優先する。
* 思わぬところで ``NaN`` が出てきたら、誤った型変換が行われていないか確認すること。
* 二項演算子のどちらか側に ``null`` や ``undefined`` が存在する場合、
  両方の側が ``null`` または ``undefined`` のどちらかである場合にのみ ``true`` を返す。
* 型変換をさせたくない場合は、さらに次の演算子がある：

  * ``===``
  * ``!==``

* 予想外の型変換で躓かないように、三文字の比較演算子を防御的に使うことをお勧めする。

Short-circuiting of logical operators
----------------------------------------------------------------------

* C/C++ などと同様に、論理演算 ``||``, ``&&`` は短絡評価を行う。
* 条件演算子も似たような働きする。

Summary
======================================================================

* ``Infinity``, ``-Infinity``, ``Nan`` を理解する。
* ``null``, ``undefined`` を理解する。
* 比較演算子 ``===``, ``!==`` を使うようにする。
