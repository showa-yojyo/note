======================================================================
GLSL 4.60 仕様書 読書ノート 4 of ?
======================================================================

.. contents:: ノート目次

4. Variables and Types
======================================================================

.. note::

   原文の英語を、次のように機械的に単語を日本語に読み換える：

   * aggregate: 集約、集約型
   * composite: 合成～
   * opaque: 不透明～
   * storage: 格納～、収納～

   その他、定訳がない単語についてはカタカナ表記という手抜きをする。

変数と関数はすべて使用する前に宣言する必要がある。変数や関数の名前とは識別子だ。

既定の型はない。変数と関数の宣言にはすべて、宣言された型が必要で、修飾子がオプションだ。
変数を宣言するには、型を指定した後、カンマで区切って一つ以上の名前を指定する。
多くの場合、代入演算子 ``=`` を使って、宣言の一部として変数を初期化することができる。

ユーザー定義型は、既存の型のリストを一つの名前に集約するために ``struct`` を使って定義することができる。

OpenGL Shading Language は型安全だ。型の間には暗黙の変換がある。
どのような場合にどのような変換が行われるかについては、
:ref:`4.1.10. Implicit Conversions` で述べられ、本仕様書の他の項からも参照されている。

.. admonition:: 感想

   おそらく仕様を C/C++ に寄せている。

4.1. Basic Types
----------------------------------------------------------------------

* **基本型** (a basic type) とは当言語のキーワードにより定義されている型だ。
* OpenGL Shading Language では、以下のように基本型を分類している：

  * Transparent Types
  * Floating-Point Opaque Types
  * Signed Integer Opaque Types
  * Unsigned Integer Opaque Types
  * Sampler Opaque Types

  これに加え、これらの基本型を配列や構造体を使って集約し、
  より複雑な型を構築することができる。

* ポインター型はない。
* 本仕様書では、集約型 (an aggregate) は構造体や配列を意味する。

  * 行列やベクトルはそれ自体は集約型ではない。
  * 集約型、行列、ベクトルを総称して **合成** (composites) と呼ぶ。

4.1.1. Void
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

値を返さない関数は ``void`` として宣言しなければならない。既定の戻り値の型はない。
キーワード ``void`` は他の宣言では使用できない（空の仮引数リストや実引数リストを除く）。
さもないとコンパイルエラーになる。

4.1.2. Booleans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**真偽型** (a boolean type) とは ``bool``, ``bvec2``, ``bvec3``, ``bvec4`` の任意のいずれかだ。

* コードの条件付き実行を表現しやすくするために、真偽型をサポートしている。
* ハードウェアがこの型の変数を直接サポートすることは想定していない。
* これは本物の真偽型であり、真か偽かの二つの値のうちただ一つを保持する。
* キーワード ``true`` と ``false`` がリテラルな定数として使用できる。
* 条件付きジャンプ (``if``, ``for``, ``? :``, ``while``, ``do``-``while``) に使われる式は
  真偽型に評価されなければならない。

4.1.3. Integers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**整数型** (an integral type) とは、符号付き、符号なし、スカラー、ベクトル整数型のことだ。
配列や構造体は含まれない。

**スカラー整数型** (a scalar integral type) とは、符号付きまたは符号なし整数型のスカラーだ。

**ベクトル整数型** (a vector integral type) とは、符号付きまたは符号なしの整数のベクトルだ。

----

* 符号付きおよび符号なしの整数変数が完全にサポートされている。
  この文書では、整数という言葉は、符号付き整数と符号なし整数の両方を一般的に意味する。
* OpenGL では、符号なし整数は正確に 32 ビットの精度を持つ。
* OpenGL では、符号付き整数は、符号ビットを含む 32 ビットを 2 の補数形式で使用する。
* 加算、減算、および乗算でオーバーフローまたはアンダーフローが発生した場合は、
  正しい結果 R の低次 32 ビットが得られる。ここで R はオーバーフローまたは
  アンダーフローを回避するのに十分な精度で計算される。
  オーバーフローの結果となる除算は、未定義の値となる。

----

C 言語と同様にしてリテラル整数定数を十進数、八進数、16 進数で表すことができる。

ビットパターンが 32 ビットに収まらないリテラル整数を用意すると、コンパイルエラーになる。
リテラルのビットパターンは常に変更されずに使用される。そのため、
ビットパターンに符号ビットが設定されている符号付きリテラルは負の値を生じる。

.. admonition:: コメント

   仕様書の例をよく見ておくこと。例えば ``-1u`` はどんな値であるか言えるようになること。

4.1.4. Floats
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一般に、浮動小数点という言葉は、単精度浮動小数点と倍精度浮動小数点の両方を指す。

浮動小数点変数は、以下の例のように定義される：

.. code:: glsl

   float a, b = 1.5; // single-precision floating-point
   double c, d = 2.0LF; // double-precision floating-point

* いずれかの処理ユニットへの入力値として、単精度または倍精度の浮動小数点変数は、
  精度とダイナミック・レンジについて、対応する IEEE 754 浮動小数点定義と一致することが期待される。
  シェーダー内の浮動小数点変数も、単精度浮動小数点値の IEEE 754 仕様に従って符号化される
  （物理的には必ずしもそうではないが、論理的には）。
* 符号化は論理的には IEEE 754 だが、演算は必ずしも IEEE 754 の要求通りには行われない。
  精度や NaN, Inf の使い方の詳細については :ref:`4.7.1. Range and Precision` を参照。

----

* 指数部が存在する場合は、小数点 ``.`` は必要ない。
* 接尾辞の前も含め、浮動小数点定数の中には空白を入れてはいけない。
* トークン化の際には、仕様書の BNF による定義に合致する最大のトークンが認識されてから新しいトークンが開始する。
* 接尾辞 ``lf`` または ``LF`` がある場合、リテラルの型は ``double`` だ。
  それ以外の場合、リテラルは ``float`` 型だ。
* 先頭の単項マイナス記号 ``-`` は単項演算子として解釈され、浮動小数点定数の一部ではない。

.. admonition:: コメント

   浮動小数点数とダイナミックレンジの関係を別途理解しておくこと。

4.1.5. Vectors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

浮動小数点値、整数値、真偽値の 2, 3, 4 成分それぞれの汎用ベクトルのデータ型がある。

* 浮動小数点ベクトル変数は、色、法線、位置、テクスチャー座標、テクスチャー検索結果などを格納するのに使用できる。
* 真偽値のベクトルは、数値のベクトルの成分ごとの比較に使用できる。

.. code:: glsl

   vec2 texcoord1, texcoord2;
   vec3 position;
   vec4 myRGBA;
   ivec2 textureLookup;
   bvec3 less;

ベクトルの初期化はコンストラクターで行う。
:ref:`5.4.2. Vector and Matrix Constructors` に記述がある。

4.1.6. Matrices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2×2, 2×3, 2×4, 3×2, 3×3, 3×4, 4×2, 4×3, 4×4 の浮動小数点数の行列の型が組み込まれている。

* ``mat`` で始まる行列型は単精度成分を持ち、
* ``dmat`` で始まる行列型は倍精度成分を持つ。
* 型の最初の数字は列数、二番目の数字は行数をそれぞれ表す。数字が一つしかない場合、それは正方行列だ。

.. code:: glsl

   mat2 mat2D;
   mat3 optMatrix;
   mat4 view, projection;
   mat4x4 view; // an alternate way of declaring a mat4
   mat3x2 m; // a matrix with 3 columns and 2 rows
   dmat4 highPrecisionMVP;
   dmat2x4 dm;

行列の値の初期化は、コンストラクターを用いて、列優先順 (column-major order) で行われる。

.. admonition:: コメント

   行列コンストラクターには列ベクトルを渡すような書き方をする。
   ただし、テキストエディター上では列ベクトルの要素を一行で書くことになるはずだから、
   そこで混乱しないようにする。

4.1.7. Opaque Types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**不透明型** (an opaque type) とは、型であって、その内部構造が言語から隠されているものだ。

----

不透明型は他のオブジェクトへの不透明なハンドルとなる変数を宣言する。
これらのオブジェクトは、宣言された変数を直接読み書きするのではなく、
組み込み関数を通してアクセスされる。
これらのオブジェクトは、関数の引数または ``uniform`` 修飾された変数としてしか宣言できない。
メモリー修飾子を取る不透明な型は ``image`` 型だけだ。
配列の添字、構造体のメンバーの選択、括弧を除き、
不透明変数は式のオペランドになることはできず、そのような使い方をするとコンパイルエラーになる。

不透明な変数は左辺値として扱うことができない。
したがって、``out`` または ``inout`` の関数引数として使用することも、代入することもできない。
このような使い方をすると、コンパイルエラーになる。
ただし、型とメモリー修飾子が一致する ``in`` 引数として渡すことは可能だ。
また、初期化子を付けて宣言することはできない。

単一の不透明型宣言ではハンドル自身と、そのハンドルとなるオブジェクトの二つのオブジェクトが効果的に宣言されるため、
格納修飾子とメモリー修飾子の両方を使用する余地がある。
格納修飾子は不透明ハンドルを修飾し、
メモリー修飾子はハンドルであるオブジェクトを修飾する。

Texture-Combined Samplers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

テクスチャー混合採取器型 (texture-combined sampler types) とは、
:ref:`4.1 Basic Types` の表（注：仕様書の本物を参照）に記載されている、
テクスチャーにアクセスするためのハンドルとなる採取器型のことだ。

* ``sampler`` や ``samplerShadow`` は含まれない。

テクスチャー対象ごとに、また、``float``, ``integer``, ``unsigned integer`` の
各データ型ごとに、異なるテクスチャー混合採取器型がある。
テクスチャーへのアクセスは、内蔵のテクスチャー関数 (TODO: link 8.9) を使って行われるが、
どのテクスチャーにアクセスするか、またどのようにフィルターリングするかを指定するために、
テクスチャー混合採取器型が使われる。

テクスチャー混合採取器型は不透明型で、前述の不透明型と同様に宣言され、動作する。
シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

Images
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

画像型は不透明型で、上記の不透明型と同様に宣言され、動作する。
さらにメモリー修飾子で修飾することができる。
シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

画像変数は、画像単位に束縛されたテクスチャー画像の単一レベルのすべてまたは一部に対応する
1, 2, 3 次元のいずれかの画像のハンドルだ。

画像変数はテクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の各データ型ごとに、異なる型がある。
画像へのアクセスは、レベルが画像単位に束縛されているテクスチャーの対象に一致する画像型を使用する必要がある。
もしくは、3D または配列画像の非レイヤー束縛の場合は、画像のレイヤーの次元に一致する画像型を使用する必要がある。

* つまり、3D, 2DArray, Cube, CubeArray のレイヤーは ``image2D`` を使用し、
* 1DArray のレイヤーは ``image1D`` を使用し、
* 2DMSArray のレイヤーは ``image2DMS``

をそれぞれ使用する必要がある。
このように画像対象型が束縛された画像と一致しない場合、データ型が束縛された画像と一致しない場合、
フォーマットレイアウト修飾子が OpenGL 仕様の 8.25 Texture Image Loads and Stores
に記載されている画像単位フォーマットと一致しない場合、画像アクセスの結果は未定義となるが、
プログラムの終了を含むことはできない。

画像変数は :ref:`8.12. Image Functions` で記述されている画像のロード、格納、原子関数において、
アクセスする画像を指定するために用いられる。

Atomic Counters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

原子カウンター型とは、カウンターへの不透明なハンドルであって、
前述の不透明型と同様に宣言され、動作するものだ。
宣言された変数は、:ref:`8.10. Atomic Counter Functions` で記述がある、組み込みの原子カウンター関数を使用するときに、
どのカウンターにアクセスするかを指定する。
また、:ref:`4.4.7. Atomic Counter Layout Qualifiers` で記述があるように、バッファーに束縛される。

シェーダー内の配列に集約された原子カウンターは、動的一様な整数式でしかインデックスを付けることができない。
そうでない場合、結果は未定義だ。

構造体のメンバーは原子カウンター型として宣言できない。

Texture, sampler, and samplerShadow Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Textures can be combined with a variable of type sampler or samplerShadow to create a texture-combined sampler type (e.g., sampler2D, or sampler2DShadow). This is done with a constructor, e.g., sampler2D(texture2D, sampler), sampler2DShadow(texture2D, sampler), sampler2DShadow(texture2D, samplerShadow), or sampler2D(texture2D, samplerShadow) and is described in more detail in section 5.4 "Constructors".

テクスチャー、採取器、samplerShadow 型は不透明型で、上記の不透明な型と同様に宣言され、動作する。
シェーダー内で配列に集約されている場合、これらの型は動的一様な式でしかインデックスを付けることができない。
そうしないとテクスチャー検索は未定義の値になる。

テクスチャー変数は、:ref:`4.1 Basic Types` の表に列挙されている一次元、二次元、三次元のテクスチャー、キューブマップなどのハンドルだ。
テクスチャー型は、テクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の各データ型ごとに異なる。

テクスチャーは、採取器型または samplerShadow 型の変数と組み合わせて、
テクスチャーを混合した採取器型 (``sampler2D``, ``sampler2DShadow``, etc.) を作ることができる。
これはコンストラクターで行う。例えば、

* ``sampler2D(texture2D, sampler)``,
* ``sampler2DShadow(texture2D, sampler)``,
* ``sampler2DShadow(texture2D, samplerShadow)``,
* ``sampler2D(texture2D, samplerShadow)``

などだ。詳細は :ref:`5.4. Constructors` で述べる。

Subpass Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

サブパス入力型（例：``subpassInput``）は不透明型で、上記の不透明型と同様に宣言され、動作するものだ。
シェーダ内ーで配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

サブパス入力型は、二次元の単一採取または複数採取された画像を扱うもので、
``float``, ``integer``, ``unsigned integer`` のデータ型ごとに異なる型がある。

サブパス入力型は、フラグメントシェーダーでのみ利用可能だ。他の段階での使用はコンパイルエラーとなる。

.. admonition:: コメント

   名詞 subpass の概念がわからないので、それまでこのままにしておく。

4.1.8. Structures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++ 言語の構造体 ``struct`` と同じようなことができる：

.. code:: glsl

   struct light {
       float intensity;
       vec3 position;
   } lightVar;

   light lightVar2;

ただし、C/C++ のそれよりは弱い：

* 構造体には少なくとも一つのメンバー宣言が必要。
* メンバー宣言には精度修飾子を付けることができるが、それ以外の修飾子を使用するとコンパイルエラー。
* ビットフィールドはサポートされていない。
* メンバー型はすでに定義されている必要がある（前方参照不可）。
* メンバー宣言に初期化子が含まれているとコンパイルエラー。
* メンバー宣言には、配列を含めることができる。配列にはサイズが指定されていなければならない。
  サイズはゼロより大きい定数の整数表現でなければならない
  (:ref:`4.3.3. Constant Expressions`)。
* 各レベルの構造体は、メンバー宣言子で指定された名前に対して独自の名前空間を持つ。
  このような名前は、その名前空間内で一意であればよい。
* 匿名構造体はサポートされていない。
* 埋め込み構造体の定義はサポートされていない。コンパイルエラーになる。

  .. code:: glsl

     struct S { float f; };

     struct T {
         S;              // Error: anonymous structures disallowed
         struct { ... }; // Error: embedded structures disallowed
         S s;
     };

* 構造体をコンストラクターを使用して宣言時に初期化することができる
  (:ref:`5.4.3. Structure Constructors`)。
* 型や修飾子の使用に関するあらゆる制限は、その型や修飾子のメンバーを含むすべての構造体にも適用される。
  これは、構造体である構造体メンバーにも再帰的に適用される。

4.1.9. Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

細かいことが色々と仕様化されている。

* 同じ型の変数は、名前の後に大括弧 ``[ ]`` でそのサイズを囲んで宣言することで、配列に集約することができる。
* 宣言の中で配列のサイズを指定する場合、それはゼロより大きい定数整数式
  (:ref:`4.3.3. Constant Expressions`) でなければならない。
* シェーダー格納ブロック (:ref:`4.3.9. Interface Blocks`) の最後に宣言されたメンバーを除き、
  配列のサイズは、一定の整数式以外でインデックスを付ける前に宣言 (explicitly sized) しなければならない。
* 任意の配列のサイズは、それを関数の引数として渡す前に宣言しなければならない。
  これらの規則に違反すると、コンパイルエラーが発生する。
* サイズを指定しないで配列を宣言 (unsized) し、後で同じ名前の配列を同じ型の配列として再宣言してサイズを指定するか、
  定数整数式のみでインデックスを付ける (implicitly sized) ことは適法だ。
  ただし、特に断りのない限り、ブロックを再宣言することはできない。
* ユーザーが宣言したブロック内のサイズのない配列メンバーは、
  ブロックの再宣言によってサイズを変更することはできない。
* サイズを指定して配列を宣言し、後で（同じシェーダー内で）宣言されたサイズ以上の定数整数式で同じ配列をインデックスするとコンパイルエラー。
* サイズのない配列を再宣言して、その配列のインデックスとしてシェーダ内で以前に使用されたインデックスと同等かそれ以下のサイズにすることは、コンパイルエラー。
  また、負の定数式で配列をインデックスすることもコンパイルエラー。
* 関数宣言で仮引数として宣言された配列は、サイズを指定しなければならない。
* 配列のサイズ以上、または 0 未満の非定数式で配列をインデックスすると、未定義の動作となる。
* 配列は一次元しか持たないが、配列の配列を宣言することができる。
* すべての型（基本型、構造体、配列）を配列にすることができる。

----

すべての配列は本質的に同質 (homogeneous) であり、すべて同じ型とサイズの要素で構成されているが、
例外が一つある。サイズのない配列を最後のメンバーとして持つシェーダー格納ブロックだ (runtime-sized)。
このようなシェーダー格納ブロックからは、格納ブロックの最後のメンバーの長さが異なっていたとしても、配列を形成することができる。

.. code:: glsl

   float frequencies[3];
   uniform vec4 lightPosition[4];
   light lights[];
   const int numLights = 2;
   light lights[numLights];

   // a shader storage block, introduced in section 4.3.7 "Buffer Variables"
   buffer b {
       float u[]; // an error, unless u gets statically sized by link time
       vec4 v[];  // okay, v will be sized dynamically, if not statically
   } name[3];     // when the block is arrayed, all u will be the same size,
                  // but not necessarily all v, if sized dynamically

----

配列型は、非配列型の後に配列指定子を指定することで形成できる。
このような配列指定子の次元すべてにサイズを含める必要がある。

.. code:: glsl

   float[5]    // an array of size [5] of float
   float[2][3] // an array of size [2][3] of float, not size [3] of float[2]

この型は、他の型が使用できる場所であればどこでも使用できる。関数からの戻り値であってもいい：

.. code:: glsl

   float[5] foo() { }

配列のコンストラクターとして：

.. code:: glsl

   float[5](3.4, 4.2, 5.0, 5.2, 1.1)

名前なし引数として：

.. code:: glsl

   void foo(float[5])

または変数や関数の引数パラメータを宣言する手段の代わりとしても使用できる。

.. code:: glsl

   float[5] a;

----

配列は、配列コンストラクターから形成される初期化子を持つことができる：

.. code:: glsl

   float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1);
   float a[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1);  // same thing

----

配列の配列を宣言することができる：
次の宣言はどれも ``vec4`` の長さ 2 の一次元配列の長さ 3 の一次元配列だ。

.. code:: glsl

   vec4 a[3][2]; // size-3 array of size-2 array of vec4
   vec4[2] a[3]; // size-3 array of size-2 array of vec4
   vec4[3][2] a; // size-3 array of size-2 array of vec4

透過的なメモリー（uniform block など）では、最内周（宣言では右端）の次元が
外周の次元よりも速く反復されるレイアウトになっている。
上記の配列の場合、メモリー上の順序は次のようになる：

.. code:: text

   Low address : a[0][0] : a[0][1] : a[1][0] : a[1][1] : a[2][0] : a[2][1] : High address

----

コンストラクターと名前なしの引数の両方に必要な ``a`` の型は ``vec4[3][2]`` となる：

.. code:: glsl

   vec4 b[2] = vec4[2](vec4(0.0), vec4(0.1));
   vec4[3][2] a = vec4[3][2](b, b, b); // constructor
   void foo(vec4[3][2]); // prototype with unnamed parameter

初期化子リスト構文を使って配列の配列を初期化することもできる：

.. code:: glsl

   vec4 a[3][2] = { vec4[2](vec4(0.0), vec4(1.0)),
                    vec4[2](vec4(0.0), vec4(1.0)),
                    vec4[2](vec4(0.0), vec4(1.0)) };

----

サイズなし配列を宣言時に初期化子で明示的にサイズを指定することができる：

.. code:: glsl

   float a[5];
   ...
   float b[] = a;  // b is explicitly size 5
   float b[5] = a; // means the same thing
   float b[] = float[](1,2,3,4,5); // also explicitly sizes to 5

しかし、サイズなし配列に代入するのはコンパイルエラーとなる。
これは、初期化子と代入が異なるセマンティクスを持っているように見えるまれなケースだ。
配列の配列では、サイズなし次元は初期化子によってサイズが明示的に決まる：

.. code:: glsl

   vec4 a[][] = { vec4[2](vec4(0.0), vec4(1.0)), // okay, size to a[3][2]
                  vec4[2](vec4(0.0), vec4(1.0)),
                  vec4[2](vec4(0.0), vec4(1.0)) };

----

配列は ``length()`` メソッドを使って含まれる要素の数を取得できる：

.. code:: glsl

   float a[5];
   a.length(); // returns 5

* 配列のサイズが明示的に決められている場合、``length()`` が返す値は定数式だ。
* 配列のサイズが明示的に設定されておらず、シェーダー格納ブロックの最後に宣言されたメンバーである場合、
  戻り値は定数式ではなく、ブロックに対して格納所を用意するバッファーオブジェクトのサイズに基づいて実行時に決定される。
  このような配列は runtime sized だ。
  runtime sized 配列において、配列が 0 より小さいか、配列内のブロック数以上の非定数式でインデックス付けられたシェーダー格納ブロックの配列に含まれている場合、
  ``length()`` の戻り値は未定義だ。


``length()`` を runtime sized ではなく、かつ明示的にサイズが設定されていない配列に対しては呼び出すことができない。コンパイルエラーとなる。

``length()`` がコンパイル時定数を返す場合、
``length()`` が適用される式は、式中の左辺値への書き込みや、
それ自体が副作用を持つ関数呼び出しなどの副作用を含めることはできない。
コンパイル時定数 ``length`` 自体しか計算する必要はない。

式に他の効果が含まれている場合、コンパイルエラー報告を含め、動作と結果は未定義だ。

.. code:: glsl

   float a, b;
   const int s = float[2](a=3.0, ++b).length(); // illegal side effects

----

``length()`` は配列の配列に対しても同様に機能する：

.. code:: glsl

   vec4 a[3][2];
   a.length()    // this is 3
   a[x].length() // this is 2

``length()`` がコンパイル時定数を返す場合、括弧 ``[ ]`` 内の式は解析され、
配列のインデックスに必要な規則に従うものの、配列を逆参照しない。
このように、式に副作用がない限り、式の実行時の値が範囲外であっても、動作はきちんと定義される。

``length()`` が（コンパイル時定数ではなく）実行時の値を返すと、配列を逆参照する。例えば、
``x`` がコンパイル時定数ではなく、範囲外の場合は、未定義の値を返す。
より一般的には、関係する式すべてが完全に評価され、実行される。

.. code:: glsl

   // for a compile time-sized array b containing a member array a:
   b[x+3].a.length(); // b is never dereferenced, x+3 is evaluated and checked
   b[++x].a.length(); // not allowed; results are undefined

   // for an array s of a shader storage object (run-time sized) containing a member array a:
   s[++x].a.length(); // s is dereferenced; ++x needs to be a valid index

----

暗黙的なサイズの配列や実行時サイズの配列では、最も外側の次元しかサイズを欠落することができない。
不明な配列サイズを含む型は、明示的なサイズが得られるまで配列を形成することができない。
ただし、シェーダー格納ブロックの場合は、唯一であるサイズなし配列メンバーがブロックの最後のメンバーになる。

シェーダー格納ブロックでは、最後のメンバーは明示的なサイズを指定せずに宣言することができる。
この場合、実効的な配列サイズは、インターフェイスブロックをバックアップする
データ格納場所のサイズから実行時に推論される。
このような実行時サイズの配列は、一般的な整数式でインデックスを付けることができる。
ただし、関数の引数として渡したり、負の定数式でインデックスを作成したりすることは、コンパイルエラーとなる。

.. admonition:: コメント

   ゴチャゴチャした節だが、配列の理論はレンダリングの観点から明らかに重要だ。
   読み落としはいけない。

4.1.10. Implicit Conversions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

状況によっては、式とその型が暗黙的に異なる型に変換されることがある。
許されるすべての暗黙の変換が表に示されている。

暗黙の変換は、コンストラクターを使った明示的な変換と同じだ。
コンストラクターによる明示的な変換については :ref:`5.4.1. Conversion and Scalar Constructors` にある。

二項演算子の暗黙の変換を行う場合、オペランド二つが変換できるデータ型が複数ある場合がある。
例えば ``int`` 型の値を ``uint`` 型の値に加算する場合、両方の値が ``uint``，``float``，``double``
に暗黙的に変換される可能性がある。

* このような場合、どちらかのオペランドが浮動小数点型であれば、浮動小数点型が採用される。
* また、どちらかのオペランドが符号なし整数型であれば、符号あり整数型が採用される。
* それ以外の場合は、符号付き整数型が採用される。
* オペランドが同じ基本データ型から派生する複数のデータ型に暗黙的に変換できる場合は、
  構成要素のサイズが最も小さいデータ型が採用される。

4.1.11. Initializers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

宣言には、変数の初期値を指定することができ、等号 ``=`` の後に初期化子を指定する。初期化子 (an initializer) とは、
*assignment-expression* であるか、中括弧 ``{ }`` で囲まれた初期化子のリストのどちらかをいう。

.. admonition:: コメント

   仕様書の BNF によると、モダン C++ のそれと同じと考えて良さそうだ。

*assignment-expression* は通常の式であって、括弧の外にあるカンマ ``,`` は初期化子の終わりと解釈される。
これにより入れ子になった初期化子を記述することができる。
変数型タイプとその初期化子は、入れ子、各レベルに存在する成分・要素・メンバーの数・型の点で正確に一致しなければならない。
大域スコープの *assignment-expression* には、ユーザー定義関数の呼び出しを含めることができる。

初期化子にある *assignment-expression* は、初期化するオブジェクトと同じ型であるか、
:ref:`4.1.10. Implicit Conversions` に従ってオブジェクトの型に変換できる型でなければならない。
コンストラクターを含むため、合成変数はコンストラクターでも初期化リストでも初期化でき、
初期化リストの要素をコンストラクターにすることもできる。

初期化子が中括弧で囲まれた初期化子リストの場合、宣言する変数はベクトル、行列、配列、構造体のいずれかでなければならない。

.. code:: glsl

   int i = { 1 }; // illegal, i is not a composite

釣り合う中括弧で囲まれた初期化子のリストが合成体一つに適用される。
これは、宣言されている変数、または宣言されている変数に含まれる合成体であってかまわない。
初期化子リストの個々の初期化子は、合成体の要素・メンバに対してその順に適用される。

* 合成体がベクトル型の場合、リストの初期化子は、ベクトルの成分に成分 0 から順に適用される。
  初期化子の数は成分の数と一致しなければならない。
* 合成体が行列型の場合、リストの初期化子はベクトルの初期化子でなければならず、
  行列の列に、列 0 から順に適用される。
  初期化子の数は行列の列数と一致しなければならない。
* 合成体に構造体型がある場合、リストの初期化子は、構造体で宣言されている順序で、
  最初のメンバーから順に構造体のメンバーに適用される。
  初期化子の数はメンバーの数と一致しなければならない。

これらの規則が適用されるので、次の宣言はすべて同値だ：

.. code:: glsl

   mat2x2 a = mat2(  vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) );
   mat2x2 b =      { vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) };
   mat2x2 c =      {     { 1.0, 0.0 },     { 0.0, 1.0 } };

次の宣言はすべてコンパイルエラーだ：

.. code:: glsl

   float a[2] = { 3.4, 4.2, 5.0 };         // illegal
   vec2 b = { 1.0, 2.0, 3.0 };             // illegal
   mat3x3 c = { vec3(0.0), vec3(1.0), vec3(2.0), vec3(3.0) }; // illegal
   mat2x2 d = { 1.0, 0.0, 0.0, 1.0 };      // illegal, can't flatten nesting
   struct {
       float a;
       int b;
   } e = { 1.2, 2, 3 };                    // illegal

いずれの場合も、オブジェクトに適用される最も内側の初期化子（つまり、中括弧で囲まれた初期化子のリストではない）は、
初期化されるオブジェクトと同じ型であるか、
:ref:`4.1.10. Implicit Conversions` に従ってオブジェクトの型に変換できる型でなければならない。
後者の場合、代入が行われる前に初期化子に対して暗黙の変換が行われる。

.. code:: glsl

   struct {
       float a;
       int b;
   } e = { 1.2, 2 }; // legal, all types match
   struct {
       float a;
       int b;
   } e = { 1, 3 };   // legal, first initializer is converted

次の宣言はすべてコンパイルエラーだ：

.. code:: glsl

   int a = true;                         // illegal
   vec4 b[2] = { vec4(0.0), 1.0 };       // illegal
   mat4x2 c = { vec3(0.0), vec3(1.0) };  // illegal

   struct S1 {
       vec4 a;
       vec4 b;
   };

   struct {
       float s;
       float t;
   } d[] = { S1(vec4(0.0), vec4(1.1)) }; // illegal

サイズなし配列に初期化子（いずれかの形式）が提供されている場合、
配列のサイズは、初期化子内のトップレベルの（入れ子になっていない）初期化子の数が決定する。
以下の宣言はすべて、明示的に 5 要素を持つ配列を生成する：

.. code:: glsl

   float a[] = float[](3.4, 4.2, 5.0, 5.2, 1.1);
   float b[] = { 3.4, 4.2, 5.0, 5.2, 1.1 };
   float c[] = a;                          // c is explicitly size 5
   float d[5] = b;                         // means the same thing

初期化される合成体の初期化子リストに含まれる初期化子の数に過不足があるとコンパイルエラーだ。
つまり、配列の要素すべて、構造体のメンバーすべて、行列の列すべて、
ベクトルの成分すべてには、厳密に一つの初期化子式が存在し、消費されない初期化子があってはならない。

4.2. Scoping
----------------------------------------------------------------------

変数のスコープは、その宣言位置によって決まる。

* すべての関数定義の外側で変数が宣言されている場合、それは大域スコープを持ち、
  宣言された場所から始まり、そのシェーダーの最後まで存続する。
* ``while`` テストや ``for`` 文の中で宣言されている場合は、それに続く部分文の最後までスコープされる。
* ``if`` 文や ``else`` 文の中で宣言されている場合は、その文の最後までスコープされる。
  :ref:`6.2. Selection`, :ref:`6.3. Iteration` を参照。
* 複文の中の文として宣言されている場合は、その複文の末尾にスコープされる。
* 関数定義の中で引数として宣言されている場合は、その関数定義の最後までスコープされる。
* 関数の引数宣言と本体は、大域スコープに入れ子になった単一のスコープを形成する。
* ``if`` 文の式では、新しい変数を宣言することができないため、新しいスコープを形成しない。

宣言の中では、名前のスコープは、初期化子がある場合はその直後から、
ない場合は宣言されている名前の直後から始まる。

.. admonition:: コメント

   仕様書ではここに C/C++ プログラマーなら納得の行くコード例が挙げられている。

----

``for`` ループも ``while`` ループも、部分文自体は変数名の新しいスコープを導入していないので、
以下は再宣言のコンパイルエラーになる：

.. code:: glsl

   for ( /* nested scope begins here */ int i = 0; i < 10; i++) {
       int i; // redeclaration error
   }

``do``-``while`` ループの本体では、本体が単文か複文かによらず、
``do`` と ``while`` の間（テスト式は含まない）だけ続く新しいスコープが導入される。

.. code:: glsl

   int i = 17;
   do
       int i = 4;  // okay, in nested scope_
   while (i == 0); // i is 17, scoped outside the do-while body

``switch(...)`` に続く文は、入れ子スコープを形成する。

あるスコープ内のすべての変数名、構造体型名、関数名は同じ名前空間を共有する。
関数名は、同じスコープ内で、同じまたは異なるパラメータでエラーなしで再宣言できる。
暗黙的なサイズの配列は、同じ基本型の配列と同じスコープで再宣言できる。
それ以外の場合、一つのコンパイル単位内では、宣言された名前を同じスコープで再宣言することはできない。
再宣言するとコンパイルエラーになる。
入れ子になったスコープが外側のスコープで使用されている名前を再宣言すると、
その名前の既存の使用がすべて隠される。隠された名前にアクセスしたり、隠蔽を解除したりするには、
隠蔽したスコープを終了しなければならない。

組み込み関数のスコープは、ユーザーが大域変数を宣言する大域スコープの外側にある。
つまり、シェーダーの大域スコープは、ユーザー定義関数や大域変数を使えられ、
組み込み関数を含むスコープの中に入れ子になっている。
入れ子になったスコープで関数名を再宣言すると、外側のスコープでその名前で宣言された関数すべてが隠蔽される。
関数の宣言（プロトタイプ）は、関数の内部には記述できない。
大域スコープか、組み込み関数の場合は大域スコープの外側に記述しなければならず、
記述しない場合はコンパイルエラーになる。

----

共有大域とは、同一言語（頂点などの同一段階）内で独立してコンパイルされた単位（シェーダー）内で同じ名前で宣言された大域変数で、
単一のプログラムを作る際にリンクされるものだ
（異なるシェーダー言語間のインターフェイスとなる大域については別の節で述べる）。
共有大域は同じ名前空間を共有し、同じ型で宣言する必要がある。
また、同じ格納域を共有する。

共有大域配列は、同じ基本型と同じ明示的なサイズでなければならない。
あるシェーダーで暗黙的にサイズ設定された配列は、同じ段階の別のシェーダーで明示的にサイズ設定することができる。
ある段階のどのシェーダーも配列の明示的なサイズを持っていない場合、
その段階の最大の暗黙的なサイズ（使用されている最大のインデックスよりも 1 多い）が採用される。
段階をまたいだ配列のサイズ変更はない。
これは、配列が他の段階やアプリケーションと共有されるインターフェースブロック内で宣言されている場合に関係する
（他の未使用の配列は最適化により排除されてもかまわない）。

共有される大域スカラーは、厳密に同じ型名と型定義を持たなければならない。
構造体は、同じ名前、一連の型名、型定義、およびメンバー名を持たなければ、同じ型とはみなされない。
この規則は入れ子になった型や埋め込まれた型にも再帰的に適用される。
共有大域に複数の初期化子がある場合、初期化子はすべて定数式であり、すべて同じ値でなければならない。
そうでない場合は、リンクエラーが発生する（初期化子が一つしかない共有大域では、その初期化子を定数式にする必要はない）。

.. admonition:: コメント

   最後の 3 パラグラフについては、仕様書を全部読んでいない段階では、
   シェーダーを書くときに ``main`` の外側に置く変数が関係しているだろうと想像する。

4.3. Storage Qualifiers
----------------------------------------------------------------------

変数宣言では、型の前に高々一つの格納修飾子を指定することができる。
詳しくは本書の表を参照。名前だけ列挙すると：
``const``, ``in``, ``out``, ``attribute``, ``uniform``, ``varying``,
``buffer``, ``shared``, 以上。

入出力修飾変数の中には、高々一つの補助格納修飾子を追加できるものがある。
詳しくは本書の表を参照。名前だけ列挙すると：
``centroid``, ``sample``, ``patch``, 以上。

すべての修飾子の組み合わせが許されるわけではない。
補助格納修飾子は ``in`` または ``out`` 修飾子と一緒にしか使用できない。
その他の修飾子の規則については、以降の節で説明。

局所変数は ``const`` 修飾子のみ使用できる（または格納修飾子を使用しない）。

関数の引数には ``const``, ``in``, ``out`` を使用できるが、
引数修飾子としては使用できないことに注意。引数修飾子については
:ref:`6.1.1. Function Calling Conventions` を参照。

関数の戻り値の型や構造体のメンバーには格納修飾子を使用しない。

大域宣言の初期化子は、格納修飾子がないか、
``const`` 修飾子があるか、または ``uniform`` 修飾子がある大域変数の宣言でしか使用できない。

格納修飾子のない大域変数は、その宣言またはアプリケーションで初期化されないと、
初期化されずに未定義の値で ``main()`` に入る。

あるシェーダー段階の出力と後続のシェーダー段階の入力を比較するとき、
補助修飾子（またはその欠落）が同じでない場合、入力と出力は一致しない。

4.3.1. Default Storage Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

大域変数に修飾子がない場合、その変数はアプリケーションや他のパイプライン段階で実行されるシェーダーとはリンクしていない。
大域変数でも局所変数でも、修飾されていない変数では、宣言は対象となる処理器に関連するメモリーが割り当てられているように見える。
この変数は、この割り当てられたメモリーへの読み取り・書き込みアクセスを提供する。

.. admonition:: コメント

   意味不明。

4.3.2. Constant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is a compile-time error to write to a const variable outside of its declaration, so they must be initialized when declared. For example,
名前付きのコンパイル時定数や読み取り専用の変数は ``const`` 修飾子を使って宣言できる。
``const`` 修飾子は、非 ``void`` 透過基本データ型や、それらの構造体や配列で使用できる。
宣言されていない ``const`` 変数に書き込むコードはコンパイルエラーとなるから、宣言時に初期化する必要がある。

.. code:: glsl

   const vec3 zAxis = vec3(0.0, 0.0, 1.0);
   const float ceiling = a + b; // a and b not necessarily constants

構造体のメンバーは ``const`` で修飾することはできない。
構造体変数は ``const`` として宣言し、構造体のコンストラクターまたは初期化子で初期化できる。

大域スコープでの ``const`` 宣言の初期化子は、次節で定義されるように、定数式でなければならない。

4.3.3. Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SPIR-V の特殊化定数は、"特殊化-定数修飾子 "で説明したように、GLSL では
``const`` にレイアウト修飾子 ``const_id`` を付けて表現される。

**定数式** (a constant expression) とは次のいずれかだ：

* リテラル値
* ``const`` 修飾子と初期化子で宣言された変数で、初期化子が定数式であるもの。
  これは ``layout(const_id = ...)`` のような特殊化定数レイアウト修飾子を付けて宣言された
  ``const`` と、特殊化定数レイアウト修飾子を付けずに宣言された ``const`` の両方を含む。
* ``const`` として修飾された組み込み変数。
* 定数配列の要素、定数構造体のメンバー、定数ベクトルの構成要素の取得など、
  すべて定数式であるオペランドに対して演算子で形成される式。
* オブジェクト自体が定数であるかどうかに関わらず、明示的なサイズのオブジェクトに対する
  ``length()`` メソッドの適切な使用（暗黙的なサイズの配列や実行時サイズの配列は定数式を返さない）。
* 引数がすべて定数式であるコンストラクター。
* 非特殊化定数の場合のみ：引数がすべて定数式である特定の組み込み関数の呼び出しの戻り値
  （少なくとも以下のリストを含む）。メモリーにアクセスしないその他の組み込み関数
  （テクスチャー探索関数、画像アクセス、原子カウンターなどを除く）であって、
  戻り値の型が非 ``void`` で ``out`` 引数がなく、ノイズ関数ではないものも定数とみなされる場合がある。
  関数が特殊化定数である引数で呼び出された場合、その結果は定数式ではない。

  * 角度および三角関数
  * 指数関数
  * 普通の関数
  * 幾何関数

* ユーザー定義関数（非組み込み関数）の関数呼び出しは、定数式には使用できない。

----

**定整数式** (a constant integral expression) とは定数式であって、スカラーの符号付きまたは符号なしの整数に評価されるものだ。

See “The Invariant Qualifier” for more details on how to create invariant expressions and “Precision Qualifiers” for detail on how expressions are evaluated.
定数式は不変的な方法で評価されるため、複数のシェーダーに同じ定数式が現れた場合、同じ値が生成される。
:ref:`4.8.1. The Invariant Qualifier`, :ref:`4.7.2. Precision Qualifiers` を参照。

定数式は ``precision`` 修飾子と ``invariant`` 修飾子を尊重するが、
そのような修飾子の使用とは関係なく、常に不変的に評価されるため、
複数のシェーダーに同じ定数式が現れた場合には、同じ値が生成される。

定数式はホストプラットフォームで評価される可能性がある。
それゆえ同じ式がシェーダー実行対象で評価するような値と同じものを計算する必要はない。
ただし、ホストは対象が使用するのと同じか、それ以上の精度を使用しなければならない。
精度修飾子が決定できない場合、式は ``highp`` で評価される。
:ref:`4.7.3. Default Precision Qualifiers` 参照。

特殊化定数式は、コンパイラーのフロントエンドでは評価されないで、
代わりに、後でホスト上で評価するために必要な式の操作を留めておく。

4.3.4. Input Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

シェーダーの入力変数は ``in`` 格納修飾子で宣言される。
この変数は、API パイプラインの前段階と宣言したシェーダーとの間の入力インターフェースを形成する。
入力変数は大域スコープで宣言しなければならない。
前のパイプライン段階から来る値は、シェーダー実行開始時に入力変数にコピーされる。
入力として宣言された変数に書き込むコードはコンパイルエラーとなる。

前の段階で書き込む必要があるのは、静的に読み込まれる入力変数だけであり、
入力変数の宣言が余計に付いていても構わない。

.. admonition:: コメント

   本文ではこのことをまとめた表がここに示されているが、割愛する。

消費エラーは静的な使用にしかよらない。
未定義の値を消費する可能性のある動的な使用方法をコンパイラーが推論する場合、エラーではなく警告を発する。
組み込み入力名の一覧は :ref:`7. Built-In Variables` を参照。

頂点シェーダーの入力変数（または属性）は、頂点ごとのデータを受け取る。
頂点シェーダー入力に補助格納修飾子や補間修飾子を使用すると、コンパイルエラーとなる。
コピーされた値は API またはレイアウト識別子 ``location`` の使用により設けられる。

以下の型で頂点シェーダー入力を宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型
* 構造体

----

頂点シェーダーにおける入力宣言の例を示す：

.. code:: glsl

   in vec4 position;
   in vec3 normal;
   in vec2 texCoord[4];

----

グラフィックスハードウェアでは、頂点入力を渡すための固定のベクトル場所が足りないことが予想される。
そのため、OpenGL Shading Language では、行列以外の入力変数は、そのようなベクトル場所を一つ使用すると定義している。
使用できる場所の数には実装依存の制限があり、これを超えるとリンクエラーが発生する
（静的使用でないと宣言された入力変数は、この制限に含まれない）。
スカラー入力は ``vec4`` と同じようにカウントされるので、
アプリケーションでは、基礎となるハードウェアの性能をよりよく活用するために、
関係のない 4 つの ``float`` 入力のグループをまとめてベクトルにすることを検討するとよいだろう。
行列入力は、複数の場所を使用する。使用される場所の数は、行列の列数と同じだ。

多角形分割制御、多角形分割評価、幾何シェーダーの入力変数は、
前のアクティブシェーダー段階で同じ名前の出力変数によって書き出された、頂点ごとの値を取得する。
これらの入力では ``centroid`` や補間修飾子が使えるが、効果はない。
多角形分割制御、多角形分割評価、幾何シェーダーは頂点集合を操作するので、
各入力変数（または入力ブロック、下記のインターフェースブロックを参照）は配列として宣言する必要がある。

.. code:: glsl

   in float foo[]; // geometry shader input for vertex "out float foo"

このような配列の各要素は、処理される基本形状の一つの頂点に対応する。
各配列はオプションでサイズを宣言することができる。
幾何シェーダーの場合、配列のサイズは、:ref:`4.4.1. Input Layout Qualifiers` のように、
入力基本形状の型を設定する入力 ``layout`` 宣言によって設定される。

----

入力と出力は配列されているものもある。これは、シェーダー段階二つの間にあるインターフェイスでは、
入力または出力の宣言を一致させるために、余分なレベルの配列インデックスが必要になることを意味する。
例えば、頂点シェーダーと幾何シェーダーのインターフェースでは、
頂点シェーダーの出力変数と幾何シェーダーの入力変数の同名の変数は、型が一致していなければならない。
ただし、幾何シェーダーは、頂点のインデックス付けを可能にするために、頂点シェーダーよりも 1 多い配列次元を持つことになる。
このように配列されたインターフェイス変数が、必要である追加的入力・出力配列次元で宣言されていない場合、リンクエラーとなる。
幾何シェーダー入力、多角形分割制御シェーダー入出力、多角形分割評価入力はすべて、
他のシェーダー入出力に比べて追加的配列レベルを持っている。
これらの入力と出力は、頂点ごとに配列された (per-vertex-arrayed) 入力と出力として知られている。
配列されたインターフェース (``gl_MaxTessControlInputComponents``, etc.)
のコンポーネント制限は、インターフェイス全体に対する制限ではなく、頂点ごとの制限だ。

非配列のインターフェイス（＝段階間配列の次元が変わらない）では、
入力変数が一致する出力変数と配列の次元を含めて同じ型で宣言されていないと、リンクエラーとなる。

リンク時の型マッチング規則は、使用されているか否かに関わらず、
宣言されたすべての入力変数と出力変数に適用される。

さらに、多角形分割評価シェーダーは ``patch`` および ``in`` 修飾子で宣言された
``patch`` ごとの入力変数をサポートしている。
パッチごとの入力変数には、多角形分割制御シェーダーによって書き込まれたパッチごとの出力変数の値が入る。
パッチごとの入力は一次元配列として宣言できるが、頂点数によるインデックスは付けられない。
入力への ``patch`` 修飾子の適用は、多角形分割評価シェーダでしか行えない。
他の入力変数と同様に、パッチごとの入力は、前の（多角形分割・制御）シェーダー段階からの
パッチごとの出力と同じ型と修飾子を使って宣言しなければならない。
他の段階の入力で ``patch`` を使用することは、コンパイルエラーとなる。

多角形分割制御、多角形分割評価、幾何シェーダーの入力を、以下のいずれかの型で宣言することは、コンパイルエラーとなる：

* 真偽型
* 不透明型

----

フラグメントシェーダーの入力は、前の段階の出力から補間されたフラグメントごとの値をふつうは取得する。
補助格納修飾子 ``centroid`` と ``sample`` も、補間修飾子 ``flat``, ``noperspective``, ``smooth`` と同様に適用できる。

フラグメントシェーダーの入力を次のいずれかの型で宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

整数型または倍精度浮動小数点型であるか、またはそれを含むフラグメントシェーダー入力には補間修飾子 ``flat`` が必要だ。

フラグメント入力は以下の例のように宣言される：

.. code:: glsl

   in vec3 normal;
   centroid in vec2 TexCoord;
   invariant centroid in vec4 Color;
   noperspective in float temperature;
   flat in vec3 myColor;
   noperspective centroid in vec2 myTexCoord;

フラグメントシェーダーの入力は、頂点処理パイプラインにおける最終アクティブシェーダーとのインターフェースを形成する。
このインターフェイスでは、最終アクティブシェーダー段階出力変数とフラグメントシェーダーの入力変数の同名の変数は、
いくつかの例外（格納修飾子の一方は ``in`` で他方は ``out`` でなければならない）を除いて、型と修飾子が一致していなければならない。
また、補間修飾子や補助修飾子も異なる場合がある。
これらのミスマッチは任意の段階対の間で許される。
補間修飾子や補助修飾子が一致しない場合は、フラグメントシェーダーで提供される修飾子が前段階で提供される修飾子よりも優先される。
フラグメントシェーダーにそのような修飾子が全くない場合は、前段階で宣言されていた修飾子ではなく、既定の修飾子が使用される。
つまり、重要なのはフラグメントシェーダーで何が宣言されているかであり、
前段階のシェーダーで何が宣言されているかではないということだ。

----

シェーダー段階間のインターフェイスが別々のプログラムオブジェクトのシェーダーを使って形成されている場合、
プログラムがリンクされたときに入力と出力の間のミスマッチを検出することはできない。
このようなインターフェイスでは、入力と出力の間にミスマッチがあると、
インターフェースを介して渡される値は、部分的にまたは完全に未定義となる。

シェーダーで入出力レイアウト修飾子 (:ref:`4.4.1. Input Layout Qualifiers`,
:ref:`4.4.2. Output Layout Qualifiers`)
を使用するか、ブロックや変数の入力宣言と出力宣言を同一にすることで、このようなインターフェイス間のマッチングを担保することができる。
インターフェイスのマッチングに関する完全な規則は、OpenGL 仕様書の 7.4.1項 Shader Interface Matching に記載されている。

----

計算シェーダはユーザ定義の入力変数を許可せず、他のシェーダー段階との正式なインターフェイスを形成しない。
組み込みの計算シェーダー入力変数については :ref:`7.1.6. Compute Shader Special Variables` を参照。
計算シェーダーへの他のすべての入力は、画像ロード、テクスチャー取得、
uniforms または uniform buffers からのロード、または他のユーザーコードによって明示的に取得される。
計算シェーダーの組み込み入力変数を再宣言することはできない。

4.3.5. Uniform Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. admonition:: コメント

   英単語 uniform をどう訳したらしっくり来るだろうか。数学科専攻としては「一様」にしたい。
   中国語の仕様書を見たら「統一」に相当する単語をあてているようだ。

修飾子 ``uniform`` は、処理される基本形状全体で値が同じになる大域変数を宣言するために用いられる。
``uniform`` 変数はすべて読み取り専用で、リンク時または API を通じて外部から初期化される。
リンク時の初期値は、変数の初期化子が存在する場合はその値で、存在しない場合は 0 だ。
不透明型は初期化子を持つことができず、そうでない場合はコンパイルエラーが発生する。

.. code:: glsl

   uniform vec4 lightPosition;
   uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time

修飾子 ``uniform`` は、基本的なデータ型のいずれか、または構造体を型とする変数を宣言するとき、
あるいはこれらのいずれかの配列を宣言するときに使用できる。

シェーダーの種類ごとに使用できる ``uniform`` 用変数の収容量には実装依存の制限がある。
これを超えるとコンパイル時またはリンク時にエラーとなる。
宣言されているが使用されていない ``uniform`` 変数はこの制限に入らない。
ユーザー定義の ``uniform`` 変数の個数と、シェーダー内で使用されている
組み込みの ``uniform`` 変数の個数の和で、利用可能な収容量を超えているかどうかを判断する。

シェーダー内の ``uniform`` 変数は、プログラムまたは分割可能なプログラムにリンクされている場合、
すべて単一の大域名前空間を共有する。したがって、同じ名前で静的に使用される ``uniform`` 変数の
型、初期化子、および任意の ``location`` 指定子は、単一プログラムにリンクされているすべてのシェーダーで
一致しなければならない。ただし、リンクされたすべてのシェーダーで初期化子や ``location`` 指定子を繰り返す必要はない。
``uniform`` 変数名がある段階（例：頂点シェーダー）で宣言され、
別の段階（例：フラグメントシェーダー）で宣言されていない場合、
その名前は別の段階で別の用途に使用することが許される。

4.3.6. Output Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

シェーダー出力変数は ``out`` 格納修飾子で宣言される。
出力変数は、宣言したシェーダーと API パイプラインの後続段階との間の出力インターフェイスを形成する。
出力変数は大域スコープで宣言しなければならない。
シェーダーの実行中は、修飾のない通常の大域変数として振る舞う。
シェーダーの終了時にその値は後続のパイプライン段階にコピーされる。
後続のパイプライン段階で読まれる出力変数だけが書き込まれる必要があり、出力変数の余計な宣言があっても構わない。

単一の変数名をシェーダーの入力と出力の両方として宣言するための ``inout`` のような格納修飾子は存在しない。
一つの変数に ``in`` と ``out`` の両方の修飾子をつけて宣言することもまたできない。コンパイル時またはリンク時にエラーとなる。
出力変数は、入力変数とは異なる名前で宣言しなければならない。
ただし、インスタンス名を持つインターフェイス・ブロックの中に入力または出力を入れ子にすると、
ブロックのインスタンス名で参照されるものと同じ名前を使うことができる。

頂点、多角形分割評価、幾何の出力変数は、頂点ごとのデータを出力し、
``out`` 修飾子を用いて宣言される。
出力への ``patch`` の適用は、多角形分割制御シェーダーでのみ可能だ。
それ以外の段階での適用はコンパイルエラーとなる。

頂点、多角形分割評価、多角形分割制御、幾何それぞれのシェーダーの出力を、
以下の型のいずれかで宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

.. code:: glsl

   out vec3 normal;
   centroid out vec2 TexCoord;
   invariant centroid out vec4 Color;
   flat out vec3 myColor;
   sample out vec4 perSampleColor;

これらは :ref:`4.3.9. Interface Blocks` で述べられるように、
インターフェイスブロックにも出現する。インターフェイスブロックでは、
頂点シェーダーから幾何シェーダーへのインターフェイスに、より単純に配列を追加することができる。
また、フラグメントシェーダーに、ある頂点シェーダーの幾何シェーダーと同じ入力インターフェイスを持たせることができる。

----

多角形分割制御シェーダーの出力変数は、頂点ごとのデータと patch ごとのデータを出力するために用いられる。
頂点ごとの出力変数は配列され (:ref:`4.3.4. Input Variables`)、
``out`` 修飾子で ``patch`` 修飾子なしに宣言される。
パッチごとの出力変数は ``patch`` 修飾子と ``out`` 修飾子で宣言される。

多角形分割制御シェーダーは、複数の頂点からなる配列された基本形状を生成するため、
各頂点ごとの出力変数（または出力ブロック）は、配列として宣言する必要がある：

.. code:: glsl

   out float foo[]; // feeds next stage input "in float foo[]"

このような配列の要素それぞれが、生成される基本形状一つの頂点に対応する。
各配列はオプションでサイズを宣言することができる。
配列のサイズは出力パッチの頂点の数を定める出力レイアウト宣言によって設定される
(:ref:`Tessellation Control Outputs`)（または、宣言されている場合は、それと一致しなければならない）。

各多角形分割制御シェーダー呼び出しは、対応する出力パッチの頂点を持ち、
その対応する頂点に属しているときに限り、
頂点ごとの出力に値を割り当てることができる。
頂点ごとの出力変数を左辺値として使用する場合、
頂点のインデックスを示す式が識別子 ``gl_InvocationID`` でないと、コンパイル時またはリンク時のエラーになる。

同じ入力パッチに対する他の呼び出しに対する多角形分割制御シェーダー呼び出しの相対的な実行順序は、
組み込み関数 ``barrier()`` が使用されない限り、未定義だ。
これにより、相対的な実行順序の制御が可能になる。
シェーダーの呼び出しが ``barrier()`` を呼び出すと、他のすべての呼び出しが同じ実行ポイントに到達するまでその実行は一時停止する。
``barrier()`` を呼び出す前に実行された任意の呼び出しによって実行された出力変数の割り当ては、
``barrier()``の呼び出しが戻った後、他の任意の呼び出しから見えるようになる。

多角形分割制御シェーダーの呼び出しは、バリア間で未定義の順序で実行されるので、
頂点ごと、あるいはパッチごとの出力変数の値は時々未定義になる。
シェーダー実行の開始と終了、および ``barrier()`` の各呼び出しを同期時点と考えるといい。
出力変数の値が不定になるのは、以下の三つの場合のいずれかだ：

1. 実行の開始時
2. 以下の場合を除く各同期時点：

   * 前回の同期時点の後に値が定義され、その後どの呼び出しによっても書き込まれなかった場合、または
   * 前回の同期時点以降、厳密に一つのシェーダー呼び出しによって値が書き込まれた場合、または
   * 前回の同期時点以降に複数のシェーダー呼び出しによって値が書き込まれ、
     そのようなすべての呼び出しによって実行された最後の書き込みが同じ値を書き込んだ場合。

3. シェーダーの呼び出しによって読み込まれたとき、もし

   * その値が前回の同期時点で未定義であり、その後同じシェーダー呼び出しによって書き込まれていない場合、または
   * 前回と次回の同期時点の間に他のシェーダー呼び出しによって出力変数が書き込まれた場合
     （その割り当てが読み取り後のコードで発生したときでさえ）

----

フラグメント出力は、フラグメントごとのデータを出力し、
``out`` 修飾子で宣言される。
フラグメントシェーダー出力の宣言に補助格納修飾子や補間修飾子を使用するとコンパイルエラーとなる。
フラグメントシェーダー出力を以下の型で宣言するとコンパイルエラーとなる：

* 真偽型
* 倍精度スカラーまたはベクトル (``double``, ``dvec2``, ``dvec3``, ``dvec4``)
* 不透明型
* 行列型
* 構造体

フラグメント出力宣言の例：

.. code:: glsl

   out vec4 FragmentColor;
   out uint Luminosity;

----

計算シェーダーは組み込みの出力変数を持たず、ユーザー定義の出力変数もサポートせず、
他のシェーダー段階との正式なインターフェースを形成しない。
計算シェーダーからの出力はすべて、画像格納や原子カウンターの演算などの副作用の形をとる。

4.3.7. Buffer Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

修飾子 ``buffer`` はAPI を通じて束縛されたバッファーオブジェクトのデータ格納空間に
値が格納される大域変数を宣言するために使用される。
バッファー変数はすべてのアクティブなシェーダー呼び出しの間で内包される格納空間を共有して読み書きすることができる。
単一のシェーダー呼び出し内でのバッファー変数のメモリーの読み取りと書き込みは順番に処理される。
しかし、ある起動で実行される読み込みと書き込みの順序は、他の呼び出しで実行されるものと比較するとほとんど未定義だ。
バッファー変数は内包されているメモリーへのアクセス方法に影響を与えるメモリー修飾子
(:ref:`4.10. Memory Qualifiers`) で修飾することができる。

修飾子 ``buffer`` は、インターフェイスブロック (:ref:`4.3.9. Interface Blocks`)
を宣言するために使用することができ、これらのブロックはシェーダー格納ブロックとして参照される。
ブロックの外でバッファー変数を宣言するとコンパイルエラーとなる。

.. code:: glsl

   // use buffer to create a buffer block (shader storage block)
   buffer BufferName { // externally visible name of buffer
       int count;      // typed, shared memory...
       ...             // ...
       vec4 v[];       // last member may be an array that is not sized
                       // until after link time (dynamically sized)
   } Name;             // name of block within the shader

シェーダーの種類ごとに使用されるシェーダー格納ブロックの数、
プログラムに使用されるシェーダー格納ストレージブロックの合計数、
個々のシェーダー格納ブロックが必要とする格納空間の量には、実装に依存した制限がある。
これらの制限を超えた場合は、コンパイル時またはリンク時にエラーが発生する。

複数のシェーダーがリンクされている場合、それらのシェーダーは単一に大域バッファー変数の名前空間を共有することになる。
したがって、同じ名前で宣言されたバッファー変数の型は、
単一のプログラムにリンクされているすべてのシェーダーで一致しなければならない。

4.3.8. Shared Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

修飾子 ``shared`` は、計算シェーダー作業グループ内のすべての作業項目間で共有される
格納空間がある大域変数を宣言するために用いられる。
``shared`` として宣言された変数は、計算シェーダーでしか使用されない
(:ref:`2.6. Compute Processor`)。
それ以外の共有変数の宣言は、コンパイルエラーとなる。
共有変数は暗黙的に ``coherent`` (:ref:`4.10. Memory Qualifiers`) だ。

共有変数として宣言された変数は初期化子を持たず、シェーダーの実行開始時にはその内容は未定義だ。
共有変数に書き込まれたどんなデータも、同じ作業グループ内の他の作業項目（同じシェーダーを実行中）から見えるということになる。

同期が行われていない場合、シェーダーの異なる呼び出しによる同じ ``shared`` 変数への読み書きの順序は未定義とする。

共有変数への読み書きの順序を決めるためには、関数 ``barrier()`` を使って制御フローの障壁を設ける必要がある
(:ref:`8.16. Shader Invocation Control Functions`)。

単一のプログラムで共有変数として宣言されたすべての変数の合計サイズには制限がある。
basic machine units 単位で表されるこの制限は、OpenGL API を使って
``MAX_COMPUTE_SHARED_MEMORY_SIZE`` の値を照会することで決定できる。

.. admonition:: コメント

   最後のパラグラフ中の basic machine units なる用語がわからない。

4.3.9. Interface Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4.4. Layout Qualifiers
----------------------------------------------------------------------

4.4.1. Input Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.2. Output Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.3. Uniform Variable Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.4. Subroutine Function Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.5. Uniform and Shader Storage Block Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.6. Opaque Uniform Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.7. Atomic Counter Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.8. Format Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.9. Subpass Input Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4.5. Interpolation Qualifiers
----------------------------------------------------------------------


4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.6. Parameter Qualifiers
----------------------------------------------------------------------


4.7. Precision and Precision Qualifiers
----------------------------------------------------------------------


4.7.1. Range and Precision
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.2. Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.3. Default Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.4. Available Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.8. Variance and the Invariant Qualifier
----------------------------------------------------------------------



4.8.1. The Invariant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.8.2. Invariance of Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.9. The Precise Qualifier
----------------------------------------------------------------------


4.10. Memory Qualifiers
----------------------------------------------------------------------


4.11. Specialization-Constant Qualifier
----------------------------------------------------------------------


4.12. Order and Repetition of Qualification
----------------------------------------------------------------------


4.13. Empty Declarations
----------------------------------------------------------------------

