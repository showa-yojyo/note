======================================================================
GLSL 4.60 仕様書 読書ノート 4 of ?
======================================================================

.. contents:: ノート目次

4. Variables and Types
======================================================================

.. note::

   原文の英語を、次のように機械的に単語を日本語に読み換える：

   * aggregate: 集約、集約型
   * opaque: 不透明～

   その他、定訳がない単語についてはカタカナ表記という手抜きをする。

変数と関数はすべて使用する前に宣言する必要がある。変数や関数の名前とは識別子だ。

既定の型はない。変数と関数の宣言にはすべて、宣言された型が必要で、修飾子がオプションだ。
変数を宣言するには、型を指定した後、カンマで区切って一つ以上の名前を指定する。
多くの場合、代入演算子 ``=`` を使って、宣言の一部として変数を初期化することができる。

ユーザー定義型は、既存の型のリストを一つの名前に集約するために ``struct`` を使って定義することができる。

OpenGL Shading Language は型安全だ。型の間には暗黙の変換がある。
どのような場合にどのような変換が行われるかについては、
:ref:`4.1.10. Implicit Conversions` で述べられ、本仕様書の他の項からも参照されている。

.. admonition:: 感想

   おそらく仕様を C/C++ に寄せている。

4.1. Basic Types
----------------------------------------------------------------------

* **基本型** (a basic type) とは当言語のキーワードにより定義されている型だ。
* OpenGL Shading Language では、以下のように基本型を分類している：

  * Transparent Types
  * Floating-Point Opaque Types
  * Signed Integer Opaque Types
  * Unsigned Integer Opaque Types
  * Sampler Opaque Types

  これに加え、これらの基本型を配列や構造体を使って集約し、
  より複雑な型を構築することができる。

* ポインター型はない。
* 本仕様書では、集約型 (an aggregate) は構造体や配列を意味する。

  * 行列やベクトルはそれ自体は集約型ではない。
  * 集約型、行列、ベクトルを総称して **合成** (composites) と呼ぶ。

4.1.1. Void
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

値を返さない関数は ``void`` として宣言しなければならない。既定の戻り値の型はない。
キーワード ``void`` は他の宣言では使用できない（空の仮引数リストや実引数リストを除く）。
さもないとコンパイルエラーになる。

4.1.2. Booleans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**真偽型** (a boolean type) とは ``bool``, ``bvec2``, ``bvec3``, ``bvec4`` の任意のいずれかだ。

* コードの条件付き実行を表現しやすくするために、真偽型をサポートしている。
* ハードウェアがこの型の変数を直接サポートすることは想定していない。
* これは本物の真偽型であり、真か偽かの二つの値のうちただ一つを保持する。
* キーワード ``true`` と ``false`` がリテラルな定数として使用できる。
* 条件付きジャンプ (``if``, ``for``, ``? :``, ``while``, ``do``-``while``) に使われる式は
  真偽型に評価されなければならない。

4.1.3. Integers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**整数型** (an integral type) とは、符号付き、符号なし、スカラー、ベクトル整数型のことだ。
配列や構造体は含まれない。

**スカラー整数型** (a scalar integral type) とは、符号付きまたは符号なし整数型のスカラーだ。

**ベクトル整数型** (a vector integral type) とは、符号付きまたは符号なしの整数のベクトルだ。

----

* 符号付きおよび符号なしの整数変数が完全にサポートされている。
  この文書では、整数という言葉は、符号付き整数と符号なし整数の両方を一般的に意味する。
* OpenGL では、符号なし整数は正確に 32 ビットの精度を持つ。
* OpenGL では、符号付き整数は、符号ビットを含む 32 ビットを 2 の補数形式で使用する。
* 加算、減算、および乗算でオーバーフローまたはアンダーフローが発生した場合は、
  正しい結果 R の低次 32 ビットが得られる。ここで R はオーバーフローまたは
  アンダーフローを回避するのに十分な精度で計算される。
  オーバーフローの結果となる除算は、未定義の値となる。

----

C 言語と同様にしてリテラル整数定数を十進数、八進数、16 進数で表すことができる。

ビットパターンが 32 ビットに収まらないリテラル整数を用意すると、コンパイルエラーになる。
リテラルのビットパターンは常に変更されずに使用される。そのため、
ビットパターンに符号ビットが設定されている符号付きリテラルは負の値を生じる。

.. admonition:: コメント

   仕様書の例をよく見ておくこと。例えば ``-1u`` はどんな値であるか言えるようになること。

4.1.4. Floats
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一般に、浮動小数点という言葉は、単精度浮動小数点と倍精度浮動小数点の両方を指す。

浮動小数点変数は、以下の例のように定義される：

.. code:: glsl

   float a, b = 1.5; // single-precision floating-point
   double c, d = 2.0LF; // double-precision floating-point

* いずれかの処理ユニットへの入力値として、単精度または倍精度の浮動小数点変数は、
  精度とダイナミック・レンジについて、対応する IEEE 754 浮動小数点定義と一致することが期待される。
  シェーダー内の浮動小数点変数も、単精度浮動小数点値の IEEE 754 仕様に従って符号化される
  （物理的には必ずしもそうではないが、論理的には）。
* 符号化は論理的には IEEE 754 だが、演算は必ずしも IEEE 754 の要求通りには行われない。
  精度や NaN, Inf の使い方の詳細については :ref:`4.7.1. Range and Precision` を参照。

----

* 指数部が存在する場合は、小数点 ``.`` は必要ない。
* 接尾辞の前も含め、浮動小数点定数の中には空白を入れてはいけない。
* トークン化の際には、仕様書の BNF による定義に合致する最大のトークンが認識されてから新しいトークンが開始する。
* 接尾辞 ``lf`` または ``LF`` がある場合、リテラルの型は ``double`` だ。
  それ以外の場合、リテラルは ``float`` 型だ。
* 先頭の単項マイナス記号 ``-`` は単項演算子として解釈され、浮動小数点定数の一部ではない。

.. admonition:: コメント

   浮動小数点数とダイナミックレンジの関係を別途理解しておくこと。

4.1.5. Vectors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

浮動小数点値、整数値、真偽値の 2, 3, 4 成分それぞれの汎用ベクトルのデータ型がある。

* 浮動小数点ベクトル変数は、色、法線、位置、テクスチャー座標、テクスチャー検索結果などを格納するのに使用できる。
* 真偽値のベクトルは、数値のベクトルの成分ごとの比較に使用できる。

.. code:: glsl

   vec2 texcoord1, texcoord2;
   vec3 position;
   vec4 myRGBA;
   ivec2 textureLookup;
   bvec3 less;

ベクトルの初期化はコンストラクターで行う。
:ref:`5.4.2. Vector and Matrix Constructors` に記述がある。

4.1.6. Matrices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2×2, 2×3, 2×4, 3×2, 3×3, 3×4, 4×2, 4×3, 4×4 の浮動小数点数の行列の型が組み込まれている。

* ``mat`` で始まる行列型は単精度成分を持ち、
* ``dmat`` で始まる行列型は倍精度成分を持つ。
* 型の最初の数字は列数、二番目の数字は行数をそれぞれ表す。数字が一つしかない場合、それは正方行列だ。

.. code:: glsl

   mat2 mat2D;
   mat3 optMatrix;
   mat4 view, projection;
   mat4x4 view; // an alternate way of declaring a mat4
   mat3x2 m; // a matrix with 3 columns and 2 rows
   dmat4 highPrecisionMVP;
   dmat2x4 dm;

行列の値の初期化は、コンストラクターを用いて、列優先順 (column-major order) で行われる。

.. admonition:: コメント

   行列コンストラクターには列ベクトルを渡すような書き方をする。
   ただし、テキストエディター上では列ベクトルの要素を一行で書くことになるはずだから、
   そこで混乱しないようにする。

4.1.7. Opaque Types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**不透明型** (an opaque type) とは、型であって、その内部構造が言語から隠されているものだ。

----

不透明型は他のオブジェクトへの不透明なハンドルとなる変数を宣言する。
これらのオブジェクトは、宣言された変数を直接読み書きするのではなく、
組み込み関数を通してアクセスされる。
これらのオブジェクトは、関数の引数または ``uniform`` 修飾された変数としてしか宣言できない。
メモリー修飾子を取る不透明な型は ``image`` 型だけだ。
配列の添字、構造体のメンバーの選択、括弧を除き、
不透明変数は式のオペランドになることはできず、そのような使い方をするとコンパイルエラーになる。

不透明な変数は左辺値として扱うことができない。
したがって、``out`` または ``inout`` の関数引数として使用することも、代入することもできない。
このような使い方をすると、コンパイルエラーになる。
ただし、型とメモリー修飾子が一致する ``in`` 引数として渡すことは可能だ。
また、初期化子を付けて宣言することはできない。

単一の不透明型宣言ではハンドル自身と、そのハンドルとなるオブジェクトの二つのオブジェクトが効果的に宣言されるため、
格納修飾子とメモリー修飾子の両方を使用する余地がある。
格納修飾子は不透明ハンドルを修飾し、
メモリー修飾子はハンドルであるオブジェクトを修飾する。

Texture-Combined Samplers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

テクスチャー混合採取器型 (texture-combined sampler types) とは、
:ref:`4.1 Basic Types` の表（注：仕様書の本物を参照）に記載されている、
テクスチャーにアクセスするためのハンドルとなる採取器型のことだ。

* ``sampler`` や ``samplerShadow`` は含まれない。

テクスチャー対象ごとに、また、``float``, ``integer``, ``unsigned integer`` の
各データ型ごとに、異なるテクスチャー混合採取器型がある。
テクスチャーへのアクセスは、内蔵のテクスチャー関数 (TODO: link 8.9) を使って行われるが、
どのテクスチャーにアクセスするか、またどのようにフィルターリングするかを指定するために、
テクスチャー混合採取器型が使われる。

テクスチャー混合採取器型は不透明型で、前述の不透明型と同様に宣言され、動作する。
シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

Images
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

画像型は不透明型で、上記の不透明型と同様に宣言され、動作する。
さらにメモリー修飾子で修飾することができる。
シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

画像変数は、画像単位に束縛されたテクスチャー画像の単一レベルのすべてまたは一部に対応する
1, 2, 3 次元のいずれかの画像のハンドルだ。

画像変数はテクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の各データ型ごとに、異なる型がある。
画像へのアクセスは、レベルが画像単位に束縛されているテクスチャーの対象に一致する画像型を使用する必要がある。
もしくは、3D または配列画像の非レイヤー束縛の場合は、画像のレイヤーの次元に一致する画像型を使用する必要がある。

* つまり、3D, 2DArray, Cube, CubeArray のレイヤーは ``image2D`` を使用し、
* 1DArray のレイヤーは ``image1D`` を使用し、
* 2DMSArray のレイヤーは ``image2DMS``

をそれぞれ使用する必要がある。
このように画像対象型が束縛された画像と一致しない場合、データ型が束縛された画像と一致しない場合、
フォーマットレイアウト修飾子が OpenGL 仕様の 8.25 Texture Image Loads and Stores
に記載されている画像単位フォーマットと一致しない場合、画像アクセスの結果は未定義となるが、
プログラムの終了を含むことはできない。

画像変数は :ref:`8.12. Image Functions` で記述されている画像のロード、格納、原子関数において、
アクセスする画像を指定するために用いられる。

Atomic Counters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

原子カウンター型とは、カウンターへの不透明なハンドルであって、
前述の不透明型と同様に宣言され、動作するものだ。
宣言された変数は、:ref:`8.10. Atomic Counter Functions` で記述がある、組み込みの原子カウンター関数を使用するときに、
どのカウンターにアクセスするかを指定する。
また、:ref:`4.4.7. Atomic Counter Layout Qualifiers` で記述があるように、バッファーに束縛される。

シェーダー内の配列に集約された原子カウンターは、動的一様な整数式でしかインデックスを付けることができない。
そうでない場合、結果は未定義だ。

構造体のメンバーは原子カウンター型として宣言できない。

Texture, sampler, and samplerShadow Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Textures can be combined with a variable of type sampler or samplerShadow to create a texture-combined sampler type (e.g., sampler2D, or sampler2DShadow). This is done with a constructor, e.g., sampler2D(texture2D, sampler), sampler2DShadow(texture2D, sampler), sampler2DShadow(texture2D, samplerShadow), or sampler2D(texture2D, samplerShadow) and is described in more detail in section 5.4 "Constructors".

テクスチャー、採取器、samplerShadow 型は不透明型で、上記の不透明な型と同様に宣言され、動作する。
シェーダー内で配列に集約されている場合、これらの型は動的一様な式でしかインデックスを付けることができない。
そうしないとテクスチャー検索は未定義の値になる。

テクスチャー変数は、:ref:`4.1 Basic Types` の表に列挙されている一次元、二次元、三次元のテクスチャー、キューブマップなどのハンドルだ。
テクスチャー型は、テクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の各データ型ごとに異なる。

テクスチャーは、採取器型または samplerShadow 型の変数と組み合わせて、
テクスチャーを混合した採取器型 (``sampler2D``, ``sampler2DShadow``, etc.) を作ることができる。
これはコンストラクターで行う。例えば、

* ``sampler2D(texture2D, sampler)``,
* ``sampler2DShadow(texture2D, sampler)``,
* ``sampler2DShadow(texture2D, samplerShadow)``,
* ``sampler2D(texture2D, samplerShadow)``

などだ。詳細は :ref:`5.4. Constructors` で述べる。

Subpass Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

サブパス入力型（例：``subpassInput``）は不透明型で、上記の不透明型と同様に宣言され、動作するものだ。
シェーダ内ーで配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

サブパス入力型は、二次元の単一採取または複数採取された画像を扱うもので、
``float``, ``integer``, ``unsigned integer`` のデータ型ごとに異なる型がある。

サブパス入力型は、フラグメントシェーダーでのみ利用可能だ。他の段階での使用はコンパイルエラーとなる。

.. admonition:: コメント

   名詞 subpass の概念がわからないので、それまでこのままにしておく。

4.1.8. Structures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.1.9. Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.1.10. Implicit Conversions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.1.11. Initializers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4.2. Scoping
----------------------------------------------------------------------

4.3. Storage Qualifiers
----------------------------------------------------------------------

4.3.1. Default Storage Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.2. Constant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.3. Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.4. Input Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.5. Uniform Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.6. Output Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.7. Buffer Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.8. Shared Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.3.9. Interface Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4.4. Layout Qualifiers
----------------------------------------------------------------------

4.4.1. Input Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.2. Output Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.3. Uniform Variable Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.4. Subroutine Function Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.5. Uniform and Shader Storage Block Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.6. Opaque Uniform Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.7. Atomic Counter Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.8. Format Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.9. Subpass Input Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4.5. Interpolation Qualifiers
----------------------------------------------------------------------


4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.6. Parameter Qualifiers
----------------------------------------------------------------------


4.7. Precision and Precision Qualifiers
----------------------------------------------------------------------


4.7.1. Range and Precision
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.2. Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.3. Default Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.4. Available Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.8. Variance and the Invariant Qualifier
----------------------------------------------------------------------



4.8.1. The Invariant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.8.2. Invariance of Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.9. The Precise Qualifier
----------------------------------------------------------------------


4.10. Memory Qualifiers
----------------------------------------------------------------------


4.11. Specialization-Constant Qualifier
----------------------------------------------------------------------


4.12. Order and Repetition of Qualification
----------------------------------------------------------------------


4.13. Empty Declarations
----------------------------------------------------------------------

