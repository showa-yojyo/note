======================================================================
GLSL 4.60 仕様書 読書ノート 4 of ?
======================================================================

.. contents:: ノート目次

4. Variables and Types
======================================================================

.. note::

   原文の英語を、次のように機械的に単語を日本語に読み換える：

   * aggregate: 集約、集約型
   * composite: 合成～
   * opaque: 不透明～
   * storage: 格納～、収納～

   その他、定訳がない単語についてはカタカナ表記という手抜きをする。

変数と関数はすべて使用する前に宣言する必要がある。変数や関数の名前とは識別子だ。

既定の型はない。変数と関数の宣言にはすべて、宣言された型が必要で、修飾子がオプションだ。
変数を宣言するには、型を指定した後、カンマで区切って一つ以上の名前を指定する。
多くの場合、代入演算子 ``=`` を使って、宣言の一部として変数を初期化することができる。

ユーザー定義型は、既存の型のリストを一つの名前に集約するために ``struct`` を使って定義することができる。

OpenGL Shading Language は型安全だ。型の間には暗黙の変換がある。
どのような場合にどのような変換が行われるかについては、
:ref:`4.1.10. Implicit Conversions` で述べられ、本仕様書の他の項からも参照されている。

.. admonition:: 感想

   おそらく仕様を C/C++ に寄せている。

4.1. Basic Types
----------------------------------------------------------------------

* **基本型** (a basic type) とは当言語のキーワードにより定義されている型だ。
* OpenGL Shading Language では、以下のように基本型を分類している：

  * Transparent Types
  * Floating-Point Opaque Types
  * Signed Integer Opaque Types
  * Unsigned Integer Opaque Types
  * Sampler Opaque Types

  これに加え、これらの基本型を配列や構造体を使って集約し、
  より複雑な型を構築することができる。

* ポインター型はない。
* 本仕様書では、集約型 (an aggregate) は構造体や配列を意味する。

  * 行列やベクトルはそれ自体は集約型ではない。
  * 集約型、行列、ベクトルを総称して **合成** (composites) と呼ぶ。

4.1.1. Void
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

値を返さない関数は ``void`` として宣言しなければならない。既定の戻り値の型はない。
キーワード ``void`` は他の宣言では使用できない（空の仮引数リストや実引数リストを除く）。
さもないとコンパイルエラーになる。

4.1.2. Booleans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**真偽型** (a boolean type) とは ``bool``, ``bvec2``, ``bvec3``, ``bvec4`` の任意のいずれかだ。

* コードの条件付き実行を表現しやすくするために、真偽型をサポートしている。
* ハードウェアがこの型の変数を直接サポートすることは想定していない。
* これは本物の真偽型であり、真か偽かの二つの値のうちただ一つを保持する。
* キーワード ``true`` と ``false`` がリテラルな定数として使用できる。
* 条件付きジャンプ (``if``, ``for``, ``? :``, ``while``, ``do``-``while``) に使われる式は
  真偽型に評価されなければならない。

4.1.3. Integers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**整数型** (an integral type) とは、符号付き、符号なし、スカラー、ベクトル整数型のことだ。
配列や構造体は含まれない。

**スカラー整数型** (a scalar integral type) とは、符号付きまたは符号なし整数型のスカラーだ。

**ベクトル整数型** (a vector integral type) とは、符号付きまたは符号なしの整数のベクトルだ。

----

* 符号付きおよび符号なしの整数変数が完全にサポートされている。
  この文書では、整数という言葉は、符号付き整数と符号なし整数の両方を一般的に意味する。
* OpenGL では、符号なし整数は正確に 32 ビットの精度を持つ。
* OpenGL では、符号付き整数は、符号ビットを含む 32 ビットを 2 の補数形式で使用する。
* 加算、減算、および乗算でオーバーフローまたはアンダーフローが発生した場合は、
  正しい結果 R の低次 32 ビットが得られる。ここで R はオーバーフローまたは
  アンダーフローを回避するのに十分な精度で計算される。
  オーバーフローの結果となる除算は、未定義の値となる。

----

C 言語と同様にしてリテラル整数定数を十進数、八進数、16 進数で表すことができる。

ビットパターンが 32 ビットに収まらないリテラル整数を用意すると、コンパイルエラーになる。
リテラルのビットパターンは常に変更されずに使用される。そのため、
ビットパターンに符号ビットが設定されている符号付きリテラルは負の値を生じる。

.. admonition:: コメント

   仕様書の例をよく見ておくこと。例えば ``-1u`` はどんな値であるか言えるようになること。

4.1.4. Floats
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一般に、浮動小数点という言葉は、単精度浮動小数点と倍精度浮動小数点の両方を指す。

浮動小数点変数は、以下の例のように定義される：

.. code:: glsl

   float a, b = 1.5; // single-precision floating-point
   double c, d = 2.0LF; // double-precision floating-point

* いずれかの処理ユニットへの入力値として、単精度または倍精度の浮動小数点変数は、
  精度とダイナミック・レンジについて、対応する IEEE 754 浮動小数点定義と一致することが期待される。
  シェーダー内の浮動小数点変数も、単精度浮動小数点値の IEEE 754 仕様に従って符号化される
  （物理的には必ずしもそうではないが、論理的には）。
* 符号化は論理的には IEEE 754 だが、演算は必ずしも IEEE 754 の要求通りには行われない。
  精度や NaN, Inf の使い方の詳細については :ref:`4.7.1. Range and Precision` を参照。

----

* 指数部が存在する場合は、小数点 ``.`` は必要ない。
* 接尾辞の前も含め、浮動小数点定数の中には空白を入れてはいけない。
* トークン化の際には、仕様書の BNF による定義に合致する最大のトークンが認識されてから新しいトークンが開始する。
* 接尾辞 ``lf`` または ``LF`` がある場合、リテラルの型は ``double`` だ。
  それ以外の場合、リテラルは ``float`` 型だ。
* 先頭の単項マイナス記号 ``-`` は単項演算子として解釈され、浮動小数点定数の一部ではない。

.. admonition:: コメント

   浮動小数点数とダイナミックレンジの関係を別途理解しておくこと。

4.1.5. Vectors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

浮動小数点値、整数値、真偽値の 2, 3, 4 成分それぞれの汎用ベクトルのデータ型がある。

* 浮動小数点ベクトル変数は、色、法線、位置、テクスチャー座標、テクスチャー検索結果などを格納するのに使用できる。
* 真偽値のベクトルは、数値のベクトルの成分ごとの比較に使用できる。

.. code:: glsl

   vec2 texcoord1, texcoord2;
   vec3 position;
   vec4 myRGBA;
   ivec2 textureLookup;
   bvec3 less;

ベクトルの初期化はコンストラクターで行う。
:ref:`5.4.2. Vector and Matrix Constructors` に記述がある。

4.1.6. Matrices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2×2, 2×3, 2×4, 3×2, 3×3, 3×4, 4×2, 4×3, 4×4 の浮動小数点数の行列の型が組み込まれている。

* ``mat`` で始まる行列型は単精度成分を持ち、
* ``dmat`` で始まる行列型は倍精度成分を持つ。
* 型の最初の数字は列数、二番目の数字は行数をそれぞれ表す。数字が一つしかない場合、それは正方行列だ。

.. code:: glsl

   mat2 mat2D;
   mat3 optMatrix;
   mat4 view, projection;
   mat4x4 view; // an alternate way of declaring a mat4
   mat3x2 m; // a matrix with 3 columns and 2 rows
   dmat4 highPrecisionMVP;
   dmat2x4 dm;

行列の値の初期化は、コンストラクターを用いて、列優先順 (column-major order) で行われる。

.. admonition:: コメント

   行列コンストラクターには列ベクトルを渡すような書き方をする。
   ただし、テキストエディター上では列ベクトルの要素を一行で書くことになるはずだから、
   そこで混乱しないようにする。

4.1.7. Opaque Types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**不透明型** (an opaque type) とは、型であって、その内部構造が言語から隠されているものだ。

----

不透明型は他のオブジェクトへの不透明なハンドルとなる変数を宣言する。
これらのオブジェクトは、宣言された変数を直接読み書きするのではなく、
組み込み関数を通してアクセスされる。
これらのオブジェクトは、関数の引数または ``uniform`` 修飾された変数としてしか宣言できない。
メモリー修飾子を取る不透明な型は ``image`` 型だけだ。
配列の添字、構造体のメンバーの選択、括弧を除き、
不透明変数は式のオペランドになることはできず、そのような使い方をするとコンパイルエラーになる。

不透明な変数は左辺値として扱うことができない。
したがって、``out`` または ``inout`` の関数引数として使用することも、代入することもできない。
このような使い方をすると、コンパイルエラーになる。
ただし、型とメモリー修飾子が一致する ``in`` 引数として渡すことは可能だ。
また、初期化子を付けて宣言することはできない。

単一の不透明型宣言ではハンドル自身と、そのハンドルとなるオブジェクトの二つのオブジェクトが効果的に宣言されるため、
格納修飾子とメモリー修飾子の両方を使用する余地がある。
格納修飾子は不透明ハンドルを修飾し、
メモリー修飾子はハンドルであるオブジェクトを修飾する。

Texture-Combined Samplers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

テクスチャー混合採取器型 (texture-combined sampler types) とは、
:ref:`4.1 Basic Types` の表（注：仕様書の本物を参照）に記載されている、
テクスチャーにアクセスするためのハンドルとなる採取器型のことだ。

* ``sampler`` や ``samplerShadow`` は含まれない。

テクスチャー対象ごとに、また、``float``, ``integer``, ``unsigned integer`` の
各データ型ごとに、異なるテクスチャー混合採取器型がある。
テクスチャーへのアクセスは、内蔵のテクスチャー関数 (TODO: link 8.9) を使って行われるが、
どのテクスチャーにアクセスするか、またどのようにフィルターリングするかを指定するために、
テクスチャー混合採取器型が使われる。

テクスチャー混合採取器型は不透明型で、前述の不透明型と同様に宣言され、動作する。
シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

Images
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

画像型は不透明型で、上記の不透明型と同様に宣言され、動作する。
さらにメモリー修飾子で修飾することができる。
シェーダー内で配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

画像変数は、画像単位に束縛されたテクスチャー画像の単一レベルのすべてまたは一部に対応する
1, 2, 3 次元のいずれかの画像のハンドルだ。

画像変数はテクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の各データ型ごとに、異なる型がある。
画像へのアクセスは、レベルが画像単位に束縛されているテクスチャーの対象に一致する画像型を使用する必要がある。
もしくは、3D または配列画像の非レイヤー束縛の場合は、画像のレイヤーの次元に一致する画像型を使用する必要がある。

* つまり、3D, 2DArray, Cube, CubeArray のレイヤーは ``image2D`` を使用し、
* 1DArray のレイヤーは ``image1D`` を使用し、
* 2DMSArray のレイヤーは ``image2DMS``

をそれぞれ使用する必要がある。
このように画像対象型が束縛された画像と一致しない場合、データ型が束縛された画像と一致しない場合、
フォーマットレイアウト修飾子が OpenGL 仕様の 8.25 Texture Image Loads and Stores
に記載されている画像単位フォーマットと一致しない場合、画像アクセスの結果は未定義となるが、
プログラムの終了を含むことはできない。

画像変数は :ref:`8.12. Image Functions` で記述されている画像のロード、格納、原子関数において、
アクセスする画像を指定するために用いられる。

Atomic Counters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

原子カウンター型とは、カウンターへの不透明なハンドルであって、
前述の不透明型と同様に宣言され、動作するものだ。
宣言された変数は、:ref:`8.10. Atomic Counter Functions` で記述がある、組み込みの原子カウンター関数を使用するときに、
どのカウンターにアクセスするかを指定する。
また、:ref:`4.4.7. Atomic Counter Layout Qualifiers` で記述があるように、バッファーに束縛される。

シェーダー内の配列に集約された原子カウンターは、動的一様な整数式でしかインデックスを付けることができない。
そうでない場合、結果は未定義だ。

構造体のメンバーは原子カウンター型として宣言できない。

Texture, sampler, and samplerShadow Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

テクスチャー、採取器、samplerShadow 型は不透明型で、上記の不透明な型と同様に宣言され、動作する。
シェーダー内で配列に集約されている場合、これらの型は動的一様な式でしかインデックスを付けることができない。
そうしないとテクスチャー検索は未定義の値になる。

テクスチャー変数は、:ref:`4.1 Basic Types` の表に列挙されている一次元、二次元、三次元のテクスチャー、キューブマップなどのハンドルだ。
テクスチャー型は、テクスチャー対象ごとに、また、
``float``, ``integer``, ``unsigned integer`` の各データ型ごとに異なる。

テクスチャーは、採取器型または samplerShadow 型の変数と組み合わせて、
テクスチャーを混合した採取器型 (``sampler2D``, ``sampler2DShadow``, etc.) を作ることができる。
これはコンストラクターで行う。例えば、

* ``sampler2D(texture2D, sampler)``,
* ``sampler2DShadow(texture2D, sampler)``,
* ``sampler2DShadow(texture2D, samplerShadow)``,
* ``sampler2D(texture2D, samplerShadow)``

などだ。詳細は :ref:`5.4. Constructors` で述べる。

Subpass Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

サブパス入力型（例：``subpassInput``）は不透明型で、上記の不透明型と同様に宣言され、動作するものだ。
シェーダ内ーで配列に集約される場合、動的一様な整数式でしかインデックスを付けることができず、
そうでない場合、結果は未定義となる。

サブパス入力型は、二次元の単一採取または複数採取された画像を扱うもので、
``float``, ``integer``, ``unsigned integer`` のデータ型ごとに異なる型がある。

サブパス入力型は、フラグメントシェーダーでのみ利用可能だ。他の段階での使用はコンパイルエラーとなる。

.. admonition:: コメント

   名詞 subpass の概念がわからないので、それまでこのままにしておく。

4.1.8. Structures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++ 言語の構造体 ``struct`` と同じようなことができる：

.. code:: glsl

   struct light {
       float intensity;
       vec3 position;
   } lightVar;

   light lightVar2;

ただし、C/C++ のそれよりは弱い：

* 構造体には少なくとも一つのメンバー宣言が必要。
* メンバー宣言には精度修飾子を付けることができるが、それ以外の修飾子を使用するとコンパイルエラー。
* ビットフィールドはサポートされていない。
* メンバー型はすでに定義されている必要がある（前方参照不可）。
* メンバー宣言に初期化子が含まれているとコンパイルエラー。
* メンバー宣言には、配列を含めることができる。配列にはサイズが指定されていなければならない。
  サイズはゼロより大きい定数の整数表現でなければならない
  (:ref:`4.3.3. Constant Expressions`)。
* 各レベルの構造体は、メンバー宣言子で指定された名前に対して独自の名前空間を持つ。
  このような名前は、その名前空間内で一意であればよい。
* 匿名構造体はサポートされていない。
* 埋め込み構造体の定義はサポートされていない。コンパイルエラーになる。

  .. code:: glsl

     struct S { float f; };

     struct T {
         S;              // Error: anonymous structures disallowed
         struct { ... }; // Error: embedded structures disallowed
         S s;
     };

* 構造体をコンストラクターを使用して宣言時に初期化することができる
  (:ref:`5.4.3. Structure Constructors`)。
* 型や修飾子の使用に関するあらゆる制限は、その型や修飾子のメンバーを含むすべての構造体にも適用される。
  これは、構造体である構造体メンバーにも再帰的に適用される。

4.1.9. Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

細かいことが色々と仕様化されている。

* 同じ型の変数は、名前の後に大括弧 ``[ ]`` でそのサイズを囲んで宣言することで、配列に集約することができる。
* 宣言の中で配列のサイズを指定する場合、それはゼロより大きい定数整数式
  (:ref:`4.3.3. Constant Expressions`) でなければならない。
* シェーダー格納ブロック (:ref:`4.3.9. Interface Blocks`) の最後に宣言されたメンバーを除き、
  配列のサイズは、一定の整数式以外でインデックスを付ける前に宣言 (explicitly sized) しなければならない。
* 任意の配列のサイズは、それを関数の引数として渡す前に宣言しなければならない。
  これらの規則に違反すると、コンパイルエラーが発生する。
* サイズを指定しないで配列を宣言 (unsized) し、後で同じ名前の配列を同じ型の配列として再宣言してサイズを指定するか、
  定数整数式のみでインデックスを付ける (implicitly sized) ことは適法だ。
  ただし、特に断りのない限り、ブロックを再宣言することはできない。
* ユーザーが宣言したブロック内のサイズのない配列メンバーは、
  ブロックの再宣言によってサイズを変更することはできない。
* サイズを指定して配列を宣言し、後で（同じシェーダー内で）宣言されたサイズ以上の定数整数式で同じ配列をインデックスするとコンパイルエラー。
* サイズのない配列を再宣言して、その配列のインデックスとしてシェーダ内で以前に使用されたインデックスと同等かそれ以下のサイズにすることは、コンパイルエラー。
  また、負の定数式で配列をインデックスすることもコンパイルエラー。
* 関数宣言で仮引数として宣言された配列は、サイズを指定しなければならない。
* 配列のサイズ以上、または 0 未満の非定数式で配列をインデックスすると、未定義の動作となる。
* 配列は一次元しか持たないが、配列の配列を宣言することができる。
* すべての型（基本型、構造体、配列）を配列にすることができる。

----

すべての配列は本質的に同質 (homogeneous) であり、すべて同じ型とサイズの要素で構成されているが、
例外が一つある。サイズのない配列を最後のメンバーとして持つシェーダー格納ブロックだ (runtime-sized)。
このようなシェーダー格納ブロックからは、格納ブロックの最後のメンバーの長さが異なっていたとしても、配列を形成することができる。

.. code:: glsl

   float frequencies[3];
   uniform vec4 lightPosition[4];
   light lights[];
   const int numLights = 2;
   light lights[numLights];

   // a shader storage block, introduced in section 4.3.7 "Buffer Variables"
   buffer b {
       float u[]; // an error, unless u gets statically sized by link time
       vec4 v[];  // okay, v will be sized dynamically, if not statically
   } name[3];     // when the block is arrayed, all u will be the same size,
                  // but not necessarily all v, if sized dynamically

----

配列型は、非配列型の後に配列指定子を指定することで形成できる。
このような配列指定子の次元すべてにサイズを含める必要がある。

.. code:: glsl

   float[5]    // an array of size [5] of float
   float[2][3] // an array of size [2][3] of float, not size [3] of float[2]

この型は、他の型が使用できる場所であればどこでも使用できる。関数からの戻り値であってもいい：

.. code:: glsl

   float[5] foo() { }

配列のコンストラクターとして：

.. code:: glsl

   float[5](3.4, 4.2, 5.0, 5.2, 1.1)

名前なし引数として：

.. code:: glsl

   void foo(float[5])

または変数や関数の引数パラメータを宣言する手段の代わりとしても使用できる。

.. code:: glsl

   float[5] a;

----

配列は、配列コンストラクターから形成される初期化子を持つことができる：

.. code:: glsl

   float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1);
   float a[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1);  // same thing

----

配列の配列を宣言することができる：
次の宣言はどれも ``vec4`` の長さ 2 の一次元配列の長さ 3 の一次元配列だ。

.. code:: glsl

   vec4 a[3][2]; // size-3 array of size-2 array of vec4
   vec4[2] a[3]; // size-3 array of size-2 array of vec4
   vec4[3][2] a; // size-3 array of size-2 array of vec4

透過的なメモリー（uniform block など）では、最内周（宣言では右端）の次元が
外周の次元よりも速く反復されるレイアウトになっている。
上記の配列の場合、メモリー上の順序は次のようになる：

.. code:: text

   Low address : a[0][0] : a[0][1] : a[1][0] : a[1][1] : a[2][0] : a[2][1] : High address

----

コンストラクターと名前なしの引数の両方に必要な ``a`` の型は ``vec4[3][2]`` となる：

.. code:: glsl

   vec4 b[2] = vec4[2](vec4(0.0), vec4(0.1));
   vec4[3][2] a = vec4[3][2](b, b, b); // constructor
   void foo(vec4[3][2]); // prototype with unnamed parameter

初期化子リスト構文を使って配列の配列を初期化することもできる：

.. code:: glsl

   vec4 a[3][2] = { vec4[2](vec4(0.0), vec4(1.0)),
                    vec4[2](vec4(0.0), vec4(1.0)),
                    vec4[2](vec4(0.0), vec4(1.0)) };

----

サイズなし配列を宣言時に初期化子で明示的にサイズを指定することができる：

.. code:: glsl

   float a[5];
   ...
   float b[] = a;  // b is explicitly size 5
   float b[5] = a; // means the same thing
   float b[] = float[](1,2,3,4,5); // also explicitly sizes to 5

しかし、サイズなし配列に代入するのはコンパイルエラーとなる。
これは、初期化子と代入が異なるセマンティクスを持っているように見えるまれなケースだ。
配列の配列では、サイズなし次元は初期化子によってサイズが明示的に決まる：

.. code:: glsl

   vec4 a[][] = { vec4[2](vec4(0.0), vec4(1.0)), // okay, size to a[3][2]
                  vec4[2](vec4(0.0), vec4(1.0)),
                  vec4[2](vec4(0.0), vec4(1.0)) };

----

配列は ``length()`` メソッドを使って含まれる要素の数を取得できる：

.. code:: glsl

   float a[5];
   a.length(); // returns 5

* 配列のサイズが明示的に決められている場合、``length()`` が返す値は定数式だ。
* 配列のサイズが明示的に設定されておらず、シェーダー格納ブロックの最後に宣言されたメンバーである場合、
  戻り値は定数式ではなく、ブロックに対して格納所を用意するバッファーオブジェクトのサイズに基づいて実行時に決定される。
  このような配列は runtime sized だ。
  runtime sized 配列において、配列が 0 より小さいか、配列内のブロック数以上の非定数式でインデックス付けられたシェーダー格納ブロックの配列に含まれている場合、
  ``length()`` の戻り値は未定義だ。


``length()`` を runtime sized ではなく、かつ明示的にサイズが設定されていない配列に対しては呼び出すことができない。コンパイルエラーとなる。

``length()`` がコンパイル時定数を返す場合、
``length()`` が適用される式は、式中の左辺値への書き込みや、
それ自体が副作用を持つ関数呼び出しなどの副作用を含めることはできない。
コンパイル時定数 ``length`` 自体しか計算する必要はない。

式に他の効果が含まれている場合、コンパイルエラー報告を含め、動作と結果は未定義だ。

.. code:: glsl

   float a, b;
   const int s = float[2](a=3.0, ++b).length(); // illegal side effects

----

``length()`` は配列の配列に対しても同様に機能する：

.. code:: glsl

   vec4 a[3][2];
   a.length()    // this is 3
   a[x].length() // this is 2

``length()`` がコンパイル時定数を返す場合、括弧 ``[ ]`` 内の式は解析され、
配列のインデックスに必要な規則に従うものの、配列を逆参照しない。
このように、式に副作用がない限り、式の実行時の値が範囲外であっても、動作はきちんと定義される。

``length()`` が（コンパイル時定数ではなく）実行時の値を返すと、配列を逆参照する。例えば、
``x`` がコンパイル時定数ではなく、範囲外の場合は、未定義の値を返す。
より一般的には、関係する式すべてが完全に評価され、実行される。

.. code:: glsl

   // for a compile time-sized array b containing a member array a:
   b[x+3].a.length(); // b is never dereferenced, x+3 is evaluated and checked
   b[++x].a.length(); // not allowed; results are undefined

   // for an array s of a shader storage object (run-time sized) containing a member array a:
   s[++x].a.length(); // s is dereferenced; ++x needs to be a valid index

----

暗黙的なサイズの配列や実行時サイズの配列では、最も外側の次元しかサイズを欠落することができない。
不明な配列サイズを含む型は、明示的なサイズが得られるまで配列を形成することができない。
ただし、シェーダー格納ブロックの場合は、唯一であるサイズなし配列メンバーがブロックの最後のメンバーになる。

シェーダー格納ブロックでは、最後のメンバーは明示的なサイズを指定せずに宣言することができる。
この場合、実効的な配列サイズは、インターフェイスブロックをバックアップする
データ格納場所のサイズから実行時に推論される。
このような実行時サイズの配列は、一般的な整数式でインデックスを付けることができる。
ただし、関数の引数として渡したり、負の定数式でインデックスを作成したりすることは、コンパイルエラーとなる。

.. admonition:: コメント

   ゴチャゴチャした節だが、配列の理論はレンダリングの観点から明らかに重要だ。
   読み落としはいけない。

4.1.10. Implicit Conversions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

状況によっては、式とその型が暗黙的に異なる型に変換されることがある。
許されるすべての暗黙の変換が表に示されている。

暗黙の変換は、コンストラクターを使った明示的な変換と同じだ。
コンストラクターによる明示的な変換については :ref:`5.4.1. Conversion and Scalar Constructors` にある。

二項演算子の暗黙の変換を行う場合、オペランド二つが変換できるデータ型が複数ある場合がある。
例えば ``int`` 型の値を ``uint`` 型の値に加算する場合、両方の値が ``uint``，``float``，``double``
に暗黙的に変換される可能性がある。

* このような場合、どちらかのオペランドが浮動小数点型であれば、浮動小数点型が採用される。
* また、どちらかのオペランドが符号なし整数型であれば、符号あり整数型が採用される。
* それ以外の場合は、符号付き整数型が採用される。
* オペランドが同じ基本データ型から派生する複数のデータ型に暗黙的に変換できる場合は、
  構成要素のサイズが最も小さいデータ型が採用される。

4.1.11. Initializers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

宣言には、変数の初期値を指定することができ、等号 ``=`` の後に初期化子を指定する。初期化子 (an initializer) とは、
*assignment-expression* であるか、中括弧 ``{ }`` で囲まれた初期化子のリストのどちらかをいう。

.. admonition:: コメント

   仕様書の BNF によると、モダン C++ のそれと同じと考えて良さそうだ。

*assignment-expression* は通常の式であって、括弧の外にあるカンマ ``,`` は初期化子の終わりと解釈される。
これにより入れ子になった初期化子を記述することができる。
変数型タイプとその初期化子は、入れ子、各レベルに存在する成分・要素・メンバーの数・型の点で正確に一致しなければならない。
大域スコープの *assignment-expression* には、ユーザー定義関数の呼び出しを含めることができる。

初期化子にある *assignment-expression* は、初期化するオブジェクトと同じ型であるか、
:ref:`4.1.10. Implicit Conversions` に従ってオブジェクトの型に変換できる型でなければならない。
コンストラクターを含むため、合成変数はコンストラクターでも初期化リストでも初期化でき、
初期化リストの要素をコンストラクターにすることもできる。

初期化子が中括弧で囲まれた初期化子リストの場合、宣言する変数はベクトル、行列、配列、構造体のいずれかでなければならない。

.. code:: glsl

   int i = { 1 }; // illegal, i is not a composite

釣り合う中括弧で囲まれた初期化子のリストが合成体一つに適用される。
これは、宣言されている変数、または宣言されている変数に含まれる合成体であってかまわない。
初期化子リストの個々の初期化子は、合成体の要素・メンバに対してその順に適用される。

* 合成体がベクトル型の場合、リストの初期化子は、ベクトルの成分に成分 0 から順に適用される。
  初期化子の数は成分の数と一致しなければならない。
* 合成体が行列型の場合、リストの初期化子はベクトルの初期化子でなければならず、
  行列の列に、列 0 から順に適用される。
  初期化子の数は行列の列数と一致しなければならない。
* 合成体に構造体型がある場合、リストの初期化子は、構造体で宣言されている順序で、
  最初のメンバーから順に構造体のメンバーに適用される。
  初期化子の数はメンバーの数と一致しなければならない。

これらの規則が適用されるので、次の宣言はすべて同値だ：

.. code:: glsl

   mat2x2 a = mat2(  vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) );
   mat2x2 b =      { vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) };
   mat2x2 c =      {     { 1.0, 0.0 },     { 0.0, 1.0 } };

次の宣言はすべてコンパイルエラーだ：

.. code:: glsl

   float a[2] = { 3.4, 4.2, 5.0 };         // illegal
   vec2 b = { 1.0, 2.0, 3.0 };             // illegal
   mat3x3 c = { vec3(0.0), vec3(1.0), vec3(2.0), vec3(3.0) }; // illegal
   mat2x2 d = { 1.0, 0.0, 0.0, 1.0 };      // illegal, can't flatten nesting
   struct {
       float a;
       int b;
   } e = { 1.2, 2, 3 };                    // illegal

いずれの場合も、オブジェクトに適用される最も内側の初期化子（つまり、中括弧で囲まれた初期化子のリストではない）は、
初期化されるオブジェクトと同じ型であるか、
:ref:`4.1.10. Implicit Conversions` に従ってオブジェクトの型に変換できる型でなければならない。
後者の場合、代入が行われる前に初期化子に対して暗黙の変換が行われる。

.. code:: glsl

   struct {
       float a;
       int b;
   } e = { 1.2, 2 }; // legal, all types match
   struct {
       float a;
       int b;
   } e = { 1, 3 };   // legal, first initializer is converted

次の宣言はすべてコンパイルエラーだ：

.. code:: glsl

   int a = true;                         // illegal
   vec4 b[2] = { vec4(0.0), 1.0 };       // illegal
   mat4x2 c = { vec3(0.0), vec3(1.0) };  // illegal

   struct S1 {
       vec4 a;
       vec4 b;
   };

   struct {
       float s;
       float t;
   } d[] = { S1(vec4(0.0), vec4(1.1)) }; // illegal

サイズなし配列に初期化子（いずれかの形式）が提供されている場合、
配列のサイズは、初期化子内のトップレベルの（入れ子になっていない）初期化子の数が決定する。
以下の宣言はすべて、明示的に 5 要素を持つ配列を生成する：

.. code:: glsl

   float a[] = float[](3.4, 4.2, 5.0, 5.2, 1.1);
   float b[] = { 3.4, 4.2, 5.0, 5.2, 1.1 };
   float c[] = a;                          // c is explicitly size 5
   float d[5] = b;                         // means the same thing

初期化される合成体の初期化子リストに含まれる初期化子の数に過不足があるとコンパイルエラーだ。
つまり、配列の要素すべて、構造体のメンバーすべて、行列の列すべて、
ベクトルの成分すべてには、厳密に一つの初期化子式が存在し、消費されない初期化子があってはならない。

4.2. Scoping
----------------------------------------------------------------------

変数のスコープは、その宣言位置によって決まる。

* すべての関数定義の外側で変数が宣言されている場合、それは大域スコープを持ち、
  宣言された場所から始まり、そのシェーダーの最後まで存続する。
* ``while`` テストや ``for`` 文の中で宣言されている場合は、それに続く部分文の最後までスコープされる。
* ``if`` 文や ``else`` 文の中で宣言されている場合は、その文の最後までスコープされる。
  :ref:`6.2. Selection`, :ref:`6.3. Iteration` を参照。
* 複文の中の文として宣言されている場合は、その複文の末尾にスコープされる。
* 関数定義の中で引数として宣言されている場合は、その関数定義の最後までスコープされる。
* 関数の引数宣言と本体は、大域スコープに入れ子になった単一のスコープを形成する。
* ``if`` 文の式では、新しい変数を宣言することができないため、新しいスコープを形成しない。

宣言の中では、名前のスコープは、初期化子がある場合はその直後から、
ない場合は宣言されている名前の直後から始まる。

.. admonition:: コメント

   仕様書ではここに C/C++ プログラマーなら納得の行くコード例が挙げられている。

----

``for`` ループも ``while`` ループも、部分文自体は変数名の新しいスコープを導入していないので、
以下は再宣言のコンパイルエラーになる：

.. code:: glsl

   for ( /* nested scope begins here */ int i = 0; i < 10; i++) {
       int i; // redeclaration error
   }

``do``-``while`` ループの本体では、本体が単文か複文かによらず、
``do`` と ``while`` の間（テスト式は含まない）だけ続く新しいスコープが導入される。

.. code:: glsl

   int i = 17;
   do
       int i = 4;  // okay, in nested scope_
   while (i == 0); // i is 17, scoped outside the do-while body

``switch(...)`` に続く文は、入れ子スコープを形成する。

あるスコープ内のすべての変数名、構造体型名、関数名は同じ名前空間を共有する。
関数名は、同じスコープ内で、同じまたは異なるパラメータでエラーなしで再宣言できる。
暗黙的なサイズの配列は、同じ基本型の配列と同じスコープで再宣言できる。
それ以外の場合、一つのコンパイル単位内では、宣言された名前を同じスコープで再宣言することはできない。
再宣言するとコンパイルエラーになる。
入れ子になったスコープが外側のスコープで使用されている名前を再宣言すると、
その名前の既存の使用がすべて隠される。隠された名前にアクセスしたり、隠蔽を解除したりするには、
隠蔽したスコープを終了しなければならない。

組み込み関数のスコープは、ユーザーが大域変数を宣言する大域スコープの外側にある。
つまり、シェーダーの大域スコープは、ユーザー定義関数や大域変数を使えられ、
組み込み関数を含むスコープの中に入れ子になっている。
入れ子になったスコープで関数名を再宣言すると、外側のスコープでその名前で宣言された関数すべてが隠蔽される。
関数の宣言（プロトタイプ）は、関数の内部には記述できない。
大域スコープか、組み込み関数の場合は大域スコープの外側に記述しなければならず、
記述しない場合はコンパイルエラーになる。

----

共有大域とは、同一言語（頂点などの同一段階）内で独立してコンパイルされた単位（シェーダー）内で同じ名前で宣言された大域変数で、
単一のプログラムを作る際にリンクされるものだ
（異なるシェーダー言語間のインターフェイスとなる大域については別の節で述べる）。
共有大域は同じ名前空間を共有し、同じ型で宣言する必要がある。
また、同じ格納域を共有する。

共有大域配列は、同じ基本型と同じ明示的なサイズでなければならない。
あるシェーダーで暗黙的にサイズ設定された配列は、同じ段階の別のシェーダーで明示的にサイズ設定することができる。
ある段階のどのシェーダーも配列の明示的なサイズを持っていない場合、
その段階の最大の暗黙的なサイズ（使用されている最大のインデックスよりも 1 多い）が採用される。
段階をまたいだ配列のサイズ変更はない。
これは、配列が他の段階やアプリケーションと共有されるインターフェイスブロック内で宣言されている場合に関係する
（他の未使用の配列は最適化により排除されてもかまわない）。

共有される大域スカラーは、厳密に同じ型名と型定義を持たなければならない。
構造体は、同じ名前、一連の型名、型定義、およびメンバー名を持たなければ、同じ型とはみなされない。
この規則は入れ子になった型や埋め込まれた型にも再帰的に適用される。
共有大域に複数の初期化子がある場合、初期化子はすべて定数式であり、すべて同じ値でなければならない。
そうでない場合は、リンクエラーが発生する（初期化子が一つしかない共有大域では、その初期化子を定数式にする必要はない）。

.. admonition:: コメント

   最後の 3 パラグラフについては、仕様書を全部読んでいない段階では、
   シェーダーを書くときに ``main`` の外側に置く変数が関係しているだろうと想像する。

4.3. Storage Qualifiers
----------------------------------------------------------------------

変数宣言では、型の前に高々一つの格納修飾子を指定することができる。
詳しくは本書の表を参照。名前だけ列挙すると：
``const``, ``in``, ``out``, ``attribute``, ``uniform``, ``varying``,
``buffer``, ``shared``, 以上。

入出力修飾変数の中には、高々一つの補助格納修飾子を追加できるものがある。
詳しくは本書の表を参照。名前だけ列挙すると：
``centroid``, ``sample``, ``patch``, 以上。

すべての修飾子の組み合わせが許されるわけではない。
補助格納修飾子は ``in`` または ``out`` 修飾子と一緒にしか使用できない。
その他の修飾子の規則については、以降の節で説明。

局所変数は ``const`` 修飾子のみ使用できる（または格納修飾子を使用しない）。

関数の引数には ``const``, ``in``, ``out`` を使用できるが、
引数修飾子としては使用できないことに注意。引数修飾子については
:ref:`6.1.1. Function Calling Conventions` を参照。

関数の戻り値の型や構造体のメンバーには格納修飾子を使用しない。

大域宣言の初期化子は、格納修飾子がないか、
``const`` 修飾子があるか、または ``uniform`` 修飾子がある大域変数の宣言でしか使用できない。

格納修飾子のない大域変数は、その宣言またはアプリケーションで初期化されないと、
初期化されずに未定義の値で ``main()`` に入る。

あるシェーダー段階の出力と後続のシェーダー段階の入力を比較するとき、
補助修飾子（またはその欠落）が同じでない場合、入力と出力は一致しない。

4.3.1. Default Storage Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

大域変数に修飾子がない場合、その変数はアプリケーションや他のパイプライン段階で実行されるシェーダーとはリンクしていない。
大域変数でも局所変数でも、修飾されていない変数では、宣言は対象となる処理器に関連するメモリーが割り当てられているように見える。
この変数は、この割り当てられたメモリーへの読み取り・書き込みアクセスを提供する。

.. admonition:: コメント

   意味不明。

4.3.2. Constant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is a compile-time error to write to a const variable outside of its declaration, so they must be initialized when declared. For example,
名前付きのコンパイル時定数や読み取り専用の変数は ``const`` 修飾子を使って宣言できる。
``const`` 修飾子は、非 ``void`` 透過基本データ型や、それらの構造体や配列で使用できる。
宣言されていない ``const`` 変数に書き込むコードはコンパイルエラーとなるから、宣言時に初期化する必要がある。

.. code:: glsl

   const vec3 zAxis = vec3(0.0, 0.0, 1.0);
   const float ceiling = a + b; // a and b not necessarily constants

構造体のメンバーは ``const`` で修飾することはできない。
構造体変数は ``const`` として宣言し、構造体のコンストラクターまたは初期化子で初期化できる。

大域スコープでの ``const`` 宣言の初期化子は、次節で定義されるように、定数式でなければならない。

4.3.3. Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SPIR-V の特殊化定数は、"特殊化-定数修飾子 "で説明したように、GLSL では
``const`` にレイアウト修飾子 ``const_id`` を付けて表現される。

**定数式** (a constant expression) とは次のいずれかだ：

* リテラル値
* ``const`` 修飾子と初期化子で宣言された変数で、初期化子が定数式であるもの。
  これは ``layout(const_id = ...)`` のような特殊化定数レイアウト修飾子を付けて宣言された
  ``const`` と、特殊化定数レイアウト修飾子を付けずに宣言された ``const`` の両方を含む。
* ``const`` として修飾された組み込み変数。
* 定数配列の要素、定数構造体のメンバー、定数ベクトルの構成要素の取得など、
  すべて定数式であるオペランドに対して演算子で形成される式。
* オブジェクト自体が定数であるかどうかに関わらず、明示的なサイズのオブジェクトに対する
  ``length()`` メソッドの適切な使用（暗黙的なサイズの配列や実行時サイズの配列は定数式を返さない）。
* 引数がすべて定数式であるコンストラクター。
* 非特殊化定数の場合のみ：引数がすべて定数式である特定の組み込み関数の呼び出しの戻り値
  （少なくとも以下のリストを含む）。メモリーにアクセスしないその他の組み込み関数
  （テクスチャー探索関数、画像アクセス、原子カウンターなどを除く）であって、
  戻り値の型が非 ``void`` で ``out`` 引数がなく、ノイズ関数ではないものも定数とみなされる場合がある。
  関数が特殊化定数である引数で呼び出された場合、その結果は定数式ではない。

  * 角度および三角関数
  * 指数関数
  * 普通の関数
  * 幾何関数

* ユーザー定義関数（非組み込み関数）の関数呼び出しは、定数式には使用できない。

----

**定整数式** (a constant integral expression) とは定数式であって、スカラーの符号付きまたは符号なしの整数に評価されるものだ。

定数式は不変的な方法で評価されるため、複数のシェーダーに同じ定数式が現れた場合、同じ値が生成される。
:ref:`4.8.1. The Invariant Qualifier`, :ref:`4.7.2. Precision Qualifiers` を参照。

定数式は ``precision`` 修飾子と ``invariant`` 修飾子を尊重するが、
そのような修飾子の使用とは関係なく、常に不変的に評価されるため、
複数のシェーダーに同じ定数式が現れた場合には、同じ値が生成される。

定数式はホストプラットフォームで評価される可能性がある。
それゆえ同じ式がシェーダー実行対象で評価するような値と同じものを計算する必要はない。
ただし、ホストは対象が使用するのと同じか、それ以上の精度を使用しなければならない。
精度修飾子が決定できない場合、式は ``highp`` で評価される。
:ref:`4.7.3. Default Precision Qualifiers` 参照。

特殊化定数式は、コンパイラーのフロントエンドでは評価されないで、
代わりに、後でホスト上で評価するために必要な式の操作を留めておく。

4.3.4. Input Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

シェーダーの入力変数は ``in`` 格納修飾子で宣言される。
この変数は、API パイプラインの前段階と宣言したシェーダーとの間の入力インターフェイスを形成する。
入力変数は大域スコープで宣言しなければならない。
前のパイプライン段階から来る値は、シェーダー実行開始時に入力変数にコピーされる。
入力として宣言された変数に書き込むコードはコンパイルエラーとなる。

前の段階で書き込む必要があるのは、静的に読み込まれる入力変数だけであり、
入力変数の宣言が余計に付いていても構わない。

.. admonition:: コメント

   本文ではこのことをまとめた表がここに示されているが、割愛する。

消費エラーは静的な使用にしかよらない。
未定義の値を消費する可能性のある動的な使用方法をコンパイラーが推論する場合、エラーではなく警告を発する。
組み込み入力名の一覧は :ref:`7. Built-In Variables` を参照。

頂点シェーダーの入力変数（または属性）は、頂点ごとのデータを受け取る。
頂点シェーダー入力に補助格納修飾子や補間修飾子を使用すると、コンパイルエラーとなる。
コピーされた値は API またはレイアウト識別子 ``location`` の使用により設けられる。

以下の型で頂点シェーダー入力を宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型
* 構造体

----

頂点シェーダーにおける入力宣言の例を示す：

.. code:: glsl

   in vec4 position;
   in vec3 normal;
   in vec2 texCoord[4];

----

グラフィックスハードウェアでは、頂点入力を渡すための固定のベクトル場所が足りないことが予想される。
そのため、OpenGL Shading Language では、行列以外の入力変数は、そのようなベクトル場所を一つ使用すると定義している。
使用できる場所の数には実装依存の制限があり、これを超えるとリンクエラーが発生する
（静的使用でないと宣言された入力変数は、この制限に含まれない）。
スカラー入力は ``vec4`` と同じようにカウントされるので、
アプリケーションでは、基礎となるハードウェアの性能をよりよく活用するために、
関係のない 4 つの ``float`` 入力のグループをまとめてベクトルにすることを検討するとよいだろう。
行列入力は、複数の場所を使用する。使用される場所の数は、行列の列数と同じだ。

多角形分割制御、多角形分割評価、幾何シェーダーの入力変数は、
前のアクティブシェーダー段階で同じ名前の出力変数によって書き出された、頂点ごとの値を取得する。
これらの入力では ``centroid`` や補間修飾子が使えるが、効果はない。
多角形分割制御、多角形分割評価、幾何シェーダーは頂点集合を操作するので、
各入力変数（または入力ブロック、下記のインターフェイスブロックを参照）は配列として宣言する必要がある。

.. code:: glsl

   in float foo[]; // geometry shader input for vertex "out float foo"

このような配列の各要素は、処理される基本形状の一つの頂点に対応する。
各配列はオプションでサイズを宣言することができる。
幾何シェーダーの場合、配列のサイズは、:ref:`4.4.1. Input Layout Qualifiers` のように、
入力基本形状の型を設定する入力 ``layout`` 宣言によって設定される。

----

入力と出力は配列されているものもある。これは、シェーダー段階二つの間にあるインターフェイスでは、
入力または出力の宣言を一致させるために、余分なレベルの配列インデックスが必要になることを意味する。
例えば、頂点シェーダーと幾何シェーダーのインターフェイスでは、
頂点シェーダーの出力変数と幾何シェーダーの入力変数の同名の変数は、型が一致していなければならない。
ただし、幾何シェーダーは、頂点のインデックス付けを可能にするために、頂点シェーダーよりも 1 多い配列次元を持つことになる。
このように配列されたインターフェイス変数が、必要である追加的入力・出力配列次元で宣言されていない場合、リンクエラーとなる。
幾何シェーダー入力、多角形分割制御シェーダー入出力、多角形分割評価入力はすべて、
他のシェーダー入出力に比べて追加的配列レベルを持っている。
これらの入力と出力は、頂点ごとに配列された (per-vertex-arrayed) 入力と出力として知られている。
配列されたインターフェイス (``gl_MaxTessControlInputComponents``, etc.)
の成分制限は、インターフェイス全体に対する制限ではなく、頂点ごとの制限だ。

非配列のインターフェイス（＝段階間配列の次元が変わらない）では、
入力変数が一致する出力変数と配列の次元を含めて同じ型で宣言されていないと、リンクエラーとなる。

リンク時の型マッチング規則は、使用されているか否かに関わらず、
宣言されたすべての入力変数と出力変数に適用される。

さらに、多角形分割評価シェーダーは ``patch`` および ``in`` 修飾子で宣言された
``patch`` ごとの入力変数をサポートしている。
パッチごとの入力変数には、多角形分割制御シェーダーによって書き込まれたパッチごとの出力変数の値が入る。
パッチごとの入力は一次元配列として宣言できるが、頂点数によるインデックスは付けられない。
入力への ``patch`` 修飾子の適用は、多角形分割評価シェーダでしか行えない。
他の入力変数と同様に、パッチごとの入力は、前の（多角形分割・制御）シェーダー段階からの
パッチごとの出力と同じ型と修飾子を使って宣言しなければならない。
他の段階の入力で ``patch`` を使用することは、コンパイルエラーとなる。

多角形分割制御、多角形分割評価、幾何シェーダーの入力を、以下のいずれかの型で宣言することは、コンパイルエラーとなる：

* 真偽型
* 不透明型

----

フラグメントシェーダーの入力は、前の段階の出力から補間されたフラグメントごとの値をふつうは取得する。
補助格納修飾子 ``centroid`` と ``sample`` も、補間修飾子 ``flat``, ``noperspective``, ``smooth`` と同様に適用できる。

フラグメントシェーダーの入力を次のいずれかの型で宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

整数型または倍精度浮動小数点型であるか、またはそれを含むフラグメントシェーダー入力には補間修飾子 ``flat`` が必要だ。

フラグメント入力は以下の例のように宣言される：

.. code:: glsl

   in vec3 normal;
   centroid in vec2 TexCoord;
   invariant centroid in vec4 Color;
   noperspective in float temperature;
   flat in vec3 myColor;
   noperspective centroid in vec2 myTexCoord;

フラグメントシェーダーの入力は、頂点処理パイプラインにおける最終アクティブシェーダーとのインターフェイスを形成する。
このインターフェイスでは、最終アクティブシェーダー段階出力変数とフラグメントシェーダーの入力変数の同名の変数は、
いくつかの例外（格納修飾子の一方は ``in`` で他方は ``out`` でなければならない）を除いて、型と修飾子が一致していなければならない。
また、補間修飾子や補助修飾子も異なる場合がある。
これらのミスマッチは任意の段階対の間で許される。
補間修飾子や補助修飾子が一致しない場合は、フラグメントシェーダーで提供される修飾子が前段階で提供される修飾子よりも優先される。
フラグメントシェーダーにそのような修飾子が全くない場合は、前段階で宣言されていた修飾子ではなく、既定の修飾子が使用される。
つまり、重要なのはフラグメントシェーダーで何が宣言されているかであり、
前段階のシェーダーで何が宣言されているかではないということだ。

----

シェーダー段階間のインターフェイスが別々のプログラムオブジェクトのシェーダーを使って形成されている場合、
プログラムがリンクされたときに入力と出力の間のミスマッチを検出することはできない。
このようなインターフェイスでは、入力と出力の間にミスマッチがあると、
インターフェイスを介して渡される値は、部分的にまたは完全に未定義となる。

シェーダーで入出力レイアウト修飾子 (:ref:`4.4.1. Input Layout Qualifiers`,
:ref:`4.4.2. Output Layout Qualifiers`)
を使用するか、ブロックや変数の入力宣言と出力宣言を同一にすることで、このようなインターフェイス間のマッチングを担保することができる。
インターフェイスのマッチングに関する完全な規則は、OpenGL 仕様書の 7.4.1項 Shader Interface Matching に記載されている。

----

計算シェーダはユーザ定義の入力変数を許可せず、他のシェーダー段階との正式なインターフェイスを形成しない。
組み込みの計算シェーダー入力変数については :ref:`7.1.6. Compute Shader Special Variables` を参照。
計算シェーダーへの他のすべての入力は、画像ロード、テクスチャー取得、
uniforms または uniform buffers からのロード、または他のユーザーコードによって明示的に取得される。
計算シェーダーの組み込み入力変数を再宣言することはできない。

4.3.5. Uniform Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. admonition:: コメント

   英単語 uniform をどう訳したらしっくり来るだろうか。数学科専攻としては「一様」にしたい。
   中国語の仕様書を見たら「統一」に相当する単語をあてているようだ。

修飾子 ``uniform`` は、処理される基本形状全体で値が同じになる大域変数を宣言するために用いられる。
``uniform`` 変数はすべて読み取り専用で、リンク時または API を通じて外部から初期化される。
リンク時の初期値は、変数の初期化子が存在する場合はその値で、存在しない場合は 0 だ。
不透明型は初期化子を持つことができず、そうでない場合はコンパイルエラーが発生する。

.. code:: glsl

   uniform vec4 lightPosition;
   uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time

修飾子 ``uniform`` は、基本的なデータ型のいずれか、または構造体を型とする変数を宣言するとき、
あるいはこれらのいずれかの配列を宣言するときに使用できる。

シェーダーの種類ごとに使用できる ``uniform`` 用変数の収容量には実装依存の制限がある。
これを超えるとコンパイル時またはリンク時にエラーとなる。
宣言されているが使用されていない ``uniform`` 変数はこの制限に入らない。
ユーザー定義の ``uniform`` 変数の個数と、シェーダー内で使用されている
組み込みの ``uniform`` 変数の個数の和で、利用可能な収容量を超えているかどうかを判断する。

シェーダー内の ``uniform`` 変数は、プログラムまたは分割可能なプログラムにリンクされている場合、
すべて単一の大域名前空間を共有する。したがって、同じ名前で静的に使用される ``uniform`` 変数の
型、初期化子、および任意の ``location`` 指定子は、単一プログラムにリンクされているすべてのシェーダーで
一致しなければならない。ただし、リンクされたすべてのシェーダーで初期化子や ``location`` 指定子を繰り返す必要はない。
``uniform`` 変数名がある段階（例：頂点シェーダー）で宣言され、
別の段階（例：フラグメントシェーダー）で宣言されていない場合、
その名前は別の段階で別の用途に使用することが許される。

4.3.6. Output Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

シェーダー出力変数は ``out`` 格納修飾子で宣言される。
出力変数は、宣言したシェーダーと API パイプラインの後続段階との間の出力インターフェイスを形成する。
出力変数は大域スコープで宣言しなければならない。
シェーダーの実行中は、修飾のない通常の大域変数として振る舞う。
シェーダーの終了時にその値は後続のパイプライン段階にコピーされる。
後続のパイプライン段階で読まれる出力変数だけが書き込まれる必要があり、出力変数の余計な宣言があっても構わない。

単一の変数名をシェーダーの入力と出力の両方として宣言するための ``inout`` のような格納修飾子は存在しない。
一つの変数に ``in`` と ``out`` の両方の修飾子をつけて宣言することもまたできない。コンパイル時またはリンク時にエラーとなる。
出力変数は、入力変数とは異なる名前で宣言しなければならない。
ただし、インスタンス名を持つインターフェイス・ブロックの中に入力または出力を入れ子にすると、
ブロックのインスタンス名で参照されるものと同じ名前を使うことができる。

頂点、多角形分割評価、幾何の出力変数は、頂点ごとのデータを出力し、
``out`` 修飾子を用いて宣言される。
出力への ``patch`` の適用は、多角形分割制御シェーダーでのみ可能だ。
それ以外の段階での適用はコンパイルエラーとなる。

頂点、多角形分割評価、多角形分割制御、幾何それぞれのシェーダーの出力を、
以下の型のいずれかで宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

.. code:: glsl

   out vec3 normal;
   centroid out vec2 TexCoord;
   invariant centroid out vec4 Color;
   flat out vec3 myColor;
   sample out vec4 perSampleColor;

これらは :ref:`4.3.9. Interface Blocks` で述べられるように、
インターフェイスブロックにも出現する。インターフェイスブロックでは、
頂点シェーダーから幾何シェーダーへのインターフェイスに、より単純に配列を追加することができる。
また、フラグメントシェーダーに、ある頂点シェーダーの幾何シェーダーと同じ入力インターフェイスを持たせることができる。

----

多角形分割制御シェーダーの出力変数は、頂点ごとのデータと patch ごとのデータを出力するために用いられる。
頂点ごとの出力変数は配列され (:ref:`4.3.4. Input Variables`)、
``out`` 修飾子で ``patch`` 修飾子なしに宣言される。
パッチごとの出力変数は ``patch`` 修飾子と ``out`` 修飾子で宣言される。

多角形分割制御シェーダーは、複数の頂点からなる配列された基本形状を生成するため、
各頂点ごとの出力変数（または出力ブロック）は、配列として宣言する必要がある：

.. code:: glsl

   out float foo[]; // feeds next stage input "in float foo[]"

このような配列の要素それぞれが、生成される基本形状一つの頂点に対応する。
各配列はオプションでサイズを宣言することができる。
配列のサイズは出力パッチの頂点の数を定める出力レイアウト宣言によって設定される
(:ref:`Tessellation Control Outputs`)（または、宣言されている場合は、それと一致しなければならない）。

各多角形分割制御シェーダー呼び出しは、対応する出力パッチの頂点を持ち、
その対応する頂点に属しているときに限り、
頂点ごとの出力に値を割り当てることができる。
頂点ごとの出力変数を左辺値として使用する場合、
頂点のインデックスを示す式が識別子 ``gl_InvocationID`` でないと、コンパイル時またはリンク時のエラーになる。

同じ入力パッチに対する他の呼び出しに対する多角形分割制御シェーダー呼び出しの相対的な実行順序は、
組み込み関数 ``barrier()`` が使用されない限り、未定義だ。
これにより、相対的な実行順序の制御が可能になる。
シェーダーの呼び出しが ``barrier()`` を呼び出すと、他のすべての呼び出しが同じ実行ポイントに到達するまでその実行は一時停止する。
``barrier()`` を呼び出す前に実行された任意の呼び出しによって実行された出力変数の割り当ては、
``barrier()`` の呼び出しが戻った後、他の任意の呼び出しから見えるようになる。

多角形分割制御シェーダーの呼び出しは、バリア間で未定義の順序で実行されるので、
頂点ごと、あるいはパッチごとの出力変数の値は時々未定義になる。
シェーダー実行の開始と終了、および ``barrier()`` の各呼び出しを同期時点と考えるといい。
出力変数の値が不定になるのは、以下の三つの場合のいずれかだ：

1. 実行の開始時
2. 以下の場合を除く各同期時点：

   * 前回の同期時点の後に値が定義され、その後どの呼び出しによっても書き込まれなかった場合、または
   * 前回の同期時点以降、厳密に一つのシェーダー呼び出しによって値が書き込まれた場合、または
   * 前回の同期時点以降に複数のシェーダー呼び出しによって値が書き込まれ、
     そのようなすべての呼び出しによって実行された最後の書き込みが同じ値を書き込んだ場合。

3. シェーダーの呼び出しによって読み込まれたとき、もし

   * その値が前回の同期時点で未定義であり、その後同じシェーダー呼び出しによって書き込まれていない場合、または
   * 前回と次回の同期時点の間に他のシェーダー呼び出しによって出力変数が書き込まれた場合
     （その割り当てが読み取り後のコードで発生したときでさえ）

----

フラグメント出力は、フラグメントごとのデータを出力し、
``out`` 修飾子で宣言される。
フラグメントシェーダー出力の宣言に補助格納修飾子や補間修飾子を使用するとコンパイルエラーとなる。
フラグメントシェーダー出力を以下の型で宣言するとコンパイルエラーとなる：

* 真偽型
* 倍精度スカラーまたはベクトル (``double``, ``dvec2``, ``dvec3``, ``dvec4``)
* 不透明型
* 行列型
* 構造体

フラグメント出力宣言の例：

.. code:: glsl

   out vec4 FragmentColor;
   out uint Luminosity;

----

計算シェーダーは組み込みの出力変数を持たず、ユーザー定義の出力変数もサポートせず、
他のシェーダー段階との正式なインターフェイスを形成しない。
計算シェーダーからの出力はすべて、画像格納や原子カウンターの演算などの副作用の形をとる。

4.3.7. Buffer Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

修飾子 ``buffer`` はAPI を通じて束縛されたバッファーオブジェクトのデータ格納空間に
値が格納される大域変数を宣言するために使用される。
バッファー変数はすべてのアクティブなシェーダー呼び出しの間で内包される格納空間を共有して読み書きすることができる。
単一のシェーダー呼び出し内でのバッファー変数のメモリーの読み取りと書き込みは順番に処理される。
しかし、ある起動で実行される読み込みと書き込みの順序は、他の呼び出しで実行されるものと比較するとほとんど未定義だ。
バッファー変数は内包されているメモリーへのアクセス方法に影響を与えるメモリー修飾子
(:ref:`4.10. Memory Qualifiers`) で修飾することができる。

修飾子 ``buffer`` は、インターフェイスブロック (:ref:`4.3.9. Interface Blocks`)
を宣言するために使用することができ、これらのブロックはシェーダー格納ブロックとして参照される。
ブロックの外でバッファー変数を宣言するとコンパイルエラーとなる。

.. code:: glsl

   // use buffer to create a buffer block (shader storage block)
   buffer BufferName { // externally visible name of buffer
       int count;      // typed, shared memory...
       ...             // ...
       vec4 v[];       // last member may be an array that is not sized
                       // until after link time (dynamically sized)
   } Name;             // name of block within the shader

シェーダーの種類ごとに使用されるシェーダー格納ブロックの数、
プログラムに使用されるシェーダー格納ストレージブロックの合計数、
個々のシェーダー格納ブロックが必要とする格納空間の量には、実装に依存した制限がある。
これらの制限を超えた場合は、コンパイル時またはリンク時にエラーが発生する。

複数のシェーダーがリンクされている場合、それらのシェーダーは単一に大域バッファー変数の名前空間を共有することになる。
したがって、同じ名前で宣言されたバッファー変数の型は、
単一のプログラムにリンクされているすべてのシェーダーで一致しなければならない。

4.3.8. Shared Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

修飾子 ``shared`` は、計算シェーダー作業グループ内のすべての作業項目間で共有される
格納空間がある大域変数を宣言するために用いられる。
``shared`` として宣言された変数は、計算シェーダーでしか使用されない
(:ref:`2.6. Compute Processor`)。
それ以外の共有変数の宣言は、コンパイルエラーとなる。
共有変数は暗黙的に ``coherent`` (:ref:`4.10. Memory Qualifiers`) だ。

共有変数として宣言された変数は初期化子を持たず、シェーダーの実行開始時にはその内容は未定義だ。
共有変数に書き込まれたどんなデータも、同じ作業グループ内の他の作業項目（同じシェーダーを実行中）から見えるということになる。

同期が行われていない場合、シェーダーの異なる呼び出しによる同じ ``shared`` 変数への読み書きの順序は未定義とする。

共有変数への読み書きの順序を決めるためには、関数 ``barrier()`` を使って制御フローの障壁を設ける必要がある
(:ref:`8.16. Shader Invocation Control Functions`)。

単一のプログラムで共有変数として宣言されたすべての変数の合計サイズには制限がある。
basic machine units 単位で表されるこの制限は、OpenGL API を使って
``MAX_COMPUTE_SHARED_MEMORY_SIZE`` の値を照会することで決定できる。

.. admonition:: コメント

   最後のパラグラフ中の basic machine units なる用語がわからない。

4.3.9. Interface Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

入力、出力、一様、バッファー変数の宣言は、名前の付いたインターフェイスブロックにまとめることができ、
個別の宣言では達せられない粗い粒度の backing が可能になる。
これらはオプションでインスタンス名を持つことができ、シェーダー内でそのメンバーを参照するために用いられる。
あるプログラム可能段階の出力ブロックは、後続のプログラム可能段階の対応する入力ブロックによって back される。
一様ブロック (a uniform block) は、アプリケーションによってバッファーオブジェクトで back される。
シェーダー格納ブロック (a shader storage block) と呼ばれるバッファー変数のブロックも、
アプリケーションによってバッファーオブジェクトで back される。
頂点シェーダーの入力ブロックやフラグメントシェーダーの出力ブロックを持つことは、コンパイルエラーとなり。
これらの用途は将来のために予約されている。

インターフェイスブロックは、キーワード ``in`, ``out``, ``uniform``, ``buffer``
と、ブロック名、そして中括弧 ``{`` で始まる。

.. admonition:: コメント

   BNF による一覧を省略。

----

次のコードは ``Transform`` という名前の一様ブロックを定義する。
``uniform`` 変数四つがグループ化される。

.. code:: glsl

   uniform Transform {
       mat4 ModelViewMatrix;
       mat4 ModelViewProjectionMatrix;
       uniform mat3 NormalMatrix;      // allowed restatement of qualifier
       float Deformation;
   };

----

型と宣言子は、ブロック外の他の入力、出力、一様、バッファー変数の宣言と同じだ、以下の例外がある：

* 初期化子は許されない。
* 不透明型は許されない。
* ブロック内での構造体定義の入れ子は許されない。

これらはいずれもコンパイルエラーになる。

メンバー宣言にオプションの修飾子がない場合、メンバーの修飾には、
interface-qualifier で決定されるすべての ``in``, ``out``, ``patch``, ``uniform``,
``buffer`` が含まれる。
オプション修飾子を使用する場合、補間修飾子、補助格納修飾子、格納修飾子を含むことができ、
ブロックのインターフェイス修飾子と一致する入力、出力、一様メンバーを宣言しなければならない。
すなわち、入力変数、出力変数、一様変数、
``buffer`` メンバーは、
``in`` ブロック、
``out`` ブロック、
``uniform`` ブロック、シェーダー格納ブロック内それぞれにしか存在しない。

メンバーのストレージ修飾子に ``in``, ``out``, ``patch``, ``uniform``, ``buffer``
のいずれかのインターフェイス修飾子を繰り返すことはオプションだ。例えば：

.. code:: glsl

   in Material {
       smooth in vec4 Color1; // legal, input inside in block
       smooth vec4 Color2;    // legal, 'in' inherited from 'in Material'
       vec2 TexCoord;         // legal, TexCoord is an input
       uniform float Atten;   // illegal, mismatched storage qualifier
   };

----

**シェーダーインターフェイス** (a shader interface) とは、次のうちの一つとする：

* プログラムの中で宣言されたすべての一様変数と一様ブロック。
  これは、一つのプログラム内でリンクされているすべてのコンパイル単位に及ぶ。
* プログラム内で宣言された ``buffer`` ブロックすべて。
* 隣接するプログラム可能パイプライン段階間の境界。
  最初の段階のコンパイル単位すべてで宣言された出力すべてと、
  次の段階のコンパイル単位すべて宣言された入力すべてに及ぶ。
  なお、実際にはフラグメントシェーダーに渡された値すべては、
  まずラスタライザーと補間器を通過するが、
  この定義では、フラグメントシェーダーと先行するシェーダーは境界を共有すると考えられる。

ブロック名 (block-name) は、シェーダーインターフェイス内での照合に用いられる。
つまり、あるパイプライン段階の出力ブロックは、後続のパイプライン段階の同名の入力ブロックに合致する。
一様ブロックやシェーダー格納ブロックの場合、アプリケーションはブロック名を使ってブロックを識別する。
シェーダー内ではインターフェイスの照合以外にはブロック名を利用できない。
大域スコープのブロック名をブロック名として以外に使用することはコンパイルエラーとなる
（例えば、大域変数名や関数名にブロック名を使用することが現在予約されている）。
ブロックの内容が同じであっても、一つのシェーダー内の同じシェーダーインターフェイスの
複数のブロック宣言に同じブロック名を使用すると、コンパイルエラーとなる。

一つのシェーダインターフェイスの中で合致したブロック名は、同じ数の宣言と同じ型の並び、
同じメンバー名の並び、そしてメンバーごとのレイアウト修飾が一致していなければならない。
一致した一様ブロック名またはシェーダー格納ロック名（入力ブロック名または出力ブロック名ではない）は、
すべてインスタンス名がないか、またはすべてインスタンス名があり、
それらのメンバーが同じスコープレベルにあることも必要だ。
合致したブロック名の上にインスタンス名がある場合、インスタンス名が違っていても構わない。
さらに、合致ブロックが配列として宣言されている場合は、配列のサイズまでも一致していなければならない。
（または、連続するシェーダー段階間のシェーダーインターフェイスの配列一致規則ルールに従う）。
不一致の場合、リンクタイムエラーとなる。
ブロック名は、同一シェーダー内の異なるシェーダーインターフェイスで異なる定義であることが許されており、
例えば、入力ブロックと出力ブロックが同じ名前であることも可能である。

インスタンス名 (instance-name) を使用しない場合、ブロック内で宣言された名前は大域レベルでスコープされ、
ブロックの外で宣言されたかのようにアクセスされる。
インスタンス名を使用すると、スコープ内のすべてのメンバーが独自の名前空間内に置かれ、
構造体と同様の、フィールドセレクター演算子 ``.`` でアクセスされる：

.. code:: glsl

   in Light {
       vec4 LightPos;
       vec3 LightColor;
   };
   in ColoredTexture {
       vec4 Color;
       vec2 TexCoord;
   } Material;           // instance name
   vec3 Color;           // different Color than Material.Color
   vec4 LightPos;        // illegal, already defined
   ...
   ... = LightPos;       // accessing LightPos
   ... = Material.Color; // accessing Color in ColoredTexture block

シェーディング言語の外では、メンバーは同様に識別されるが、
インスタンス名の代わりにブロック名が常に使用される。API のアクセスはシェーダーではなくシェーダーインターフェイスに対して行われるのだ。
インスタンス名がない場合、API はメンバーにアクセスするためにブロック名を使用せず、メンバー名だけを使用する。

シェーダーインターフェイス内では、同じ大域名の宣言すべては同じオブジェクトに対するものでなければならず、
型や、インスタンス名のないブロックの変数やメンバーを宣言しているかどうかが一致していなければならない。
また、API はシェーダーインターフェイス内のオブジェクトを一意に識別するためにこの名前を必要とする。
次のどちらかが成り立つならば、どのシェーダーインターフェイスもリンクエラーになる：

* インスタンス名を持たず、同じ名前のメンバーを持つ相異なるブロックが含まれている。
* ブロック外の変数と、インスタンス名のないブロックで、その変数がブロック内のメンバーと同じ名前である。

.. code:: glsl

   out Vertex {
       vec4 Position;  // API transform/feedback will use "Vertex.Position"
       vec2 Texture;
   } Coords;           // shader will use "Coords.Position"
   out Vertex2 {
       vec4 Color;     // API will use "Color"
       float Color2;
   };

   // in same program as Vertex2 above:
   out Vertex3 {
       float Intensity;
       vec4 Color;     // ERROR, name collision with Color in Vertex2
   };
   float Color2;       // ERROR, collides with Color2 in Vertex2

----

配列として宣言されたブロックでは、メンバーにアクセスする際に配列のインデックスも含める必要がある：

.. code:: glsl

   uniform Transform { // API uses "Transform[2]" to refer to instance 2
       mat4 ModelViewMatrix;
       mat4 ModelViewProjectionMatrix;
       vec4 a[]; // array will get implicitly sized
       float Deformation;
   } transforms[4];
   ...
   ... = transforms[2].ModelViewMatrix; // shader access of instance 2
   // API uses "Transform.ModelViewMatrix" to query an offset or other query
   transforms[x].a.length(); // same length for 'a' for all x
   Transform[x];             // illegal, must use 'transforms'
   Transform.a.length();     // illegal, must use 'transforms'
   ...transforms[2].a[3]...  // if these are the only two dereferences of 'a',
   ...transforms[3].a[7]...  // then 'a' must be size 8, for all
   transforms[x]

配列として宣言された一様ブロックやシェーダー格納ブロックでは、個々の配列要素が、
ブロックのインスタンス一つを back する、個別のバッファーオブジェクトの結合範囲に対応する。
配列のサイズは必要なバッファーオブジェクトの数を示すため、
一様ブロックやシェーダー格納ブロックの配列宣言では、配列のサイズを指定する必要がある。
一様ブロックやシェーダー格納ブロックの配列は、動的一様な整数式でしかインデックスを付けることができず、
それ以外の場合は結果が未定義だ。

OpenGL API のエントリーポイントを使用してブロックの配列内の個々のブロックの名前を特定する場合、
``Transform[2]`` のようにして、名前の文字列に配列のインデックスを含めることができる。
OpenGL API のエントリーポイントを使用してブロックメンバーのオフセットやその他の性質を参照する場合、
``Transform.ModelViewMatrix`` のように、配列インデックスを抜かなければならない。

多角形分割制御、多角形分割評価、幾何シェーダー入力ブロックは、配列として宣言されなければならず、
それぞれの段階のシェーダー入力すべては配列宣言とリンクルールに従わなければならない。
その他のすべての入出力ブロックの配列は、配列サイズを指定しなければならない。

段階ごとに使用できる一様ブロックの個数とシェーダー格納ブロックの個数は、実装依存の制限がある。
いずれかの制限を超えた場合、リンクエラーとなる。

4.4. Layout Qualifiers
----------------------------------------------------------------------

レイアウト修飾子は宣言形式がいくつかある。
前節の文法で示したように、インターフェイスブロックの定義やブロックメンバーの一部として現れることがある。
一つの *layout-qualifier* だけで、その修飾子を使った他の宣言のレイアウトを設定することもできる。

| *layout-qualifier* *interface-qualifier* ;

また、インターフェース修飾子で宣言された個別の変数で出現することもある：

| *layout-qualifier* *interface-qualifier* *declaration* ;

レイアウトの宣言は、大域スコープまたはブロックメンバーでしか行えず、以下の節で示される場所でしか行えない。

レイアウト修飾子は次のように展開する：

|   *layout-qualifier* :
|       ``layout (`` *layout-qualifier-id-list* ``)``
|
|   *layout-qualifier-id-list* :
|       *layout-qualifier-id*
|       *layout-qualifier-id* , *layout-qualifier-id-list*
|
|   *layout-qualifier-id* :
|       *layout-qualifier-name*
|       *layout-qualifier-name* = *layout-qualifier-value*
|       ``shared``
|
|   *layout-qualifier-value* :
|       *integer-constant-expression*

*layout-qualifier-name* に使用されるトークンは、キーワードではなく識別子で、
*layout-qualifier-id* としてキーワード **shared** を使用することができる。
一般的に、これらはどのような順序でも並べてよい。
順序に依存する意味は、下で明示されている場合に限り存在する。
同様に、これらの識別子は、明示的に別段の記載がない限り、大文字と小文字を区別しない。

単一の宣言にレイアウト修飾子を複数含めることができる。
また、同じ *layout-qualifier-name* が、一つのレイアウト修飾子の中で複数回現れたり、
同じ宣言の中で複数のレイアウト修飾子にまたがって現れたりすることがある。
同じ *layout-qualifier-name* が単一の宣言の中で複数回出現する場合、
最後に出現したものがそれ以前に出現したものよりも優先される。
さらに、このような *layout-qualifier-name* が後続の宣言やその他の観察可能な挙動に影響する場合、
影響を与えるのは最後に出現するものだけであり、
以前に出現したものは存在しないかのように振る舞う。
これは *layout-qualifier-name* を上書きする場合にも当てはまり、
一方が他方を上書き場合 (e.g. ``row_major`` vs. ``column_major``) には、
最後に出現するものだけが影響を及ぼす。

*integer-constant-expression* は :ref:`4.3.3. Constant Expressions` で
*constant integral expression* として定義されており、
*integer-constant-expression* が特殊化定数であることはコンパイルエラーになる。

.. admonition:: コメント

   仕様書本文ではレイアウト修飾子の使用法の概要が表になって掲載されている。
   巨大なデータなので引用は控える。

4.4.1. Input Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

計算シェーダーを除くすべてのシェーダーでは、入力変数宣言、入力ブロック宣言、入力ブロックメンバー宣言に対して
レイアウト修飾子 ``location`` を使うことができる。このうち、変数とブロックメンバー（ブロックは不可）には、
さらにレイアウト修飾子 ``component`` が使用できる。

| *layout-qualifier-id* :
| ``location`` = *layout-qualifier-value*
| ``component`` = *layout-qualifier-value*

例：

.. code:: glsl

   layout(location = 3) in vec4 normal;
   const int start = 6;
   layout(location = start + 2) int vec4 v;

これにより、シェーダー入力の ``normal`` はベクトル位置番号 3 に、
``v`` は位置番号 8 に割り当てられる。
頂点シェーダー入力の場合、位置を入力値を取得する頂点属性の番号で指定する。
他のすべてのシェーダー型の入力では、そのシェーダーが別のプログラムオブジェクト内にあったとしても、
位置を以前のシェーダー段階からの出力との照合に使用できるベクトル番号で指定する。

続く言語では、特定の型で消費される位置の数を記述する。
ただし、幾何シェーダー入力、多角形分割制御シェーダー入出力、
多角形分割評価入力はすべて、他のシェーダー入出力に対して追加の配列レベルを持っている。
この外側の配列レベルは、型が消費する位置の数を考慮する前に、型から取り除かれます。

Vulkan を対象にしている場合を除き、頂点シェーダー入力が任意のスカラーまたはベクトル型である場合、
位置を一つを消費する。非頂点シェーダーの入力や Vulkan を対象にしている場合の段階入力が
``dvec3`` や ``dvec4`` 以外のスカラー型やベクトル型の場合は、
位置を一つを消費するが、
``dvec3`` や ``dvec4`` 型の場合は連続した二つの位置を消費する。
``double`` 型や ``dvec2`` 型の入力は、段階すべてで一つの位置しか消費しない。

上述のように外側の配列レベルを削除した後、宣言された入力がサイズ n の配列で、
各要素が m 個の位置を取る場合、指定された位置から始まる m × n 個の連続した位置が割り当てられる。
例えば：

.. code:: glsl

   layout(location = 6) in vec4 colors[3];

これにより、シェーダーの入力色がベクトルの位置番号 6, 7, 8 に割り当てられることが確定する。

宣言された入力が n × m 行列の場合は、指定された位置から始まる複数の位置が割り当てられる。
各行列に割り当てられる位置の数は、m 成分のベクトルの n 要素の配列と同じになる。例えば：

.. code:: glsl

   layout(location = 9) in mat4 transforms[2];

これにより、シェーダー入力 ``transforms`` がベクトルの 9～16番に割り当てられる：

* ``transforms[0]`` が 9, 10, 11, 12 番に、
* ``transforms[1]`` が 13, 14, 15, 16 番に

割り当てられる。

----

宣言された入力が構造体やブロックの場合、そのメンバーには宣言順に連続した位置が割り当てられ、
最初のメンバーにはレイアウト修飾子で指定された位置が割り当てられる。
構造体の場合、この処理は構造体全体に適用される。
``layout`` 修飾子を構造体のメンバーに使用するとコンパイルエラーとなる。
ブロックの場合、この処理はブロック全体に適用される。
つまり ``location`` レイアウト修飾子を持つ最初のメンバーに到達するまで適用される。

ブロックのメンバーが ``location`` 修飾子付きで宣言されている場合、
そのメンバーの位置はその修飾子に由来し、メンバーの ``location`` 修飾子がブロックレベルの宣言よりも優先される。
後続のメンバーには、次の ``location`` 修飾子が宣言されたメンバーまで、
最新の位置に基づいて連続した位置が再び割り当てられる。
位置に使用される値は、昇順に宣言する必要はない。

ブロックレベルの ``location`` 修飾子がないブロックでは、
そのメンバーのすべてが ``location`` 修飾子を持つか、またはそれを一つも持たないことが要求される。
さもないとコンパイルエラーとなる。
配列として宣言されたブロックには ``location`` がブロックレベルでしか適用できないものがある。
ブロックが配列として宣言されていて、ブロックの配列要素ごとに各メンバーに追加の位置が必要な場合、
ブロックのメンバーに位置を指定するとコンパイルエラーになる。
つまり、ブロックメンバ上ーに位置を適用することで指定不足になる場合、それは認められない。
配列されたインターフェイス（一般にインターフェイスの拡張により余計な配列を持つもの）では、
この規則を適用する前に外側の配列が取り除かれる。

ブロックや構造体のメンバーが消費する位置は、構造体のメンバーが同じ型の入力変数として宣言されているかのように、
上記の規則を再帰的に適用して決定される：

.. code:: glsl

   layout(location = 3) in struct S
   {
       vec3 a;                      // gets location 3
       mat2 b;                      // gets locations 4 and 5
       vec4 c[2];                   // gets locations 6 and 7
       layout(location = 8) vec2 A; // ERROR, can't use on struct member
   } s;
   layout(location = 4) in block
   {
       vec4 d;                      // gets location 4
       vec4 e;                      // gets location 5
       layout(location = 7) vec4 f; // gets location 7
       vec4 g;                      // gets location 8
       layout(location = 1) vec4 h; // gets location 1
       vec4 i;                      // gets location 2
       vec4 j;                      // gets location 3
       vec4 k;                      // ERROR, location 4 already used
   };

シェーダーが利用できる入力位置の数には制限がある。
頂点シェーダーでは、その制限は公示された頂点属性の数だ。
その他のシェーダーでは、制限は実装に依存し、公示された最大入力成分数の 1/4 以上でなければならない。

取り付けられたシェーダーがサポートされている個数を超える位置を使用している場合、
デバイス依存最適化がプログラムに利用可能なハードウェア資源内に収まるようにさせない限り、
プログラムはリンクに失敗する。

明示的な位置割り当てにより、リンカーが他の明示的割り当てのない変数のための空間を見つけられない場合、プログラムはリンクに失敗する。

非頂点入力が以前のシェーダー段階の出力と一致するかどうかを判断するためには、
``location`` レイアウト修飾子がもしあれば一致していなければならない。

シェーダーテキストに位置が割り当てられていない頂点シェーダー入力変数に
OpenGL API で指定された位置がある場合は、その指定位置が使用される。
そうでなければ、そのような変数はリンカーによって場所が割り当てられる。
入力変数が同じ言語の複数のシェーダーで宣言されていて、位置が競合している場合、リンクエラー。

修飾子 ``component`` を使用すると、スカラーやベクトルの位置をより細かく指定することができ、
消費される位置内の個々の成分まで指定することができる
修飾子 ``location`` を指定せずに ``component`` を使用すると、コンパイルエラーになる（順序は重要でない）。
位置内の成分は 0, 1, 2, 3 だ。
成分 N で始まる変数やブロックメンバーは、そのサイズまでの成分 N, N+1, N+2, ...を消費する。
この成分の並びが 3 より大きくなると、コンパイルエラーになる。
スカラー ``double`` はこれらの成分のうち二つを消費し、
``dvec2`` はある位置で利用可能な四つの成分全てを消費する。
``dvec3`` や ``dvec4`` は成分指定なしでしか宣言できない。
``dvec3`` は一つ目の位置の四つの成分と、二つ目の位置の成分 0 と 1 をすべて消費する。
これにより、成分 2 と 3 は他の成分修飾された宣言に使用できる。

.. code:: glsl

   // a consumes components 2 and 3 of location 4
   layout(location = 4, component = 2) in vec2 a;

   // b consumes component 1 of location 4
   layout(location = 4, component = 1) in float b;

   // ERROR: c overflows component 3
   layout(location = 3, component = 2) in vec3 c;

   // d consumes components 2 and 3 of location 5
   layout(location = 5, component = 2) in double d;

   // ERROR: e overflows component 3 of location 6
   layout(location = 6, component = 2) in dvec2 e;

   // ERROR: f overlaps with g
   layout(location = 7, component = 0) double f;
   layout(location = 7, component = 1) float g;

   layout(location = 8) in dvec3 h; // components 0,1,2 and 3 of location 8
                                    // and components 0 and 1 of location 9
   layout(location = 9, component = 2) in float i; // okay, compts 2 and 3

but all at the same specified component within each location. For example:
変数が配列の場合、配列の各要素は順番に連続した位置に割り当てられるが、
各位置の中ですべて同じ指定された成分になる：

.. code:: glsl

   // component 3 in 6 locations are consumed
   layout(location = 2, component = 3) in float d[6];

この場合、位置 2 の成分 3 は ``d[0]`` を、位置 3 の成分 3 は ``d[1]`` を、...
位置 7 の成分 3 に ``d[5]`` を格納する。

これにより二つの配列を同じ位置にまとめることができる：

.. code:: glsl

   // e consumes beginning (components 0, 1 and 2) of each of 6 slots
   layout(location = 0, component = 0) in vec3 e[6];

   // f consumes last component of the same 6 slots
   layout(location = 0, component = 3) in float f[6];

これを配列の配列に適用する場合は、すべてのレベルの配列性が取り除かれ、
指定された成分に位置ごとに割り当てられた要素になる。
これらの非配列要素は :ref:`4.1.9. Arrays` が指定する順序で配列の配列に対する位置を埋める。

修飾子 ``component`` を行列、構造体、ブロック、またはこれらを含む配列に適用するとコンパイルエラーになる。
``component`` 1 または 3 を ``double`` または ``dvec2`` の先頭に使用するとコンパイルエラーになる。
プログラム内で同じ変数に異なる成分を指定すると、リンクエラーになる。

----

**位置エイリアシング** (location aliasing) とは、二つの変数やブロックメンバーに同じ位置番号を持たせることだ。
**成分エイリアシング** (component aliasing) とは、二つの位置エイリアスに同じ（または重複する）成分番号を割り当てることだ
（``component`` を使用しない場合は 0 から始まる成分が割り当てられることを思い出せ）。
一つの例外を除いて、位置エイリアシングは成分エイリアシングを起こさない場合に限り許される。
さらに、位置エイリアシングを行う場合、その位置を共有するエイリアスは、
基礎となる数値型とビット幅が同じでなければならず、補助格納修飾子と補間修飾子も同じでなければならない。
成分エイリアシングが許可される例外とは、頂点シェーダーへの二つの入力変数
（ブロックメンバーではない）に対して OpenGL を対象にする場合で、
これらは成分エイリアシングが許されている。
この頂点変数の成分エイリアシングは、各実行パスがエイリアシングされた各成分ごとに
高々一つの入力にアクセスする頂点シェーダーをサポートすることしか目的としていない。
頂点シェーダー実行形式を通るすべての実行パスが、
任意の単一成分にエイリアスされた複数の入力にアクセスすることを検出した場合、
実装はこれをリンクタイムエラーとすることが許されているが、必須ではない。

Tessellation Evaluation Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

多角形分割評価シェーダーで使える追加的な入力レイアウト修飾子の識別子は次の通り：

| *layout-qualifier-id* :
|     *primitive-mode*
|     *vertex-spacing*
|     *ordering*
|     *point-mode*

識別子 *primitive-mode* は多角形分割基本形状生成器が使用する。

| *primitive-mode*:
|     ``triangles``
|     ``quads``
|     ``isolines``

*primitive-mode* がもしあれば、多角形分割基本形状生成器は三角形をより小さな三角形に、
四角形を三角形に、四角形を線の集合体にそれぞれ細分するべきだと指定する。

レイアウト識別子の二番目のグループである頂点間隔は、
多角形分割基本形状生成器が辺を細分化する際の間隔を指定するために用いられる。

| *vertex-spacing*:
|     ``equal_spacing``
|     ``fractional_even_spacing``
|     ``fractional_odd_spacing``

``equal_spacing`` は辺を同じ大きさのセグメントの集まりに分割することを指定する。

``fractional_even_spacing`` は、辺を偶数個の同じ長さのセグメントとさらに二つのより短い「小数」のセグメントに分割することを指定する。

``fractional_odd_spacing`` は、辺を奇数個の同じ長さのセグメントとさらに二つの短い「小数」セグメントに分割することを指定する。

三番目のレイアウト識別子である *ordering* は、多角形分割基本形状生成器が、
OpenGL 仕様にある座標系に従い、時計回りまたは反時計回りのどちらの順序で三角形を生成するのかを指定する。

| *ordering*:
|     cw
|     ccw

識別子 ``cw`` と ``ccw`` は、それぞれ時計回りと反時計回りの三角形を示す。
多角形分割基本形状生成器が三角形を生成しない場合、この順序は無視される。

最後の *point-mode* は、多角形分割基本形状生成器が、線や三角形を生成するのではなく、
細分化された基本形状のそれぞれの紛れのない頂点に対して一点を生成するべきであることを示す。

| *point-mode*:
|     point_mode

----

これらの識別子は、単一の入力レイアウト宣言の中で、一回またはそれ以上指定することができる。
プログラムの多角形分割評価シェーダーの中で、
*primitive-mode*, *vertex-spacing*, *ordering* が複数回宣言されている場合、
そのような宣言はすべて同じ識別子を使用しなければならない。

プログラム内の少なくとも一つの多角形分割評価シェーダー（コンパイル単位）は、
その入力レイアウトで *primitive-mode* を宣言しなければならない。
*vertex-spacing*, *ordering*, *point_mode* 識別子の宣言はオプションだ。
プログラム内の多角形分割評価シェーダーすべてが *primitive_mode* を宣言するということは必須ではない。
*vertex-spacing* や *ordering* の宣言が省略された場合、多角形分割基本形状生成器は、
それぞれ等間隔または反時計回りの頂点順序を採用する。
*point-mode* の宣言が省略された場合、多角形分割基本形状生成器は、
*primitive-mode* に従って線分または三角形を生成する。

Geometry Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

幾何シェーダー入力に対する追加のレイアウト修飾子識別子には、基本形状 (primitive) 識別子と
呼び出し回数 (invocation count) 識別子がある：

| *layout-qualifier-id* :
|     ``points``
|     ``lines``
|     ``lines_adjacency``
|     ``triangles``
|     ``triangles_adjacency``
|     ``invocations`` = *layout-qualifier-value*

識別子 ``points``, ``lines``, ``lines_adjacency``, ``triangles``, ``triangles_adjacency``
は、幾何シェーダーが受け付ける入力基本形状の種類を指定するためのもので、
これらのうちただ一つを受け付ける。
プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、
この入力基本形状のレイアウトを宣言しなければならず、
プログラム内の幾何シェーダーすべての入力レイアウト宣言は同じレイアウトを宣言しなければならない。
プログラム内のすべての幾何シェーダーが入力基本形状レイアウトを宣言することは必須ではない。

識別子 ``invocations`` は、受けとった入力基本形状それぞれに対して幾何シェーダー実行形式が
呼び出される回数を指定するために用いられる。回数の宣言はオプションだ。
プログラム内のどの幾何シェーダーでも回数が宣言されていない場合、
幾何シェーダーは入力基本形状それぞれに対して一度実行される。
宣言されている場合は、すべての宣言で同じ回数を指定しなければならない。
シェーダーが実装依存の最大値を超える呼び出し回数を指定したり、
ゼロ以下の呼び出し回数を指定したりすると、コンパイルエラーとなる。

.. code:: glsl

   layout(triangles, invocations = 6) in;

例えば上の宣言では、幾何シェーダーへの入力はすべて三角形であり、幾何シェーダーの実行形式は、
処理される三角形ごとに 6 回実行される。

幾何シェーダー入力サイズなし配列宣言のすべてで、以前の入力基本形状レイアウト修飾子がある場合、サイズが変更される：

* ``points``: 1
* ``lines``: 2
* ``lines_adjacency``: 4
* ``triangles``: 3
* ``triangles_adjacency``: 6

内在的に宣言された入力配列 ``gl_in[]`` は、任意の入力基本形状レイアウト宣言によってもサイズが決定される。
そのため、式 ``gl_in.length()`` 式は上にある値を返す。

``gl_in`` などの内在的に宣言された入力、配列サイズを持たずに宣言された入力については、
メソッド ``length()`` を使用する前か、配列サイズを知る必要のあるその他の配列使用の前に
レイアウトを宣言しなければならない。

レイアウト宣言の配列サイズが、同じシェーダー内の入力変数の宣言で指定されている明示的な配列サイズすべてと一致しない場合は
コンパイルエラーとなります。コンパイルエラーの例：

.. code:: glsl

   // code sequence within one shader...
   in vec4 Color1[];     // legal, size still unknown
   in vec4 Color2[2];    // legal, size is 2
   in vec4 Color3[3];    // illegal, input sizes are inconsistent
   layout(lines) in;     // legal for Color2, input size is 2, matching Color2
   in vec4 Color4[3];    // illegal, contradicts layout of lines
   layout(lines) in;     // legal, matches other layout() declaration
   layout(triangles) in; // illegal, does not match earlier layout() declaration

プログラム内の幾何シェーダーすべてにおいて、提供されたサイズのすべて
（サイズ付き入力配列とレイアウトサイズ）が一致しない場合は、リンクエラーとなる。

Fragment Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``gl_FragCoord`` には以下のような追加的フラグメントレイアウト修飾子がある：

| *layout-qualifier-id* :
|     ``origin_upper_left``
|     ``pixel_center_integer``

OpenGL の ``gl_FragCoord`` は既定ではウィンドウの座標は左下を原点とし、
ピクセル中心は半ピクセルの座標にあるとしている。例えば、ウィンドウの左下端のピクセルに対しては
``(x, y)`` 座標 ``(0.5, 0.5)`` が返される。
原点は ``gl_FragCoord`` に ``origin_upper_left`` 修飾子を付けて再宣言することで変更することができ、
``gl_FragCoord`` の原点をウィンドウの左上に移動させ、
``y`` はウィンドウの下に向かって値を大きくしていく。
また、返される値は、``pixel_center_integer`` によって、
``x`` と ``y`` の両方で半ピクセルずつずらすことができ、
ピクセルが整数のオフセットで中心に置かれているように見える。
これは ``gl_FragCoord`` で返される ``(x, y)`` の値が既定値が ``(0.5, 0.5)`` であるのに対し、
``pixel_center_integer`` で ``(0.0, 0.0)`` に移動する。

Vulkan を対象にする場合、``gl_FragCoord`` の原点は左上で、
ピクセル中心は半ピクセル座標に配置されていると仮定し、要求される。
この原点を明示的に設定するには ``gl_FragCoord`` を ``origin_upper_left`` 識別子で再宣言する。

再宣言は次のように行う：

.. code:: glsl

   in vec4 gl_FragCoord; // redeclaration that changes nothing is allowed

   // All the following are allowed redeclaration that change behavior
   layout(origin_upper_left) in vec4 gl_FragCoord;
   layout(pixel_center_integer) in vec4 gl_FragCoord;
   layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;

``gl_FragCoord`` がプログラム内のいずれかのフラグメントシェーダーで再宣言された場合、
そのプログラム内で ``gl_FragCoord`` を静的に使用しているすべてのフラグメントシェーダーで
再宣言されなければならない。
単一のプログラム内にあるフラグメントシェーダーすべてにおける ``gl_FragCoord`` の再宣言は
すべてが同じ修飾子の集合でなければならない。
どのシェーダー内でも ``gl_FragCoord`` の最初の再宣言が
``gl_FragCoord`` のどの使用の前にも現れなければならない。
組み込み ``gl_FragCoord`` はフラグメントシェーダーでしか事前に宣言されていないので、
他のシェーダー言語で再宣言するとコンパイルエラーになる。

``origin_upper_left`` 修飾子と ``pixel_center_integer`` 修飾子の両方とも、またはいずれか一方をつけて
``gl_FragCoord`` を再宣言しても ``gl_FragCoord.x`` と ``gl_FragCoord.y`` にしか影響しない。
ラスタライズ、座標変換、その他の API パイプラインや言語機能には影響しない。

フラグメントシェーダーでは、OpenGL 仕様書の 15.2.4 "Early Fragment Tests" に記載されているように、
フラグメントシェーダーの実行前にフラグメントテストを行うことを要求するために、
``in`` のみで次のレイアウト修飾子を使用することが許される（変数宣言では不可）：

| *layout-qualifier-id* :
|     early_fragment_tests

.. code:: glsl

   layout(early_fragment_tests) in;

例えば上の宣言では、フラグメントシェーダーの実行前にフラグメントごとのテストが行われるようになる。
これを宣言しない場合は、フラグメントシェーダーの実行後にフラグメントごとのテストが行われる。
この宣言が必要となるのは、一つのフラグメントシェーダー（コンパイル単位）だけだが、
複数のフラグメントシェーダーが宣言することもできる。
少なくとも一つがこれを宣言していれば有効になる。

Compute Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

計算シェーダー入力にはレイアウト位置修飾子がない。

計算シェーダー入力に対するレイアウト修飾子の識別子は、作業グループサイズ修飾子だ：

| *layout-qualifier-id* :
|     ``local_size_x`` = *layout-qualifier-value*
|     ``local_size_y`` = *layout-qualifier-value*
|     ``local_size_z`` = *layout-qualifier-value*

If a shader does not specify a size for one of the dimensions, that dimension will have a size of 1.

For example, the following declaration in a compute shader
``local_size_x``, ``local_size_y``, ``local_size_z`` 各修飾子は、
それぞれ 1, 2, 3 次元の計算シェーダーによる固定作業グループのサイズを宣言するために用いられる。
シェーダーが次元のサイズをここから指定していない場合、その次元は 1 となる。

例えば、計算シェーダーで次のように宣言した場合、

.. code:: glsl

   layout(local_size_x = 32, local_size_y = 32) in;

作業グループサイズが 32×32 要素の二次元計算シェーダーを宣言するために用いられる。
これは、3次元目のサイズが 1 である三次元計算シェーダーに相当する。

.. admonition:: コメント

   上の一文は何を言っているのか。

もう一つ別の例として、次の宣言は、一次元の計算シェーダーがコンパイルされており、
そのサイズが実質的には 8 要素であることを指定している：

.. code:: glsl

   layout(local_size_x = 8) in;

いずれかの次元におけるシェーダーの固定作業グループサイズがゼロ以下、
または実装でサポートされる最大サイズよりも大きい場合、コンパイルエラー。
また、このようなレイアウト修飾子が同一シェーダー内で複数回宣言されている場合、
それらの宣言はすべて同じ作業グループサイズの集合を設定し、同じ値を設定しなければならない。
さもなければコンパイルエラー。
単一のプログラムオブジェクトに取り付けられた複数の計算シェーダーが固定作業グループサイズを宣言する場合、
その宣言は同一でなければならない。さもなければリンクエラー。

さらに、プログラムオブジェクトが計算シェーダーを何か含む場合、
少なくとも一つはプログラムの固定作業グループサイズを指定する入力レイアウト修飾子を含まなければならない。
さもなければリンクエラー。

4.4.2. Output Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



4.4.3. Uniform Variable Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.4. Subroutine Function Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.5. Uniform and Shader Storage Block Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.6. Opaque Uniform Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.7. Atomic Counter Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.8. Format Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.4.9. Subpass Input Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4.5. Interpolation Qualifiers
----------------------------------------------------------------------


4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.6. Parameter Qualifiers
----------------------------------------------------------------------


4.7. Precision and Precision Qualifiers
----------------------------------------------------------------------


4.7.1. Range and Precision
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.2. Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.3. Default Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.7.4. Available Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.8. Variance and the Invariant Qualifier
----------------------------------------------------------------------



4.8.1. The Invariant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.8.2. Invariance of Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


4.9. The Precise Qualifier
----------------------------------------------------------------------


4.10. Memory Qualifiers
----------------------------------------------------------------------


4.11. Specialization-Constant Qualifier
----------------------------------------------------------------------


4.12. Order and Repetition of Qualification
----------------------------------------------------------------------


4.13. Empty Declarations
----------------------------------------------------------------------

