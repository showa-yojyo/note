======================================================================
GLSL 4.60 仕様書 読書ノート 3 of ?
======================================================================

.. contents:: ノート目次

3. Basics
======================================================================

.. note::

   原文の英語を、次のように機械的に単語を日本語に読み換える：

   * directive: 指令

   その他、定訳がない単語についてはカタカナ表記という手抜きをする。

3.1. Character Set and Phases of Compilation
----------------------------------------------------------------------

OpenGL Shading Language に使用されるソースコードを構成する文字集合は UTF-8 符号規格の Unicode だ。

前処理後の GLSL トークンのストリームでは、以下の文字だけが使用可能だ：

* ``[a-zA-Z_]``
* ``[0-9]``
* 記号各種

それ以外の文字を GLSL のトークンに使用した場合は、コンパイル時にエラーになる。

* 行は、コンパイラーの診断メッセージや前処理器に関係する。
* 行は、キャリッジリターンまたはラインフィードで終了する。
* 両者が同時に使用された場合は、一つの行終端としてカウントされる。
* この文書では、これらの組み合わせを単に改行と呼ぶことにする。
* 行の長さは自由に設定できる。
* 一般的に、この言語では文字集合の大文字と小文字を区別する。
* 文字や文字列のデータ型がないため、引用符文字も含まれない。
* ファイル終端文字もない。

より正式には、コンパイルは以下の論理的局面が順番に実行されるように行われる：

1. ソースとなる文字列が連結され、単一の入力となる。改行はすべて保持される。
2. 行番号は、現在のすべての改行に基づいて表示され、後に改行が削除されても変更されない。
3. 改行の直前にバックスラッシュがある場合は、両方とも削除される
   （空白は置換されないので、一つのトークンが改行をまたぐことができる)。
   新たに生成されたバックスラッシュと改行は取り除かれず、
   局面 1. 以降に最初に生成された対しか取り除かれない。
4. すべてのコメントは単一の空白文字で置き換えられる。
   ただし、// スタイルのコメントは、終了する改行の前で終わり、空白は一般的に前処理に関係する。
5. 前処理が行われ、上記の文字集合から形成された GLSL トークンの一連の並びが得られる。
6. GLSL トークンの一連の並びに対して GLSL 処理が行われる。

3.2. Source Strings
----------------------------------------------------------------------

単一のシェーダーに対するソースとは、文字集合の文字列の配列だ。
単一のシェーダーはこれらの文字列を連結したものからなる。
各文字列は改行で区切られた複数の行を含むことができる。
一つの文字列の中に改行がある必要はなく、複数の文字列から単一行を形成することができる。
文字列を連結して単一シェーダーを形成する際には、実装は改行やその他の文字を挿入しない。
複数のシェーダーをリンクして単一のプログラムにすることができる。

シェーダーのコンパイルから返される診断メッセージは、
文字列内の行番号と、そのメッセージがどのソース文字列に該当するかの両方を特定する必要がある。
ソース文字列は、最初の文字列を文字列 0 として順次カウントされる。
行番号は、処理された新しい行の数よりも一つ多くなるが、これには、
行継続文字によって削除される新しい行をカウントすることも含まれる。

改行 (a new-line) の前にあって、行継続文字により区切られた行（複数形）は、コメント処理や前処理の前に連結される。
これは行継続文字の代わりに空白文字が使われることはないことを意味する。
すなわち、ある行の終わりの文字とその次の行の始まりの文字を連結することで、単一トークンが形成される。

.. code:: glsl

   // equivalent to "float foo;"
   float f\
   oo;

.. note::

   Pygments (2.9.0) は上記コード片を正しくハイライトできない。

3.3. Preprocessor
----------------------------------------------------------------------

コンパイルの一環としてソース文字列を処理する前処理器がある。
後で記す点を除けば C++ 標準の前処理器として動作する。

.. note::

   指示子の一覧省略。

各記号 ``#`` は、その行の前に空白またはタブしか置くことができない。
また、空白やタブを、指令の前に置くこともできる。
各指令は改行で終了する。前処理では、文字列中の改行の数や相対的な位置は変更されない。
前処理は、行継続文字によって改行が取り除かれた後に行われる。

行中の記号 ``#`` は無視される。上記以外の指令は、コンパイル時にエラーになる。

C++ 前処理器の標準機能である ``#define`` および ``#undef`` 機能は、
マクロパラメーターを持つマクロ定義と持たないマクロ定義の両方で定義される。

----

以下の定義済みマクロが用意されている：

.. code:: glsl

   __LINE__
   __FILE__
   __VERSION__

``__LINE__`` は、現在のソース文字列における先行する改行数よりも 1 多い十進数の整数定数に置換される。

``__FILE__`` は、どのソース文字列番号が現在処理されているのかを示す十進数の整数定数に置換される。

``__VERSION__`` は、OpenGL シェーディング言語のバージョン番号を反映した十進数の整数に置換される。
この文書によるシェーディング言語のバージョンは 460 に置換される。

慣習上、二つ以上の連続したアンダースコアを含むすべてのマクロ名は、
下位のソフトウェア層が使用するために予約済みだ。
シェーダー内でこのような名前を定義したり定義解除したりしても、それ自体がエラーになることはないものの、
同じ名前が複数定義されていることに起因する意図しない動作が発生する可能性がある。
また、``GL_`` から始まるマクロ名もすべて予約済みで、このような名前を定義したり、
定義解除したりすると、コンパイル時にエラーになる。

実装では、マクロ名の長さを最大 1024 文字までサポートする必要がある。
実装では、1024 文字を超える長さのマクロ名に対してエラーを生成することも、
そのようなマクロ名をサポートすることも許可されている。

----

``#if``, ``#ifdef``, ``#ifndef``, ``#else``, ``#elif``, ``#endif`` は、
以下の点を除き、C++ 前処理器の標準的な動作をするように定義されている：

* ``#if`` および ``#elif`` に続く式は次の二つに制限される：

  * リテラルの整数定数と、
  * 演算子 ``defined`` によって消費される識別子を操作する式

* 文字定数はサポートされていない。

----

使用できる演算子の表省略。

----

.. todo::

   長い説明を消化する。

3.4. Comments
----------------------------------------------------------------------

コメントは ``/*`` と ``*/``、または ``//`` と改行で区切られる。
コメント開始時のデリミターは、コメント内ではコメントデリミターとして認識されないため、
コメントを入れ子にすることはできない。
コメント ``/*`` はコメント終了時のデリミター ``*/`` を含む。
しかし ``//`` コメントは終端の改行を含まない（つまり排除する）。

コメント内では、値が 0 のバイトを除き、任意のバイト値を使用することができる。
コメントの内容については、エラーは発生せず、コメントの内容を検証する必要もない。

コメントが処理される前に、論理的には行継続文字による改行の除去が行われる。
つまり、文字 ``\`` で終わる単一行コメントは、次の行も含めてコメントになる。

.. code:: glsl

   // a single-line comment containing the next line \
   a = b; // this is still in the first comment

3.5. Tokens
----------------------------------------------------------------------

前処理を終えた言語は、トークンの順序のある並びだ。

.. code:: text

   token :
       keyword
       identifier
       integer-constant
       floating-constant
       operator
       ; { }

3.6. Keywords
----------------------------------------------------------------------

この節の前半にある一覧が当言語のキーワードであり、前処理以降はこの仕様書に記載されている通りにしか使用できず、
そうでない場合はコンパイル時にエラーが発生する。

Vulkan を対象にする場合には追加のキーワードが存在する。

さらに、将来使用するために予約されてるキーワードが多数定義されている。
これらを使用すると、コンパイル時にエラーが発生する。

その上、前述のダブルアンダースコア規則が適用される。

3.7. Identifiers
----------------------------------------------------------------------

識別子は、変数名、関数名、構造体名、フィールドセレクター（構造体のメンバーと同様に、
フィールドセレクターはベクトルや行列の構成要素を選択する）に使用される。

.. note::

   識別子の BNF みたいな表がここにあるが省略。

* ``gl_`` で始まる識別子は予約されており、一般的にはシェーダ内で宣言することはできない。
* 前述の 1024 文字ルールがここでも適用される。

3.8. Definitions
----------------------------------------------------------------------

後述する言語規則のいくつかは、次の定義に依存する。

3.8.1. Static Use
----------------------------------------------------------------------

シェーダーに変数 ``x`` が **静的に使用されている** (a static use) のは、
前処理後にシェーダーに ``x`` の任意の部分にアクセスするような文が含まれている場合であり、
制御の流れによってその文が実行されるかどうかには関係ない。
このような変数は、 **静的に使用されている** (statically used) と呼ばれる。
アクセスが書き込みの場合、``x`` は **静的に割り当てられている** (statically assigned) とも言われる。

3.8.2. Dynamically Uniform Expressions and Uniform Control Flow
----------------------------------------------------------------------

一部の操作では、式が **動的に一様である** (dynamically uniform) ことや、
**一様な制御フロー** (uniform control flow) の中に配置されていることが要求される。
これらの要件は以下の定義集合で定義されている。

**呼び出し** (an invocation) とは、特定の段階における ``main()`` の単一実行のことあって、
その段階のシェーダー内で明示的に公開されているデータ量に対してしか作用しない
（データの追加的なインスタンスに対する暗黙の操作は、追加的な呼び出しとなる)。
例えば、計算実行モデルでは、単一の呼び出しが単一の作業項目に対してしか作用せず、
頂点実行モデルでは、単一の呼び出しが単一の頂点に対してしか作用しない。

**呼び出しグループ** (an invocation group) とは、特定の計算作業グループまたは
グラフィック操作をまとめて処理する呼び出しの完全な集合だ。
「グラフィック操作」の範囲は実装に依存するが、クライアント API で定義されているように、
少なくとも単一の三角形またはパッチと同じ大きさであり、最大でも一つのレンダリングコマンドと同じ大きさだ。

単一の呼び出しで、単一のシェーダー文が複数回実行され、その命令の
**動的インスタンス** (dynamic instances) が複数得られる。
これは、命令がループ内で実行される場合や、複数の呼び出し場所から呼び出される関数内で実行される場合、
あるいはこれらの複数の組み合わせで発生する。
ループの繰り返しや、関数と呼び出し場所の動的な連鎖が異なると、
そのような命令の動的インスタンスも異なる。
動的インスタンスは、どの呼び出しが実行されたかではなく、呼び出し内の制御フローの経路によって区別される。
つまり、``main()`` の異なる呼び出しは、同じ制御フロー経路をたどる場合、
その命令の同じ動的インスタンスを実行する。

ある式がそれを消費するある動的インスタンスに対して **動的に一様** (dynamically uniform) であるとは、
動的インスタンスを実行する（呼び出しグループ内の）呼び出しすべてに対してその値が同じであるときに言う。

**一様制御フロー** （収束制御フロー）は、呼び出しグループ内のすべての呼び出しが同じ制御フロー経路
（したがって、命令の動的インスタンスの順序も同じ）を実行するときに発生する。
一様制御フローは ``main()`` に入ったときの初期状態であり、
条件分岐が異なる呼び出しに対して異なる制御経路を取るまで続く
（非一様制御フローまたは発散制御フロー）。
このような発散は再収束し、すべての呼び出しが再び同じ制御フローの経路を実行するようになり、
これにより一様制御フローの存在が再び確立される。
選択肢やループに入ったときに制御フローが一様であり、その後、
呼び出しグループのすべての呼び出しがその選択肢やループから離れると、制御フローは一様に収束し直す。

.. code:: glsl

   main()
   {
       float a = ...; // this is uniform control flow
       if (a < b) {   // this expression is true for some fragments, not all
           ...;       // non-uniform control flow
       } else {
           ...;       // non-uniform control flow
       }
       ...;           // uniform control flow again
   }

定数式は動的に一様であることは自明だ。
これにより、定数式に基づく典型的なループカウンターも動的に一様であることがわかる。
