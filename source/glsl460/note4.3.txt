4.3. Storage Qualifiers
----------------------------------------------------------------------

変数宣言では、型の前に高々一つの格納修飾子を指定することができる。

.. glossary::

   （格納修飾子なし：既定値）
       局所的な読み書き可能なメモリー、または関数の入力引数。

   ``const``
       値を変更することができない変数。

   ``in``
       前の段階のシェーダーにリンケージを持つ場合、変数が入力コピーされる。

   ``out``
       シェーダの後段へにリンケージを持つ場合、変数が出力コピーされる。

   ``attribute``
       互換性プロファイルおよび頂点言語のみ。頂点シェーダーの場合は ``in`` と同じ。

   ``uniform``
       処理される基本形状間で値が変化しない、
       一様変数はシェーダー、API, アプリケーション間のリンクを形成する。

   ``varying``
       互換性プロファイルのみ、頂点言語およびフラグメント言語のみ。
       頂点シェーダーの場合は ``out`` と同じ。
       フラグメントシェーダーの場合は ``in`` と同じ。

   ``buffer``
       値はバッファーオブジェクトに格納され、シェーダー呼び出しと
       API の両方で読み書きできる。

   ``shared``
       計算シェーダーのみ。変数格納は作業グループ内のすべての作業項目で共有される。

入出力修飾変数の中には、高々一つの補助格納修飾子を追加できるものがある。

.. glossary::

   ``centroid``
      重心基準補間

   ``sample``
      一標本ごとの補間

   ``patch``
      多角形分割一パッチごとの属性

すべての修飾子の組み合わせが許されるわけではない。
補助格納修飾子は ``in`` または ``out`` 修飾子と一緒にしか使用できない。
その他の修飾子の規則については、以降の節で説明。

局所変数は ``const`` 修飾子のみ使用できる（または格納修飾子を使用しない）。

関数の引数には ``const``, ``in``, ``out`` を使用できるが、
引数修飾子としては使用できないことに注意。引数修飾子については
:ref:`6.1.1. Function Calling Conventions` を参照。

関数の戻り値の型や構造体のメンバーには格納修飾子を使用しない。

大域宣言の初期化子は、格納修飾子がないか、
``const`` 修飾子があるか、または ``uniform`` 修飾子がある大域変数の宣言でしか
使用できない。

格納修飾子のない大域変数は、その宣言またはアプリケーションで初期化されないと、
初期化されずに未定義の値で ``main()`` に入る。

あるシェーダー段階の出力と後続のシェーダー段階の入力を比較するとき、
補助修飾子（またはその欠落）が同じでない場合、入力と出力は一致しない。

4.3.1. Default Storage Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

大域変数に修飾子がない場合、その変数はアプリケーションや他のパイプライン段階で
実行されるシェーダーとはリンクしていない。
大域変数でも局所変数でも、修飾されていない変数では、宣言は対象となる処理器に
関連するメモリーが割り当てられているように見える。
この変数は、この割り当てられたメモリーへの読み取り・書き込みアクセスを提供する。

.. admonition:: コメント

   意味不明。

4.3.2. Constant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

名前付きのコンパイル時定数や読み取り専用の変数は ``const`` 修飾子を使って宣言できる。
``const`` 修飾子は、非 ``void`` 透過基本データ型や、それらの構造体や配列で使用できる。
宣言されていない ``const`` 変数に書き込むコードはコンパイルエラーとなるから、
宣言時に初期化する必要がある。

.. code:: glsl

   const vec3 zAxis = vec3(0.0, 0.0, 1.0);
   const float ceiling = a + b; // a and b not necessarily constants

構造体のメンバーは ``const`` で修飾することはできない。
構造体変数は ``const`` として宣言し、構造体のコンストラクターまたは初期化子で
初期化できる。

大域スコープでの ``const`` 宣言の初期化子は、次節で定義されるように、定数式で
なければならない。

4.3.3. Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SPIR-V の特殊化定数は、
:ref:`4.11. Specialization-Constant Qualifier` で記述されるように、
GLSL では ``const`` にレイアウト修飾子 ``const_id`` を付けて表現される。

**定数式** (a constant expression) とは次のいずれかだ：

* リテラル値
* ``const`` 修飾子と初期化子で宣言された変数で、初期化子が定数式であるもの。
  これは ``layout(const_id = ...)`` のような特殊化定数レイアウト修飾子を付けて宣言された
  ``const`` と、特殊化定数レイアウト修飾子を付けずに宣言された ``const`` の両方を含む。
* ``const`` として修飾された組み込み変数。
* 定数配列の要素、定数構造体のメンバー、定数ベクトルの構成要素の取得など、
  すべて定数式であるオペランドに対して演算子で形成される式。
* オブジェクト自体が定数であるかどうかに関わらず、明示的なサイズのオブジェクトに対する
  ``length()`` メソッドの適切な使用（暗黙的なサイズの配列や実行時サイズの配列は
  定数式を返さない）。
* 引数がすべて定数式であるコンストラクター。
* 非特殊化定数の場合のみ：引数がすべて定数式である特定の組み込み関数の呼び出しの
  戻り値（少なくとも以下のリストを含む）。メモリーにアクセスしないその他の組み込み関数
  （テクスチャー探索関数、画像アクセス、不可分カウンターなどを除く）であって、
  戻り値の型が非 ``void`` で ``out`` 引数がなく、ノイズ関数ではないものも定数と
  みなされる場合がある。
  関数が特殊化定数である引数で呼び出された場合、その結果は定数式ではない。

  * 角度および三角関数
  * 指数関数
  * 普通の関数
  * 幾何関数

* ユーザー定義関数（非組み込み関数）の関数呼び出しは、定数式には使用できない。

----

**定整数式** (a constant integral expression) とは定数式であって、
スカラーの符号付きまたは符号なしの整数に評価されるものだ。

定数式は不変的な方法で評価されるため、複数のシェーダーに同じ定数式が現れた場合、
同じ値が生成される。
:ref:`4.8.1. The Invariant Qualifier`, :ref:`4.7.2. Precision Qualifiers` を参照。

定数式は ``precision`` 修飾子と ``invariant`` 修飾子を尊重するが、
そのような修飾子の使用とは関係なく、常に不変的に評価されるため、
複数のシェーダーに同じ定数式が現れた場合には、同じ値が生成される。

定数式はホストプラットフォームで評価される可能性がある。
それゆえ同じ式がシェーダー実行対象で評価するような値と同じものを計算する必要はない。
ただし、ホストは対象が使用するのと同じか、それ以上の精度を使用しなければならない。
精度修飾子が決定できない場合、式は ``highp`` で評価される。
:ref:`4.7.3. Default Precision Qualifiers` 参照。

特殊化定数式は、コンパイラーのフロントエンドでは評価されないで、
代わりに、後でホスト上で評価するために必要な式の操作を留めておく。

4.3.4. Input Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

シェーダーの入力変数は ``in`` 格納修飾子で宣言される。
この変数は、API パイプラインの前段階と宣言したシェーダーとの間の入力インター
フェイスを形成する。入力変数は大域スコープで宣言しなければならない。
前のパイプライン段階から来る値は、シェーダー実行開始時に入力変数にコピーされる。
入力として宣言された変数に書き込むコードはコンパイルエラーとなる。

前の段階で書き込む必要があるのは、静的に読み込まれる入力変数だけであり、
入力変数の宣言が余計に付いていても構わない。

.. admonition:: コメント

   本文ではこのことをまとめた表がここに示されているが、割愛する。

消費エラーは静的な使用にしかよらない。
未定義の値を消費する可能性のある動的な使用方法をコンパイラーが推論する場合、
エラーではなく警告を発する。
組み込み入力名の一覧は :ref:`7. Built-In Variables` を参照。

頂点シェーダーの入力変数（または属性）は、頂点ごとのデータを受け取る。
頂点シェーダー入力に補助格納修飾子や補間修飾子を使用すると、コンパイルエラーとなる。
コピーされた値は API またはレイアウト識別子 ``location`` の使用により設けられる。

以下の型で頂点シェーダー入力を宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型
* 構造体

----

頂点シェーダーにおける入力宣言の例を示す：

.. code:: glsl

   in vec4 position;
   in vec3 normal;
   in vec2 texCoord[4];

----

グラフィックスハードウェアでは、頂点入力を渡すための固定のベクトル場所が足りない
ことが予想される。そのため、OpenGL Shading Language では、行列以外の入力変数は、
そのようなベクトル位置を一つ使用すると定義している。
使用できる場所の数には実装依存の制限があり、これを超えるとリンクエラーが発生する
（静的使用でないと宣言された入力変数は、この制限に含まれない）。
スカラー入力は ``vec4`` と同じようにカウントされるので、
アプリケーションでは、内在するハードウェアの性能をよりよく活用するために、
関係のない 4 つの ``float`` 入力のグループをまとめてベクトルにすることを検討する
とよいだろう。
行列入力は、複数の場所を使用する。使用される場所の数は、行列の列数と同じだ。

多角形分割制御、多角形分割評価、幾何シェーダーの入力変数は、
前のアクティブシェーダー段階で同じ名前の出力変数によって書き出された、
頂点ごとの値を取得する。
これらの入力では ``centroid`` や補間修飾子が使えるが、効果はない。
多角形分割制御、多角形分割評価、幾何シェーダーは頂点集合を操作するので、
各入力変数（または入力ブロック、下記のインターフェイスブロックを参照）
は配列として宣言する必要がある。

.. code:: glsl

   in float foo[]; // geometry shader input for vertex "out float foo"

このような配列の各要素は、処理される基本形状の一つの頂点に対応する。
各配列はオプションでサイズを宣言することができる。
幾何シェーダーの場合、配列のサイズは、:ref:`4.4.1. Input Layout Qualifiers`
のように、入力基本形状の型を設定する入力 ``layout`` 宣言によって設定される。

----

入力と出力は配列されているものもある。これは、シェーダー段階二つの間にある
インターフェイスでは、
入力または出力の宣言を一致させるために、余分なレベルの配列インデックスが必要に
なることを意味する。
例えば、頂点シェーダーと幾何シェーダーのインターフェイスでは、
頂点シェーダーの出力変数と幾何シェーダーの入力変数の同名の変数は、
型が一致していなければならない。
ただし、幾何シェーダーは、頂点のインデックス付けを可能にするために、
頂点シェーダーよりも 1 多い配列次元を持つことになる。
このように配列されたインターフェイス変数が、必要である追加的入力・出力配列次元で
宣言されていない場合、リンクエラーとなる。
幾何シェーダー入力、多角形分割制御シェーダー入出力、多角形分割評価入力はすべて、
他のシェーダー入出力に比べて追加的配列レベルを持っている。
これらの入力と出力は、頂点ごとに配列された (per-vertex-arrayed) 入力と出力として
知られている。
配列されたインターフェイス (``gl_MaxTessControlInputComponents``, etc.)
の成分制限は、インターフェイス全体に対する制限ではなく、頂点ごとの制限だ。

非配列のインターフェイス（＝段階間配列の次元が変わらない）では、
入力変数が一致する出力変数と配列の次元を含めて同じ型で宣言されていないと
リンクエラーとなる。

リンク時の型マッチング規則は、使用されているか否かに関わらず、
宣言されたすべての入力変数と出力変数に適用される。

さらに、多角形分割評価シェーダーは ``patch`` および ``in`` 修飾子で宣言された
``patch`` ごとの入力変数をサポートしている。
パッチごとの入力変数には、多角形分割制御シェーダーによって書き込まれたパッチごとの
出力変数の値が入る。
パッチごとの入力は一次元配列として宣言できるが、頂点数によるインデックスは付けられない。
入力への ``patch`` 修飾子の適用は、多角形分割評価シェーダでしか行えない。
他の入力変数と同様に、パッチごとの入力は、前の（多角形分割制御）シェーダー段階からの
パッチごとの出力と同じ型と修飾子を使って宣言しなければならない。
他の段階の入力で ``patch`` を使用することは、コンパイルエラーとなる。

多角形分割制御、多角形分割評価、幾何シェーダーの入力を、
以下のいずれかの型で宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

----

フラグメントシェーダーの入力は、前の段階の出力から補間されたフラグメントごとの値
をふつうは取得する。
補助格納修飾子 ``centroid`` と ``sample`` も、補間修飾子 ``flat``, ``noperspective``,
`smooth`` と同様に適用できる。

フラグメントシェーダーの入力を次のいずれかの型で宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

整数型または倍精度浮動小数点型であるか、またはそれを含むフラグメントシェーダー
入力には補間修飾子 ``flat`` が必要だ。

フラグメント入力は以下の例のように宣言される：

.. code:: glsl

   in vec3 normal;
   centroid in vec2 TexCoord;
   invariant centroid in vec4 Color;
   noperspective in float temperature;
   flat in vec3 myColor;
   noperspective centroid in vec2 myTexCoord;

フラグメントシェーダーの入力は、頂点処理パイプラインにおける最終アクティブシェーダー
とのインターフェイスを形成する。
このインターフェイスでは、最終アクティブシェーダー段階出力変数と
フラグメントシェーダーの入力変数の同名の変数は、いくつかの例外
（格納修飾子の一方は ``in`` で他方は ``out`` でなければならない）を除いて、
型と修飾子が一致していなければならない。
また、補間修飾子や補助修飾子も異なる場合がある。
これらのミスマッチは任意の段階対の間で許される。
補間修飾子や補助修飾子が一致しない場合は、フラグメントシェーダーで提供される
修飾子が前段階で提供される修飾子よりも優先される。
フラグメントシェーダーにそのような修飾子が全くない場合は、前段階で宣言されていた
修飾子ではなく、既定の修飾子が使用される。
つまり、重要なのはフラグメントシェーダーで何が宣言されているかであり、
前段階のシェーダーで何が宣言されているかではないということだ。

----

シェーダー段階間のインターフェイスが別々のプログラムオブジェクトのシェーダーを
使って形成されている場合、プログラムがリンクされたときに入力と出力の間の
不一致を検出することはできない。
このようなインターフェイスでは、入力と出力の間に不一致があると、
インターフェイスを介して渡される値は、部分的にまたは完全に未定義となる。

シェーダーで入出力レイアウト修飾子 (:ref:`4.4.1. Input Layout Qualifiers`,
:ref:`4.4.2. Output Layout Qualifiers`)
を使用するか、ブロックや変数の入力宣言と出力宣言を同一にすることで、
このようなインターフェイス間のマッチングを担保することができる。
インターフェイスのマッチングに関する完全な規則は、
OpenGL 仕様書の 7.4.1 "Shader Interface Matching" に記載されている。

----

計算シェーダはユーザ定義の入力変数を許可せず、他のシェーダー段階との正式な
インターフェイスを形成しない。
組み込みの計算シェーダー入力変数については
:ref:`7.1.6. Compute Shader Special Variables` を参照。
計算シェーダーへの他のすべての入力は、画像ロード、テクスチャー取得、
一様変数または一様バッファーからのロード、または他のユーザーコードによって
明示的に取得される。
計算シェーダーの組み込み入力変数を再宣言することはできない。

4.3.5. Uniform Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. admonition:: コメント

   英単語 uniform をどう訳したらしっくり来るだろうか。数学科専攻としては「一様」
   にしたい。
   中国語の仕様書を見たら「統一」に相当する単語をあてているようだ。

修飾子 ``uniform`` は、処理される基本形状全体で値が同じになる大域変数を宣言する
ために用いられる。
``uniform`` 変数はすべて読み取り専用で、リンク時または API を通じて外部から初期化される。
リンク時の初期値は、変数の初期化子が存在する場合はその値で、存在しない場合は 0 だ。
不透明型は初期化子を持つことができず、そうでない場合はコンパイルエラーが発生する。

.. code:: glsl

   uniform vec4 lightPosition;
   uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time

修飾子 ``uniform`` は、基本的なデータ型のいずれか、または構造体を型とする変数を宣言するとき、
あるいはこれらのいずれかの配列を宣言するときに使用できる。

シェーダーの種類ごとに使用できる ``uniform`` 用変数の収容量には実装依存の制限がある。
これを超えるとコンパイル時またはリンク時にエラーとなる。
宣言されているが使用されていない ``uniform`` 変数はこの制限に入らない。
ユーザー定義の ``uniform`` 変数の個数と、シェーダー内で使用されている
組み込みの ``uniform`` 変数の個数の和で、利用可能な収容量を超えているかどうかを
判断する。

シェーダー内の ``uniform`` 変数は、プログラムまたは分割可能なプログラムにリンク
されている場合、すべて単一の大域名前空間を共有する。したがって、同じ名前で静的に
使用される ``uniform`` 変数の型、初期化子、および任意の ``location`` 指定子は、
単一プログラムにリンクされているすべてのシェーダーで一致しなければならない。
ただし、リンクされたすべてのシェーダーで初期化子や `location`` 指定子を繰り返す
必要はない。
``uniform`` 変数名がある段階（例：頂点シェーダー）で宣言され、
別の段階（例：フラグメントシェーダー）で宣言されていない場合、
その名前は別の段階で別の用途に使用することが許される。

4.3.6. Output Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

シェーダー出力変数は ``out`` 格納修飾子で宣言される。
出力変数は、宣言したシェーダーと API パイプラインの後続段階との間の出力
インターフェイスを形成する。
出力変数は大域スコープで宣言しなければならない。
シェーダーの実行中は、修飾のない通常の大域変数として振る舞う。
シェーダーの終了時にその値は後続のパイプライン段階にコピーされる。
後続のパイプライン段階で読まれる出力変数だけが書き込まれる必要があり、
出力変数の余計な宣言があっても構わない。

単一の変数名をシェーダーの入力と出力の両方として宣言するための
``inout`` のような格納修飾子は存在しない。
一つの変数に ``in`` と ``out`` の両方の修飾子をつけて宣言することもまたできない。
コンパイル時またはリンク時にエラーとなる。
出力変数は、入力変数とは異なる名前で宣言しなければならない。
ただし、インスタンス名を持つインターフェイスブロックの中に入力または出力を入れ子
にすると、ブロックのインスタンス名で参照されるものと同じ名前を使うことができる。

頂点、多角形分割評価、幾何の出力変数は、頂点ごとのデータを出力し、
``out`` 修飾子を用いて宣言される。
出力への ``patch`` の適用は、多角形分割制御シェーダーでのみ可能だ。
それ以外の段階での適用はコンパイルエラーとなる。

頂点、多角形分割評価、多角形分割制御、幾何それぞれのシェーダーの出力を、
以下の型のいずれかで宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

.. code:: glsl

   out vec3 normal;
   centroid out vec2 TexCoord;
   invariant centroid out vec4 Color;
   flat out vec3 myColor;
   sample out vec4 perSampleColor;

これらは :ref:`4.3.9. Interface Blocks` で述べられるように、
インターフェイスブロックにも出現する。インターフェイスブロックでは、
頂点シェーダーから幾何シェーダーへのインターフェイスに、
より単純に配列を追加することができる。
また、フラグメントシェーダーに、ある頂点シェーダーの幾何シェーダーと
同じ入力インターフェイスを持たせることができる。

----

多角形分割制御シェーダーの出力変数は、頂点ごとのデータとパッチごとのデータを出力
するために用いられる。
頂点ごとの出力変数は配列され (:ref:`4.3.4. Input Variables`)、
``out`` 修飾子で ``patch`` 修飾子なしに宣言される。
パッチごとの出力変数は ``patch`` 修飾子と ``out`` 修飾子で宣言される。

多角形分割制御シェーダーは、複数の頂点からなる配列された基本形状を生成するため、
各頂点ごとの出力変数（または出力ブロック）は、配列として宣言する必要がある：

.. code:: glsl

   out float foo[]; // feeds next stage input "in float foo[]"

このような配列の要素それぞれが、生成される基本形状一つの頂点に対応する。
各配列はオプションでサイズを宣言することができる。
配列のサイズは出力パッチの頂点の数を定める出力レイアウト宣言によって設定される
(:ref:`Tessellation Control Outputs`)（または、宣言されている場合は、
それと一致しなければならない）。

各多角形分割制御シェーダー呼び出しは、対応する出力パッチの頂点を持ち、
その対応する頂点に属しているときに限り、
頂点ごとの出力に値を割り当てることができる。
頂点ごとの出力変数を左辺値として使用する場合、
頂点のインデックスを示す式が識別子 ``gl_InvocationID`` でないと、コンパイル
エラーまたはリンクエラーになる。

同じ入力パッチに対する他の呼び出しに対する多角形分割制御シェーダー呼び出しの
相対的な実行順序は、組み込み関数 ``barrier()`` が使用されない限り、未定義だ。
これにより、相対的な実行順序の制御が可能になる。
シェーダーの呼び出しが ``barrier()`` を呼び出すと、他のすべての呼び出しが同じ
実行箇所に到達するまでその実行は一時停止する。
``barrier()`` を呼び出す前に実行された任意の呼び出しによって実行された出力変数の
割り当ては、
``barrier()`` の呼び出しが戻った後、他の任意の呼び出しから見えるようになる。

多角形分割制御シェーダーの呼び出しは、障壁間で未定義の順序で実行されるので、
頂点ごと、あるいはパッチごとの出力変数の値は時々未定義になる。
シェーダー実行の開始と終了、および ``barrier()`` の各呼び出しを同期時点と考える
といい。出力変数の値が不定になるのは、以下の三つの場合のいずれかだ：

1. 実行の開始時
2. 以下の場合を除く各同期時点：

   * 前回の同期時点の後に値が定義され、その後どの呼び出しによっても書き込まれなかった場合、または
   * 前回の同期時点以降、厳密に一つのシェーダー呼び出しによって値が書き込まれた場合、または
   * 前回の同期時点以降に複数のシェーダー呼び出しによって値が書き込まれ、
     そのようなすべての呼び出しによって実行された最後の書き込みが同じ値を書き込んだ場合。

3. シェーダーの呼び出しによって読み込まれたとき、もし

   * その値が前回の同期時点で未定義であり、その後同じシェーダー呼び出しによって
     書き込まれていない場合、または
   * 前回と次回の同期時点の間に他のシェーダー呼び出しによって出力変数が書き込まれた場合
     （その割り当てが読み取り後のコードで発生したときでさえ）

----

フラグメント出力は、フラグメントごとのデータを出力し、
``out`` 修飾子で宣言される。
フラグメントシェーダー出力の宣言に補助格納修飾子や補間修飾子を使用すると
コンパイルエラーとなる。
フラグメントシェーダー出力を以下の型で宣言するとコンパイルエラーとなる：

* 真偽型
* 倍精度スカラーまたはベクトル (``double``, ``dvec2``, ``dvec3``, ``dvec4``)
* 不透明型
* 行列型
* 構造体

フラグメント出力宣言の例：

.. code:: glsl

   out vec4 FragmentColor;
   out uint Luminosity;

----

計算シェーダーは組み込みの出力変数を持たず、ユーザー定義の出力変数も対処せず、
他のシェーダー段階との正式なインターフェイスを形成しない。
計算シェーダーからの出力はすべて、画像格納や不可分カウンターの演算などの副作用の形をとる。

4.3.7. Buffer Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

修飾子 ``buffer`` はAPI を通じて束縛されたバッファーオブジェクトのデータ格納空間に
値が格納される大域変数を宣言するために使用される。
バッファー変数はすべてのアクティブなシェーダー呼び出しの間で内包される格納空間を
共有して読み書きすることができる。
単一のシェーダー呼び出し内でのバッファー変数のメモリーの読み取りと書き込みは順番
に処理される。しかし、ある起動で実行される読み込みと書き込みの順序は、
他の呼び出しで実行されるものと比較するとほとんど未定義だ。
バッファー変数は内包されているメモリーへのアクセス方法に影響を与えるメモリー修飾子
(:ref:`4.10. Memory Qualifiers`) で修飾することができる。

修飾子 ``buffer`` は、インターフェイスブロック (:ref:`4.3.9. Interface Blocks`)
を宣言するために使用することができ、これらのブロックはシェーダー格納ブロックと
して参照される。ブロックの外でバッファー変数を宣言するとコンパイルエラーとなる。

.. code:: glsl

   // use buffer to create a buffer block (shader storage block)
   buffer BufferName { // externally visible name of buffer
       int count;      // typed, shared memory...
       ...             // ...
       vec4 v[];       // last member may be an array that is not sized
                       // until after link time (dynamically sized)
   } Name;             // name of block within the shader

シェーダーの種類ごとに使用されるシェーダー格納ブロックの数、
プログラムに使用されるシェーダー格納格納ブロックの合計数、
個々のシェーダー格納ブロックが必要とする格納空間の量には、実装に依存した制限がある。
これらの制限を超えた場合は、コンパイル時またはリンク時にエラーが発生する。

複数のシェーダーがリンクされている場合、それらのシェーダーは単に
大域バッファー変数の名前空間を共有することになる。
したがって、同じ名前で宣言されたバッファー変数の型は、
単一のプログラムにリンクされているすべてのシェーダーで一致しなければならない。

4.3.8. Shared Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

修飾子 ``shared`` は、計算シェーダー作業グループ内のすべての作業項目間で共有される
格納空間がある大域変数を宣言するために用いられる。
``shared`` として宣言された変数は、計算シェーダーでしか使用されない
(:ref:`2.6. Compute Processor`)。
それ以外の共有変数の宣言は、コンパイルエラーとなる。
共有変数は暗黙的に ``coherent`` (:ref:`4.10. Memory Qualifiers`) だ。

共有変数として宣言された変数は初期化子を持たず、シェーダーの実行開始時にはその
内容は未定義だ。
共有変数に書き込まれたどんなデータも、同じ作業グループ内の他の作業項目
（同じシェーダーを実行中）から見えるということになる。

同期が行われていない場合、シェーダーの異なる呼び出しによる同じ ``shared`` 変数へ
の読み書きの順序は未定義とする。

共有変数への読み書きの順序を決めるためには、関数 ``barrier()`` を使って
制御フローの障壁を設ける必要がある
(:ref:`8.16. Shader Invocation Control Functions`)。

単一のプログラムで共有変数として宣言されたすべての変数の合計サイズには制限がある。
basic machine units 単位で表されるこの制限は、OpenGL API を使って
``MAX_COMPUTE_SHARED_MEMORY_SIZE`` の値を照会することで決定できる。

.. admonition:: コメント

   最後のパラグラフ中の basic machine units なる用語がわからない。

4.3.9. Interface Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

入力、出力、一様、バッファー変数の宣言は、名前の付いたインターフェイスブロックに
まとめることができ、個別の宣言では達せられない粗い粒度の backing が可能になる。
これらはオプションでインスタンス名を持つことができ、シェーダー内でそのメンバーを
参照するために用いられる。
あるプログラム可能段階の出力ブロックは、後続のプログラム可能段階の対応する入力
ブロックによって back される。
一様ブロック (a uniform block) は、アプリケーションによってバッファーオブジェクト
で back される。
シェーダー格納ブロック (a shader storage block) と呼ばれるバッファー変数のブロックも、
アプリケーションによってバッファーオブジェクトで back される。
頂点シェーダーの入力ブロックやフラグメントシェーダーの出力ブロックを持つことは、
コンパイルエラーとなる。これらの用途は将来のために予約されている。

インターフェイスブロックは、キーワード ``in`, ``out``, ``uniform``, ``buffer``
と、ブロック名、そして中括弧 ``{`` で始まる。

.. admonition:: コメント

   BNF による一覧を省略。

----

次のコードは ``Transform`` という名前の一様ブロックを定義する。
``uniform`` 変数四つがグループ化される。

.. code:: glsl

   uniform Transform {
       mat4 ModelViewMatrix;
       mat4 ModelViewProjectionMatrix;
       uniform mat3 NormalMatrix;      // allowed restatement of qualifier
       float Deformation;
   };

----

型と宣言子は、ブロック外の他の入力、出力、一様、バッファー変数の宣言と同じだ、
以下の例外がある：

* 初期化子は許されない。
* 不透明型は許されない。
* ブロック内での構造体定義の入れ子は許されない。

これらはいずれもコンパイルエラーになる。

メンバー宣言にオプションの修飾子がない場合、メンバーの修飾には、
interface-qualifier で決定されるすべての ``in``, ``out``, ``patch``, ``uniform``,
``buffer`` が含まれる。
オプション修飾子を使用する場合、補間修飾子、補助格納修飾子、格納修飾子を含むことができ、
ブロックのインターフェイス修飾子と一致する入力、出力、一様メンバーを宣言しなければ
ならない。すなわち、入力変数、出力変数、一様変数、
``buffer`` メンバーは、
``in`` ブロック、
``out`` ブロック、
``uniform`` ブロック、シェーダー格納ブロック内それぞれにしか存在しない。

メンバーの格納修飾子に ``in``, ``out``, ``patch``, ``uniform``, ``buffer``
のいずれかのインターフェイス修飾子を繰り返すことはオプションだ。例えば：

.. code:: glsl

   in Material {
       smooth in vec4 Color1; // legal, input inside in block
       smooth vec4 Color2;    // legal, 'in' inherited from 'in Material'
       vec2 TexCoord;         // legal, TexCoord is an input
       uniform float Atten;   // illegal, mismatched storage qualifier
   };

----

**シェーダーインターフェイス** (a shader interface) とは、次のうちの一つとする：

* プログラムの中で宣言されたすべての一様変数と一様ブロック。
  これは、一つのプログラム内でリンクされているすべてのコンパイル単位に及ぶ。
* プログラム内で宣言された ``buffer`` ブロックすべて。
* 隣接するプログラム可能パイプライン段階間の境界。
  最初の段階のコンパイル単位すべてで宣言された出力すべてと、
  次の段階のコンパイル単位すべて宣言された入力すべてに及ぶ。
  なお、実際にはフラグメントシェーダーに渡された値すべては、
  まずラスタライザーと補間器を通過するが、
  この定義では、フラグメントシェーダーと先行するシェーダーは境界を共有すると
  考えられる。

ブロック名 (*block-name*) は、シェーダーインターフェイス内での照合に用いられる。
つまり、あるパイプライン段階の出力ブロックは、後続のパイプライン段階の同名の
入力ブロックに合致する。
一様ブロックやシェーダー格納ブロックの場合、アプリケーションはブロック名を使って
ブロックを識別する。
シェーダー内ではインターフェイスの照合以外にはブロック名を利用できない。
大域スコープのブロック名をブロック名として以外に使用することはコンパイルエラーとなる
（例えば、大域変数名や関数名にブロック名を使用することが現在予約されている）。
ブロックの内容が同じであっても、一つのシェーダー内の同じシェーダーインターフェイスの
複数のブロック宣言に同じブロック名を使用すると、コンパイルエラーとなる。

一つのシェーダインターフェイスの中で合致したブロック名は、同じ数の宣言と同じ型の並び、
同じメンバー名の並び、そしてメンバーごとのレイアウト修飾が一致していなければならない。
一致した一様ブロック名またはシェーダー格納ロック名（入力ブロック名または出力
ブロック名ではない）は、
すべてインスタンス名がないか、またはすべてインスタンス名があり、
それらのメンバーが同じスコープレベルにあることも必要だ。
合致したブロック名の上にインスタンス名がある場合、インスタンス名が違っていても構わない。
さらに、合致ブロックが配列として宣言されている場合は、配列のサイズまでも一致して
いなければならない。
（または、連続するシェーダー段階間のシェーダーインターフェイスの配列一致規則に従う）。
不一致の場合、リンクタイムエラーとなる。
ブロック名は、同一シェーダー内の異なるシェーダーインターフェイスで異なる定義で
あることが許されており、
例えば、入力ブロックと出力ブロックが同じ名前であることも可能である。

インスタンス名 (*instance-name*) を使用しない場合、ブロック内で宣言された名前は
大域レベルでスコープされ、ブロックの外で宣言されたかのようにアクセスされる。
インスタンス名を使用すると、スコープ内のすべてのメンバーが独自の名前空間内に置かれ、
構造体と同様の、フィールドセレクター演算子 ``.`` でアクセスされる：

.. code:: glsl

   in Light {
       vec4 LightPos;
       vec3 LightColor;
   };
   in ColoredTexture {
       vec4 Color;
       vec2 TexCoord;
   } Material;           // instance name
   vec3 Color;           // different Color than Material.Color
   vec4 LightPos;        // illegal, already defined
   ...
   ... = LightPos;       // accessing LightPos
   ... = Material.Color; // accessing Color in ColoredTexture block

シェーディング言語の外では、メンバーは同様に識別されるが、
インスタンス名の代わりにブロック名が常に使用される。API のアクセスはシェーダー
ではなくシェーダーインターフェイスに対して行われるのだ。
インスタンス名がない場合、API はメンバーにアクセスするためにブロック名を使用せず、
メンバー名だけを使用する。

シェーダーインターフェイス内では、同じ大域名の宣言すべては同じオブジェクトに
対するものでなければならず、
型や、インスタンス名のないブロックの変数やメンバーを宣言しているかどうかが一致
していなければならない。
また、API はシェーダーインターフェイス内のオブジェクトを一意に識別するためにこの
名前を必要とする。
次のどちらかが成り立つならば、どのシェーダーインターフェイスもリンクエラーになる：

* インスタンス名を持たず、同じ名前のメンバーを持つ相異なるブロックが含まれている。
* ブロック外の変数と、インスタンス名のないブロックで、その変数がブロック内の
  メンバーと同じ名前である。

.. code:: glsl

   out Vertex {
       vec4 Position;  // API transform/feedback will use "Vertex.Position"
       vec2 Texture;
   } Coords;           // shader will use "Coords.Position"
   out Vertex2 {
       vec4 Color;     // API will use "Color"
       float Color2;
   };

   // in same program as Vertex2 above:
   out Vertex3 {
       float Intensity;
       vec4 Color;     // ERROR, name collision with Color in Vertex2
   };
   float Color2;       // ERROR, collides with Color2 in Vertex2

----

配列として宣言されたブロックでは、メンバーにアクセスする際に配列のインデックスも
含める必要がある：

.. code:: glsl

   uniform Transform { // API uses "Transform[2]" to refer to instance 2
       mat4 ModelViewMatrix;
       mat4 ModelViewProjectionMatrix;
       vec4 a[]; // array will get implicitly sized
       float Deformation;
   } transforms[4];
   ...
   ... = transforms[2].ModelViewMatrix; // shader access of instance 2
   // API uses "Transform.ModelViewMatrix" to query an offset or other query
   transforms[x].a.length(); // same length for 'a' for all x
   Transform[x];             // illegal, must use 'transforms'
   Transform.a.length();     // illegal, must use 'transforms'
   ...transforms[2].a[3]...  // if these are the only two dereferences of 'a',
   ...transforms[3].a[7]...  // then 'a' must be size 8, for all
   transforms[x]

配列として宣言された一様ブロックやシェーダー格納ブロックでは、個々の配列要素が、
ブロックのインスタンス一つを back する、個別のバッファーオブジェクトの結合範囲
に対応する。
配列のサイズは必要なバッファーオブジェクトの数を示すため、
一様ブロックやシェーダー格納ブロックの配列宣言では、配列のサイズを指定する必要がある。
一様ブロックやシェーダー格納ブロックの配列は、動的一様な整数式でしかインデックス
を付けることができず、それ以外の場合は結果が未定義だ。

OpenGL API のエントリー点を使用してブロックの配列内の個々のブロックの名前を特定する場合、
``Transform[2]`` のようにして、名前の文字列に配列のインデックスを含めることができる。
OpenGL API のエントリー点を使用してブロックメンバーのオフセットやその他の性質を参照する場合、
``Transform.ModelViewMatrix`` のように、配列インデックスを抜かなければならない。

多角形分割制御、多角形分割評価、幾何シェーダー入力ブロックは、配列として宣言され
なければならず、それぞれの段階のシェーダー入力すべては配列宣言とリンク規則に
従わなければならない。
その他のすべての入出力ブロックの配列は、配列サイズを指定しなければならない。

段階ごとに使用できる一様ブロックの個数とシェーダー格納ブロックの個数は、
実装依存の制限がある。いずれかの制限を超えた場合、リンクエラーとなる。
