======================================================================
オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 3/3
======================================================================

:doc:`gamma95-note2` からの続き。

:著者: Eric Gamma/Richard Helm/Ralph Johnson/John Vlissides
:監訳者: 本位田真一 吉田和樹
:出版社: ソフトバンク クリエイティブ株式会社
:ISBN: ISBN4-7973-1112-6

.. contents:: ノート目次

第 5 章 振る舞いに関するパターン
======================================================================

Chain of Responsibility
----------------------------------------------------------------------
後回し。

Command
----------------------------------------------------------------------
後回し。

Interpreter
----------------------------------------------------------------------
真面目に読む気なし。

Iterator
----------------------------------------------------------------------
後回し。

Mediator
----------------------------------------------------------------------
後回し。

Memento
----------------------------------------------------------------------
後回し。

Observer
----------------------------------------------------------------------
<あるオブジェクトが状態を変えたときに、
それに依存するすべてのオブジェクトに自動的にそのことが知らされ、
また、それらが更新されるように、
オブジェクト間に一対多の依存関係を定義する> (p. 313)

* <関連するオブジェクト間で無矛盾性を保つ必要がある> (p. 313)
* しかし、そのためにクラス間の結合度を高めるようなことはしたくない (p. 313)
* スプレッドシートとバーチャートの例え (p. 313) は、
  <同じデータに対して異なるユーザインタフェースがいくつあっても構わない> (p. 314)
  ということを示したい。

* <subject には、それに依存する observer を任意の数だけ持たせることができる>
  (p. 314) ということは、極端な話ゼロでも構わない（意義があるかどうかは置いて）。

適用可能性のところに色々書いてあるが、基本的には
<1 つのオブジェクトを変化させるときに、
それに伴いその他のオブジェクトも変化させる必要があり、
しかも変化させる必要があるオブジェクトを固定的に決められないとき> (p. 314)
状況で決まりだろう。

* subject は observer を知っている。
* observer は更新のインタフェースを定義する。
* ConcreteSubject は ConcreteObserver に影響する状態を保存している。
* ConcreteObserver は ConcreteSubject への参照を保持している。

* <通知を得るまでには自身の状態の更新を延ばしている> (p. 316)

* <subject と observer の結合は抽象的であり極小である> (p. 316)
* <observer 同士は互いに相手の存在を知らないため、
  subject の変化に伴うコストの総計を observer が予測することはできない> (p. 316)

このパターンは記述量がけっこうある。

* <subect が多くて observer が少ないときにはコストが高くつく> (p. 317)
* 1 つの observer が複数の subject に依存しているような場合、
  <どの subject が通知を送ったのかを observer に知らせるように
  Update オペレーションインタフェースを拡張する必要がある> (p. 317)
* <どのオブジェクトが Notify オペレーションを呼び出すことになるのか> (p. 317)
  だが、subject にやらせるにせよ observer にやらせるにせよ、トレードオフがある。

* <subject が削除される際に、observer に対して subject への参照を
  リセットするように通知を出すようにすること> (p. 317) を検討する。

* <Subject クラスのどのオペレーションが通知のきっかけを作るのかは、
  文書化しておくのがよい> (p. 318)

* subject の変更情報をどのように observer に引き渡すかで、
  push 型と pull 型に分類できる。
  これもトレードオフがある (pp. 318-319)

* subject と observer の依存関係が複雑なときには、間にワンクッション
  ChangeManager オブジェクトのようなものをはさんで、
  依存関係や変更通知を管理させる場合がある (pp. 319-320)

サンプルコードは「時計」の実装例。
タイマーが Subject で、各種時計が Observer だ。

State
----------------------------------------------------------------------
後回し。

Strategy
----------------------------------------------------------------------
* Strategy はカプセル化された交換可能なアルゴリズム (p. 335)
* 別名が Policy になっている。

テキストストリームを取り扱う方法を例に話が進む。

* <特に、改行について複数のアルゴリズムをサポートする場合> (p. 335)
* <テキストをフォーマットするときには、Compositor のオブジェクトに対して
  この責任を委譲する> (p. 336)

適用可能性も色々挙げているが、基本はこれだろう。

* 多くの振る舞いが <複数の条件文として現れている場合> (p. 336)

構造、構成要素、協調関係について。

* Strategy がアルゴリズムに共通のインタフェースを宣言する。
* ConcreteStrategy がアルゴリズムを実装する。
* Context が Strategy を利用する。
  アルゴリズムに必要なデータを引き渡したりするのかもしれない。

* 色々なアルゴリズムをサポートするのに Context を派生させない理由は、
  <アルゴリズムの実装と Context クラスの実装が混ざってしまい、
  Context クラスを理解し、保守し、拡張することをより難しくしてしまう>
  (p. 338) から。わざわざアルゴリズムを独立させている。

* <振る舞いの種類がクライアントに関係がある場合にのみ、
  Strategy パターンを利用するべきである> (p. 339)

* Context は ConcreteStrategy が効果的にアクセスできるようにするべし (p. 339)

* C++ の場合、テンプレートを利用して
  Strategy をコンパイル時に選択させることができる (p. 340)
  もっとも、Strategy を動的に変更できなくて構わない場合に限る手段だが。

サンプルコードの ``Compose`` メソッドは引数リストがゴチャゴチャしてないか？

Template Method
----------------------------------------------------------------------

Visitor
----------------------------------------------------------------------
後回し。

まとめ
----------------------------------------------------------------------

第 6 章 終わりに
======================================================================

付録以降
======================================================================
