================================================================================
オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 3/3
================================================================================

:doc:`gamma95-note2` からの続き。

:著者: Eric Gamma/Richard Helm/Ralph Johnson/John Vlissides
:監訳者: 本位田真一 吉田和樹
:出版社: ソフトバンク クリエイティブ株式会社
:ISBN: ISBN4-7973-1112-6

.. contents:: ノート目次

第 5 章 振る舞いに関するパターン
======================================================================

Chain of Responsibility
----------------------------------------------------------------------
複数オブジェクトに要求を処理する機会を与える。
要求の送信・受信オブジェクト間の結合を避け、オブジェクトをチェーンでつなぐ。

動機として、GUI アプリで状況依存ヘルプ機能について考察している。

* ヘルプ情報は <もっとも特殊なものからもっとも一般的なものへと組織化していく> (p. 237)

  印刷ボタン→印刷ダイアログ→アプリケーション、のような順にヘルプ優先度がある感じがわかる。

* <ヘルプ要求を出すオブジェクトをヘルプ情報を与えるオブジェクトから引き離す方法> (p. 237)
  が必要。
* <このパターンのポイントは、
  複数のオブジェクトに要求を処理する機会を与えることにより、
  要求を送信するオブジェクトと受信するオブジェクトを引き離すことにある> (p. 237)
* <チェーンの中にある各オブジェクトは、
  要求を処理したり後続のオブジェクト (successor) にアクセスするための
  共通のインタフェースを持っている> (p. 238)
* ヘルプの要求を処理したいクラスは、HelpHandler を親クラスにする (p. 238)

結果

* 結合度を低くする。
* 責任分散を柔軟にする。
* 要求が受信されるかどうかは保証されない。

実装

* チェーンの実装

  * オブジェクト間に既存の参照関係があれば、
    それを流用して successor チェーンとすることもあり。

* チェーンの接続

  * Handler クラスでは、通常は successor も保持する。
    要求を successor に転送することを実装のデフォルトとする。

* 要求の表現

  * 要求を Request オブジェクトとしてカプセル化して
    ``HandleRequest`` に渡すのが普通。

  * <サブクラスは自らが関与すべき要求のみを扱う。
    他の要求は転送する> (p. 242)

サンプルコードではさっきのヘルプの実装を検討している。

* <既存のウィジェット階層での親オブジェクトへの参照を利用する> (p. 243)
  ことで、ヘルプ要求を伝えていく方法をとる。

* 「チェーンの最初」といったら、
  一番最初に要求を処理するチャンスのあるオブジェクトを指すようだ。

* <ただし、successor は ``Widget`` オブジェクトではなく、
  任意の ``HelpHandler`` オブジェクトである> (p. 245)

使用例

* <ユーザのイベントを処理するために Chain of Responsibility パターンが使われている> (p. 246)
* <ユーザがマウスをクリックしたりキーを押したりすると、
  イベントが生成され、チェーンに沿って伝えられていくことになる> (p. 246)

関連するパターン

* <しばしば Composite パターンとともに適用される。
  その場合、component の親オブジェクトを successor にすることができる> (p. 247)

  子（持たれている方）が先に要求を処理するチャンスがあって、
  無視するならば親（所有者）に転送、か。

Command
----------------------------------------------------------------------
後回し。

Interpreter
----------------------------------------------------------------------
真面目に読む気なし。

Iterator
----------------------------------------------------------------------
後回し。

Mediator
----------------------------------------------------------------------
後回し。

Memento
----------------------------------------------------------------------
後回し。

Observer
----------------------------------------------------------------------
<あるオブジェクトが状態を変えたときに、
それに依存するすべてのオブジェクトに自動的にそのことが知らされ、
また、それらが更新されるように、
オブジェクト間に一対多の依存関係を定義する> (p. 313)

* <関連するオブジェクト間で無矛盾性を保つ必要がある> (p. 313)
* しかし、そのためにクラス間の結合度を高めるようなことはしたくない (p. 313)
* スプレッドシートとバーチャートの例え (p. 313) は、
  <同じデータに対して異なるユーザインタフェースがいくつあっても構わない> (p. 314)
  ということを示したい。

* <subject には、それに依存する observer を任意の数だけ持たせることができる>
  (p. 314) ということは、極端な話ゼロでも構わない（意義があるかどうかは置いて）。

適用可能性のところに色々書いてあるが、基本的には
<1 つのオブジェクトを変化させるときに、
それに伴いその他のオブジェクトも変化させる必要があり、
しかも変化させる必要があるオブジェクトを固定的に決められないとき> (p. 314)
状況で決まりだろう。

* subject は observer を知っている。
* observer は更新のインタフェースを定義する。
* ConcreteSubject は ConcreteObserver に影響する状態を保存している。
* ConcreteObserver は ConcreteSubject への参照を保持している。

* <通知を得るまでには自身の状態の更新を延ばしている> (p. 316)

* <subject と observer の結合は抽象的であり極小である> (p. 316)
* <observer 同士は互いに相手の存在を知らないため、
  subject の変化に伴うコストの総計を observer が予測することはできない> (p. 316)

このパターンは記述量がけっこうある。

* <subect が多くて observer が少ないときにはコストが高くつく> (p. 317)
* 1 つの observer が複数の subject に依存しているような場合、
  <どの subject が通知を送ったのかを observer に知らせるように
  Update オペレーションインタフェースを拡張する必要がある> (p. 317)
* <どのオブジェクトが Notify オペレーションを呼び出すことになるのか> (p. 317)
  だが、subject にやらせるにせよ observer にやらせるにせよ、トレードオフがある。

* <subject が削除される際に、observer に対して subject への参照を
  リセットするように通知を出すようにすること> (p. 317) を検討する。

* <Subject クラスのどのオペレーションが通知のきっかけを作るのかは、
  文書化しておくのがよい> (p. 318)

* subject の変更情報をどのように observer に引き渡すかで、
  push 型と pull 型に分類できる。
  これもトレードオフがある (pp. 318-319)

* subject と observer の依存関係が複雑なときには、間にワンクッション
  ChangeManager オブジェクトのようなものをはさんで、
  依存関係や変更通知を管理させる場合がある (pp. 319-320)

サンプルコードは「時計」の実装例。
タイマーが Subject で、各種時計が Observer だ。

State
----------------------------------------------------------------------
後回し。

Strategy
----------------------------------------------------------------------
* Strategy はカプセル化された交換可能なアルゴリズム (p. 335)
* 別名が Policy になっている。

テキストストリームを取り扱う方法を例に話が進む。

* <特に、改行について複数のアルゴリズムをサポートする場合> (p. 335)
* <テキストをフォーマットするときには、Compositor のオブジェクトに対して
  この責任を委譲する> (p. 336)

適用可能性も色々挙げているが、基本はこれだろう。

* 多くの振る舞いが <複数の条件文として現れている場合> (p. 336)

構造、構成要素、協調関係について。

* Strategy がアルゴリズムに共通のインタフェースを宣言する。
* ConcreteStrategy がアルゴリズムを実装する。
* Context が Strategy を利用する。
  アルゴリズムに必要なデータを引き渡したりするのかもしれない。

* 色々なアルゴリズムをサポートするのに Context を派生させない理由は、
  <アルゴリズムの実装と Context クラスの実装が混ざってしまい、
  Context クラスを理解し、保守し、拡張することをより難しくしてしまう>
  (p. 338) から。わざわざアルゴリズムを独立させている。

* <振る舞いの種類がクライアントに関係がある場合にのみ、
  Strategy パターンを利用するべきである> (p. 339)

* Context は ConcreteStrategy が効果的にアクセスできるようにするべし (p. 339)

* C++ の場合、テンプレートを利用して
  Strategy をコンパイル時に選択させることができる (p. 340)
  もっとも、Strategy を動的に変更できなくて構わない場合に限る手段だが。

サンプルコードの ``Compose`` メソッドは引数リストがゴチャゴチャしてないか？

Template Method
----------------------------------------------------------------------
* <アルゴリズムのスケルトン> (p. 347)
* <その中のいくつかのステップについては、サブクラスの定義に任せることにする> (p. 347)

またぞろ Application と Document クラスの例を挙げ、
Document を「開く」オペレーションについての議論。

.. code-block:: c++

   // pp. 347-348; 一部省略
   void Application::OpenDocument(const char* name){
       if(!CanOpenDocument(name)){
           return;
       }

       Document* doc = DoCreateDocument();
       if(doc){
           _docs->AddDocument(doc);
           AboutToOpenDocument(doc);
           doc->Open();
           doc->DoRead();
       }
   }

* <``OpenDocument`` オペレーションは、文書を開くための各ステップを定義する> (p. 348)

  ``OpenDocument`` はおそらく仮想関数になっていなくて、
  この中の各呼び出しメソッドが Application や Document の仮想関数になっている。
  <抽象オペレーションを使ってアルゴリズムのいくつかのステップを定義することにより、
  template method はそれらの順番を固定する> (p. 348)

適用可能性にいいことが書いてある。

* <まず、既存のコードにおける相違点を識別し、次にその相違点を新しいオペレーションに分離する。
  最後に、既存のコードを、その相違点については新しいオペレーションを呼び出すようにした
  template method で置き換える> (p. 348)

このセクションは短い。

* <template method は、コード再利用のための基本的な方法である> (p. 349)
* ハリウッドの原則
* <hook operation は、デフォルトでは何もしないようにしておくことがしばしばある> (p. 350)

実装のコツ

* C++ では

  * primitive operation を private 宣言する (p. 351)
  * <template method は非仮想関数として宣言しておく> (p. 351)

* primitive operation の数を最小化すること (p. 351)
* 名前を見て template method, primitive operation とわかるようにすると便利 (p. 351)

<template method はたいへん基本的なもの> (p. 352)

Visitor
----------------------------------------------------------------------
後回し。

まとめ
----------------------------------------------------------------------
まだ全部読み切っていない。

* Observer パターンでは <observer と subject が制約を維持するために協力し合わなければならない> (p. 370)
* <mediator を再利用可能なものにするよりも、
  observer と subject を再利用可能なものにする方が容易なのは明らかである> (p. 370)
* <Observer パターンよりも Mediator パターンの方が通信の流れを理解するのは容易である> (p. 370)

* <協力し合うオブジェクトが直接お互いを参照しているときには、
  （略）システムの階層化と再利用性に対してマイナスの効果を及ぼす> (p. 371)
* <Observer パターンは、Command パターンよりも送信―受信オブジェクトの結合をさらにゆるく定義する> (p. 371)

* <mediator は、さらに柔軟性を得るためには独自のディスパッチスキーマを実装しなければならないだろう> (p. 372)

第 6 章 終わりに
======================================================================
* <本書は単に既存の設計法について述べたものである。
  本書はチュートリアルとしては妥当だが、
  熟練したオブジェクト指向設計者にはあまり役に立たないと思われるかもしれない> (p. 375)

* <読者がいかにデザインパターンを見つけてカタログ化していくことができるかについて述べる> (p. 375)

6.1 デザインパターンに何を期待するか
----------------------------------------------------------------------
* <デザインパターンを用いることで、
  より高いレベルで設計し、設計について議論することが可能になるのだ> (p. 376)

* <十分に長い間オブジェクト指向システムに従事すれば、
  自力でデザインパターンを習得することができるだろう。
  しかし、本書を読めばはるかに速く習得できるはずである> (p. 376)

* <デザインパターンは分析モデルから実装モデルへの転換のときに特に効果がある> (p. 377)
* <柔軟で再利用可能な設計には、分析モデルには存在しないオブジェクトが含まれる> (p. 377)

* <進化を続けるためには、ソフトウェアは“リファクタリング”と呼ばれるプロセスによって
  作り直さなければならない> (p. 378)

* <優秀は設計者はリファクタリングが必要になるような変更には気付くものである> (p. 378)

6.2 経緯
----------------------------------------------------------------------
* <本書のカタログは Erich の学位論文の一部として始まった> (p. 378)
  おお、学位論文なのか。

* <しかし、パターンを理解できるのは、すでにパターンを使ったことのある人に限られていた> (p. 379)

* <なぜ行っているのかを理解することは、
  何をしているかを理解するよりも難しい> (p. 379)
  これはいい言葉だ。

付録以降
======================================================================
ノートに取るほどの重大な記述はなさそうだ？
