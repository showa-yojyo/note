======================================================================
入門 bash 読書ノート 1/2
======================================================================

:著者: Cameron Newham, Bill Rosenblatt
:訳者: 株式会社クイープ
:出版社: オライリー・ジャパン
:ISBN: 4-87311-254-0

.. contents:: ノートの目次

まえがき
========
* ``echo $BASH_VERSION`` で使用している ``bash`` のバージョンを確認できる。 (p. v)

  * 今手許の環境を調べたら ``3.2.48(21)-release`` と出た。

* 本書の想定読者は「初心者」の次の段階に位置する一般的な UNIX/Linux ユーザー。(p. vi)
* 本書の狙いは、実用的なシェルプログラムを作成するためにコンピュータの学位を取得する必要はないことを示すことにある。 (p. vii)
* RUBOUT: rub out を辞書で調べると、「すり消す」とある。
* <本書では、UNIX を「UNIX と Linux」の略語と捉えている。> (p. x)

1 章 bash の基礎
================
1.3 UNIX シェルの歴史
---------------------
* 歴史的な説明から。

  * Bourne シェル (``sh``) 

    * 作成者 Steven Bourne
    * 1979 年に登場した最初の普及版 UNIX である Version 7 に搭載されていた

  * C シェル (``csh``) 

    * 作者はカリフォルニア州立大学バークレー校の Bill Joy
    * Berkley Software Disribution UNIX (BSD UNIX) の一部として書かれた

  * Korn シェル (``ksh``)

    * ``sh`` と ``csh`` の優れた機能プラス多数の独自機能から構成
    * 商用製品

1.3.1 bash
~~~~~~~~~~
* ``bash`` の名前は Bourne Again Shell から来ている。
  ``sh`` へのリスペクトが込められている。
* GNU プロジェクトのために作成されたシェルなので、無償で配布されている。
* <``bash`` は、GNU システム用の標準のシェルとして、
  公式には 1988 年 1 月 10 日の日曜日に産声をあげた。> (p. 4)

1.3.2 bash の特徴
~~~~~~~~~~~~~~~~~
以下の三点を指摘している。

* コマンドライン編集モード
* ジョブ制御
* 主にシェルをカスタマイズしたりプログラミングしたりするための機能

1.4 bash の入手
---------------
* ``echo $SHELL`` で使用しているシェルを確認できる。

  * 手許の環境で試した結果、 ``/bin/bash`` と出た。

1.6 ファイル
------------
1.6.1 ディレクトリ
~~~~~~~~~~~~~~~~~~
* チルダ展開について。

  * ユーザー名の前に ``~`` を付けると、それはそのユーザーのホームディレクトリの絶対パスとなる。
  * ``~`` はユーザー自身のホームディレクトリを参照する。

1.6.2 ファイル名、ワイルドカード、パス名の展開
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ワイルドカードとは記号だと思えばよい。
  すべてのファイルの名前がわからなくても、パターンで指定できる機能を利用するときに使う特殊な記号。
* ``?``, ``*``, ``[set]``, ``[!set]``
* セット構造は初めて知った。
* <開きかっこ (``[``) の後に感嘆符 (``!``) を入れると、セットを「否定」することができる> (p. 12)

1.6.3 ブレース展開
~~~~~~~~~~~~~~~~~~
* 後で以下の入力を試してみる。

::

  echo b{ed,olt,ar}s
  echo b{ar{d,n,k},ed}s
  echo {d..h}
  ls *.{c,h,o}

1.7 入力と出力
--------------
1.7.1 標準入出力
~~~~~~~~~~~~~~~~
* 標準入力を利用してのコマンド入力終了を告げるために CTRL+D を押す。

1.7.3 パイプライン
~~~~~~~~~~~~~~~~~~
* <入出力リダイレクトとパイプラインが UNIX のブロック構造原理をどのように支援しているかが理解できたと思う。
  表記は実に簡単で強力である。
  特に重要なのは、パイプの概念によってコマンドの出力をほかのコマンドに渡すための見苦しい一時ファイルが要らなくなったことである。> (p. 18)

1.8 バックグラウンドジョブ
--------------------------
* バックグラウンドジョブの基本は

  1. コマンド ``&``
  2. ``jobs`` でバックグラウンドジョブを確認することができる。

1.9 特殊記号とクォーティング
----------------------------
* \p. 21 表 1-6 に特殊記号がまとまっている。

1.9.1 クォーティング
~~~~~~~~~~~~~~~~~~~~
* 特殊記号をリテラルで使用したいときは、それらを単一引用符で囲むことで OK だ。

1.9.2 バックスラッシュエスケープ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``find . -name`` *string* などと入力する場合、
  *string* の部分にはワイルドカードを検索対象ファイル名として指示できるが、
  これを引用符で囲むこと。

1.9.5 コントロールキー
~~~~~~~~~~~~~~~~~~~~~~
* ``stty`` コマンドを使用すると、コントロールキーの設定を確認できる。
  また必要に応じて変更できる。
  ``stty all`` か ``stty -a`` と入力してみること。

* うっかり CTRL+S を押すと画面が止まる。
  もしだしぬけに画面が止まったら、CTRL+Q を試すこと。
  <CTRL+S キーと CTRL+Q キーは基本的に迷惑な存在になっている。> (p. 26)

2 章 コマンドライン編集
=======================
* <``bash`` の編集モードでは、UNIX エディタとして最も有名な ``vi`` と ``emacs`` と同様の編集コマンドを使って、
  コマンドラインを編集することができる。> (p. 29)
* <とにかく編集モードを 1 つは覚えておきたいという場合は、 ``emacs`` モードをお勧めする。
  ``emacs`` モードのほうが、シェルそのものが提供する基本的な編集機能をより自然な形で拡張しているからだ。> (pp. 29-30)

2.3 emacs モード
----------------
* コマンドライン入力を <1 行のウィンドウからなる手軽な ``emacs``> (p. 31) と考えればよい。

2.3.1 基本コマンド
~~~~~~~~~~~~~~~~~~
* ``emacs`` を知らないユーザーにとっては、
  <基本的なキー操作は覚えやすいが、 ``emacs`` 特有の概念をひととおり身につけることが要求される。> (p. 31)

2.3.4 履歴ファイル内での移動
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``emacs`` での行単位での上下方向の移動を、コマンド履歴の移動に流用している。
* CTRL+R は ``reverse-i-search`` になる。

  * 目当てのコマンドラインが見つかったら、Enter ではなく CTRL+E を押すのがよさそう。

2.3.5 テキスト補完
~~~~~~~~~~~~~~~~~~
* <``emacs`` モードの最も強力な（そして一般に使用されている）機能の 1 つは、
  **テキスト補完** 機能である。> (p. 35)
* 最も重要なのは TAB である。
* \p. 37 の表 2-5 を見ると、いろいろな補完コマンドがあることがわかるが、
  やっぱり TAB 一丁で何とかなる。

2.3.6 その他のコマンド
~~~~~~~~~~~~~~~~~~~~~~
1. CTRL+L は ``clear`` と同じ。
2. CTRL+V は ``quote-char`` と同じ。
3. ESC+. および ESC+_ が便利で、前のコマンドラインの最後のワードをポイント位置に挿入する。

2.6 履歴の展開
--------------
* イベント指示記号

  * タイプミス直後に ``^string1^string2`` を活用できる。

* ワード指示記号

  * <``!!:0`` に続いて新しい引数を入力すれば、最後のコマンドを別の引数で実行することができる。> (p. 51)

* 修飾子

このセクション、もう少し実用的な具体例が欲しい。
と思っていたら、最後にこんなことが書いてあった。
<履歴の展開は、コマンドをすばやく再実行するのに便利だが、
前述のコマンドライン編集メカニズムでは無効になってしまう。> (p. 52)

2.7 readline
------------
* ``bash`` のコマンドライン編集インターフェイス
* テキストベースのインターフェースを有するアプリケーションが
  ``readline`` を利用している場合がある。
* キーバインドをカスタマイズすることができる。

2.7.1 readline の起動ファイル
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* <デフォルトの起動ファイルは ``.inputrc`` である。> (p. 52)
* <``readline`` を使用するアプリケーションが別にある場合は、
  ``bash`` 専用のキーバインドを別にしておいたほうがよいだろう。
  これには、（略） ``.inputrc`` ファイルに ``$if bash`` という条件文を挿入する。> (p. 54)
* <変数を設定するには、 ``.inputrc`` ファイルで ``set`` コマンドを使用する。> (p. 55)

::

  # bash を vi モードで起動するようにする
  set editing-mode vi

2.7.2 bind を使ったキーバインド
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* <``bind -P`` と入力すれば、現在のキーバインドを表示することができる> (p. 55)
  そうなので、今手許の Cygwin で試したら大量に出力された。
* <キー配列にシェルコマンドをバインドしたい場合には、
  ``bind -x`` が便利である>

::

  # CTRL+L を ls コマンドにバインドする
  bind -x '"\C-l":ls'

2.8 キー入力の習慣
------------------
* ``vi`` や ``emacs`` のエディタを使った経験がなければ、
  ``emacs`` モードのキー入力を憶えることを著者は推奨している。また、
  ``emacs`` のコマンド構造がミニバージョンを作成するのに向いていることも指摘している。

3 章 環境のカスタマイズ
=======================
冒頭で、環境という概念を、職場の机の例を挙げてわかりやすく説明している。
文房具や電話機を個人の趣向に合わせて配置することは、環境のカスタマイズの一例だ。

3.1 .bash_profile, .bash_logout, .bashrc
----------------------------------------
* ``.bash_profile`` はシステムにログインする度に読み込まれ、そこに書いてあるものを実行する。
* ``.bash_profile`` に類似するファイルとして、 ``.bash_login`` と ``.profile`` がある。

  * ``.bash_login`` は C シェルの ``.login`` に由来している。
  * ``.profile`` は Bourne シェルと Korn シェルの同名の設定ファイルに由来している。
  * ログイン時には、これらのいずれか 1 つだけが読み込まれる。
    優先度は ``.bash_profile``, ``.bash_login``, ``.profile`` の順。

* コマンドラインから ``bash`` を起動した場合（サブシェル）、
  ``.bashrc`` からコマンドを読み込もうとする。

3.2 エイリアス
--------------
* 構文は以下の通り。等号記号の前後に空白文字を入れてはならない。

::

  alias <名前>=<コマンド>

* ``bash`` はエイリアスの対象となるものにテキスト置換を実行する。
  例えば ``alias printall='pr * | lpr'`` というエイリアスに対して、
  ``*`` をワイルドカード展開する。
* エイリアスは再帰的であるが、無限ループに陥らないようにできている。

::

  # 無限ループにならない
  alias ls='ls -l'

* 等号なしで ``alias XXXX`` を実行すると ``XXXX`` の値が表示される。
* 引数なしで ``alias`` を実行すると、定義済みのエイリアスの一覧が表示される。
* エイリアルは、<シェルのスクリプトや関数では基本的に無効となる。> (p. 64)

3.3 オプション
--------------
* ``set -o <オプション名>`` と ``set +o <オプション名>`` が基本。
  前者はオプションを ON にし、後者は OFF にする。
* ``ignoreeof`` と ``nounset`` が面白そう。
* オプションの状態を確認するには、単に ``set -o`` とだけ入力する。

  * 今試してみたら、ほとんどのオプションが値が off だった。

3.3.1 shopt
~~~~~~~~~~~
* bash 2.0 で追加されたコマンドで、環境変数や ``set`` コマンドで行われていた設定に代わるもの。
* ``shopt -p`` で一覧を見てみよう。

3.4 シェル変数
--------------
* 変数を定義する構文は ``<変数名>=<値>`` であり、等号記号の左右に空白文字は入らない。
* 変数を削除するには ``unset <変数名>`` とする。
  別に便利ではないようだ。
* <変数の値を確認する最も簡単な方法は ``echo`` コマンドを使用することだ> (p. 67)

3.4.1 変数とクォーティング
~~~~~~~~~~~~~~~~~~~~~~~~~~
* <引用符で囲まれている文字列を 1 つのワードをシェルに思い込ませる> (p. 68)

3.4.2 組み込み変数
~~~~~~~~~~~~~~~~~~
* 最初にコマンドライン履歴関連の変数を紹介している。
  よく使っているのは ``HISTFILESIZE``, ``HISTSIZE``, ``HISTTIMEFORMAT`` の三つ。

  * ``HISTCONTROL`` 変数をうまく設定すると、重複するコマンドラインが履歴リストに追加されなくなる。
    例えば ``HISTCONTROL=ignoredups`` とする。

* プロンプト変数 (``PS1``, ``PS2``, ``PS3``, ``PS4``) により、プロンプトをカスタマイズできる。

  * <Bash は 4 種類のプロンプト文を使い分ける。> (p. 73) 
  * <プロンプト文を設定する最も効果的な方法は、常にカレントディレクトリが表示されるようにすることだろう> (p. 74)
    たとえば ``PS1="\u \!--> "`` のようにする。
  * <セカンダリプロンプト文は、コマンドラインを入力して RETURN キーを押したときに、
    コマンドが未完成であることを示すために使用される。> (p. 75)

* コマンド検索パス ``PATH``

  * この記法をおさえる。
    ``PATH=$PATH:"/home/user-name/bin"``
  * セキュリティ上 ``PATH`` を自分のディレクトリをほかのよりも優先されるように設定してはいけない。

* ``bash`` はコマンドハッシュなるものを管理している。
  ``hash`` コマンドでそれを確認できる。

  * <``hash`` の詳細について頭を悩ませる必要はない。> (p. 77)

* ``CDPATH`` の紹介。「Cygwin へ送る」ユーザーである私は使わない。

3.5 カスタマイズとサブプロセス
------------------------------
* <ユーザーがコマンドを入力するたびに、シェルがそのコマンドをサブプロセスで実行することを思い出そう。
  複雑なプログラムになると、サブプロセスを独自に生成することもある。> (p. 79)

3.5.1 環境変数
~~~~~~~~~~~~~~
* 環境変数は、すべてのサブプロセスが参照できる特殊なシェル変数だ。
* 以下のように処理した変数は、環境変数として使用することができる。

::

  export <変数名>
  # or
  export <変数名>=<値>

* 特定のサブプロセス環境だけで使用する環境変数を定義することもできる。

::

  TERM=trythisone emacs file-name

* 環境変数をリストするには ``export`` を引数なしで実行する。

  * 実行してみたら ``declare -x`` の嵐となった。

3.5.2 環境定義ファイル
~~~~~~~~~~~~~~~~~~~~~~
* <原則としては、 ``.bash_profile`` 内の定義をできるだけ減らし、
  環境定義ファイル (``.bashrc``) の定義をできるだけ増やす。> (p. 84)

::

  stty stop ^S intr ^C erase ^?
  date
  source .bashrc

4 章 基本的なシェルプログラミング
=================================
4.1 シェルスクリプトと変数
--------------------------
* <**スクリプト** とは、シェルコマンドが含まれたファイル、
  つまりシェルプログラムのことである。
  3 章で説明した ``.bash_profile`` や環境定義ファイルもシェルスクリプトである。> (p. 85)
* スクリプト名を入力すると、<**サブシェル** と呼ばれるシェルの新しいコピーがサブプロセスとして実行される。
  サブシェルはスクリプトからコマンドを取り出し、
  それらを実行して終了した後、制御を親シェルに戻す> (p. 86)
  という一連の処理が発生する。

4.1.1 関数
~~~~~~~~~~
* <関数とはスクリプトの中のスクリプトのようなもの> (p. 87) メモリにシェルコードが格納される。
* 定義方法は次のどちらかとなる。機能差はない。

::

  function <関数名>
  {
    <シェルコマンド>
  }
  # or
  <関数名> ()
  {
    <シェルコマンド>
  }

* ``declare -F`` で、存在する関数の名前一覧を表示できる。
* 組み込みコマンド ``type`` でコマンドの種類を確認できる。

4.2 シェル変数
--------------
* <言語の違いを特徴付ける方法として、変数の機能を比較することが重要なほどである。> (p. 90)
* ``bash`` は <文字列をことのほか重視する。> (p. 90)

4.2.1 位置パラメータ
~~~~~~~~~~~~~~~~~~~~
* **位置パラメータ** は、スクリプトが呼び出されたときに、そのコマンドライン引数を保持する。
* ``$1``, ``$2``, ``$3``, ... で参照できる。
* ``$0`` はスクリプト自身の名前を含む。
* ``$*`` は ``$1`` 以降すべての位置パラメータからなる文字列。

  * ``IFS`` の 1 文字目で区切られた文字列

* ``$@`` は ``"$1" "$2" "$3" ... "$N"`` に等しい。二重引用符とスペース文字は固定。
* ``$#`` は、位置パラメータの個数（を示す文字列）。
* 関数も独自の位置パラメータを持つ。

``$*`` と ``$@`` はよくどっちがどっちだか忘れるので注意。

4.2.2 関数のローカル変数
~~~~~~~~~~~~~~~~~~~~~~~~
* <関数の定義に ``local`` 文が含まれている場合、その関数の変数は **すべて**
  関数のローカル変数になる。> (p. 93)

4.2.3 $@ と $* での引用
~~~~~~~~~~~~~~~~~~~~~~~
* ``$*`` は出力での活躍が多いらしい。位置パラメータのリストをカンマ区切りで表示したい場合は、
  ``IFS=, echo "$*"`` とする。

4.2.4 変数の構文について
~~~~~~~~~~~~~~~~~~~~~~~~
* 正式には ``${変数名}`` のように中括弧がある。

4.3 文字列演算子
----------------
4.3.1 文字列演算子の構文
~~~~~~~~~~~~~~~~~~~~~~~~
``${variable:-word}``
  変数が未定義のときにデフォルト値を **返す**
``${variable:=word}``
  変数が未定義のときにデフォルト値を **設定する**
``${variable:+word}``
  変数が定義されているかどうかを知る。
  定義されていても ``word`` を返すので ``variable`` 自身の値は得られない。
``${variable:offset:length}``
  部分文字列を返す（スライス）

* <位置パラメータの値をわかりやすい名前の変数に代入すれば、
  変数名を改善することができる。> (p. 98)

::

  filename=$1
  howmany=${2:-10}

* <``echo`` の ``-e`` オプションは、引数を表示した後に改行しないことを示す。> (p. 100)

4.3.2 パターンとパターン照合
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``${variable#pattern}`` 等を照合演算子という。

  * ``#`` は始めの部分を照合し、 ``%`` は終わりの部分を照合する。
  * 一文字が最短一致で、二文字が最長一致。

* 置換は ``${variable/pattern/string}`` か ``${variable//pattern/string}`` で行う。

::

  outfile=${filename%.pcx}.jpg

* ``$PATH`` を読みやすくするには ``echo -e ${PATH//:/'\n'}`` がおすすめ。

4.3.4 高度なパターン照合
~~~~~~~~~~~~~~~~~~~~~~~~
* <``shopt`` の ``extglob`` オプションをオンにした場合に使用できるパターン照合演算子がいくつかある。> (p. 104)

  ===================  ====================
  ``*(pattern-list)``  0 個以上検出
  ``+(pattern-list)``  1 個以上検出
  ``?(pattern-list)``  0 or 1 個検出
  ``@(pattern-list)``  1 個検出
  ``!(pattern-list)``  一致しないものを検出
  ===================  ====================

::

  $ shopt -s extglob
  $ echo *.+(txt|html)
  <ファイル名が .txt または .html で終わるものすべて>
  $ echo !(*Makefile)
  <ファイル名が Makefile なんとか以外すべて>

4.4 コマンド置換
----------------
* ``$(<コマンド>)`` とすると、<コマンドの標準出力を変数の値として使用することができる。> (p. 105)
* 昔はバッククォートで囲んでいたようだが、読みにくいうえに入れ子にできない。
  ドルカッコのほうを使うべし。

::

  ls -l $(type -path -all command-name)

* <関数の名前に他意はない> (p. 108) とか小ネタで笑わせてくる。
* タスク 4-7 を読んでいて思うのだが、
  ``ls -l`` の結果を加工する種のスクリプトは、
  どうしても可搬性に難のあるものにはなるまいか。

5 章 フロー制御
===============
* この章では ``if/else``, ``for`` などの導入をする。
* <一から説明されることにうんざりしているプログラマの気持ちもわからないではない。> (p. 113)

5.1 if/else
-----------
::

  if <条件>
  then
      <文ブロック>
  elif <条件>
      then <文ブロック> ...
  else
      <文ブロック>
  fi

5.1.1 終了ステータス
~~~~~~~~~~~~~~~~~~~~
* コマンドや関数は終了時に呼び出し元に整数コードを返す。これを **終了ステータス** という。
* <**通常は** 0 が正常終了、それ以外 (1 から 255) が異常終了を示す。> (p. 115)

5.1.2 return
~~~~~~~~~~~~
* ``return N`` 文が含まれている関数は、終了ステータス ``N`` で終了する。
  ``N`` を省略することもでき、その場合は最後のコマンドの終了ステータスが設定される。

5.1.3 終了ステータスの組み合わせ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``bash`` の ``if`` 文において、 ``&&``, ``||`` は short-circuit rule が適用される。

5.1.4 条件の評価
~~~~~~~~~~~~~~~~
* ``[...]`` と ``[[...]]`` の二つがある。ここでは一つ目の構文を使用する。
* ``[...]`` 構文を使用すれば、次のことができる。

  * ファイルの属性をテストする
  * 二つのファイルの新しさを比較する
  * 文字列同士を比較する (``str1 = str2``, ``str1 != str2``, ``str1 < str2``, etc.)

* 文字列変数をテストする際は、二重引用符で囲むのが望ましい。
* <コード全体が ``if-then-else`` で囲まれているほうがよいプログラミング作法であるという考え方もあるが、
  エラーを確認しながらいくつかに分岐するような長いスクリプトを書くのは混乱のもとである。> (pp. 121-122)

* ファイル属性演算子。よく使いそうなのをノートしておく。
  ``-x`` 演算子の意味だけ注意がいる。

-a file  file が存在する
-d file  file が存在し、かつディレクトリである
-e file  ``-a`` と同じ
-r file  file を読み取れる
-w file  file を上書きできる
-x file  file がファイルの場合、それが実行可能である。
         file がディレクトリの場合、その中を検索できる。


file1 -nt file2  file1 が file2 よりも新しい

file1 -ot file2  file1 が file2 よりも古い

5.1.5 整数の条件式
~~~~~~~~~~~~~~~~~~
* 整数を比較する演算子が存在するが、整数値だけを扱う条件式の構文が別に存在するのでそちらを使うこと。

5.2 for
-------
* <``for`` ループはコマンドラインの引数や一連のファイルを処理するのに最適である。> (p. 129)

::

  for name [in list]
  do
      <$name を使用する文ブロック>
  done

* in *list* の部分を省略すると、デフォルトでは ``$@`` となる。
* <``for`` ループの使用法としては、コマンドライン引数を 1 つずつ処理するほうが一般的である。> (p. 130)
* タスクで紹介している再帰処理で、ディレクトリ階層を下がるたびに出力文字列をタブでインデントしている。
  ``tab=$tab$singletab`` でタブ文字を伸ばしているのが面白い。
  階層を上がるときは ``tab=${tab%"$singletab"}`` としている。

5.3 case
--------
* Pascal の ``case`` 文に相当する。
* ワイルドカードを使ったパターンと文字列の照合が可能。

::

  case <式> in
      <パターン> )
          <文ブロック> ;;
      <パターン> )
          <文ブロック> ;;
      ...
  esac

* C 言語の ``default`` のような処理をするならば ``* )`` を使える。

5.4 select
----------
使いそうにないので飛ばす。

5.5 while と until
------------------
* 構文は共に以下の通りで、 ``while`` と ``until`` は条件式を扱う方法の違いしかない。

::

  while <条件>
  do
      <文ブロック>
  done

* <本書の見解では、 ``until`` が必要になることはまれである。> (p. 143)

6 章 コマンドラインオプションと型を持つ変数
===========================================
6.1 コマンドラインオプション
----------------------------
6.1.1 shift
~~~~~~~~~~~
* ``shift`` コマンドで、位置パラメータを前にずらすことができる。

  * ``shift 3`` とすると、位置パラメータが 3 個ずれる。

* <通常の UNIX 構文では、オプションが引数の前にある> (p. 147)

6.1.2 引数付きのオプション
~~~~~~~~~~~~~~~~~~~~~~~~~~
* <多くのコマンドに **独自に** 引数をとるオプションがあることを思い出そう。> (p. 148)
  そういう場合は追加の ``shift`` が要る。

6.1.3 getopts
~~~~~~~~~~~~~
* ``shift`` の利用だけでは <``-a -b -c`` ではなく ``-abc`` のように、
  ハイフンを 1 つで組み合わされた引数には対応できない。また、
  ``-b arg`` ではなく ``-barg`` のように、スペースを要れずに引数を指定することもできない。> (p. 149)

::

  while getopts ":ab:c" opt; do
    case $opt in
      -a ) <オプション -a の処理> ;;
      -b ) <オプション -b の処理> 
           <$OPTARG はオプション固有の引数> ;;
      -c ) <オプション -c の処理> ;;
      -? ) echo 'usage: alice [-a] [-b barg] [-c] args...'
           exit 1
      esac
  done

  shift $(($OPTIND - 1))

  <通常の引数処理>

* <オプションが引数をとる場合、 ``getopts`` はそれを ``OPTARG`` 変数に設定する。> (p. 150)

6.2 型を持つ変数
----------------
* 変数には「読み取り専用」や「整数型」といった属性を設定することができる。
  それには、組み込みコマンド ``declare`` を使用する。

-a  配列
-f  関数名
-i  整数値
-r  読み取り専用
-x  変数をエクスポート

* <関数において ``declare`` で宣言された変数は、関数のローカル変数となる。> (p. 155)

6.3 整数型の変数と算術演算
--------------------------
* <``$((`` と ``)`` で囲まれた文字列は、算術演算式として評価される。> (p. 155)
* 表 6-2 によると、算術演算子は C 言語のそれとほぼ同じ。べき乗演算子があるのが面白い。
  ``**`` と書けばよいようだ。
* 関係演算子と論理演算子もある。
* 基数もサポート。例えば ``$((2#1001))`` は二進数の ``1001`` のことだ。

6.3.2 数値変数と代入
~~~~~~~~~~~~~~~~~~~~
* <``let`` 文を使用すれば、算術演算子を評価した後、
  その結果を変数に代入することができる。> (p. 158)

::

  let <整数型の変数>=<式>

6.4 配列
--------
* 配列の定義方法はいくつかある。とりあえず次の方法だけ覚える。

::

  # 方法 1
  names[2]=alice
  names[0]=hatter
  names[1]=duchess

  # 方法 2
  names=([2]=alice [0]=hatter [1]=duchess)

  # 方法 3
  names=(hatter duchess alice)

* 配列の要素を参照するには ``${names[0]}`` のようにする。
* 位置パラメータのそれと同様に、 ``${names[@]}``, ``${names[*]}`` が使用できる。

  * ``for`` ループで配列の要素を順番に参照することができる。
  * 値が設定されている要素のインデックスを知るには、 ``${!names[@]}`` とする。
  * 配列の長さを ``${#names[@]}`` とする。

* 配列の特定の要素を削除するには ``unset names[1]`` のようにする。
* 配列全体を削除するには ``unset names`` とする。
* ``/etc/passwd`` のユーザー名とユーザー ID から配列を作成する例。
  ``cut`` で切り出したコロン区切りの文字列を、文字列演算子を利用して split して、
  上述方法 1 のやり方で配列要素を順次追加している。

7 章 入出力とコマンドラインの処理
=================================
7.1 入出力リダイレクタ
----------------------
* 表 7-1 にまとまっている。
  いつも ``&`` が付くリダイレクタの意味がわからなくなるのだが、
  ``&`` はコピー、 ``&-`` は停止と憶えておけばよい？
* <``set -o noclobber`` と入力すると、
  ``> file`` によるファイルの上書きを阻止することができる。> (p. 173)

7.1.1 ヒアドキュメント
~~~~~~~~~~~~~~~~~~~~~~
* <ヒアドキュメントは、コマンドプロンプトから使用してもあまり意味がない。> (p. 173)
* <``<<`` リダイレクタは 2 種類に分かれる。
  まず、 *label* を単一引用符または二重引用符で囲むと、
  パラメータ置換とコマンド置換は実行されなくなる。> (p. 175)
* <``<<-`` リダイレクタを使用すると、
  ヒアドキュメントとラベル行からの先頭のタブを削除することができる
  （それ以外の空白は残る）> (p. 175) ので、
  ヒアドキュメントのテキストを読みやすくするためにインデントできる。

7.1.2 ファイルデスクリプタ
~~~~~~~~~~~~~~~~~~~~~~~~~~
* エラーメッセージをファイルに出力するには ``コマンド 2> file`` とする。
* かつ、標準出力も同じように処理するには ``コマンド > file1 2> file`` とする。
* 標準出力と標準エラーの両方をファイルに出力するには ``コマンド > file 2>&1`` とする。

  * パイプに出力するには ``コマンド 2>&1 |`` とする。

7.2 文字列の入出力
------------------
7.2.1 echo
~~~~~~~~~~
* ``-e``, ``-n`` オプションを憶える。
* **エスケープシーケンス** はあまり憶えなくても済む。
  使うときは ``-e`` と組み合わせることになると思う。

7.2.2 printf
~~~~~~~~~~~~
* ザッと見る限り、C 言語のそれと同じように使えるようだ。

7.2.3 read
~~~~~~~~~~
* シェル変数に値を取り込むためのコマンド。
  ``read var1 var2 ...`` のような構文をとる。
* <ワードよりも変数の方が多い場合、余分なワードは最後の変数に代入される。
  変数を 1 つも指定しないと、入力行はまとめて ``REPLY`` 変数に代入される。> (p. 183)
* ``read`` は行単位の処理を指向している。が、そういうのはパイプラインが行う仕事だろうから
  <行単位での処理を行いたいのであれば、シェルスクリプトを使用する理由はまったくない> (p. 183)。

* 関数は標準入出力デスクリプタを独自に持つ。
  関数呼び出しの右側にリダイレクタを書いたり、
  関数定義の終了直後にリダイレクタを書いたりできる。

::

  findterm () {
    <...関数定義>
  }

  findterm < /etc/terms

::

  findterm () {
    <...関数定義>
  } < /etc/terms

* ループや ``if...fi``, ``case...esac``, ``select...done`` 等の定義直後でも同様に可能。

* <コマンドを ``{`` と ``}`` で囲むと、そのコードは名前のない関数のように機能する。> (p. 186)
  本書ではこれを **コマンドブロック** と呼んでいる。このブロックの終了直後も、
  リダイレクタを置ける。

* ユーザーへのプロンプトの出し方が参考になる。
  下のコード片だが、 ``echo -n`` で改行を抑制していることと、
  ``>&2`` で標準出力を標準エラー出力に切り替えていることがポイント。

::

  echo -n 'terminal? ' >&2

7.3 コマンドラインの処理
------------------------
* 図 7-1 の「コマンドライン処理の流れ」の要点がよくわからない。
* 小ネタだが、 ``~+`` と ``~-`` はそれぞれカレントディレクトリと、
  直前のディレクトリに置換されるらしい。p. 192 の脚注より。

7.3.2 command, builtin, enable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* <コマンドは、関数、組み込みコマンド、スクリプト、実行可能ファイルの順に検索される。
  この順序は、 ``command``, ``builtin``, ``enable`` の 3 つの組み込みコマンドを使って、
  変更することができる。> (p. 194)

  * ``command`` は組み込みコマンドと検索パス上にあるコマンドだけに実行候補を絞る。
  * ``builtin`` は組み込みコマンドだけ。
    ``builtin printf`` のように使う。
  * ``enable`` は<組み込みコマンドを有効または無効にする。> (p. 195)

    * ``enable -n enable`` で ``enable`` 自身を無効にできる。元に戻せない？

* <``test`` という名前はプログラムに向いていないようだ。> (p. 196) は至言。

7.3.3 eval
~~~~~~~~~~
* <スクリプトを実行しながらコマンド文字列をその場で生成し、
  シェルにそれらを実行させることができる> (p. 197)
* <変数名の先頭のドル記号をバックスラッシュエスケープしたのは、
  変数の値に ``>`` や ``|`` といった特殊記号が含まれていると、
  思わぬ結果を招くからだ。バックスラッシュには、
  ``eval`` コマンド自体が実行されるまでの変数の評価を先送りするという働きがある。> (p. 198)

::

  eval sort -nr \$1 ${2:+"| head -\$2"}

  eval "$@" > logfile 2>&1 &

----

:doc:`newham05-note2` へ。
