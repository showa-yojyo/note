======================================================================
Modern C++ Design 読書ノート
======================================================================

テンプレートの専門的な利用技法とデザインパターンを同時に習得できるかもしれない一冊。
読み切るだけでも相当な根気が要る。これを理解するとなると……。

:著者: Andrey Alexandrescu
:訳者: 村上雅章
:出版社: ピアソン・エデュケーション
:ISBN: 4-89471-435-3

.. contents:: ノート目次

ローマ数字ページ各種
======================================================================
* 本書推薦その 1 は Scott Meyers が寄せている。
  言うまでもなく Effective C++ シリーズの著者だ。

  * <パターン自身をコード化するのではなく、パターンの実装を自動的に生成させる> (p. x)

* 推薦その 2 は John Vlissides が寄せている。GoF の一人。

  * <テンプレート・パラメータによって、実行時のオーバーヘッドをまったく発生させずに、
    実装上のトレード・オフを変えることもできるのです> (p. xiii)

* 著者によるまえがきで、本書の目的を明瞭に示している。

  * 対象読者タイプ 1: <C++ プログラマ経験者で最新のライブラリ作成テクニックをマスターしたいと考えている方々>
  * 対象読者タイプ 2: <忙しいプログラマで手っ取り早く作業を済ませてしまう必要がある方々> (p. xviii)
  * <Loki という実在する C++ ライブラリ> (p. xviii) を解説する本である。
  * 本書中のコード例では、Herb Sutter 式コーディング規則を採用。
    もしかして Exceptional C++ Style が関係ある？

* 訳者まえがき

  * <ある種の意思決定は実装段階でなければ行えない> (p. xxiii)
  * <センス・オブ・ワンダーの渦巻く C++ の新世界をお楽しみ下さい>

第 1 章 ポリシーを基にしたクラス・デザイン
======================================================================
* ポリシーとポリシー・クラスとは、重要なクラス設計技術のひとつらしい。
* **ポリシー** とは、<特定の動作や構造上の側面を専門的に受け持った小さなクラス群> (p. 3) のこと。

----

* <プログラミングの天才が若年層に分布しているのに対して、
  ソフトウェア設計の天才がより高年齢層に分布する傾向にある> (p. 4)

* <システム・アーキテクチャには、「設計によってある種の公理を強制する」という
  重要な目標があります> (p. 4)

* <理想的には、設計によって課された制約のほとんどが、コンパイル時点で強制されるべきなのです> (p. 4)

* <組み合わせ爆発と真っ向勝負を挑んではいけない> (p. 5)

* <設計指向のライブラリ> (p. 5)

----

* <いくつかの吟味された基底クラスを用意しておき、
  多重継承によって設計の選択における組み合わせの爆発を取り扱うというアイディアが考えられます。
  （略）しかし、少しでもクラス設計の経験があれば、
  こういった単純な設計がうまく機能しないことは理解できるでしょう> (p. 6)

* <クラス・テンプレートは、通常のクラスではサポートされていないような方法でカスタマイズすることが可能です。
  もし特殊なケースを実装したいのであれば、特定のクラス・テンプレートを生成する際に、
  そのテンプレートにおける任意のメンバ関数を特殊化することができるのです。
  例えば、 ``SmartPtr<T>`` というテンプレートがある場合、
  ``Smart<Widget>`` における任意のメンバ関数を特殊化することができるわけです> (p. 6)

* <さらに、多重パラメータのクラス・テンプレートを用いた場合、
  部分的にテンプレートの特殊化を行うこともできます> (p. 6)

.. code-block:: c++

   // こういう定義がある場合、
   template <class T, class U> class SmartPtr { ... };
   
   // この定義は部分特殊化となる。
   template <class U> class SmartPtr<Widget, U>{ ... };

* <多重継承とテンプレートには相補的なトレード・オフが存在しています> (p. 7)

----

* ポリシーは traits と通じるものがあるが、型ではなく動作を強調する点が異なる。
* ポリシーは「コンパイル時 Strategy パターン」と見ることもできる。
* <ポリシーは、シグネチャ指向ではなく、シンタックス指向なのです> (p. 8)
  <例えば、 ``Creator`` ポリシーでは ``Create`` が static であるか virtual であるかを規定しません> (p. 8)

* **ホスト** または **ホスト・クラス** とは、1 つ以上のポリシーを利用するクラスのことを指す。

----

テンプレート・パラメータに ``template`` を用いる技法が紹介されている。
自分ではこういうクラスを定義することはないが、利用する可能性があるので覚えておくこと。

* ポリシーを使用することで得られる柔軟性

  * 実体化する際のテンプレート引数を変更するだけで、簡単に外部からポリシーを変更できる。
  * アプリケーションに特化した自作ポリシーを提供できる。

----

ポリシー・クラスのデストラクタについて言及あり。

* ポリシーに対してデストラクタを virtual にすると、ポリシーの性質が静的ではなくなる。
  効率のよい解決策としては、デストラクタを非 virtual かつ protected とする。

----

「不完全実体化」の技法について解説あり。

「あるクラス・テンプレートのメンバ関数が使用されない場合、
それは実体化されることがない」すなわちコンパイルエラーが起こらない。

----

* <ポリシーに基づいたクラス設計を行う上で最も難しいのは、
  クラスの機能を正しくポリシーへと分解することです> (p. 20)

* <極端に言えば、ホスト・クラスから固有のポリシーを完全に無くしてしまうのです> (p. 20)

* <過度に一般化されたホスト・クラスの欠点は、
  テンプレート・パラメータが氾濫するということです> (p. 20)

* ``typedef`` の使用によって、秩序だった使用と容易な保守性が保証される。

* <クラスをポリシーに分解する際、
  **直交性のある** (orthogonal) 切り口を見つけ出すことが大変重要になります> (p. 21)
  
  <お互いが完全に独立した> (p. 21) 役割になるように、
  ポリシー分割するのがよいということだな。
  あるポリシーが別のポリシーに干渉するようではまずい。

第 2 章 テクニック
======================================================================
