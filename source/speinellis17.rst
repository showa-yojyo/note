======================================================================
Effective Debugging 読書ノート
======================================================================

:著者: Diomidis Spinellis
:訳者: 黒川 利明
:出版社: オライリー・ジャパン
:ISBN: 978-4-87311-799-7
:関連 URL: `O'Reilly Japan - Effective Debugging <https://www.oreilly.co.jp/books/9784873117997/>`__

.. contents:: ノート目次

まえがき
======================================================================
* 本書は経験を積んだ開発者向けに書かれている。
* 本書で紹介するデバッグ技法は、あえて詳細にまでこだわって記述した。

本書の内容
----------------------------------------------------------------------
* 本書で扱うテーマは、一般的なものからより特殊なものに並んでいる。

本書の利用法
----------------------------------------------------------------------
#. 戦略と手法
#. スキルとツール

   * <慣れ親しんだツールを使い続ける安楽さを放棄して、より高度なツールを習得する学習に挑戦する>

#. 技法のアイデア

仕事の流儀
----------------------------------------------------------------------
#. ソフトウェア設計で行うすべての事項

   * 最高水準のメカニズム
   * デバッグモード
   * ログのメカニズム
   * コマンドラインツールによるスクリプトで分析する
   * エラーを見せる
   * コアダンプを取得する方法を用意する
   * 非決定性のあるものを最小化する

#. ソフトウェア構築の手順

   * 同僚
   * 単体テスト
   * assertion
   * コードの品質
   * 非決定性のあるもの排除

#. 開発と運用の管理で行うこと

   * 課題管理システム
   * 問題をトリアージ（この本はどういうわけか医療用語がしばしば現れる）
   * バージョン管理システム
   * ツールや環境の多様性を担保する
   * ライブラリーのソースや高度なツールを買う
   * etc.

用語についての注意
----------------------------------------------------------------------
* ISO/IEC/IEEE 24765:2010 という規格で用語が定義されているので、
  それに準拠すると言っている。

  * 「故障」「欠陥」は fault, defect, bug の意味にとる。
  * 「障害」は failure の意味にとる。
  * <故障や欠陥という用語が障害を表すのに使われることが、IOS 標準でも
    認められているが、混乱を招くことがある>

* Unix を Unix の原則や API に従うシステムすべてに使う。
* ルーチンをメンバー関数、メソッド、関数、手続き、サブルーチンの総称として使う。

本書の表記法
----------------------------------------------------------------------
* <コマンドラインツールのインターフェースは何十年も変わらないのに、
  GUI ではバージョンごとに異なる>

1 章 高水準戦略
======================================================================

項目 1: あらゆる問題を課題管理システムで扱う
----------------------------------------------------------------------
* <課題管理システムに登録されていない問題を扱うことは断固拒否すること> か。
  これは肝に銘じておきたい。

* 問題の関係者（取引先の名前とか）を明らかにするのは優先度を決めるのに有用だ。
* 進捗のドキュメントを残すことも重要だ。

知らなかった単語：
  JIRA, SaaS, オンプレミス

項目 2: 問題に対する洞察を得るにはウェブで焦点を絞って検索する
----------------------------------------------------------------------
* コード専用の検索エンジンを使ってみるのも吉。
* 質問の出し方

知らなかった単語：
  SSCCE, SourceLair, JSFiddle

項目 3: 前条件と後条件が満たされていることを確認する
----------------------------------------------------------------------
* ルーチンだけでなく、高水準の操作や設定に対しても同じ手法を使える。

項目 4: 問題からバグをドリルアップするかプログラムの先頭からバグへドリルダウンする
----------------------------------------------------------------------------------
* ドリルアップ

  #. デバッガーやコアダンプが使える場合は簡単。
  #. フリーズの場合はうまく↑に帰着させる。
  #. エラーメッセージが出る場合は :command:`grep` する。

* ドリルダウンはプロファイルや脆弱性診断

  * メモリ食い過ぎ
  * 時間かかり過ぎ
  * セキュリティー
  * 信頼性

項目 5: 既知の正常なシステムと問題を起こしているシステムとの違いを検出する
--------------------------------------------------------------------------
* トレースツールについて

  * 汎用：DTrace, SystemTap
  * システムコール：:command:`strace`, :command:`truss`, Procmon
  * DLL トレース： :command:`ltrace`, Procmon
  * ネットワークトレース： :command:`tcpdump`, Wireshark
  * その他 SQL データベース呼び出しをトレースするもの等

* 環境変数、OS, etc. 多過ぎるシステムの振る舞いに影響する要素。
* バージョン間二分探索 (:command:`git bisect`)
* ログファイルの diff では先に本質的でない行をフィルターしておくのがコツだ。
  例えば :command:`grep -v` などでノイズを除去する。
  場合によっては :command:`sort` してからの :command:`comm` の投入まである。

  * 本書のコマンドライン例では :command:`awk` と :command:`sort` の結果二つのストリームを
    :command:`comm -23` しているものを紹介している。

項目 6: ソフトウェアのデバッグ機能を使う
----------------------------------------------------------------------
* シェルの ``-x`` オプション。
* 各種コマンドラインツールの ``--verbose`` オプション。
* SQL の ``explain`` 文。

知らなかった単語：
  Postfix

項目 7: ビルドと実行環境を多様化する
----------------------------------------------------------------------
* 実行環境を変えてみることで、意外なバグが見つかるかもしれない。
  C/C++ のようにハードウェアと強く結びつく言語で書かれたソフトウェアでは特に期待できる。

* 他の実行環境でデバッグする三つの方式

  #. 仮想マシンソフト
  #. 小型の安価な計算機 e.g. Raspberry Pi;
     Windows や OS X ユーザーには有益。
  #. クラウドベースのホストを借りる

* 他のコンパイラーによるセカンドオピニオンが役に立つ。
* アルゴリズム自体のデバッグとして、他言語（普通は高水準なもの）でコードを
  書き起こすという手法もある。

項目 8: 作業の焦点を最も重要な問題に絞る
----------------------------------------------------------------------
* デバッグの効率を上げるため、バグの優先度をつける。
* 優先度が低いものは思い切って無視する。
* レガシーサポート、後方互換性、見てくれ、使用頻度の低い機能は優先しない。

2 章 汎用の手法と実践
======================================================================

項目 9: デバッグを成功させるために心の準備をする
----------------------------------------------------------------------
* <問題が再現可能な場合は、間違いなく解決できる>
* <寝ている間も取り組む>
* <継続的に環境、ツール、知識に投資しなければならない>

項目 10: 問題の効率的な再現を可能にする
----------------------------------------------------------------------
* 問題再現の最短手順のことを SSCCE と呼ぶようだ。
* 再現可能な実行環境。

知らなかった単語：
  Docker, Ansible, CFEngine, Chef, Puppet, Salt

  システム構成管理ツール

項目 11: 変更から結果までのターンアラウンド時間を最小化する
----------------------------------------------------------------------
ラウンドトリップ時間のようなものか。

項目 12: 複雑なテストシナリオを自動化する
----------------------------------------------------------------------
* Lua という言語で C 言語の三角関数のテストコードを書いているのだが、
  利点が何なのかわかりにくい。テストコードの生産性が C より高いとか？

項目 13: デバッグデータを包括的に概観する
----------------------------------------------------------------------
* データ全てを目の前に適切に並べると良い。関連性、パターンが見つかりやすくなる。
* 老眼鏡をかけてでもフォントを小さくしてモニターに映る情報量を増やす。
* モニターで見るものと紙で見るものを動と静で区別する。

項目 14: ソフトウェアのアップデートを考える
----------------------------------------------------------------------
* 大抵の場合、サードパーティー製コードのせいだと思ったバグは、自分の問題によるものだ。

項目 15: サードパーティソースコードを調べて洞察を得る
----------------------------------------------------------------------
* どのように動作するのかをよく理解するための工程。
* IDE や :command:`ctags` のコードナビゲーション機能を上手く活用して目当てのコードを探しやすくする。
* ライブラリーがオープンソースであれば問答無用。商用であっても保険だと思ってコードを買う。

項目 16: 特別な監視およびテスト装置を使う
----------------------------------------------------------------------
* 前半はスペシャル過ぎて私の参考にならない。
* I/O やネットワークとかハード間のやりとり。

知らなかった単語：
  Wireshark, :command:`tcpdump -w`

項目 17: 失敗による結果をさらに際立たせる
----------------------------------------------------------------------
* ロボトミー（この本は医療用語がよく出るな）して、望みのように実行パスを強制する。
  例えば ``if`` 文の条件などは容易に改造できる。

* 定数を極端な値に書き換えて、正常時との振る舞いの差を際立たせる。
  本書では CAD の例や RPG のキャラクターの属性値を挙げている。

知らなかった単語：
  ファジング (fuzzing?)

項目 18: 手に負えないシステムのデバッグを自分のデスクで行えるようにする
-----------------------------------------------------------------------
* リモートアクセスの話題。
* 本書では KVM over IP と標語的に表現している。

知らなかった単語：
  TeamViewer, :command:`strace`, :command:`truss`, シム

項目 19: デバッグタスクを自動化する
----------------------------------------------------------------------
* :command:`which` コマンドの実行が遅いのを調べる例は興味深い。
  自分でもやってみたい。

  * Cygwin でちょっと試したら、シェル組み込みの :command:`time` しかなくてダメだった。

項目 20: デバッグの前後で大掃除をする
----------------------------------------------------------------------
* コードクリーニングにはリスクがないこともない。
* 作業の過程で得られた assertion, ログ出力文、デバッグコマンドは何らかの形で残す。

項目 21: 問題を起こすクラスのすべてのインスタンスを修正する
----------------------------------------------------------------------
* 同じ欠陥を同時に潰すのが肝要。なおかつ、二度と起こらないように処置する。
* この過程でも :command:`grep` や :command:`sort -u` が役に立つ。

3 章 汎用ツールと技法
======================================================================
The Art of Command Line は気になるから確認しよう。

項目 22: デバッグデータを Unix コマンドラインツールで分析する
----------------------------------------------------------------------
* IDE だけでは問題を検討する能力が十分でないことがある。
* Unix ツールボックスのプログラムを短いパイプラインに組み合わせ、
  コマンドラインプロンプトから実行する方法が（スクリプトの使用より）
  効果を発揮する。
* Windows では Cygwin がいちばんだ。
* テキストでないデータはテキストに変換してから処理する。

知らなかった単語：
  :command:`nm`, :command:`dumpbin`, :command:`javap`

項目 23: コマンドラインツールのオプションとイディオムを活用する
----------------------------------------------------------------------
* :command:`grep` のコツについて。特にオプション ``-l``, ``-r``, ``-v``, ``--color`` など。
* リダイレクト :command:`command 2>&1 | more` のようにすると標準出力と標準エラーを同時に流せる。
* 長い時間がかかるコマンドの実行に :command:`printf '\a'` を添えて音を鳴らす。

  * 今試したら無音だった……。

項目 24: デバッグデータをエディタで調べる
----------------------------------------------------------------------
* 本物のエディターを使うこと。
* テキスト同士の差分を比較する前に、本質的でない違いを「処理」しておくと効率的だ。

項目 25: 作業環境を最適化する
----------------------------------------------------------------------
* CPU やメモリは強力にしておくのが鉄則。
* キーバインド、エイリアス、スクリプト、ショートカット、環境変数等々の個人的設定も入念に整える。
* テキスト入力についての自動補完は重要。

この項目に関しては本書をいちいち参照したほうがよさそうだ。

* <ツールに費やした投資が何倍にもなって返ってくる> (p. 61)
* :command:`ssh` 関連のアドバイスを理解する知識がない。まずい。
* GUI とプロンプトを行ったり来たりする「コスト」を最小化しておく。
* いわゆるドットファイルのリポジトリーを構築しておき、
  あらゆるホスト（仕事場）で同じ設定を利用できるようにしておく。

項目 26: バグの原因と経緯とをバージョン管理システムで探す
----------------------------------------------------------------------
:command:`git` のよく使うコマンドラインが紹介されている。

項目 27: 独立なプロセスからなるシステムの監視ツールを使う
----------------------------------------------------------------------
知らなかった単語：
  Nagios

4 章 デバッガ技法
======================================================================

項目 28: シンボリックデバッグ用にコンパイルしたコードを使う
----------------------------------------------------------------------
* コンパイラーやリンカーのオプションで、各ソースファイルに関連する命令、
  メモリアドレス、行番号、等々をオブジェクトコードに埋め込めるものがある。
* いわゆるデバッグビルドの話題。最適化オプションは「なし」とする。

項目 29: コードをステップ実行する
----------------------------------------------------------------------
* ステップ実行中は step over やブレイクポイントを使いこなしたい。

項目 30: コードとデータのブレークポイントを活用する
----------------------------------------------------------------------
* 行、ルーチンに対してブレイクポイントを設定できる。
  場合によっては ``exit`` や ``abort`` にも設定することがある。
* データに対するブレイクポイントも存在する。
  これはウォッチポイントなどと呼ぶものだ。

項目 31: 逆デバッグ機能をよく知っておく
----------------------------------------------------------------------
* Visual Studio でいうところの Intelli Trace の機能を逆デバッグ機能と呼ぶ。
* :command:`gdb` では ``reverse-`` で始まるコマンド群が相当する。

項目 32: ルーチン間の呼び出しに沿って探索する
----------------------------------------------------------------------
* スタックフレームの話題。
* :command:`gdb` では ``frame n``, ``up``, ``down`` のコマンドがある。

項目 33: 変数と式の値を調べてエラーを見つける
----------------------------------------------------------------------
* 特にローカル変数に対して値を調べる。
* 任意の式の値も表示できる。Visual Studio ならば Quick Watch であり、
  :command:`gdb` ならば ``expression`` がその機能だ。
* リアルタイムで監視するならばウォッチが有用だ。
* 特別なデータ構造のオブジェクトについては専用のデバッガー拡張、ツールを用いる。

  * Python Tutor の図がすごい。

項目 34: 実行プロセスにどのようにデバッガをアタッチするかを知っておく
----------------------------------------------------------------------
これは高級で手に負えない。

項目 35: コアダンプの扱い方を知っておく
----------------------------------------------------------------------
* Windows の場合は注意を要する。
  専用の API を呼ばないとプロセスはダンプを生成しない。
* マネージド環境の言語ではコアダンプ的なものは期待できない。
* コアダンプのデバッグには p. 90 にあるように事前に組織的な準備が必要。
  ユーザーからデータを送信することが必要なので、開発側に相当な覚悟がいる。

項目 36: デバッグツールを整備する
----------------------------------------------------------------------
* <デバッグは GUI を使うほうが常に生産性が上がる> (p. 91)
* IDE を使用しているならばまずは OK だ。
  色々考えないといけないのは :command:`gdb` のようなタイプのデバッグツールメインのときだ。

知らなかった単語：
  DDD, :command:`bashdb`, :command:`remake`, :command:`pydb`

* :file:`.gdbinit` の内容いろいろ。
* :command:`gdb` スクリプトなるものもある。

項目 37: アセンブラコードとハードのメモリ内容を確認する方法を知っておく
-----------------------------------------------------------------------
* 計算機の内部表現をよく知っていると、機械語レベルのデータをデバッグできる。
* 昔のゲーム機のエミュレーターも教えてあげたい。

5 章 プログラミング技法
======================================================================

項目 38: 怪しいコードをレビューして手動で実行する
----------------------------------------------------------------------
* アナログ手法でコード（アルゴリズム）をデバッグする。

  * 敢えて電卓を使う。
  * データ構造を紙やホワイトボードにペンで描く。キャンバスは大きいほど良い。

* 物理的なオブジェクトもムリヤリ使うとなお良い。

項目 39: コードとその内容を同僚に説明する
----------------------------------------------------------------------
* コードを説明すると、脳の異なる部分が働いて問題の原因が明らかになりやすい。
  というか、レビューしてもらうと有益な指摘が返ってくることが普通に期待できる。

* マルチパーティーアルゴリズムとは何だ？

項目 40: デバッグ機能を追加する
----------------------------------------------------------------------
* ログ出力、情報表示、専用コマンドなどを有効化するモード。
* マインクラフトのデバッグワールドの例は面白い。
* 組み込みの事情はよくわからないので飛ばす。

項目 41: ロギング文を追加する
----------------------------------------------------------------------
* ログ出力とデバッガーは相補的に利用できる。
* ログテキストに適切な書式を与えておくことで、後々のフィルターやクエリーが効率よくなる。
* ログ出力には自作ではなく専用フレームワークを利用する。
* 組み込みの事情はよくわからないので飛ばす。
* なお、非テキストベースのソフトウェアでは「ログ」に工夫が要る。
  メッセージボックスを出すような。

項目 42: ユニットテストを使う
----------------------------------------------------------------------
* 単体テストのフレームワークを利用する。次のような利点が考えられる：

  * テストを反復的に実施しやすくなる。
  * リファクタリングを気兼ねなしに？実施しやすくなる。

項目 43: アサーションを使う
----------------------------------------------------------------------
* 隙あらば ``assert`` 文をコードに埋め込む。
  事前条件、不変条件、事後条件を明白にできる。

* コンパイルオプションを設定して ``assert`` 文をデバッグビルドでのみ有効化する。

項目 44: デバッグしたプログラムに変動を与えて推理を検証する
----------------------------------------------------------------------
* これは学習目的か？

項目 45: 稼働例と問題コードとの相違を最小化する
----------------------------------------------------------------------
* 一方を他方に「変形」させていく途中で問題を生じさせる何かを発見できるはずだ。

項目 46: 怪しいコードを単純にする
----------------------------------------------------------------------
* 分割統治の話か。

項目 47: 怪しいコードを他の言語で書き直す
----------------------------------------------------------------------
* 問題コードをより表現力に富む言語で書き直す。
* 元の問題を解決するには、書き直したものにすっかり置き換えるか、
  項目 45 の技法を両者に対して適用するか。

項目 48: 怪しいコードの可読性と構造を改善する
----------------------------------------------------------------------
本項はリファクタリングについての基本的な事項が詳細に述べられている。
必要に応じて本書を参照したい。

項目 49: バグの症状を取り除くのではなく、原因を取り除く
----------------------------------------------------------------------
* 問題を一般化して考えてから解決する。
* 背後にある原因の方を重視するのが本質的な解決法であって、
  対処療法的修正は意味がない。

6 章 コンパイル時の技法
======================================================================

項目 50: 生成コードを調べる
----------------------------------------------------------------------
TBW

項目 51: 静的プログラム解析ツールを使う
----------------------------------------------------------------------
TBW

項目 52: ビルドと実行を決定的に構成する
----------------------------------------------------------------------
TBW

項目 53: デバッグライブラリを使用してチェックするよう構成する
----------------------------------------------------------------------
TBW


7 章 実行時の技法
======================================================================

項目 54: テストケースを作って問題を発見する
----------------------------------------------------------------------
TBW

項目 55: 迅速に失敗させる
----------------------------------------------------------------------
TBW

項目 56: アプリケーションのログファイルを調べる
----------------------------------------------------------------------
TBW

項目 57: システムとプロセスの演算操作のプロファイルをとる
----------------------------------------------------------------------
TBW

項目 58: コード実行をトレースする
----------------------------------------------------------------------
TBW

項目 59: 動的なプログラム解析ツールを使う
----------------------------------------------------------------------
TBW


8 章 マルチスレッドコードのデバッグ
======================================================================

項目 60: デッドロックを事後検討デバッグで分析する
----------------------------------------------------------------------
TBW

項目 61: キャプチャして複製する
----------------------------------------------------------------------
TBW

項目 62: 専用ツールでデッドロックと競合条件を見つける
----------------------------------------------------------------------
TBW

項目 63: 非決定性を切り分けて取り除く
----------------------------------------------------------------------
TBW

項目 64: 競合制約状態を調べてスケーラビリティ問題を検討する
----------------------------------------------------------------------
TBW

項目 65: 性能カウンタを使ってフォールスシェアリングを探す
----------------------------------------------------------------------
TBW

項目 66: 高水準な抽象化を用いてコードを書き直すことを検討する
----------------------------------------------------------------------
TBW
