======================================================================
オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 2/3
======================================================================

:doc:`gamma95-note1` からの続き。

:著者: Eric Gamma/Richard Helm/Ralph Johnson/John Vlissides
:監訳者: 本位田真一 吉田和樹
:出版社: ソフトバンク クリエイティブ株式会社
:ISBN: ISBN4-7973-1112-6

.. contents:: ノート目次

第 3 章 生成に関するパターン
======================================================================
* <クラス継承よりもオブジェクトコンポジションに頼る形でシステムを発展させていく場合に、
  生成に関するパターンは重要になる> (p. 89)

* ``MazeGame::CreateMaze`` についての考察が数ページ続くが、
  高密度な記述ゆえに上手い形にノートにまとめられない。

  * 2 つの部屋からなる簡単な迷路を作っているだけなのに、コードが複雑 (p. 92)
  * 迷路構成を変更しようとすると、メンバ関数のオーバーライド（実質再定義）か、
    それと同等の仕事が必要となる (p. 92)

* <より柔軟な設計（必ずしも、コードを短くするわけではない）> (p. 93)
  このカッコ内がポイント。

* <インスタンス化されるクラスがコード中に直接書かれていることが最大の問題> (p. 93)

Abstract Factory
----------------------------------------------------------------------
* Motif とか Presentation Manager とかって何？
* <各種の基本ウィジェットを生成するためのインタフェースを宣言した抽象クラス
  WidgetFactory を定義する> (p. 95)
* 各種のウィジェットに対する抽象クラスを作成したら、
  <その具象クラスで特定の look-and-feel 規格のもとでの実装を与える> (p. 95)
* <たとえば Motif ではスクロールバーはボタンやテキストエディタとともに
  使わなければならないといった制約が、MotifWidgetFactory クラスを利用する結果として
  自動的に規定されることになる> (p. 96)

* このパターンでは Client は AbstractFactory と AbstractProduct で宣言された
  インタフェースのみを利用する (p. 97)
* <普通、ConcreteFactory クラスのインスタンスは実行時に生成される> (p. 97)
  とあるが、実行時に生成されないインスタンスなど考えられる？

* 新たな種類の部品への対応は AbstractFactory とそのすべてのサブクラスについて、
  インタフェースの修正が必要となる。これが面倒。

* 部品を実際に生成するのは ConcreteProduct クラスになるが、
  各部品について factory method を定義する方法がよく用いられる (p. 98)

* Prototype パターンを使って ConcreteFactory クラスを実装する方法がある。
  部品の集合が多数存在する場合にそうすることができる (p. 98)

* <クラスをオブジェクトとして扱うことのできる言語では、
  prototype を用いたアプローチに変化をつけることが可能になる> (p. 99)

* 生成する部品の種類を表すパラメータを取る AbstractFactory の手法は、
  <C++ を使うときには、すべてのオブジェクトが同じ抽象基底クラスを持つ場合か、
  要求を出すクライアントにより部品オブジェクトが正しい型に変換できる場合にのみ、
  適用することができる> (p. 100)

  この条件はそんなにきつくない。
  <サブクラスに特有のオペレーション> (p. 100) をする必要がない場合は、
  この手法の採用の検討に値する。

サンプルコードで ``MazeGame::CreateMaze`` を Abstract Factory パターンで実装している。

* <``MazeFactory`` クラスは、単に factory method を集めたものになっているが、
  これは Abstract Factory パターンを実装するときにもっとも一般的な方法である> (p. 102)
* AbstractFactory が ConcreteFactory を兼ねるのも一般的な実装方法 (p. 102)

Builder
----------------------------------------------------------------------
後回し。

Factory Method
----------------------------------------------------------------------
フレームワーク寄りのデザインパターンらしい。

* フレームワークにしばしば見られる特徴 (p. 115):

  * オブジェクト間の関係を表現するのに、抽象クラスを用いる。
  * （具象型のわからない）オブジェクトの生成を行う責任がある。

* フレームワークの立場としては、<Application クラスは Document
  のどのサブクラスがインスタンス化されるのかを事前に知ることはできない> (p. 115)
  ので、Application クラスに Document を生成するオーバーライド可能な
  メソッド CreateDocument を用意し、ユーザーにサブクラス型を返すような実装をさせる。
  
  この CreateDocument みたいなものを一般に factory method と呼ぶ。

* <クラス内部でオブジェクトを生成する場合、
  直接生成するよりも factory method を使うほうが柔軟性を高める> (p. 117)

* 図形操作ツールの話 (pp. 118-119) が面白かったので、後でもう一回読んでみる。
  Figure インタフェースに CreateManipulator (factory method) を与えておき、
  各 Figure のサブクラスがそれに応じた Manipulator のサブクラスを生成する、
  というトリック。

* Creator クラスを抽象クラスにして、factory method を空にする場合と、
  Creator クラスを具象クラスにして、factory method にデフォルト実装を与える場合がある
  (p. 118)

* Factory Method パターンの変形として、<factory method が数種類の
  ConcreteProduct オブジェクトを生成できるようにしておく> (p. 119) ものがある。
  種類を表すパラメータを取るようなメソッドにするらしい。

  * この手法はシリアライズ実装で使うというようなことが書かれている。

* 言語によっては <インスタンス化されるクラスを返すメソッド> (p. 120) を使う。
  オブジェクトではなく、クラス自体を返すということ。

* C++ では Creator クラスのコンストラクタ内で factory method を呼び出せない (p. 121)

  そんなことをしたら実行時エラーが起こって即終了。

* C++ ではさらに <テンプレートを用いてサブクラス化を避ける> (p. 121) 技法も駆使したい。
* factory method には、見てそれとわかる名前を付けると便利 (p. 122)

サンプルコードでは ``MazeGame::CreateMaze`` を factory method で実装している。

* <factory method は、ツールキットやフレームワークの中で広く採用されている> (p. 124)
* Abstract Factory パターンは factory method を使って実装されることが多い (p. 125)

Prototype
----------------------------------------------------------------------
後回し。

Singleton
----------------------------------------------------------------------
ここは読まなくていいや。

まとめ
----------------------------------------------------------------------
* オブジェクトを生成するクラスをサブクラス化する方法

  * Factory Method パターンを使うことに対応。

* 生成するオブジェクトのクラスを把握しているオブジェクトを定義してから、
  それをパラメータにする方法

  * Abstract Factory, Builder, Prototype パターンの基本。
    設計は柔軟だが、より複雑 (p. 146)

* 図形エディタフレームワークを設計するのならば、
  Factory Method パターンがもっとも使いやすいパターン (p. 145)
  だが、GraphicTool のサブクラスが多く必要になる。

* <全般的に見て、Prototype パターンが図形エディタフレームワークにとって、
  おそらく最適なパターンになるだろう> (p. 146)
  ``Graphic::Clone`` のオーバーライドだけでよいから。

* <Factory Method パターンを使うことで、
  設計はカスタマイズが容易になると同時に若干複雑になる> (p. 146)

* 設計の初期段階では Factory Method パターンを採用しておき、
  様子を見て他のパターンに発展させていくやり方がよい (p. 146)

どの方法も複雑であると言っている？

第 4 章 構造に関するパターン
======================================================================
* <クラスやオブジェクトを合成する方法に関係している> (p. 147)
  なるほど。構造イコール合成なのか。

* 構造に関するパターンも、「オブジェクトに適用するもの」と
  「クラスに適用するもの」がある。
  前者が動的で後者が静的な性質のものだということなのだろう。

Adapter
----------------------------------------------------------------------

Bridge
----------------------------------------------------------------------
後回し。

Composite
----------------------------------------------------------------------

Decorator
----------------------------------------------------------------------

Facade
----------------------------------------------------------------------
後回し。

Flyweight
----------------------------------------------------------------------
後回し。

Proxy
----------------------------------------------------------------------
後回し。

まとめ
----------------------------------------------------------------------
Composite, Decorator, Proxy の比較 (p. 234) が面白かった。

* Decorator は退化した Composite ではない。

  * 両者は目的が異なっている。
  * ということは、相補的に利用できる。

* Decorator も Proxy も、クライアントに合成前のインタフェースと同じものを与えるが、
  Proxy に関しては

  * 特性を動的に加えたりはずしたりしない。
  * 再帰的な合成のために設計されていない。

----

:doc:`gamma95-note3` へ。
