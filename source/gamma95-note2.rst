================================================================================
オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート 2/3
================================================================================

:doc:`gamma95-note1` からの続き。

:著者: Eric Gamma/Richard Helm/Ralph Johnson/John Vlissides
:監訳者: 本位田真一 吉田和樹
:出版社: ソフトバンク クリエイティブ株式会社
:ISBN: ISBN4-7973-1112-6

.. contents:: ノート目次

第 3 章 生成に関するパターン
======================================================================
* <クラス継承よりもオブジェクトコンポジションに頼る形でシステムを発展させていく場合に、
  生成に関するパターンは重要になる> (p. 89)

* ``MazeGame::CreateMaze`` についての考察が数ページ続くが、
  高密度な記述ゆえに上手い形にノートにまとめられない。

  * 2 つの部屋からなる簡単な迷路を作っているだけなのに、コードが複雑 (p. 92)
  * 迷路構成を変更しようとすると、メンバ関数のオーバーライド（実質再定義）か、
    それと同等の仕事が必要となる (p. 92)

* <より柔軟な設計（必ずしも、コードを短くするわけではない）> (p. 93)
  このカッコ内がポイント。

* <インスタンス化されるクラスがコード中に直接書かれていることが最大の問題> (p. 93)

Abstract Factory
----------------------------------------------------------------------
* Motif とか Presentation Manager とかって何？
* <各種の基本ウィジェットを生成するためのインタフェースを宣言した抽象クラス
  WidgetFactory を定義する> (p. 95)
* 各種のウィジェットに対する抽象クラスを作成したら、
  <その具象クラスで特定の look-and-feel 規格のもとでの実装を与える> (p. 95)
* <たとえば Motif ではスクロールバーはボタンやテキストエディタとともに
  使わなければならないといった制約が、MotifWidgetFactory クラスを利用する結果として
  自動的に規定されることになる> (p. 96)

* このパターンでは Client は AbstractFactory と AbstractProduct で宣言された
  インタフェースのみを利用する (p. 97)
* <普通、ConcreteFactory クラスのインスタンスは実行時に生成される> (p. 97)
  とあるが、実行時に生成されないインスタンスなど考えられる？

* 新たな種類の部品への対応は AbstractFactory とそのすべてのサブクラスについて、
  インタフェースの修正が必要となる。これが面倒。

* 部品を実際に生成するのは ConcreteProduct クラスになるが、
  各部品について factory method を定義する方法がよく用いられる (p. 98)

* Prototype パターンを使って ConcreteFactory クラスを実装する方法がある。
  部品の集合が多数存在する場合にそうすることができる (p. 98)

* <クラスをオブジェクトとして扱うことのできる言語では、
  prototype を用いたアプローチに変化をつけることが可能になる> (p. 99)

* 生成する部品の種類を表すパラメータを取る AbstractFactory の手法は、
  <C++ を使うときには、すべてのオブジェクトが同じ抽象基底クラスを持つ場合か、
  要求を出すクライアントにより部品オブジェクトが正しい型に変換できる場合にのみ、
  適用することができる> (p. 100)

  この条件はそんなにきつくない。
  <サブクラスに特有のオペレーション> (p. 100) をする必要がない場合は、
  この手法の採用の検討に値する。

サンプルコードで ``MazeGame::CreateMaze`` を Abstract Factory パターンで実装している。

* <``MazeFactory`` クラスは、単に factory method を集めたものになっているが、
  これは Abstract Factory パターンを実装するときにもっとも一般的な方法である> (p. 102)
* AbstractFactory が ConcreteFactory を兼ねるのも一般的な実装方法 (p. 102)

Builder
----------------------------------------------------------------------
* 同じ作成過程で異なる表現形式の複合オブジェクトを生成できる (p. 105)

* <変換すべきフォーマットのすべてを事前に確定できるとは限らないので、
  読み取り部を修正することなく、新たに与えられたフォーマットへの変換が
  容易に行えるようにしておくことが望ましい> (p. 105)

* <RTFReader オブジェクトが RTF の文書の構文解析を行い、
  その結果を TextConverter オブジェクトを使って変換する> (p. 105)

  「何に」変換するかはまだ言及していないことに注意。

* この各変換クラスを **builder** と呼び、読み取り部のクラスを **director** と呼ぶ (p. 106)
* <RTFReader クラスの構文解析アルゴリズムは再利用することができる> (p. 106)

* オブジェクトの作成プロセスが、多様な表現を認めるようにしておける (p. 106)

* 当パターンのクラス構造を見ると、Director が Builder を持っている。
  面白いのは ``Director`` が ``Builder::BuildPart`` メソッドしか利用していないこと。

  * ConcreteBuilder は <Product オブジェクトを取り出すためのインターフェイスを提供する> (p. 107)
  * Product クラスは <多くの構成要素からなる複合オブジェクト> (p. 107) である。

このパターンはトレード・オフがないのか。

* <別の Director オブジェクトが同じ構成要素からなる Product オブジェクトを作成する場合に、
  それを再利用することができるようになる> (p. 108)

  各 ConcreteBuilder がそのまま（変更せずに）再利用できると強調している。

* <生成要求の結果を、それまでに得られている Product
  オブジェクトに単純に追加していくだけのモデルで十分な場合が多い> (p. 109)

* <異なる Product オブジェクトに共通の親クラスを作るメリットは少ない> (p. 109)

  なるほど。

サンプルコードでは、MazeGame の例を Builder パターンを導入して書き直している。

* MazeBuilder クラスにメソッド群 BuildXXXX を定義するメリットは、
  各 Product (Room, Door) の生成ロジックを隠蔽することにある。
  <異なる種類の迷路を作成する場合に MazeBuilder クラスを再利用できることを意味している> (p. 110)

* <MazeBuilder クラスは迷路そのものを作るのではなく、
  迷路作成のためのインターフェイスを定義しているにすぎない> (p. 110)

* <しかし、Maze クラスを小さくしておくことで理解や修正が容易になるという利点があり、
  また、StandardMazeBuilder クラスは Maze クラスから容易に分離することもできる。
  もっと重要なことは、この 2 つを分離しておくことにより、
  部屋、壁、ドアに対して、異なるクラスを使ってさまざまな
  MazeBuilder クラスを作れるようになるという点である> (p. 112)

* Abstract Factory パターンは <複合オブジェクトを作成するという点で Builder パターンに類似している> (p. 114)

Factory Method
----------------------------------------------------------------------
フレームワーク寄りのデザインパターンらしい。

* フレームワークにしばしば見られる特徴 (p. 115):

  * オブジェクト間の関係を表現するのに、抽象クラスを用いる。
  * （具象型のわからない）オブジェクトの生成を行う責任がある。

* フレームワークの立場としては、<Application クラスは Document
  のどのサブクラスがインスタンス化されるのかを事前に知ることはできない> (p. 115)
  ので、Application クラスに Document を生成するオーバーライド可能な
  メソッド CreateDocument を用意し、ユーザーにサブクラス型を返すような実装をさせる。
  
  この CreateDocument みたいなものを一般に factory method と呼ぶ。

* <クラス内部でオブジェクトを生成する場合、
  直接生成するよりも factory method を使うほうが柔軟性を高める> (p. 117)

* 図形操作ツールの話 (pp. 118-119) が面白かったので、後でもう一回読んでみる。
  Figure インタフェースに CreateManipulator (factory method) を与えておき、
  各 Figure のサブクラスがそれに応じた Manipulator のサブクラスを生成する、
  というトリック。

* Creator クラスを抽象クラスにして、factory method を空にする場合と、
  Creator クラスを具象クラスにして、factory method にデフォルト実装を与える場合がある
  (p. 118)

* Factory Method パターンの変形として、<factory method が数種類の
  ConcreteProduct オブジェクトを生成できるようにしておく> (p. 119) ものがある。
  種類を表すパラメータを取るようなメソッドにするらしい。

  * この手法はシリアライズ実装で使うというようなことが書かれている。

* 言語によっては <インスタンス化されるクラスを返すメソッド> (p. 120) を使う。
  オブジェクトではなく、クラス自体を返すということ。

* C++ では Creator クラスのコンストラクタ内で factory method を呼び出せない (p. 121)

  そんなことをしたら実行時エラーが起こって即終了。

* C++ ではさらに <テンプレートを用いてサブクラス化を避ける> (p. 121) 技法も駆使したい。
* factory method には、見てそれとわかる名前を付けると便利 (p. 122)

サンプルコードでは ``MazeGame::CreateMaze`` を factory method で実装している。

* <factory method は、ツールキットやフレームワークの中で広く採用されている> (p. 124)
* Abstract Factory パターンは factory method を使って実装されることが多い (p. 125)

Prototype
----------------------------------------------------------------------
既存インスタンスをコピーすることで新たなオブジェクトの生成を行うパターン。

* 「動機」に書いてあること

  * Graphics: 音符、休止符、譜表、等々の図形オブジェクトを表現するための抽象クラス
  * Tool: ツールパレット上のツールを定義するための抽象クラス
  * GraphicTool: Graphics をドキュメントに追加するための Tool のサブクラス

  * <GraphicTool クラスは、音符などのクラスのインスタンスを楽譜に加えるために
    どのように生成したらよいのかを知らない> (p. 127)
  * <Graphic のサブクラスのインスタンスをクローン化して、
    新たなオブジェクトを生成する方法> (p. 127) によって得られるインスタンスのことを
    **prototype** と呼ぶ。

* <Prototype パターンは、Client オブジェクトに対してインスタンス化する具象クラスを隠蔽している> (p. 129)

* <たとえば回路設計エディタでは、回路をいくつかの部分回路から作成するようになっている> (p. 130)

  つまり、部分回路が繰り返し使われる状況である可能性が高く、
  そうなれば当パターンの守備範囲だ。

* <C++ のようにクラスが first-class オブジェクトとして扱われない言語> (p. 130)
  にとっては、Creator のクラス階層を作らずに済む当パターンにメリットがある。

* <prototype マネージャ> (p. 130)

* <その内部に複製をサポートしていないオブジェクトや
  循環する参照を持つオブジェクトを含む場合> (p. 131) 等、
  prototype 各サブクラスで ``Clone`` を実装するのが困難な場合もある。

実装ポイント

* Prototype パターンは C++ のような静的な言語において有効なパターンである (p. 131)
* <Client オブジェクトは prototype を直接扱うのではなく、
  登録されている prototype オブジェクトを検索したり、
  新たに登録したりする> (p. 131)

  prototype マネージャは連想配列ベースのデータ構造。

* <もっとも困難な点は、Clone オペレーションを正しく実装することである> (p. 131)

  * <複製を行うということを、元のインスタンス変数を共有させることにするのか、
    またはインスタンス変数の複製を行うことにするのか> (p. 131)

  * お手軽な Clone の実装例として、もしオブジェクトが Save/Load
    オペレーションを提供しているのであれば、これで実装できると言っている (p. 132)

サンプルコードのページでは MazeFactory の Prototype パターン版を紹介。

* MazePrototypeFactory では
  <生成オブジェクトをあらかじめ prototype として持つように初期化> (p. 132) する。

  * ``MazePrototypeFactory::MakeXXXX`` では XXXX 型メンバーデータの
    prototype に対して ``Clone`` を呼び出し、戻り値をそのまま返す。

    * 場合によっては clone のパラメータを修正する。

  * <他の迷路を作成する場合には、MazePrototypeFactory オブジェクトを別の
    prototype で初期化すればよい> (p. 133)

* <Client オブジェクトの側では、Clone オペレーションの返却値を
  望む型にダウンキャストしなくてもよいようにしておくべきである> (p. 135)

Singleton
----------------------------------------------------------------------
ここは読まなくていいや。

まとめ
----------------------------------------------------------------------
* オブジェクトを生成するクラスをサブクラス化する方法

  * Factory Method パターンを使うことに対応。

* 生成するオブジェクトのクラスを把握しているオブジェクトを定義してから、
  それをパラメータにする方法

  * Abstract Factory, Builder, Prototype パターンの基本。
    設計は柔軟だが、より複雑 (p. 146)

* 図形エディタフレームワークを設計するのならば、
  Factory Method パターンがもっとも使いやすいパターン (p. 145)
  だが、GraphicTool のサブクラスが多く必要になる。

* <全般的に見て、Prototype パターンが図形エディタフレームワークにとって、
  おそらく最適なパターンになるだろう> (p. 146)
  ``Graphic::Clone`` のオーバーライドだけでよいから。

* <Factory Method パターンを使うことで、
  設計はカスタマイズが容易になると同時に若干複雑になる> (p. 146)

* 設計の初期段階では Factory Method パターンを採用しておき、
  様子を見て他のパターンに発展させていくやり方がよい (p. 146)

どの方法も複雑であると言っている？

第 4 章 構造に関するパターン
======================================================================
* <クラスやオブジェクトを合成する方法に関係している> (p. 147)
  なるほど。構造イコール合成なのか。

* 構造に関するパターンも、「オブジェクトに適用するもの」と
  「クラスに適用するもの」がある。
  前者が動的で後者が静的な性質のものだということなのだろう。

Adapter
----------------------------------------------------------------------
このセクションは他のパターンのそれに比べて妙に長く感じた。

* <再利用を目的として設計されたツールキットクラスは、
  そのインタフェースがアプリケーションの要求するドメインに特化した
  インタフェースと一致しないというだけの理由で、
  再利用できないことがある> (p. 149) もったいない話だ。

既存のツールキットクラス TextView をうまく再利用して、
LineShape や PolygonShape のテキスト版と言える
TextShape というクラスを定義できないかを議論している。

* <それに対して、テキストの表示と編集を行う TextShape クラスは、
  基本的なテキスト編集の歳にも、複雑な画面の更新やバッファの管理などを
  しなければならないため、実装はより困難であると考えられる> (p. 149)

* <しかし TextView クラスを変更するのは勧められない。
  なぜならば、このツールキットが、ある 1 つのアプリケーションを動作させるため
  だけに、ドメインに特化したインタフェースを採用したとすると、
  このツールキット自体が汎用性を欠くものになってしまうからである> (p. 149)

* ここでやりたいことは TextView を Shape に適合させること。

  * 方法 1: Shape のインタフェースと TextView の実装を継承したクラスを定義する。
  * 方法 2: TextView を持ったクラスを定義し、それは Shape インタフェースを有する。

  →クラスに適用する Adapter と、オブジェクトに適用するパターン (p. 152)
  があるということ。

* <Shape のどのオブジェクトも、ユーザがインタラクティブにドラッグして
  別の場所に移すことができるようになっているべきである。
  ところが、TextView クラスは、それができるように設計されていない> (p. 150)

考慮すべき問題点を挙げている。

* 何らかのインタフェースに一致させる作業が必要になるが、
  <作業の範囲は、オペレーションの名前を変えるだけの簡単なインタフェースの変更から、
  まったく異なるオペレーションの集合をサポートすることまでが考えられる> (p. 152)

* <インタフェースの適合機能が作りこまれているクラスを
  **pluggable adapter** と呼んでいる> (p. 153) の例として、
  TreeDisplay を紹介している。

  * 異なる木構造は異なるインタフェースを持つことになるだろう。
  * 言い換えると、TreeDisplay ウィジェットはインタフェース適合機能
    を内部に組み込むべきなのである。

実装にも問題点が色々。

* C++ の場合、クラスに適合するタイプの Adapter では、
  Adaptee 側クラスを private 継承する。ということは、
  Adapter クラスは Adaptee クラスのサブクラスではなくなる (p. 154)

* 適合させなければならない最小限のオペレーションの集合を意識すること
  (p. 154)

サンプルコード。
<オブジェクトを基にした adapter の方が、
コードの作成では若干の労力が必要になるが、
より柔軟なものになっている> (p. 159) 
ポイントは、TextView のサブクラスでも OK だというところ。

関連パターン。
<アプリケーションにとっては、adapter よりも decorator の方が透過性が高い> (p. 161)

Bridge
----------------------------------------------------------------------
後回し。

Composite
----------------------------------------------------------------------
* <オブジェクトを木構造に組み立てる> (p. 175)
* <個々のオブジェクトとオブジェクトを合成したものを一様に扱うことができる> (p. 175)
* <Composite パターンの特徴は、1 つの抽象クラスがプリミティブとコンテナの両方を表すことである> (p. 175)

* プリミティブの意味がよくわからんが、
  <プリミティブなオブジェクトは子を持たないため、
  子オブジェクトに関するオペレーションは実装しない> (p. 176)

* <Draw オペレーションをその子オブジェクトの Draw オペレーションを呼び出すように実装し、
  またそれ以外にも、子オブジェクトに関連するオペレーションを実装する> (p. 176)
* <Picture オブジェクトは別の Picture オブジェクトを再帰的に生成していくことができる> (p. 176)

* Component クラスにおいて、親にあたる composite にアクセスする
  インタフェースを宣言するのはオプション (p. 177)

* ある要求を composite が受け取ったとき、
  <通常、その要求を子にあたる component に転送し、
  さらに転送の前後に付加的なオペレーションを実行することもある> (p. 177)

実装のセクションにある記述が濃い。

* 親オブジェクトへの参照を持たせる場合、composite 構造の走査や管理が簡単になるが、
  「ある composite のすべての子オブジェクトは、その親オブジェクトとしてそれを持つ」
  という制約を壊さないように注意しないといけない (p. 178)

* <Component クラスでサポートされているが、
  Leaf クラスには無意味なオペレーションも多く存在する> (p. 179)

* Add/Remove オペレーションをどのクラスで宣言するかは重要な問題。
  この議論に 2 ページ近くを割いている。
  普通は安全性を捨てて、透過性をとる方向に解決するのだろう。

* 多くの設計では、<子オブジェクトの順番を明確にする> (p. 182)

* <composite に、自身が削除されるときにその子オブジェクトの削除も
  一緒に行わせるようにするのが、通常ではもっとも良い> (p. 182)
  が、子オブジェクトが共有されているような場合は話は別だ。

Decorator
----------------------------------------------------------------------
<サブクラス化よりも柔軟な機能拡張方法> (p. 187) を動的に行えるようだ。

* <クラス全体に対してではなく、個々のオブジェクトに責任を追加したくなることがある> (p. 187)
* いつぞやのスクロールバー付き枠付き TextView の例を持ちだしている。

  * <常にスクロールバーが必要とは限らない>
  * <必要になったときには ScrollDecorator オブジェクトを用いてスクロールバーを追加する> (p. 188)

Decorator クラスの構造は、

* <component または decorator への参照を保持する>
* <Component クラスのインタフェースと一致したインタフェースを定義する> (p. 189)

の二点。

* <Decorator パターンを用いると、decorator を付けたりはずしたりして、
  実行時に簡単に責任の追加や削除ができる> (p. 190) 
  
  個人的には削除の例は見たことがない。

* <1 つの単純なクラスを定義し、decorator を用いて機能を段階的に追加していく> (p. 190)
* Component クラスを軽く保つことが重要。メンバーデータは極力サブクラスに持たせる (p. 191)
* <Component クラスが本質的に重く、
  そのため Decorator パターンを適用するにはコストがかかりすぎるような状況では
  Strategy パターンを選択する方がよい> (p. 191)

サンプルコード。コンストラクタの呼び出し方にインパクトあり。

.. code-block:: c++

   // p. 194
   window->SetContents(
       new BorderDecorator(
           new ScrollDecorator(textView, 1)
       )
   );

使用例。

* <ストリームはほとんどの I/O 機構に存在する基本的な抽象概念である> (p. 195)
* decorator は adapter とは異なる。
  責任を変えるだけで、インタフェースまでは変えない (p. 196)
* オブジェクトを変化させる方法には、decorator と strategy の 2 通りが考えられる (p. 196)

Facade
----------------------------------------------------------------------
後回し。

Flyweight
----------------------------------------------------------------------
後回し。

Proxy
----------------------------------------------------------------------
後回し。

まとめ
----------------------------------------------------------------------
Composite, Decorator, Proxy の比較 (p. 234) が面白かった。

* Decorator は退化した Composite ではない。

  * 両者は目的が異なっている。
  * ということは、相補的に利用できる。

* Decorator も Proxy も、クライアントに合成前のインタフェースと同じものを与えるが、
  Proxy に関しては

  * 特性を動的に加えたりはずしたりしない。
  * 再帰的な合成のために設計されていない。

----

:doc:`gamma95-note3` へ。
