======================================================================
クラス ``docutils.nodes.Node``
======================================================================
Docutils_ では reStructuredText 形式のデータを処理するために、
中間形式として木構造のオブジェクト群を組み立てる。
この木のオブジェクトの型を定義する一連のクラスは ``Node`` というスーパークラスを継承の始点とする。
これらのスーパークラスとサブクラスは全てモジュール ``docutils.nodes`` で定義されている。
本節ではデータ構造を中心に、ノード群の設計を解読していく。
ただし、各具象ノードの構造までは深く立ち入らないで、別の節で検討したい。
例えばノードオブジェクトの処理方法については、次節 :doc:`./visitor` で解読していく。

.. contents:: ノート目次

クラス図
======================================================================
まずは抽象クラス ``Node`` を継承グラフの始点とする簡単なクラス図を示す。
ただし、本来は具象クラスが 98 個もあるにもかかわらず、
一枚の図に全てを掲載することは紙幅の都合上避ける。
また、理解し易さを優先するべく、説明の目的とは外れた関係、属性の記載を省略している。

.. figure:: /_static/docutils-nodes.png
   :align: center
   :alt: (class diagram)
   :scale: 100%

* クラス名が普通なもの (CamelCase) は抽象クラスまたは補助クラス。
* クラス名が小文字ベースなもの (snake_case) は対応する名前の XML 要素的なものにマッチする。
* ノードの位置は抽象クラスにより表現される？
* 全ての具象ノードクラスの名前はリストオブジェクト ``doutils.nodes.node_class_names`` で確認可能。
  クラス ``NodeVisitor`` の宣言直前に書いてある。

クラス ``Node``
======================================================================
クラス ``Node`` はドキュメントツリーの全ノードクラスの抽象クラスだ。

メンバーデータ
----------------------------------------------------------------------
これらはクラススコープで宣言されているが、実際はむしろオブジェクトデータとして参照されるもよう。

``Node.parent``
  このノードを直下に含むノードへの参照。
  メソッド ``setup_child`` を見ると、実体はノードオブジェクトらしい。

``Node.document``
  このノードの所属するドキュメントツリーのルートノードということだ。
  実体はクラス ``document`` のオブジェクトだ。

``Node.source``
  このノードを生成した入力元のファイルパスまたは説明文を示す文字列。

``Node.line``
  このノードに対応する文字列の開始位置が ``source`` の何行目にあるかを示す正の整数。

メンバーメソッド
----------------------------------------------------------------------
``__bool__(self)``
  ノードオブジェクトを if 文に置いた時に真を返すようにしたいので、これがある。
  メソッド ``traverse`` を見ればわかる。

``copy(self)``, ``deepcopy(self)``
  オーバーライド専用メソッド。
  デフォルトの実装はいつもの ``raise NotImplementedError`` だ。

  * ``copy`` をオーバーライドするのはサブクラス ``Text``, ``Element``, ``document``, ``pending`` だけ。
  * ``deepcopy`` をオーバーライドするのはサブクラス ``Text``, ``Element`` だけ。

``walk(self, visitor)``, ``walkabout(self, visitor)``
  これらは :doc:`./visitor` で解説する。

``traverse(self, condition=None, include_self=True, descend=True, siblings=False, ascend=False)``
  このノードツリーに対して、
  引数で指示したようなノードオブジェクトを含むリストオブジェクトを返す。
  キーワード引数の意味は、型が ``bool`` なものはその名前の示すとおり。

  * ``condition`` が特殊。
    述語関数を渡す場合と、ノードのサブクラスを型として渡す場合がある。
    いずれにせよ、このメソッドは ``condition(n)`` が真となるノード ``n`` をかき集める。

``next_node(self, condition=None, include_self=False, descend=True, siblings=False, ascend=False)``
  ``self.traverse(...)[0]`` または ``None`` を返す。

  * ``include_self=False`` がデフォルト値なので注意。

サブクラス
======================================================================
* 差し当たり ``Text``, ``Element``, ``document`` が Docutils の設計を読み解くのに特に重要なサブクラスだろう。

  * クラス ``Text`` はノードツリーの末端オブジェクトになる。
    子ノードも属性も存在しない。オブジェクトのコピーが可能。

  * クラス ``Element`` がノードツリーのオブジェクトの基本機能、
    子ノードと属性値へのアクセスのためのインターフェイスを提供する。
    オブジェクトのコピーが可能。

    このクラスそれ自体もいずれ解読したい。

  * クラス ``document`` はドキュメントツリーのルートノードのための型だ。

    これは解読するなら別ページにしたい。

* クラス ``Element`` の下には大量のサブクラスが存在するが、
  インターフェイスが新規に追加されていることはほぼない。
  代わりに Visitor がその辺を賄うという設計だ。

* 一般に、ノードオブジェクトを生成するのはクラス ``State`` のサブクラスのそれぞれのメソッドとなる。
  入力の reStructuredText データを一行一行構文解析すると同時に、
  順次オブジェクトを生成する。

  例えば ``doctest_block`` オブジェクトを生成するのは、
  クラス ``docutils.parsers.rst.states.Body`` のメソッド ``doctest`` による。
  生成したオブジェクトをメンバーデータであるオブジェクト ``parent`` に収納する。

.. todo:: 大量にある具象ノードクラスの宣言を考察する。

感想
======================================================================
* 文字列 ``line`` を grep するのがたいへん難しい。
* メソッド ``Node.traverse`` 系は generator にできるだろうか。
* クラス ``Element`` における演算子のオーバーロードは注意したい。
  もしかすると ``+= x`` で「要素 ``x`` を子要素とする」の意味があるかもしれない。

.. include:: /_include/python-refs-core.txt
