======================================================================
Python 入門［２＆３対応］読書ノート 3/3
======================================================================

.. include:: /_include/book-details/hosoda10.txt

.. contents:: ノート目次

第 16 章 日時の操作
===================================
16.1 datetime クラス
-----------------------------------
* ``now`` メソッドはクラスメソッド。
* ``weekday`` メソッドの戻り値は、0 が月曜日なので注意。

* ``timedelta`` クラスで加算や減算を行う例がある (p. 276) が、
  ありがたいことに乗算もできる。

  >>> print(datetime.timedelta(seconds=38) * 20)  # 38 秒の 20 倍はいくらだ？
  0:12:40

* ``strftime`` メソッドで、日時を書式化した文字列を得られる。
  書式の仕様を見ると ANSI C のそれの簡略版みたい。

16.2 date クラス
-----------------------------------
* <``datetime`` クラスは ``date`` クラスのサブクラス> (p. 280)
* <現在日付の取得には ``now`` 関数ではなく ``today`` 関数を使います> (p. 281)
* ``datetime`` オブジェクトと ``date`` オブジェクトの比較・変換が面倒みたい。

16.3 dateutils モジュール
-----------------------------------
* ``easy_install dateutils`` でインストールできるモジュール。
* 名前については、コードでは ``import dateutil`` のように末尾に s がつかないのが正。
* ``dateutil.relativedelta`` クラスを使った加算処理、月始・月末の取得。
* ``dateutil.parser.parse`` 関数による「特定規格の日付文字列」の解析。

第 17 章 正規表現
===================================
ページ数をもっと割いて解説してもよかったのでは。

17.1 re モジュールの基本
-----------------------------------
* ``match`` と ``search`` の違いが文書化されているようなので、後で見ておく。
* <Unicode 表と厳密に対応させたい場合は ``\uXXXX`` の表記を用いる> (p. 292)

  >>> import re
  >>> re.compile(u'[\u3041-\u3093]')   # 同ページより。ひらがな全て。

* 部分一致の説明にある例コードのおかげで ``groupdict`` メソッドの意義がわかった。

* <``escape`` メソッドは、全てのメタ文字をエスケープした文字列を返します> (p. 295)
* 先読み、後読みの概念がわからないので、勉強する。

17.2 便利なテクニック
-----------------------------------
* Wikipedia の Unicode 表が便利らしい。
* ``re.U`` による全角文字マッチオプション有効化が便利らしい。

第 18 章 データのやり取り
===================================
18.3 XML データの利用
-----------------------------------
* ``lxml`` モジュールを紹介している。
  ネットに接続している環境では ``easy_install lxml`` で楽にインストールできる。

  * XML を探索・編集することができる。
  * うれしいことに XPath が使える。

    >>> # p. 310 より
    >>> from lxml import etree
    >>> xml = '<root><node key="value"><node>leaf</node></node></root>'
    >>> root = etree.fromstring(xml)
    >>> nodes = root.xpath('//node/node')
    >>> for node in nodes: print(etree.tostring(node))
    ... 
    <node>leaf</node>

18.4 CSV データの読み書き
-----------------------------------
これは実践しようと思っていて、まだ現場で試せていないモジュールだ。

* <Python の CSV の操作には、 ``csv`` モジュールを使用します> (p. 312)
* ``csv.reader`` にファイルハンドラを渡して for ループで回す。
  <``dialect`` 引数のデフォルト値は ``csv.excel`` となっています> (p. 313)
* CSV ファイルへの書き込みには ``csv.writer`` 関数を利用する。

18.5 データベースの利用
-----------------------------------
Python が標準で提供している ``sqlite3`` モジュールと、
MySQL と接続するための ``MySQLdb`` モジュールの説明。

MySQL 5.1 をインストールしてあると、MySQLdb の配布版がまだ対応していなかったのか、通らなかった。
それでソースコードを入手して、若干コンフィグファイル的なものを修正してから
setup を試みたが、vcvarsall.bat が見つかりませんとかいうエラーで詰んだ。
VC がインストールされていない環境では駄目か。

第 19 章 ウェブの基本ツール
===================================
HTTP, SMTP, CGI ネタだが、当環境がネットから孤立しているためコードを試せず習得を断念。

第 20 章 メディアファイルの作成
===================================
20.1 画像の作成
-----------------------------------
PIL を紹介している。ImageMagick みたいなことをしてくれるライブラリー。
個人的には PyOpenGL でテクスチャーイメージをメモリに読み込むときに利用する。

* easy_install でのインストールと、ソースからのインストールとではモジュール配置が異なる。 (p. 340)
* <PIL の ``save`` メソッドは、末尾の拡張子から、自動的にフォーマットを判定して変換します> (p. 341)
* <画像フォーマットを GIF から JPEG に変換する場合には、カラーモードを RGB に変更しておく必要があります>
  (p. 342) GIF のカラーモードがパレットモードというものであることによる。

* 画像のリサイズで、比率を維持する場合は ``thumbnail`` メソッドを使用する。(p. 344)

20.2 PDF の作成
-----------------------------------
ReportLab を紹介している。

* ネットに接続して ``easy_install reportlab`` でインストールできる。
* 基本的に Python のコード一丁で PDF を生成する。面倒くさい。

  .. code-block:: python

     from reportlab import canvas

     canvas = canvas.Canvas('helloworld.pdf')
     ... canvas に色々施す。
     canvas.save()

* <組み込みの日本語フォント> (p. 355)
* テンプレート機能もあるようだ。でも面倒くさい。
* PIL がインストール済みならば、画像も配置できる。

第 21 章 ウェブフレームワーク
===================================
この手のフレームワークは個人的になじみのない分野なので、勉強になる。

21.1 - 21.5 Django
-----------------------------------
* <Python で代表的に利用されているウェブフレームワーク> (p. 362)
* ネットに接続していれば ``easy_install django`` でインストールできる。
  本書ではバージョン 1.1.1 を解説しているが、1.2.3 をインストールした。

* ``django-admin.py`` でプロジェクト作成、
  生成された ``manage.py`` でアプリを作成したり、開発サーバーを起動したりする。

* ``settings.py``, ``urls.py``, ``views.py``
* HTML テンプレート
* 管理画面
* モデルフィールド

21.6 - 21.13 Web2py
-----------------------------------
こちらはまだノートを取れるほど動かしていないが、

* 単なるパッケージではなさそうだ。
* Python 2.6 用がない？
* Google App Engine なるものが気になる。
  <Google 社が管理するデータセンターの上で、ウェブサービスを展開できるプラットフォーム> (p. 410)
  だそうだ。

第 22 章 バッチ処理の基本ツール
===================================
22.1 コマンドラインオプションの解釈
-----------------------------------
個人的には ``OptionParser`` 派なので読み飛ばす。

22.2 ログを出力する
-----------------------------------
まったく馴染みのない機能だったが、知ってみると便利。

* <``logging`` モジュールの ``getLogger`` 関数でロギング・オブジェクトを生成します> (p. 419)
* ``addHandler`` というメソッドがあるところを見ると、ログ出力先は複数存在できるようだ。
* メソッド名を見ると、Java 由来のモジュールなのではないかと思っていたら、やはりそうらしい。

* <ログの出力時には、ロギング・オブジェクトの各エラーレベルの出力メソッドを呼び出します> (p. 421)
  出力関数がログの重要度によって異なるというわけだ。

* ``setFormatter`` で出力書式を設定できる。この書式仕様はいかにも Python らしいもので安心。

* ``basicConfig`` 関数で ``getLogger`` の戻り値に対する共通設定を定義するという設計は乙だ。

22.3 管理タスクの実行
-----------------------------------
``fabric`` という非標準ライブラリーを紹介している。
本書では ``easy_install fabric`` でインストールできるとあるが、
細かいことは忘れてしまったが Windows 環境にインストールすることができなかった。

第 23 章 GUI アプリケーション
===================================
23.1 デスクトップアプリを作る
-----------------------------------
* <本格的なアプリを作成したい場合は、wxPython や PyQt, 
  PyGTK などのサードパーティ製ライブラリを利用した方がよいでしょう> (p. 434)

* 本書では PyQt を紹介する。Qt を Python でラップしたもの。
  <Qt 自身は Google Earth や Mathematica, Skype など、幅広く利用されています> (p. 434)

* これはインストーラーが用意されているので、それを利用するべし。

* ちょっと気づきにくいが、p. 442 の描画コード、インデントが足りていない。

* 最後に PyQt のアプリを PyInstaller なるものを利用して exe ファイル化するやり方を紹介している。
  が、これ Python 2.6+ ではダメだった。
  総本山サイトで調べると「開発版 trunk のソースコードなら何とかなるよ」みたいなことが書いてあったので、
  ソースを入手して色々やったが、ここでも VC の壁が立ちふさがった記憶がある。

23.2 Android
-----------------------------------
すごい。何が書かれているのかまるで理解できなかった。

* あることをすれば、Android でも Python スクリプトの実行が可能になる。
* Android SDK なるものをインストールしておくといいらしい。
  文章の感じからすると、インターネットに接続している必要があるようだ。
* Android Virtual Device
* USB デバッグ。
* 実機と PC を USB で接続する。
* 最後のページに API でどういうことができるのかがリストされている。

第 24 章 プログラムの調査
===================================
24.1 オブジェクトの属性を調査
-----------------------------------
* ``inspect`` モジュール。
  <関数の引数に関する情報を調査するには、
  ``inspect`` モジュールの ``getargspec`` 関数を用います> (p. 455)

24.2 対話型デバッグツール
-----------------------------------
``pdb`` モジュールの関数でブレークポイントを設定したり、変数ウォッチができたりする。

* ``set_trace`` 関数が呼び出されると対話型デバッグに突入する。
  <すると ``(Pdb)`` と書かれたプロンプトが現れるので、現在の変数の状態を確認できます> (p. 457)

24.3 実行時間を調べる
-----------------------------------
``profile`` モジュールについて説明。

* <特別な理由がない限り ``cProfile`` を使うといいでしょう> (p. 458)
* <計測したい処理内容を文字列として渡します> (p. 458)

  >>> profile.run('loop(bench1)')

* スクリプト全体のプロファイルを取るには、インタープリターの ``-m`` オプションを使う。
  ``profile`` 自体もオプションを取るので、色々試すといい。
  ::

    $ python -m cProfile list_bench.py
    $ python -m cProfile -s list_bench.py

* PyScripter のツールメニュー下にある Profile は、このモジュールを利用しているのだろう。

第 25 章 開発支援フレームワーク
===================================
<近年のプログラム開発では、ユニットテストとドキュメンテーションの重要性が認識されています> (p. 469)

25.1 ユニットテスト
-----------------------------------
* <テストコードを全てクラス内に書かなければいけません> (p. 472)
* 囲み記事が紹介しているサードパーティー製のライブラリーのうち、
  nose は持っているが、py.test は使ったことすらない。
* サンプルコード (p. 473) の ``__contains__`` と ``__getitem__`` のやり方を覚えよう。

25.2 ドキュメンテーション
-----------------------------------
* Sphinx は依存ライブラリーが多い。
  ``easy_install sphinx`` が使えないとインストールは厳しい。
  あらかじめ依存パッケージを調査して、そのすべての egg を確保しておくというやり方でいくか。

* 色々とマークアップ？の紹介をしているが、
  公式サイトの配布する Sphinx Documentation を確保しておくと重宝する。
* ``toctree`` の使用例 (p. 478) はインデントがそろっていない。
* ``code-block`` の使用例 (pp. 479-480) は PHP の閉じタグがない。

* <autodoc という sphinx の拡張モジュールを用いれば、
  ソースコードから自動で同様のドキュメントを生成することができます> (p. 482)
  いつか試す。

第 26 章 関数型プログラミング
===================================
26.1 関数型プログラミングの基本
-----------------------------------
* ``map`` 関数は C++ の ``std::transform`` 関数のようなものらしい。
* ``zip`` 関数は多言語では for ループ等で複数のコンテナーを同時に走査するような場合に使うものらしい。

  >>> map(None, ['A', 'B', 'C'], ['a', 'b', 'c'])
  [('A', 'a'), ('B', 'b'), ('C', 'c')]

* ``filter`` 関数だが、これは内包表現で代用できるのではないか。
  サンプルコード (p. 490) は、確かに ``filter`` を利用する方が簡便な表記になる。

* ``reduce`` 関数は C++ の ``std::accumulate`` 関数に相当するものらしい。
* ``reduce`` の利用を考える前に、既にある ``max``, ``min``, ``sum`` が利用できないか検討する。
* C++ の ``std::multiply<T>`` みたいなものが Python では ``operator`` モジュールにある。

26.2 イテレータ・ツール
-----------------------------------
* <Python 3 でリストからイテレータを返すようになった組み込み関数 ``map``,
  ``filter``, ``zip`` は、Python 2 系におけるこのモジュールの ``imap``,
  ``ifilter``, ``izip`` 関数が組み込み関数へと昇格したものです> (p. 492)
  なので、3 では i を付けなくて済む。

* ``itertools.islice`` 関数で SQL の LIMIT 句みたいなことができる。
* ``itertools.groupby`` 関数で SQL の GROUP BY 句みたいなことができる。
  <テーブルのようなものに対して、同じキーが続く部分をまとめていきます> (p. 493)
  ただし、先にキー部分で対象範囲をソートしておく必要がある。

* ``itertools.tee`` 関数は同じ要素を指す別個のイテレータを複数個返す。
  慣れていないので応用例がすぐに思い浮かばないのがくやしい。

* ``itertools.repeat`` 関数と ``random.choice`` 関数を組み合わせる例 (p. 497) が面白い。

第 27 章 高度な計算
===================================
27.1 マルチスレッド処理
-----------------------------------
* <``Thread`` クラスの ``run`` メソッドをオーバーライドする方法を採ること>
  (p. 500) でスレッドの処理を定義する。
  ``start`` メソッドを呼び出すと、新しいスレッドが起動する。
* ``threading`` モジュールに ``Lock`` クラスがあるので、それをロックに利用する。
  pp. 502-503 のサンプルコードの構造を頭に叩き込んでおく。

  .. code-block:: python

     lock.acquire()
     try:
         # スレッドセーフにしたい処理
         ...

     finally:
         lock.release()

* 再入可能ロックなるものがある。
  <``RLock`` オブジェクトの特徴は、「ロック済みであっても同一スレッドから呼び出された場合
  ``acquire`` から即時復帰する」ことです> (p. 505)

* <スレッドの終了を待つ ``join`` メソッドも、処理の同期に有効です> (p. 506)

27.2 科学計算と可視化
-----------------------------------
* Windows の場合、SciPy/NumPy は専用インストーラーでインストールの一択。
  自力でソースコードからビルドできるとは思えない。

* ``matplotlib`` も専用インストーラーを利用すること。

  * 職場ではインストール後 ``from matplotlib import pylab`` でエラーが出た。
    何かフォントの列挙中に例外を送出するようで、そこを手でコードを修正してごまかした記憶がある。

  * 簡単な関数（特に一変数関数）グラフのイメージを作成したいぐらいでも、
    ``matplotlib`` は重宝する。さっそく仕事で機会があったので活用できた。

* フィッティングのサンプルコード (pp. 520-522) は統計の技法か。

第 28 章 国際化
===================================
GNU gettext を知らないので、そちらを学んでから再度読みなおそう。

28.1 国際化の手順
-----------------------------------
* ``babel`` モジュールをインストールする。easy_install でいける。
  URL を見ると Trac と同じところが開発しているようだ？

* 国際化対応したいコードで ``gettext`` モジュールをインポート。

  ``gettext.translation('messages', '.', languages=('ja',)).ugettext`` 等を利用する。

* 国際化対応予定コードから、翻訳ファイルを作成する必要がある。
  ``pybabel`` ツールを使って pot ファイルを作成する。

  ``pybabel extract -o POTFILE DIR`` のようにコンソールで入力。

* <翻訳対象の抽出結果をテンプレートにして、各言語の翻訳ファイルを作成し、編集します> (p. 530)

  ``pybabel init -i POTFILE -d POTDIR -l LANG`` のようにして po ファイルを作成する。

* po ファイル編集後、コンパイルして mo ファイルを作成する。

  ``pybabel compile -d PODIR -l LANG`` のようにする。

* 囲み記事に pot ファイルのアップデートのやり方が書いてある。

28.2 発展編
-----------------------------------
翻訳ファイルがない場合に翻訳対象オリジナルのまま出力させる方法と、
複数形の取り扱い方法を説明している。

感想
===================================
何と言っても量に満足した。本書は紛れもない実用書だ。
利用価値の高いモジュール・パッケージを
標準、サードパーティー製の別なく貪欲に紹介しているのがうれしい。
