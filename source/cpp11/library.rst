======================================================================
What's New In C++11 標準ライブラリー
======================================================================

このノートでは C++11 で注目すべき標準ライブラリーの機能を学習する。
すでに cpprefjp_ がそのへんをきれいに整理している。
それを利用して、読みながら急所を記していくことにする。
興味のないもの、知らなくて良いものは積極的に無視する。

.. contents::

コンテナー
======================================================================

固定長配列 ``std::array``
----------------------------------------------------------------------

* ヘッダーファイル ``<array>`` に定義がある。
* 組み込み配列で事欠かないので後回しでいい。
* ``.size()`` と ``.fill()`` が少し便利なくらいか。

単方向リンクリスト ``std::forward_list``
----------------------------------------------------------------------

* ヘッダーファイル ``forward_list`` に定義がある。
* 一言で言えば「末尾がよくわからないリスト」か。例えば ``.front()`` はあるが ``.back()`` がない。
  その他、メンバー関数の名前が ``_front`` や ``_after`` で終わるものがある。

ハッシュベースの連想コンテナー
----------------------------------------------------------------------

従来の ``std::map``, ``std::multimap``, ``std::set``, ``std::multiset`` のハッシュ実装が追加された。
これらは積極的に採用するべきだろう。

* クラステンプレート ``std::unordered_map`` は役割としては ``std::map`` と同じだ。
  違いはハッシュによる実装だということだ。

  * ヘッダーファイル ``<unordered_map>`` に定義がある。
  * インターフェイスは ``std::map`` とよく似ているので、使い方がわからないというようなことはなさそうだ。
  * デモコードの ``um["5th"]`` が 0 を返すことに注意。オブジェクトが存在しないときは、新しい要素が追加される。

* クラステンプレート ``std::unordered_multimap`` は ``std::map`` に対する ``std::multimap`` と類比的なコンテナー型だ。
  つまり、同一キーに対して複数の異なる値を格納することが許されるハッシュマップだ。

  * ヘッダーファイル ``<unordered_map>`` に定義がある。
  * インターフェイスは ``std::unordered_map`` と同様。``operator[]`` についての注意も同様。

* クラステンプレート ``std::unordered_set`` は ``std::set`` のハッシュ実装版と考えて良い。

  * ヘッダーファイル ``<unordered_set>`` に定義がある。
  * 特定の要素が含まれるかどうかのテストには ``.count()`` を用いるのは C++03 から変わりない。
    後年の仕様変更で ``.contains()`` が登場する。

* クラステンプレート ``std::unordered_multiset`` は ``std::set`` に対する ``std::multiset`` と類比的なコンテナー型だ。
  Python でいう ``collections.Counter`` のような役割を期待したい。

  * ヘッダーファイル ``<unordered_set>`` に定義がある。
  * インターフェイスは ``std::unordered_set`` と同様。

コンテナー全般がムーブセマンティクスに対応
----------------------------------------------------------------------

言語仕様で習ったように、コピー処理が省ける文法が追加された。
そこでそれをサポートするメンバー関数のオーバーロードが既存のコンテナーに追加された。

* クラステンプレートのパラメータ ``T`` はムーブ構築のみ可能な型も許される。
* ``push_back()`` や ``insert()`` 等の要素追加のためのメンバ関数が、
  一時オブジェクトも受け取れて、move で挿入することが許される。
* 要素追加のためのメンバ関数として、クラステンプレートのパラメータ ``T`` のコンストラクタ引数を受け取り、
  一時オブジェクトの生成コストを減らせるものが追加。

  * ``emplace()``
  * ``emplace_back()``
  * ``emplace_front()``

  例えば次のコードが有効であるとする。

  .. code:: c++

     commands.push_back(Command("save", false, false));

  このコードは次のように書ける：

  .. code:: c++

     commands.emplace_back("save", false, false);

初期化子リストでオブジェクトを初期化できる
----------------------------------------------------------------------

:doc:`./language` で習ったように、特に標準ライブラリーのコンテナーのオブジェクトを
次のようにしても初期化することができる（実はイコール記号も不要）：

.. code:: c++

   std::vector<int> v = {1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9};

連想コンテナーの場合には結果的に中括弧が入れ子になるだろう。

クラステンプレート ``std::initializer_list`` 追加
----------------------------------------------------------------------

* ヘッダーファイルは ``<initializer_list>`` だ。
* 初期化リストを渡したい関数の引数リストに ``initializer_list<T>`` オブジェクトを（値渡しで）受けとる。
* ``.begin()`` と ``.end()`` があるので、ループで全要素を順にアクセスすることができる。

:doc:`./language` も参照。

イテレーター
======================================================================

関数テンプレート ``std::next()`` および ``std::prev()`` 追加
----------------------------------------------------------------------

受け取ったイテレーターを指定数ぶん次へ進めた、または前へ戻したイテレーターを返す。

* どちらもヘッダーファイル ``<iterator>`` で宣言されている。
* オプショナルにいくつ進めるかを指定できる。デフォルト引数は 1 である。

  * たぶん ``it + 2`` とか ``it - 5`` というコードで間に合うと思うがどうだろう。

* C++03 に ``advance()`` というものがあるが、これとは異なって引数のイテレーターを動かさない。

クラステンプレート ``std::move_iterator`` 追加
----------------------------------------------------------------------

間接参照時に、参照先の要素を move するためのアダプターとして振る舞う。

* ヘッダーファイル ``<iterator>`` に定義されている。
* オブジェクトを生成するにはコンストラクターよりも ``make_move_iterator()`` を呼び出すのが普通。
* デモコードでは ``std::unique_ptr`` の ``std::vector`` オブジェクトを ``assign()`` している。
  この代入はコピーではなくムーブ代入となる。

関数テンプレート ``std::begin()`` および ``std::end()`` 追加
----------------------------------------------------------------------

これらの関数の意味は想像通りだ。フリー関数として提供されるというのが本質的だ。

* ヘッダーファイル ``<iterator>`` で提供されているが、これをインクルードする必要はない。
  新スタイルの ``for`` ループを成立させるためにこれらの関数テンプレートが存在する必要がある。
* 適用できるオブジェクトの型は

  * メンバー関数としての ``.begin()``, ``.end()`` を持つものか、
  * 組み込みの配列

  のどちらかとなっている。

アルゴリズム
======================================================================

TBW

メモリー管理
======================================================================

TBW

入出力
======================================================================

TBW

文字列処理
======================================================================

TBW

関数オブジェクト
======================================================================

TBW

並行プログラミング
======================================================================

TBW

ユーティリティー
======================================================================

TBW

エラー報告
======================================================================

TBW

正規表現
======================================================================

TBW

乱数
======================================================================

TBW

C 互換ライブラリー
======================================================================

TBW

.. include:: /_include/cpp-refs.txt
