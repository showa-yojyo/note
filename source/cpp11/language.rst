======================================================================
What's New In C++11 言語仕様
======================================================================

このノートでは C++11 で注目すべき言語仕様を学習する。
すでに cpprefjp_ がそのへんをきれいに整理している。
それを利用して、読みながら急所を記していくことにする。

.. contents::

一般的な機能
======================================================================

型推論 ``auto``
----------------------------------------------------------------------

いちばんありがたいのが仕様転生したキーワード ``auto`` だ。
変数の宣言と定義を同時にする場合には、右辺の値の型を明示する代わりに ``auto`` と書く。

.. code:: c++

   std::string line;
   // ...
   boost::tokenizer<escaped_list_separator<char>> tok(line);
   // tokenizer<escaped_list_separator<char>>::iterator first = tok.begin(), last = tok.end();
   auto first = tok.begin(), last = tok.end();

   for(; first != last; ++first){
       // ...
   }

* 従来の自動変数（スタックに積む変数）を意味するためのキーワードという意味は廃止された。
* ``const``/``volatile``, ``*``, ``&``, ``&&`` と共に用いることも可能だ。
* テンプレート型引数や関数引数の型として用いることは許されない。

式の型を取得 ``decltype``
----------------------------------------------------------------------

* ``decltype`` は型を指定する必要のある場所で用いる。オペランドは式とする。
  演算結果がその式の返す値の型となる。コンパイル時に評価される。
* ``decltype`` は変数宣言の用途にはあまり向かない。式自体を二度書く必要がある。

.. code:: c++

   int i = 0;
   decltype(i) j = 0; // int j = 0;
   decltype(i)* p = &i; // int* p = &i;
   decltype((i)) k = i; // int& k = i;

* ``decltype`` のオペランドは値には評価されない。例えば ``decltype(2 + 3)``
  とあっても、コンパイラーはこの和を使わない。型だけを見る。
* 丸括弧の使い方が独特なので注意する。上のコード片における ``k`` の定義など。
* cpprefjp_ のコード例はわりと高度だ。

範囲 ``for`` 文
----------------------------------------------------------------------

よそのプログラミング言語ではおなじみの機能が C++11 に追加された。
cpprefjp_ のコードを引用する：

.. code:: c++

   std::vector<int> v;

   for(const auto& e : v){
       std::cout << e << std::endl;
   }

この記法が許されるコンテナーは生の配列か、``begin()``, ``end()`` および
イテレーターを進める機能を提供するコンテナー型オブジェクトだと思って問題ない。

初期化子リスト
----------------------------------------------------------------------

生の配列や POD 構造体のように、オブジェクトを ``{ ... };`` の構文で初期化できる機能だ。
これを実装するには、パラメーターリストに ``std::initializer_list`` を取るコンストラクターを定義する。

.. code:: c++

   #include <initializer_list>

   template <typename T>
   class MyClass{
   public:
       MyClass(std::initializer_list<T>);
       ...
   };


* ``explicit`` コンストラクターの例はどうも好かない。
* コンストラクターの他に、``operator new`` 呼び出し、 ``return`` 文などでも用いることができる。
* 初期化子リストに列挙した要素は、先頭から順番に評価される。
* この機能の急所は、テンプレートやオーバーロードの仕様との絡み。いちいち確認するほうがいい。

一様初期化
----------------------------------------------------------------------

コンストラクターの呼び出しを丸括弧だけではなく、上述の初期化子リストを引数に取るコンストラクターの呼び出しと同じ構文で書ける。

* 例えばデフォルトコンストラクターの呼び出しですらこう書ける：

  .. code:: c++

     //MyClass x;
     MyClass x{};

* 呼び出し時に列挙した要素は、先頭から順番に評価される。
* この機能の急所もやはり初期化子リストと同様だ。

右辺値参照・ムーブセマンティクス
----------------------------------------------------------------------

* 右辺値・左辺値の定義は問題ない。C++03 以前のものが通じる。
* 〈右辺値参照は、右辺値を束縛する参照である〉

  * C++03 以前までの参照を **左辺値参照** と呼ぶようになったらしい。
  * そして C++11 で追加になった ``&&`` で宣言される参照型を **右辺値参照** と呼ぶ。

* 〈C++11 以降では、代入式 2 の右辺の型は右辺値参照 ``vector<int>&&`` になり、
  左辺値参照とは区別して処理される。
  また、こうした処理のことを「**ムーブ**」と呼ぶ〉

  .. code:: c++

     std::vector<int> v, vv;
     v = vv; // 代入式 1
     v = std::vector<int>(100, 0); // 代入式 2

  この式自体は ``std::vector<...>::operator=(rhs)`` の呼び出しとコンストラクターが組み合わさったものだ。
  本文はこの ``rhs`` が C++11 では右辺値参照 ``&&`` であると主張しているようだ。

右辺値参照とは、ムーブされたオブジェクトを示すものだ。

* 〈右辺値参照で宣言された変数は右辺値ではなく、左辺値である〉

  ``int&& x = 0;`` に対して ``x`` は左辺値であるということを言っている。
  したがって例えばこの後で ``int&& y = x;`` などとはできない。

次に ``std::move()`` について学習する。この関数の挙動を説明するのに右辺値参照の概念が要るのだ。

* 〈ムーブされた変数は右辺値となり、それ以降使える保証はなくなる〉。
  この Hello world は実際にコードをコンパイルして実行するといい。コメント通りの挙動を確認できる。
  要するに、ムーブされた変数にもし名前が付いていたならば、それは「吸い殻」になっているので、
  もはや参照してはならない。
* 所有権の移動の実例は自然でわかりやすい。
* C++11 から、コンストラクターおよび代入演算子に（従来型のコピーとは別の）ムーブ版が考えられるようになった。

  * ムーブコンストラクターとムーブ代入演算子のシグニチャーに注目。``const`` なし ``&&`` 付き。
    実装例は想像しているとおり。

* 〈標準ライブラリで提供されるクラスのほとんどは、このようなムーブコンストラクタを用意している〉
  代入演算子も同様。とにかく ``std::move()`` を介せばいい。
* ムーブコンストラクター・ムーブ代入演算子は、それらのコピー版もそうであるように、
  コンパイラーが自動生成するケースがある。
  その条件は本文にある通りだが、ここではコピー演算、ムーブ演算の意味が明白でない……。
* 〈また、``default`` を指定することができる〉とあり、新仕様の ``default`` を学習する必要がある。

以下のトピックは以上を完全に習得してから学習すること。

* 全称的参照：テンプレートや ``auto`` に ``&&`` をつける場合は意味が異なる。
  cpprefjp_ の説明によると、次の関数テンプレート ``f`` において実引数が

  * 左辺値ならば ``x`` は左辺値参照となる。
  * 右辺値ならば ``x`` は右辺値参照となる。

  .. code:: c++

     template <typename T>
     void f(T&& x) {}

* 完全転送

  * 〈引数を全称的参照で宣言した場合安易にムーブできない。
    引数は右辺値参照の場合と左辺値参照の場合両方があり得るからである〉

    例えば上述の関数テンプレートの定義において、別の関数 ``g()`` に ``x`` を渡したいとする。
    前者の場合はムーブしたいが、後者はそのままにして関数 ``g`` に渡したい。
    こういう引数の引き渡し方を **完全転送** という。

  * ``std::forward()`` は左辺値参照の場合はムーブせず、右辺値参照の場合はムーブして渡す。
    この関数テンプレートについてはライブラリー編で見ていく。

あとはこの機能が必要になった背景・経緯を読んでおくといい。
やはり ``std::auto_ptr`` はインターフェイスに問題があった。
しかしそのおかげでここで観てきたような諸概念が標準に導入されたのだから良かった。

ちなみに ``std::auto_ptr`` は C++11 から deprecated らしい。

ラムダ式
----------------------------------------------------------------------

* Python の lambda 式と期待される役割は同じ。
  ありがたいことに lambda といちいちスペルアウトせずにそれを定義できる。
* 概要を理解したら **capture** と呼ばれる機能を理解する。

  * copy と reference とで分類される。
  * すべての capture notation を習得する。
  * ``this`` を capture した場合、lambda 式が定義する関数オブジェクトは当該クラスの ``friend`` 扱い。
  * 〈ラムダ式がデフォルト引数に現れる場合、いかなるキャプチャもしてはならない〉

* 文法を習得する。

  .. code:: text

     "[" キャプチャリスト "]"
     "(" パラメータリスト ")" "mutable" 例外仕様 属性
     "->" 戻り値の型 "{" 関数の本体 "}"

  このうちのいくつかは省略できる。

* 〈ラムダ式は、その場に関数オブジェクトのクラスを定義し、その一時オブジェクトを生成する。
  関数オブジェクトのクラスを「クロージャ型 (closure type)」、
  その一時オブジェクトを「クロージャオブジェクト (closure object)」という〉
* キーワード ``mutable``

  * copy capture した変数を変更するためにこの記述をパラメーターリストの直後に要する。

* 〈戻り値の型を省略した場合、その戻り値型は、関数本体の ``return`` 文から推論される〉ので、
  次のようなコードは許されない：

  * 複数の ``return`` パスが存在するときに、それらの戻り値の推論型が一致しない場合
  * リテラルの ``std::initializer_list`` による初期化リスト

* 〈キャプチャを含まないラムダ式によって生成されたクロージャオブジェクトは、
  同じパラメータ型と戻り値型のシグニチャを持つ関数ポインタに変換できる〉

〈標準 C++ のアルゴリズムライブラリには、関数を引数とするものが多くある。
それらは各問題を解くために非常に有用ではあったが、
アルゴリズムを使用するたびに関数オブジェクトを定義することは非常に冗長で使いにくかった。
アルゴリズムをより使いやすくするための言語サポートとして、ラムダ式が導入されることとなった〉

キーワード ``noexcept``
----------------------------------------------------------------------

``noexcept`` は C++ という言語の基本にある例外送出に関係する重要な概念なので優先度は高い。

* 新キーワード ``noexcept`` は、関数宣言において、例外を送出するか否かを明示するキーワードだ。
  必ずしも書かなくともよい。

  .. code:: c++

     void f() noexcept;
     void g() noexcept(true);
     void h() noexcept(false);

* 関数が例外を送出するか否かをコンパイル時に判定する演算子

  * 関数呼び出しを ``noexcept()`` で括る。すると例外を送出する可能性のあるものは ``false`` に展開される。
  * その呼び出し自体は実行時に実行されない。

* 指定が書いてなければ関数のほとんどは ``noexcept(false)`` としてコンパイラーが関数を扱う。
  その例外がデストラクターと ``operator delete`` であり、コンパイラーは ``noexcept(true)`` とみなす。
  このへんの理由は C++03 時代の書籍で理解できるだろう。

* ``noexcept`` の利点の一つにパフォーマンス向上があることに注意。
  その理由は例外送出時のスタック巻き戻しに必要なメモリ領域を確保するのを省くようになるからだと。
  もう一つの理由はもちろん no-throw 保証。

* 関数宣言のときに用いる ``throw`` による例外指定は C++11 から非推奨。注意。

  * どんな例外を送出するのかということより、例外送出の有無が本質的だったようだ。

定数式 ``constexpr``
----------------------------------------------------------------------

``constexpr`` は誤解なきよう習得すること。それと ``std::numeric_limits`` の従来の実装に関する
〈抽象化された機能を使うより、抽象化されていない機能の方がよい、というのは、改善すべき事態だった〉
という cpprefjp_ の一文が印象的だ。

空ポインター ``nullptr``
----------------------------------------------------------------------

``nullptr`` の特性はまともな C++03 プログラマーの直観と合致する。
しかし ``0`` と書くほうが楽なのだが。

インライン名前空間 ``inline namespace``
----------------------------------------------------------------------

``inline namespace`` はどういう立場になったときに使うのか。

* C++11 で ``inline namespace`` という構文が追加された。
* この機能の急所は ``using namespace`` 文で何がスコープに持ち込まれるのかを見分けることと、
  引数依存の名前探索ルールを理解することだろう。
  例えば cpprefjp_ の例だが：

  .. code:: c++

     namespace my_namespace
     {
         inline namespace features
         {
             void f(){ ... }
         }
         void g(){ ... }
     }

  ``using namespace my_namespace::features`` の一文だけで
  ``f`` と ``g`` の両方を宣言するスコープに持ち込める。

* このリファレンスの記事だけでは名前なし ``inline namespace`` の概要がわからない？

ユーザー定義リテラル
----------------------------------------------------------------------

ユーザー定義リテラルはシグニチャーが風変わりであることだけを頭に入れて後回し。

クラス
======================================================================

キーワード ``default``/``delete``
----------------------------------------------------------------------

キーワード ``default``, ``delete`` を関数宣言に付与する使い方。cpprefjp_ の当該記事の要約は理想的。
そしてこれらの用法は要習得。便利なので。

クラスを定義するときには、ユーザーがそれを定義しなければ一定の特別なメンバー関数をコンパイラーが自動生成する。
C++11 では、その「暗黙の定義を使う」という宣言を明示的にコードに表すことができるようになった。
それが ``= default`` 記法だ。

反対に、コンパイラーに自動生成を禁止するように支持するのが ``= delete`` 記法だ。
例えば Singleton なクラスを定義するときにこれが有用であることは想像できる。
C++03 では ``private`` メンバーとして宣言だけしておくという技法を用いていた。

``= delete`` はフリー関数にも適用可能。これは特定のオーバーロードを禁じるという用法になる。

``= default`` は関数定義にも書かれる。他方 ``= delete`` は宣言時に限定される。

委譲コンストラクター
----------------------------------------------------------------------

委譲コンストラクターも要習得。
コンストラクターが複数あるクラスを書いたことがある人間ならばこの新機能の意義は肌感覚で理解できる。

非静的メンバーの初期化
----------------------------------------------------------------------

非静的メンバ変数の初期化。コンストラクターの定義によってはこの代入が実際に行われないことがあることに注意。

継承コンストラクター
----------------------------------------------------------------------

派生クラスのコンストラクターの引数リストは基底クラスのそれと同じになりがちだということで生まれた新機能。
``using BaseClassName::BaseClassName;`` を派生クラスに一筆加える。
オプショナルに、その上派生クラス独自の定義をしてもよい。

キーワード ``final``/``override``
----------------------------------------------------------------------

キーワード ``final`` は用途が二つある。クラス丸ごとと仮想メンバー関数ごと。

キーワード ``override`` の存在がうれしいかと言われると微妙だ。
オーバーライドするつもりが間違えてオーバーロードになってしまうミスを防ぐくらいにしか役に立たない？

これらのキーワードはコンテキスト依存キーワードという特別なキーワードとのこと。

この記事では角括弧を二重に使う新文法が見える。これは後で習う？

明示的な型変換演算子のオーバーロード
----------------------------------------------------------------------

C++03 以前に ``explicit`` コンストラクターというのがある。この考え方を
C++11 では型変換演算子 ``operator T()`` にも適用できる。

これはいい仕様追加だ。

cpprefjp_ のサンプルコードが実のところ少し高級かもしれない。
``bool`` 型でないほうがわかりやすい？

``friend`` 宣言の要件の緩和
----------------------------------------------------------------------

私は ``friend`` 機能を一切採用しないのでスキップ。cpprefjp_ の記事も短いし。

メンバ関数の左辺値／右辺値修飾
----------------------------------------------------------------------

メンバー関数が左辺値・右辺値である場合にしか呼び出されないことを保証する記法が仕様に含まれた。
メンバー関数の宣言の末尾に ``&`` または ``&&`` を付加することでそのような制限を加えることを意味する。
〈これを使用することで、「一時オブジェクトな ``*this`` に対して特定のメンバ関数を呼び出せてはならない制約」、
「``*this`` が左辺値もしくは右辺値である場合の効率的な実装を使い分ける」といった設計ができるようになる〉。

サンプルコード。〈参照を返すと一時オブジェクトの寿命が尽きてしまうため、ムーブで返す〉とある。
これだと何か悪いことを避けているように読めるが違う。
ここで示しているのは、むしろ寿命が尽きることを利用して ``move`` を使ってデータを流用してコピーを避けるという優れた技法だ。

クラス以外の型に関する機能
======================================================================

Scoped ``enum``
----------------------------------------------------------------------

* 新文法 ``enum class`` で列挙型を定義すると、暗黙の型変換が無効になり、
  列挙子が列挙型スコープを有する。
* 「基底型」を宣言することができる。列挙子が少なければ ``char`` で十分とか？

  * 従来の ``enum`` にもこれが適用できる。

* これにより列挙型の前方宣言が可能になった。宣言と定義の「ガワ」は一致していなければならない。

``union`` に対する規制緩和
----------------------------------------------------------------------

``union`` のメンバー変数にユーザー定義型オブジェクトを置くことができる。
共用体は全く使わないのでどうでもいい。

テンプレート
======================================================================

テンプレートの ``>`` を空白を挟まずに書けるようになった
----------------------------------------------------------------------

これは仕事で C++ をやった人間なら一発で理解できる。

.. code:: c++

   std::map<int, std::vector<double> > positions;

みたいなものが次のように書けるようになったということ。

.. code:: c++

   std::map<int, std::vector<double>> positions;

コンパイラーが後の方の宣言を ``operator>>`` として扱って結果的に構文エラーになっていた。
C++11 でこれがなくなる。

外部テンプレート ``extern template``
----------------------------------------------------------------------

クラステンプレート C または関数テンプレート F が存在して、
それを実体化するとサイズが巨大になるようなものであると仮定する。
さらに、複数の cpp で C または F を参照するとし、cpp の一つで特定の実体化がされているとする。

このとき、別の cpp で次のように宣言すると、その cpp では実体化をしなくなる。
別の cpp の実体化を参照するのだろう。

.. code:: c++

   extern template class C<T1>;
   extern template F<T2>(the_parameter_list);

この機能をどうやって検証しよう？

別名テンプレート
----------------------------------------------------------------------

テンプレートを含む型に別名をつける方法ができた。例えば次のようにする。

.. code:: c++

   template <class T>
   using Vec = std::vector<T>;

キーワード ``using`` の強化の話をまだ学習していないことに注意。
別名定義はテンプレートが関係していなくてもいい。例えば次のような宣言も正しい：

.. code:: c++

   using VecInt = std::vector<int>;

可変引数テンプレート
----------------------------------------------------------------------

``template <typename... Args>`` というような文法になる。この ``...`` はこのままタイプする。
ここで ``Args`` のことを parameter pack という。

定義中で paramter pack を他の要素に転送するときは ``Args...`` というような記法を使う。

* 問題はたぶん parameter pack の要素を一つずつ参照・処理する場合だろう。
* サンプルコードを g++ (GCC) 10.2.0 でコンパイルしたら時間がかかって驚く。

あと paramter pack の拡張機能というのがある。
要素それぞれに同じ処理を適用する式を書くこともできる。これは使うかもしれない。

ローカル型と無名型をテンプレート実引数として使用することができる
----------------------------------------------------------------------

〈ローカルで定義した型と、名前のない型を、テンプレート引数として渡すことが許可された〉そうだ。

関数スコープで古典的な ``enum`` を定義することを考える。これは無名列挙型として定義する必要がある。
そうなると、そのスコープから関数テンプレートなどの実引数として列挙子を与えるコードがコンパイルエラーを引き起こしていた。
関数スコープでの定義を諦めることで回避していたが、その必要がなくなる。

SFINAE 強化
----------------------------------------------------------------------

SFINAE の概念については *Exceptional C++* あたりを参照すること。
ほんとうの問題は私が SFINAE を必要とするコードを書く可能性があるかどうかだ。ないと思う。

テンプレートのエクスポート機能を削除
----------------------------------------------------------------------

ここは読まなくていい。

並行プログラミング
======================================================================

スレッドローカルストレージ
----------------------------------------------------------------------

〈変数宣言の際に、記憶域として ``thread_local`` キーワードを指定することで、
スレッドごとの静的記憶域に変数が保持される〉ので、このような変数は
``static`` であると考えるほうが理解しやすい。スレッド別に ``static`` なわけだ。

乱数のほうのサンプルコード、改行文字を出力するコードを
``<< std::endl`` に書き換えて実行すると面白いことに改行されない。

ブロックスコープを持つ ``static`` 変数初期化のスレッドセーフ化
----------------------------------------------------------------------

``static`` 変数の初期化のときに暗黙的にロックがかかるようになったと解釈してよいだろうか。

その他
======================================================================

戻り値の型を後置する関数宣言構文
----------------------------------------------------------------------

従来の関数宣言文法に加え、戻り値の型をとりあえず ``auto`` と書いておいて、
パラメーターリストの後に ``->`` を書いて最後に戻り値の型を（おそらく間接的な形式で）
書く文法が追加された。

コンパイル時 assertion
----------------------------------------------------------------------

``static_assert()`` が言語レベルでサポートされるようになった。
Boost にあった類似機能が標準に昇格したのだろう。あちらはマクロだったと記憶している。

さっそく使わせてもらっているが、コンパイルオプションによっては第二引数を与えなければエラーになる。
例えば ``g++`` ならば ``-std=c++17`` が必要。

生文字列リテラル
----------------------------------------------------------------------

Python でいう ``r'...'`` に相当する仕様。SQL にもある。ユースケースも同じ。
C++11 では ``R"(...)"`` という形で書く。括弧については変種を許す。

UTF-16 と UTF-32の文字型
----------------------------------------------------------------------

使いにくそう。

* C++11 では新しく組み込み型 ``char16_t`` と ``char32_t`` が加わる。
* ``u"..."`` と ``U"..."`` でそれぞれ ``char16_t`` 型配列と ``char32_t`` 型配列のリテラルを宣言できる。

等々。Unicode の知識が要る。

UTF-8 文字列リテラル
----------------------------------------------------------------------

``u8`` プレフィクスを付与した文字列リテラルがあるとする。これはコンパイル時に UTF-8 に符号化される。

属性構文
----------------------------------------------------------------------

二重の角括弧で囲まれた属性を C++ コードの構成要素に付与することで、コンパイラーが助かるらしい。
今は ``[[noreturn]]`` と ``[[carries_dependency]]`` の二つしかない。

``[[noreturn]]`` は関数に対する属性であって、文字通り ``return`` することがない関数に付与する。
cpprefjp_ の例では、実行時に必ず例外が送出する関数に対して適用している。

``[[carries_dependency]]`` は難しい。並行プログラミングで用いられる。
関数に付与するものと、引数に付与するものの二種類ある。あとでやろう。

演算子 ``alignas`` - アライメントを指定する
----------------------------------------------------------------------

C/C++ のコードを機械語レベルに落として考えるプログラマーならこの機能の役割はすぐにわかると思う。

〈構造体やクラスの宣言時に使用した場合、その型のインスタンス全てをアライメントする〉とある。
例えば 28 バイトの構造体を定義しても、その型の変数を定義するとアドレスが 32 バイト境界に揃えられるということだろう。

このルールは構造体やクラスのメンバー変数についても適用される。

``alinas(nn) typename identifier;`` のような文法で指定する（ここで ``alinas`` だけがキーワード）。

cpprefjp_ のサンプルコードは 4 バイト型の align を 1, 2 などで指定しようと試みていることに注意。
そんなことはできないので結局 4 バイト境界揃えになる。

g++ (GCC) 10.0.2 では ``alinas(0)`` は認められない。あるいはコンパイルオプションの指定が悪いのかもしれない。

演算子 ``alignof`` - アライメントを取得する
----------------------------------------------------------------------

演算子 ``alignof`` は型に対して作用する。``sizeof`` が型にも変数にも作用するのとは違う。

さっきの演算子も含め alignment 関連の演算子は C++ ではなく C の仕様とするべきだと思う（たぶんそうなっている）。

cpprefjp_ のデモコードに対しては 32bit 環境での結果が掲載されている。
64bit 環境で出力すると結果の一部が 4 から 8 になる。

小さな変更
======================================================================

更新された定義済みマクロ
----------------------------------------------------------------------

読まなくていい。

機能テストマクロ
----------------------------------------------------------------------

g++ (GCC) 10.0.2 では ``__has_cpp_attribute(carries_dependency)`` が使えないようだ。

テンプレート再帰回数の制限緩和
----------------------------------------------------------------------

読まなくていい。

キーワード ``typename`` および ``template`` の適用範囲拡大
----------------------------------------------------------------------

cpprefjp_ のデモコードの関数 ``main`` の二行とも、従来は何かのテンプレートの中でしか書けないコードだった。
二行目は C++03 時代でもお目にかかったことがない文法だが。

入れ子の指定にグローバルスコープ ``::`` を付加する
----------------------------------------------------------------------

cpprefjp_ の記事だけでは何のことか理解できないので、あとで仕様を見に行く。

前方宣言時要素数指定配列機能
----------------------------------------------------------------------

これは試すのが面倒臭い。そしてこれも詳細がわからない（意味はわかる）。

名前空間 ``std::posix`` および ``::posix``
----------------------------------------------------------------------

これらの名前空間が予約された。我々一般プログラマーはこの名前空間を定義してはならない。

演算子 ``sizeof`` が非静的メンバー変数をオペランドにとれる
----------------------------------------------------------------------

``sizeof MyClass::my_member`` のような書き方が許されるようになった。
クラス ``MyClass`` のどのオブジェクトも ``sizeof my_member`` の値は等しいのだから問題ない。

キーワード ``register`` は非推奨となった
----------------------------------------------------------------------

いにしえの記憶域制御系キーワードだが、ついに非推奨になった。
遠い未来の C++ では ``auto`` のように転生するかもしれない。

参照への参照はエラーではなくなった
----------------------------------------------------------------------

テンプレートメタプログラミングでありがちなコンパイルエラーであったが、
これが C++11 からコンパイラーは単なる参照として扱うようになる。

C99 互換機能
======================================================================

C++11 というより C の仕様なのでここでは細かく分析しない。

* ノートにはとらないが ``long long`` の件はふつうに重要なので一読すること。64bit 固定とは意味が異なる。
* ``__func__`` は Python にも似たものがある (``__func__.__name__``) が、``static const char*``
  型の変数として関数名をその関数のスコープの内部から参照できる。
* 列挙子の末尾へのカンマ付加を許可。まさか ``enum`` しか認められていない？
* divmod 演算の丸め結果はだいじなので学習する。

  * ``a``, ``b`` を負かもしれない整数型変数とする。いちおう断るが ``b != 0`` とする。
    このとき値 ``a / b`` は整数であって、この除算を小数で考えるときに得られる商をゼロ方向に丸める値と等しいものとする。
  * 恒等式 ``(a / b) * b + a % b == a`` を憶えること。

.. include:: /_include/cpp-refs.txt
