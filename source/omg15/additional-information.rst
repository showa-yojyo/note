======================================================================
6 Additional Information
======================================================================
UML 2.5 pp. 11-20 に関するノート。
全体的に英単語の訳し方に困っている。

.. contents:: ノート目次

6.1 Specification Simplification
======================================================================
当仕様書は、以前の版 (UML 2.4.1) を読みやすさを重視して広範囲に亘って書き直したものである旨を表明している。

* 私は 2.4.1 を知らないので、この節を読み飛ばす。

6.2 Architectural Alignment
======================================================================
* MDA_: Model Driven Architecture
* MDA において UML と MOF_ と関連仕様が
  言語を提供したり、モデルを生成・変換したりすることで重要な役割を果たす。

* UML の抽象構文は UML メタモデルと呼ばれる UML モデルを用いて仕様化されている。

* メタモデル内のクラスはメタクラスと呼ばれる。

  * 例えば次章 (:doc:`./common-structure`)
    で仕様化するメタクラス Element は UML メタモデル内の抽象クラスである。

* UML が UML 自身で定義されているということは、
  多数のプログラミング言語がその言語自身で書かれたコンパイラーを持つようなものだ。

* 「MOF 2.x メタモデル」という表現は「UML 2.x メタモデル」を包含する。
* 「MOF 2.x メタモデル」は有効な UML 2.x モデルである。

以下未調査概念

* MOF 2 XMI Mapping Specification

6.3 On the Semantics of UML
======================================================================

6.3.1 Models and What They Model
----------------------------------------------------------------------
* 一つの UML モデルはモデル要素の主要な 3 カテゴリーからなる。

  * Classifiers: 物体 (objects) の集合の特徴を述べる
  * Events: 起こり得る出来事 (occurrences) の集合の特徴を述べる
  * Behaviors: 起こり得る実行処理 (executions) の集合の特徴を述べる

* UML モデルはオブジェクト、出来事、実行を含まない。
  そういうモノはモデル化されるドメインの一部である。
  UML が持つのはモノを直接モデリングするモデリング構成要素である。

6.3.2 Semantic Areas
----------------------------------------------------------------------
* 冒頭のパラグラフ群が難解。
  こういう抽象的な議論をスラスラと消化できるようになりたいものだ。

* UML モデリング構成概念を次の 2 つの意味論的なカテゴリーに分割して考える。

  * Structural Semantics
  * Behavioral Semantics

* Figure 6.1 により詳細な UML の semantic areas のアウトラインが図示されている。
  この図は「土台」から見ていくのが理解が良さそうだ。
  というより、この仕様書の造りをそのまま示しているとも読める。

  Structural Modeling
    Common Structure
      型、名前空間、関係、依存といった基本的概念共通の土台。

      :doc:`./common-structure` で議論する。

      Values
        :doc:`./values` で議論する。

      Classifiers
        データ型、クラス、シグナル、インターフェイス、コンポーネント等を指す。

        :doc:`./classification`,
        :doc:`./simple-classifiers`,
        :doc:`./structured-classifiers`
        で議論する。

      Packages
        パッケージおよびプロファイルという概念がある。

        :doc:`./packages` で議論する。

  Behavioral Modeling
    Common Behavior
      振る舞いの実行・処理のための枠組みを与える基礎構造。

      13 章で議論する。

      Actions
        UML での振る舞いの基本構成単位である。
        より細やかな振る舞いを定義するのに用いられる。

        16 章で議論する。

        State Machines
          14 章で議論する。

        Activities
          15 章で議論する。

        Interactions
          17 章で議論する。

  Supplemental Modeling
    その他の補助的な構成概念。構造的でも振る舞い的でもある。

    Use Cases
      18 章で議論する。

    Deployments
      19 章で議論する。

    Information Flows
      20 章で議論する。

6.3.3 Stable and Transient Behavioral Semantics
----------------------------------------------------------------------
* 前節で見たように structural semantics は対象となるモデルのある瞬間を切り取って表現したものではあるが、
  それでも behavioral な観点をモデル化する能力をも含んでいることに注意したい。

  * 例えば classifier は、
    その classifier から発動可能な何らかの振る舞いを求めるために、
    behavioral features を持ってよい。

  * あるクラスは active であるとモデル化されてよい。その意味は、
    そのクラスのオブジェクトに何か主動的な振る舞いがあるということだ。

* 基本的構造モデリング構成要素の振る舞いに関する特徴は、
  一般的にそのシステムがある特定の時点でのある安定状態であるときに確かめられる
  システムの振る舞いについての高水準な陳述を生じさせる。

  * どのようにしてシステムが前の状態からその状態に本当に至ったのかについては定義しない。
    ただ何らかの振る舞いがこの変化をもたらすために起きたはずであるということを定義するだけだ。

  * 束の間の (transient) 振る舞いの詳しい定義は、
    振る舞いに関するモデリング構成要素の利用をそのうちに必要とする。

* 多くの場合に UML モデル内のある構造に関する要素は、
  その構造的要素のために見分けられる高水準な振る舞いを実現するために
  詳細な振る舞いを定義する振る舞いに関する要素 (pl.) と関連するだろう。

  * 例えばあるクラスが所有するある操作 (operation) に、
    その詳細な振る舞いを定義するある関連メソッド (method) があってよい。

  * あるアクティブクラスに
    その主動的な振る舞いを詳らかにする classifier behavior があってよい。

.. todo:: 今のところここはうまくノートにまとめられない。

* いくつか重要な用語の定義がポツポツある。

  Operational behaviors
    * 操作とはクラスの振る舞いに関する機能である。
      そのクラスのオブジェクト上で直接発動 (invoke) されてよい。
      :doc:`./classification` 参照。

    * 操作の定義には入力・出力パラメーター、
      事前条件、事後条件といった概念を含む。

    * ひとつ操作にはひとつのメソッドをもあってよい。
      メソッドとはそれの（操作の？）必要な振る舞いの詳細な定義である。
      13 章参照。

    * クラスには不変条件 (invariant conditions) もまたあってよい。
      クラスがその操作の実行の前後において成り立つ条件のこと。
      その実行中は成り立つかどうか問わない。

  Property default values
    * これはプログラマーが暗黙のうちに知っている概念と同じとみなして問題なさそうだ。

    * 仕様書中では attributes と properties を使い分けていることに注意。

      <Thus, when instantiating a classifier, all its attributes (i.e.,
      properties of the classifier) with default values should be properly
      initialized once any behavior required to instantiate the classifier
      completes.>(p. 15)

  Active class behaviors
    * アクティブクラスの意味は、
      オブジェクトが生成するときに、
      そのオブジェクトが生成の直接の帰結としてそれの振る舞いの実行を開始する
      ようなクラスのこと。
      :doc:`./structured-classifiers` 参照。

    * オブジェクト生成作用は、
      いかなる関連された振る舞いの実行をも開始することのないオブジェクトを
      生成するように指定されている。
      16 章参照。

6.4 How to Read this Specification
======================================================================

6.4.1 Specification Format
----------------------------------------------------------------------
この仕様書の構成方法と、各章の構造を説明しているだけ。

* 前方参照をなるべく少なくするべく各章を配列している。
* 仕様書をリファレンスとして利用されることを意図している。
  つまり順番通りに読まれないことを想定している。
  そこで本文中では相互参照をふんだんに提供する。

* 各章が含む節 (sub clause) の構造は次のようになっている。

  * Abstract Syntax: MOF モデル（先程書いたように UML メタモデルである）の言葉で定義された図式
  * Semantics: その節が説明している全ての概念の意味
  * Notation: その節が説明している全ての概念の記法
  * Examples: その節の概念を図説する意図がある見本

* 各種スタイリングに関する規約

  * イタリック体は強調のために用いる。

  * メタクラス名は capitalize して表記するものの、
    テキスト中では名詞であるかのように用いる。必要に応じて複数形にする。

  * プロパティー名は 8 ポイントの Arial フォントを用いる。
    こちらも必要に応じて複数形にする。
    PDF で仕様書を見るときにはプロパティー名が「浮いて」見えるので便利。

* テキストを用いる記法の説明では BNF 記法の変種を用いる。

  * これも記法として潰しが効くので p. 17 をいつでも参照できるようにしておくとよい。

* Notation と Examples の節で現れる図式は色々なツールで制作したものにつき、
  フォント、線幅、矢印等のスタイルの詳細が若干異なるかも (may) しれないが、
  この手の差異は仕様に対する本質ではない。

* Notation の節では図式は白地に黒で描画されることを仮定している。
  UML を扱うツールは他のカラースキームを採用しても構わないのだが、
  その場合は「黒」「白」「灰色」を「塗る」「塗らない」
  「両者の中にある見分けの付く色」としてそれぞれ解釈すること。

* 各章の最後の 2 節は機械生成による。

  * Classifier Descriptions
  * Association Descriptions

  当ノートではこれらを飛ばす。
  その代わり、直前の節で言及の見つからなかった情報のためにここを参考にはしている。

6.4.2 Diagram Format
----------------------------------------------------------------------
仕様書全体を通じて、全てのメタモデル図式に対して採用されている規約を列挙している。
かなり重要な約束なので、読み飛ばすことは考えられない。
規約リストの項目からいくつか拾ってみる：

* ひとつのメタクラスが色々な図に現れるが、
  そのメタクラスが主役を張る図はただ一つだけだ。
  それはどの図なのかというと、そのメタクラスの意味を仕様化している箇所に隣接し、
  メタクラスの属性区画が展開されて表記されている図だ。

  * 実は同様のことが前節でも書かれている。

* ドット記法。関連を示す線分の端点にドットが描画されていることがあり、
  これがその端点の所有権に関する情報を示しているようだ。
  私が誤読していなければ、ドットの反対側にあるクラスが所有者を意味するはず。

  * 詳しくは :doc:`./structured-classifiers` の該当する節で述べられている。
  * 当ノートでは association end を関連端（点）と書くことにする。

* 矢印記法。関連端点の navigability を示すのに用いる。
  この英単語は日本語に訳すと「航行可能性」となって意味は理解できるもののしっくりこないので、
  少々意訳せざるを得ないか。
  当ノートではよい日本語表現が見つからない間は英単語をそのまま記すことにする。

  * 定義により全ての「クラス所有」の関連端点は navigable であるものとする。
  * 慣習によりメタモデルの全ての「関連所有」の関連端点は navigable でないものとする。

* 頭にも尾にも印の付いていない関連は「両方向に対して navigable である」の意とする。

* 特殊化と再定義。関連端点近くに適用する制約情報表示ラベルを付す。

  ``{subsets endA}``
    「この制約が適用される関連端は、関連端 ``endA`` の部分集合である」を意味する。

    .. note::

       この文書では <X subsets Y> という言い回しが頻出するが、
       意味は <X is a subset of Y> である。

  ``{redefines endA}``
    「この制約が適用される関連端は、関連端 ``endA`` を再定義する」を意味する。

  ここで関連端 ``endA`` は既存の関連の要素であることを仮定している。

* 関連端に多重度が示されていないならば、
  それは多重度がちょうど 1 であることを示唆する。

* 関連端にラベルが付いていないならば、
  その端点のデフォルトの名前は、取り付けられているクラスの名前から、
  頭文字を小文字に変えたものとする。

  ただ、non-navigable な関連端にはしばしばラベルを付けないままである
  （名前が Association Descriptions の節に文書化されている場合であっても）。

.. todo:: ここまでの説明を補足するイラストを入れたい。

* 明示的に命名されていない関連については、次のルールに従い「構築」する (p. 19)。
  ここで ``<association-end-nameX>`` はそれぞれの関連端の名前とする。

  .. code-block:: text

     "A_" <association-end-name1> "_" <association-end-name2>

  つまり、関連の名前はその両端点の名前から一意に決まるということだ。

  * 視覚的には矢印が name2 から name1 に向いていることが極めて多い。
  * この記法はたいへん便利なので、次章以降のノートで私も多用する。

6.5 Acknowledgements
======================================================================
仕様書の著者、技術支援提供者、査読者、投稿者、寄稿者等々に対する謝意を表している。

.. include:: /_include/uml-refs.txt
