======================================================================
6 Additional Information
======================================================================
UML 2.5 pp. 11-20 に関するノート。
全体的に英単語の訳し方に困っている。

.. contents:: ノート目次
   :depth: 2

6.1 Specification Simplification
======================================================================
* この仕様書は前の版を広範囲に亘って書き直し、
  冗長性を取り除き、明瞭さを増すことで読みやすくしたものである。
  とりわけ次に挙げる UML 2.4.1 からの大きな変化を加えた。

  * 私は 2.4.1 を知らないので、ここを読み飛ばす。

* しかしメタモデル自身は UML 2.4.1 の上部構造から変更せずにしてあるが、
  次のように例外が少々ある。

  * 私は 2.4.1 を知らないので、ここを読み飛ばす。

6.2 Architectural Alignment
======================================================================
* OMG の Model Driven Architecturre (MDA_) 構想 (initiative) とは、
  ソフトウェア開発のモデル駆動型な取り組みを支援する
  業界全体におよぶ技術仕様の集合のための概念上の様式である。

  * MDA において UML と MOF_ と関連仕様が
    言語を提供したり、モデルを生成・変換したりすることで重要な役割を果たす。

* UML の抽象構文は UML メタモデルと呼ばれる UML モデルを用いて仕様化されている。

  * メタモデル内のクラスはメタクラスと呼ばれる。

  * 例えば次章 (:doc:`./common-structure`)
    で仕様化するメタクラス Element は UML メタモデル内の抽象クラスである。

* UML が UML 自身で定義されているということは、
  プログラミング言語の多くにその言語自身で書かれたコンパイラーがあるという事実や、
  再帰関数（階乗関数のような）がそれ自身を用いて定義することが可能であるという事実
  と同じ程度に驚くようなものではない。

* それ自身のこの制約の付いた部分集合を用いて UML を定義することは、
  UML モデルを MOF 機能を用いて操作可能な
  MOF 2 という貯蔵庫に収容することが可能であることを保証し、
  MOF 2 XMI Mapping Specification に従った XMI を用いて交換される。

* バージョン 2.4.1 は MOF 2.x メタモデル、
  これは UML 2.x メタモデルを含むが、有効な UML 2.x モデルである。
  これは早いバージョンと比較して相当な簡素化と調整であった。

* UML と MOF の間のメタモデルと関係のさらなる議論は
  MOF 2 Core 仕様の中で見つけられる。

6.3 On the Semantics of UML
======================================================================

6.3.1 Models and What They Model
----------------------------------------------------------------------
* モデルとはいつでも「何か」のモデルである。
  モデル化をしようとしているものは一般的に
  論述のある範囲の内部にあるシステムとみなされる可能性がある。

* UML モデルはモデル要素の主要カテゴリー 3 個から構成され、
  それぞれはモデル化をしようとしているシステムの内側にある
  個々の物事のさまざまな種類についての言明を与えるのに用いてよい。
  これらのカテゴリーとは次のものである。

  * Classifiers: 物体 (objects) の集合の特徴を述べる
  * Events: 起こり得る出来事 (occurrences) の集合の特徴を述べる
  * Behaviors: 起こり得る実行処理 (executions) の集合の特徴を述べる

* UML モデルはオブジェクト、出来事、実行を含まない。
  そういうモノはモデル化される範囲の一部であり、モデル自身の内容物ではない。
  UML にあるのはモノを直接モデリングするモデリング構成要素である。

* モデル化されたシステム内部にある挙動の実行は、
  結果的にそのシステム内部にあるオブジェクトの生成と破壊になることが許される。

6.3.2 Semantic Areas
----------------------------------------------------------------------
* 本節では UML の（具体的および抽象的）構文に対するツールの適合と
  それの意味に対する適合との区別をする。

* UML の構文は UML モデルがどのように生成、表現、交換されるかを処理しなければならない。
  UML 仕様は UML の構文を抽象的にも具体的にも両方定義する。

* これに対し、UML 自身の意味はモデル化されようとしているシステムについての
  UML モデルによってなされる言明の標準的な意味を処理しなければならない。

* UML モデリング構成概念を次の 2 つの意味についてのカテゴリーに分割して考える。

  * Structural Semantics
  * Behavioral Semantics

* Figure 6.1 により詳細な UML の意味範囲の輪郭が図示されている。
  この図は「土台」から見ていくのが理解が良さそうだ。
  というより、この仕様書の造りをそのまま示しているとも読める。

  Structural Modeling
    Common Structure
      型、名前空間、関係、依存といった基本的概念共通の土台。

      :doc:`./common-structure` で議論する。

      Values
        :doc:`./values` で議論する。

      Classifiers
        データ型、クラス、シグナル、インターフェイス、コンポーネント等を指す。

        :doc:`./classification`,
        :doc:`./simple-classifiers`,
        :doc:`./structured-classifiers`
        で議論する。

      Packages
        パッケージおよびプロファイルという概念がある。

        :doc:`./packages` で議論する。

  Behavioral Modeling
    Common Behavior
      挙動の実行・処理のための枠組みを与える基礎構造。

      :doc:`./common-behavior` で議論する。

      Actions
        UML での挙動の基本構成単位である。
        より細やかな挙動を定義するのに用いられる。

        :doc:`./actions` で議論する。

        State Machines
          :doc:`./statemachines` で議論する。

        Activities
          :doc:`./activities` で議論する。

        Interactions
          :doc:`./interactions` で議論する。

  Supplemental Modeling
    その他の補助的な構成概念。構造的でも挙動的でもある。

    Use Cases
      :doc:`./usecases` で議論する。

    Deployments
      :doc:`./deployments` で議論する。

    Information Flows
      :doc:`./informationflows` で議論する。

6.3.3 Stable and Transient Behavioral Semantics
----------------------------------------------------------------------
* 前節で見たように structural semantics は対象となるモデルのある瞬間を切り取って表現したものではあるが、
  それでも behavioral な観点をモデル化する能力をも含んでいることに注意したい。

  * 例えば classifier には、
    その classifier から発動可能な何らかの挙動を求めるために、
    behavioral features があってよい。

  * あるクラスは active であるとモデル化されてよい。その意味は、
    そのクラスのオブジェクトに何か主動的な挙動があるということだ。

* 基本的構造モデリング構成要素の挙動に関する特徴は、
  一般的にそのシステムがある特定の時点でのある安定状態であるときに確かめられる
  システムの挙動についての高水準な陳述を生じさせる。

  * どのようにしてシステムが前の状態からその状態に本当に至ったのかについては定義しない。
    ただ何らかの挙動がこの変化をもたらすために起きたはずであるということを定義するだけだ。

  * 束の間の (transient) 挙動の詳しい定義は、
    挙動に関するモデリング構成要素の利用をそのうちに必要とする。

* 多くの場合に UML モデル内のある構造に関する要素は、
  その構造的要素のために見分けられる高水準な挙動を実現するために
  詳細な挙動を定義する挙動に関する要素 (pl.) と関連するだろう。

  * 例えばあるクラスが所有するある操作 (operation) に、
    その詳細な挙動を定義するある関連メソッド (method) があってよい。

  * あるアクティブクラスに
    その主動的な挙動を詳らかにする classifier behavior があってよい。

* 次のものは、この意味の差異が UML においてとりわけ重要な領域のいくつかである。

  Operational behaviors
    * 操作とは、
      クラスのオブジェクトで直接発動 (invoke) されてよい、
      クラスの挙動に関する機能である。
      :doc:`./classification` 参照。

    * 操作の定義には操作の入力および出力引数の型を含み、
      モデル化されようとしているシステムの状態にまつわる
      操作の発動前後での事前条件、事後条件といった概念を含んでもよい。

    * 操作にはメソッドがあることも許されているが、
      それは要求される挙動の詳細な定義である。
      :doc:`./common-behavior` 参照。

    * クラスには、
      その操作の実行の前後において成り立つ必要があるが、
      その実行中は成り立つかどうか問われない
      不変条件があることも許されている。

  Property default values
    * 特性の意味は、
      デフォルト値のある特性がオブジェクト化されるときに、
      その特性のための固有のセッティングの何らかが不在で、
      デフォルト値が評価されてその特性の初期値を与えることを
      指定するものである。

    * ある classifier をオブジェクト化するときには、
      いったん classifier をオブジェクト化するのが必要な挙動のどれもが完了すると、
      そのデフォルト値のある属性すべてが適切に初期化されるべきである。

  Active class behaviors
    * アクティブクラスの意味は、
      オブジェクトが生成するときに、
      そのオブジェクトが生成の直接の帰結としてそれの挙動の実行を開始する
      ようなクラスのこと。
      :doc:`./structured-classifiers` 参照。

    * オブジェクト生成作用は、
      いかなる関連された挙動の実行をも開始することのないオブジェクトを
      生成するように指定されている。
      :doc:`./actions` 参照。

6.4 How to Read this Specification
======================================================================

6.4.1 Specification Format
----------------------------------------------------------------------
この仕様書の構成方法と、各章の構造を説明しているだけ。

* 前方参照をなるべく少なくするべく各章を配列している。
* 仕様書をリファレンスとして利用されることを意図している。
  つまり順番通りに読まれないことを想定している。
  そこで本文中では相互参照をふんだんに提供する。

* 各章が含む節 (sub clause) の構造は次のようになっている。

  * Abstract Syntax: MOF モデル（先程書いたように UML メタモデルである）の言葉で定義された図式
  * Semantics: その節が説明している全ての概念の意味
  * Notation: その節が説明している全ての概念の記法
  * Examples: その節の概念を図説する意図がある見本

* 各種スタイリングに関する規約

  * イタリック体は強調のために用いる。

  * メタクラス名は capitalize して表記するものの、
    テキスト中では名詞であるかのように用いる。必要に応じて複数形にする。

  * プロパティー名は 8 ポイントの Arial フォントを用いる。
    こちらも必要に応じて複数形にする。
    PDF で仕様書を見るときにはプロパティー名が「浮いて」見えるので便利。

* テキストを用いる記法の説明では BNF 記法の変種を用いる。

  * これも記法として潰しが効くので p. 17 をいつでも参照できるようにしておくとよい。

* Notation と Examples の節で現れる図式は色々なツールで制作したものにつき、
  フォント、線幅、矢印等のスタイルの詳細が若干異なるかも (may) しれないが、
  この手の差異は仕様に対する本質ではない。

* Notation の節では図式は白地に黒で描画されることを仮定している。
  UML を扱うツールは他のカラースキームを採用しても構わないのだが、
  その場合は「黒」「白」「灰色」を「塗る」「塗らない」
  「両者の中にある見分けの付く色」としてそれぞれ解釈すること。

* 各章の最後の 2 節は機械生成による。

  * Classifier Descriptions
  * Association Descriptions

  当ノートではこれらを飛ばす。
  その代わり、直前の節で言及の見つからなかった情報のためにここを参考にはしている。

6.4.2 Diagram Format
----------------------------------------------------------------------
仕様書全体を通じて、全てのメタモデル図式に対して採用されている規約を列挙している。
かなり重要な約束なので、読み飛ばすことは考えられない。
規約リストの項目からいくつか拾ってみる：

* ひとつのメタクラスが色々な図に現れるが、
  そのメタクラスが主役を張る図はただ一つだけだ。
  それはどの図なのかというと、そのメタクラスの意味を仕様化している箇所に隣接し、
  メタクラスの属性区画が展開されて表記されている図だ。

  * 実は同様のことが前節でも書かれている。

* ドット記法。関連を示す線分の端点にドットが描画されていることがあり、
  これがその端点の所有権に関する情報を示しているようだ。
  私が誤読していなければ、ドットの反対側にあるクラスが所有者を意味するはず。

  * 詳しくは :doc:`./structured-classifiers` の該当する節で述べられている。
  * 当ノートでは association end を関連端（点）と書くことにする。

* 矢印記法。関連端点の navigability を示すのに用いる。
  この英単語は日本語に訳すと「航行可能性」となって意味は理解できるもののしっくりこないので、
  少々意訳せざるを得ないか。
  当ノートではよい日本語表現が見つからない間は英単語をそのまま記すことにする。

  * 定義により全ての「クラス所有」の関連端点は navigable であるものとする。
  * 慣習によりメタモデルの全ての「関連所有」の関連端点は navigable でないものとする。

* 頭にも尾にも印の付いていない関連は「両方向に対して navigable である」の意とする。

* 特殊化と再定義。関連端点近くに適用する制約情報表示ラベルを付す。

  ``{subsets endA}``
    「この制約が適用される関連端は、関連端 ``endA`` の部分集合である」を意味する。

    .. note::

       この文書では <X subsets Y> という言い回しが頻出するが、
       意味は <X is a subset of Y> である。

  ``{redefines endA}``
    「この制約が適用される関連端は、関連端 ``endA`` を再定義する」を意味する。

  ここで関連端 ``endA`` は既存の関連の要素であることを仮定している。

* 関連端に多重度が示されていないならば、
  それは多重度がちょうど 1 であることを示唆する。

* 関連端にラベルが付いていないならば、
  その端点のデフォルトの名前は、取り付けられているクラスの名前から、
  頭文字を小文字に変えたものとする。

  ただ、non-navigable な関連端にはしばしばラベルを付けないままである
  （名前が Association Descriptions の節に文書化されている場合であっても）。

* 明示的に命名されていない関連については、次のルールに従い「構築」する (p. 19)。
  ここで ``<association-end-nameX>`` はそれぞれの関連端の名前とする。

  .. code-block:: text

     "A_" <association-end-name1> "_" <association-end-name2>

  つまり、関連の名前はその両端点の名前から一意に決まるということだ。

  * 視覚的には矢印が name2 から name1 に向いていることが極めて多い。
  * この記法はたいへん便利なので、次章以降のノートで私も多用する。

.. note::

   ドット記法と矢印記法と ``{subsets}`` を例示するためのイラストをここに載せる。
   左側のクラス図は次章の最初に出て来るものであり、
   右側の文の羅列はここにある矢印から読み取れる、所有権や航行可能性の情報である。
   矢印自体は例えば A_relatedElement_relationship のように呼ぶことができる。

   .. figure:: /_images/omg15-diagram-format.png
      :align: center
      :alt: Diagram Format

6.5 Acknowledgements
======================================================================
仕様書の著者、技術支援提供者、査読者、投稿者、寄稿者等々に対する謝意を表している。

.. include:: /_include/uml-refs.txt
