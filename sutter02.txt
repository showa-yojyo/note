======================================================================
More Exceptional C++ 読書ノート
======================================================================

2009 年の正月だったと思う。
かの名著 Exceptional C++ の続編を秋葉原駅前ヨドバシの有隣堂書店で発見した。
前作が「本物」であったがゆえに、本書も購入してみたのだが───。

:著者: Herb Sutter
:訳者: 浜田真理
:出版社: ピアソン・エデュケーション
:ISBN: 978-4-89471-483-0

.. contents:: ノート目次

序章
======================================================================
* <古代ギリシャの哲学者ソクラテスは、問答によって弟子に伝授した>
  →ソクラテスメソッド
* <標準 C++ と標準ライブラリの効果的な利用方法>
* <合理的根拠>
* 本書は <標準ライブラリの効果的な使用方法に重点を置いている> と繰り返す。
* 読者に求める前提条件として、<古典的な名著> である
  Bjarne Stroustrup, "The C++ Programming Language" やら
  Stan Lippman and Josee Lajoie, "C++ Primer" を挙げている。
  これらの本は分厚くて、まともに読みこなせなかったことを思い出した。

* <特に、私の管理下にないものは移動する。>
* <インターネット社会における印刷メディアの過酷な状況>

* 著者は本書レビュアーに対して
  <酷評を惜しみなく浴びせてくださいました> と礼を述べている。

汎用プログラミングと C++ 標準ライブラリ
=======================================
前作にも同じテーマの章があった。

ストリームの操作
-----------------------------------
* <``basic_ostream`` が、 ``basic_streambuf`` オブジェクトを入力として受け付ける
  ``operator<<()`` を提供> (p. 3) しているので、ここでの回答である
  ``cout << cin.rgbuf()`` の形を着想できる。
* ``is_open()`` はこういう形でないと使わないな。
* <均衡のとれた判断> <適切な妥協点> (p. 5)
* <拡張性を考慮した設計がしばしばカプセル化を意味している> (p. 6)
* <関連性の分離を適切に行う> (p. 6) 

ステートフル述語
-----------------------------------
* <一般に「ステートフル」であると言えば、変更可能な状態のことを意味する。
  したがって、ステートフル述語においては適用過程の順が重要になる> (p. 14)
* <ステートフル述語とそれ以外の述語には重要な相違点がある> (p. 15)
  と切り出して、ステートフル述語のコピーがオリジナルと等価とならないものと、
  適用順が不定の実装であるような ``remove_if`` についての思考実験を始める。
  それで標準アルゴリズムの要件が厳密には足りていないよ、と著者は指摘したい。

継承と特性 (traits)
-----------------------------------
クラステンプレート ``traits`` について。

* テンプレートの特殊化がキモ。
* ``std::char_traits<T>``
* [C++98] 17.1.18
* Requirements - 制約クラス

* <``B`` の意味がわからない限り、 ``instantiated_type`` についてもわからない> (p. 35)
* <空の基底クラス ``X_base`` は、 ``typedef`` を提供するためだけに存在している。
  しかしながら、通常、派生クラスはそれを再度 ``typedef`` し直す。
  無駄ではないだろうか？> (p. 36)

* 追記のコードをコンパイルしたいが、手許に環境がない。残念。

コンテナではないコンテナ
-----------------------------------
* スタニスラウって誰だ。
* <ポインタが無効化される時期にさえ注意すれば安全だ。
  それはまた、イテレータが無効化される時期でもある> (p. 39)::

    vector<char> v;
    // ...
    char* p = &v[0];
    // ...

* ``map<Name, PhoneNumber>`` の逆方向検索マップが
  ``map<PhoneNumber*, Name*, Deref>`` になるのが面白い。

* 某書にもあるが <``std::vector<bool>`` はその「どんなコンテナ」に含まれない> (p. 41)
* <「プロキシコンテナ」とは、オブジェクトに対する直接的なアクセスや操作ができないコンテナのことである> (p. 42)
* <``vector<bool>`` のアクセスは遅い> (p. 43)

* <``vector<bool>`` は、プロキシコンテナの実装例を示すことが目的の一部であり、
  ディスクベースのコンテナや、直接的なアクセスが難しいオブジェクトのコンテナを実装する際の手本にもなるはずだった。
  だが同時に、標準コンテナの要求によってプロキシコンテナが許されないという実例にもなってしまったのだ> (p. 44)

* <プロファイラや他のテストを実施しておけば、
  その最適化が本当に改善となるかどうかわかる> (p. 45) →実測が基本。

* <``vector<bool>`` の代わりに（略）
  ``deque<bool>`` を使う方が良い> (p. 46)

* もう一回ノートしておこう。<実測上の証拠を握るまで> (p. 47) 最適化はしない。

最適化と効率
===================================

例外安全問題とテクニック
===================================

継承とポリモルフィズム
===================================

メモリとリソースの管理
===================================

フリー関数とマクロ
===================================

各種トピック
===================================

あとがき以降のノート
===================================
