======================================================================
More Exceptional C++ 読書ノート
======================================================================

2009 年の正月だったと思う。
かの名著 Exceptional C++ の続編を秋葉原駅前ヨドバシの有隣堂書店で発見した。
前作が「本物」であったがゆえに、本書も購入してみたのだが───。

:著者: Herb Sutter
:訳者: 浜田真理
:出版社: ピアソン・エデュケーション
:ISBN: 978-4-89471-483-0

.. contents:: ノート目次

序章
======================================================================
* <古代ギリシャの哲学者ソクラテスは、問答によって弟子に伝授した>
  →ソクラテスメソッド
* <標準 C++ と標準ライブラリの効果的な利用方法>
* <合理的根拠>
* 本書は <標準ライブラリの効果的な使用方法に重点を置いている> と繰り返す。
* 読者に求める前提条件として、<古典的な名著> である
  Bjarne Stroustrup, "The C++ Programming Language" やら
  Stan Lippman and Jose&#x099E;e Lajoie, "C++ Primer" を挙げている。
  これらの本は分厚くて、まともに読みこなせなかったことを思い出した。

* <特に、私の管理下にないものは移動する。>
* <インターネット社会における印刷メディアの過酷な状況>

* 著者は本書レビュアーに対して
  <酷評を惜しみなく浴びせてくださいました> と礼を述べている。

汎用プログラミングと C++ 標準ライブラリ
=======================================
前作にも同じテーマの章があった。

ストリームの操作
-----------------------------------
* <``basic_ostream`` が、 ``basic_streambuf`` オブジェクトを入力として受け付ける
  ``operator<<()`` を提供> (p. 3) しているので、ここでの回答である
  ``cout << cin.rgbuf()`` の形を着想できる。
* ``is_open()`` はこういう形でないと使わないな。
* <均衡のとれた判断> <適切な妥協点> (p. 5)
* <拡張性を考慮した設計がしばしばカプセル化を意味している> (p. 6)
* <関連性の分離を適切に行う> (p. 6) 

ステートフル述語
-----------------------------------
* <一般に「ステートフル」であると言えば、変更可能な状態のことを意味する。
  したがって、ステートフル述語においては適用過程の順が重要になる> (p. 14)
* <ステートフル述語とそれ以外の述語には重要な相違点がある> (p. 15)
  と切り出して、ステートフル述語のコピーがオリジナルと等価とならないものと、
  適用順が不定の実装であるような ``remove_if`` についての思考実験を始める。
  それで標準アルゴリズムの要件が厳密には足りていないよ、と著者は指摘したい。

継承と特性 (traits)
-----------------------------------
クラステンプレート ``traits`` について。

* テンプレートの特殊化がキモ。
* ``std::char_traits<T>``
* [C++98] 17.1.18
* Requirements - 制約クラス

* <``B`` の意味がわからない限り、 ``instantiated_type`` についてもわからない> (p. 35)
* <空の基底クラス ``X_base`` は、 ``typedef`` を提供するためだけに存在している。
  しかしながら、通常、派生クラスはそれを再度 ``typedef`` し直す。
  無駄ではないだろうか？> (p. 36)

* 追記のコードをコンパイルしたいが、手許に環境がない。残念。

コンテナではないコンテナ
-----------------------------------
* スタニスラウって誰だ。
* <ポインタが無効化される時期にさえ注意すれば安全だ。
  それはまた、イテレータが無効化される時期でもある> (p. 39)::

    vector<char> v;
    // ...
    char* p = &v[0];
    // ...

* ``map<Name, PhoneNumber>`` の逆方向検索マップが
  ``map<PhoneNumber*, Name*, Deref>`` になるのが面白い。

* 某書にもあるが <``std::vector<bool>`` はその「どんなコンテナ」に含まれない> (p. 41)
* <「プロキシコンテナ」とは、オブジェクトに対する直接的なアクセスや操作ができないコンテナのことである> (p. 42)
* <``vector<bool>`` のアクセスは遅い> (p. 43)

* <``vector<bool>`` は、プロキシコンテナの実装例を示すことが目的の一部であり、
  ディスクベースのコンテナや、直接的なアクセスが難しいオブジェクトのコンテナを実装する際の手本にもなるはずだった。
  だが同時に、標準コンテナの要求によってプロキシコンテナが許されないという実例にもなってしまったのだ> (p. 44)

* <プロファイラや他のテストを実施しておけば、
  その最適化が本当に改善となるかどうかわかる> (p. 45) →実測が基本。

* <``vector<bool>`` の代わりに（略）
  ``deque<bool>`` を使う方が良い> (p. 46)

* もう一回ノートしておこう。<実測上の証拠を握るまで> (p. 47) 最適化はしない。

vector と deque
-----------------------------------
* 配列でなく vector を利用する理由は
  <コンテナの抽象化やカプセル化という点において配列よりも優れており、
  簡単かつ安全に利用できるから> (p. 48)
* <コンテナ自体とサイズを別々に管理する必要がない> (p. 49)
* 配列と vector の交換可能性については
  <現在、標準は、vector の要素が配列と同じフォーマットで連続に格納されることを要求している> (p. 50)
  ので、安心してレガシーコードに ``&v[0]`` を渡せる。

* <実のところ、これらの関数を持つことが vector の欠点なのである> (p. 50) という指摘は面白い。
  <これらの関数> というのは capacity と reserve のことなのだが。

* 今となってはおなじみの、消費メモリ削減テク「一時オブジェクトと swap イディオム」を紹介している。

set と map
-----------------------------------
何に役立てるのかはわからないが、既存 map オブジェクトのキー、
すなわち map::iterator の first メンバーを無理やり書き換える方法を議論する。

* <キーの比較には、必ず引数の Compare 型が使われる> (p. 55)
* <問題となるのは、コンテナに挿入済みのキーの相対順を変更するコードだ> (p. 57)

等価なコード？
-----------------------------------
* f が関数型マクロならば <ステートメント ``f(a++)`` はどのような意味にもなり得る> (p. 62)
  ``#define f(x) (x,x,x,x,x,x,x,x,x)`` の例を出して説得力を補強。
  C++ ではマクロの仕様は可能な限り避ける。

* <「無効なイテレータの使用」のバグは非常に見つけにくいからだ
  （チェックバージョンのライブラリ実装でデバッグするのが好きならば、話は別だが）> (p. 65)
  チェックバージョンは動作が当然遅いので、
  プロジェクト内容によってはオプションをオフにしている場合すらある。

テンプレートの特殊化とオーバーロード
------------------------------------
個人的にテンプレートの特殊化は興味がないので読み飛ばす。
それにしても、本項目オチの一文が強烈な皮肉だ。

マスターマインドゲーム
-----------------------------------
* <厳格かつ健全なソフトウェアエンジニアリングが本書の目的である> (p. 72) が、ここで羽目を外す。
  <ステートメントの区切り子としてセミコロンの代わりにカンマを可能な限り使うことにした> (p. 73)
  やら <if/else の代わりに 3 項演算子 (?:) を使うことにした> (p. 73) などやりたい放題。

* <``inner_product()`` という名前がまだ気になるならば、
  この標準アルゴリズムを ``accumulate()`` と ``transform()`` の合成だと考えればよい> (p. 81)

* <実社会の商用コードではめったに使わないカンマ演算子> (p. 84)

最適化と効率
===================================
inline
-----------------------------------
個人的には inline は最近本当に使わなくなった。コンパイラーに任せた方が利口だもの。

* <そもそも何を最適化したいのか定義せずに答えようとしても意味がない> (p. 88)
  と切り出し、候補対象を列挙していく。
  個人的には開発速度とビルド時間を優先したいところだ。

* ここでも実測主義が全面に出る。この姿勢は本書中で一貫していて気持ちがいい。
  <通常、実測に基づいた証拠だけが真のホットスポットを言い当てることができる> (p. 90)

* <このような場合でも、やはりプロファイラを使い、
  そのアドバイスにしたがって最適化を行うべきである> (p. 90)

* 最後に <インラインコードはモジュール間の結合を強める> (p. 90)
  と締めくくり、読者にあてずっぽな inline の使用を戒めることを忘れない。

遅延最適化 Part 1
-----------------------------------
* <一般に、最高のパフォーマンスを示す方法は指数拡張である> (p. 94)
* <Koenig は、指数拡張における最良の指数が一般に 2 ではない理由を説明している> (p. 94)

遅延最適化 Part 2
-----------------------------------
* <コピー処理を後回しにするため、
  ``String`` オブジェクト内部でバッファを共有させよう> (p. 95)
  ``String`` クラスを ``String`` と ``StringBuf`` に分離して、
  後者をコピー不可能なクラスとして、
  ``String`` オブジェクト同士で共有する作戦らしい。

* 「参照回数」は ``StringBuf`` の内部にあるが、これを更新するのは ``String`` のメンバー。
* 遅延コピーを実装するので、コピーコンストラクターは「浅いコピー」になる。
* <``AboutToModify()`` は、まだ実行していなければ「深い」コピーを遅延実行して、
  内部バッファの非共有を保証する> (p. 97)

遅延最適化 Part 3
-----------------------------------
* <``operator[]()`` はそれほど簡単ではない> (p. 100)
  <少なくとも、内部表現が共有されていないことを保証する必要がある> (p. 101)
  どんどん話が複雑になってきて、<シングルスレッド環境ならば、
  まあ、こんなところだろう> (p. 105) と不吉な伏線を張る。

遅延最適化 Part 4
-----------------------------------
* ``AboutToModify`` の最初の if 文の条件式がスレッドセーフではないことに気付けないとダメか。
* 脚注にいいことが書いてある。
  Win32 では効率の点から <できる限りクリティカルセクションを利用すべき> (p. 111) だそうだ。

* <「深いコピー」の間、ずっとロックを取得していることに注意しよう> (p. 113)
  例示のためにちょっと手抜きをしているようだ。

* <ロックが必要な操作は ``refs`` へのアクセスだけである、ということに注意しよう> (p. 114)

例外安全問題とテクニック
===================================
<C++ 標準ライブラリを使うのであれば、例外に備える必要がある> (p. 119)

継承とポリモルフィズム
===================================

メモリとリソースの管理
===================================

フリー関数とマクロ
===================================

各種トピック
===================================

あとがき以降のノート
===================================
