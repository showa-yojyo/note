
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promises, async/await &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/mermaid.js"></script>
    <link rel="next" title="Generators, advanced iteration" href="12-generators-iterators.html" />
    <link rel="prev" title="Error handling" href="10-error-handling.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="10-error-handling.html" title="Previous document">Error handling</a>
        </li>
        <li>
          <a href="12-generators-iterators.html" title="Next document">Generators, advanced iteration</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="promises-async-await">
<h1><a class="toc-backref" href="#id5">Promises, async/await</a><a class="headerlink" href="#promises-async-await" title="Permalink to this heading">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#promises-async-await" id="id5">Promises, async/await</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction-callbacks" id="id6">Introduction: callbacks</a></p></li>
<li><p><a class="reference internal" href="#promise" id="id7">Promise</a></p></li>
<li><p><a class="reference internal" href="#promises-chaining" id="id8">Promises chaining</a></p></li>
<li><p><a class="reference internal" href="#error-handling-with-promises" id="id9">Error handling with promises</a></p></li>
<li><p><a class="reference internal" href="#promise-api" id="id10">Promise API</a></p></li>
<li><p><a class="reference internal" href="#promisification" id="id11">Promisification</a></p></li>
<li><p><a class="reference internal" href="#microtasks" id="id12">Microtasks</a></p></li>
<li><p><a class="reference internal" href="#async-await" id="id13">Async/await</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction-callbacks">
<h2><a class="toc-backref" href="#id6">Introduction: callbacks</a><a class="headerlink" href="#introduction-callbacks" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/callbacks">https://javascript.info/callbacks</a>&gt; のノート。</p>
<p>この章では各種抽象的概念の使い方を示すために、ブラウザーのメソッドをいくつか使用する。具体的には、スクリプトの読み込みと簡単な文書操作だ。</p>
<ul class="simple">
<li><p>非同期アクションとは、今始めたアクションが、後で終了するようなものを意味するらしい。</p></li>
<li><p>最初の <code class="docutils literal notranslate"><span class="pre">loadScript()</span></code> は常識らしい。このコードは非同期的に処理される。つまり、スクリプトのロードが完了する前に、この関数の実行が終了することが一般的だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">script.onload</span></code> にコールバックを指定する。スクリプトのロードが完了すると、呼び出されることになる関数だ。</p></li>
</ul>
<p>コールバックベース非同期処理の問題点を理解すること。</p>
<div class="section" id="callback-in-callback">
<h3>Callback in callback<a class="headerlink" href="#callback-in-callback" title="Permalink to this heading">¶</a></h3>
<p>三つのスクリプトを厳密に特定の順序でロードするには、このように
<code class="docutils literal notranslate"><span class="pre">loadScript()</span></code> のコールバックに <code class="docutils literal notranslate"><span class="pre">loadScript()</span></code> を含めることになる。</p>
<p>コードのインデントの深い部分にあるほど、ロード順序が遅い。</p>
</div>
<div class="section" id="handling-errors">
<h3>Handling errors<a class="headerlink" href="#handling-errors" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">script.onload</span></code> と <code class="docutils literal notranslate"><span class="pre">script.onerror</span></code> をセットで覚える。成功時と失敗時とでコールバックを使い分ける仕組みを理解する。</p>
<p>本文の例では、両方に同じコールバック関数を指定して、呼び出された時の引数で成功か失敗かを区別、処理する方針を採っている。</p>
</div>
<div class="section" id="pyramid-of-doom">
<h3>Pyramid of Doom<a class="headerlink" href="#pyramid-of-doom" title="Permalink to this heading">¶</a></h3>
<p>複数の非同期アクションが次々と続くと、本文のようなインデントの深いコードが出来上がる。これはコードの管理をひじょうにやりにくい構造だ。</p>
<p>そこで、複数の非同期アクションを個別の関数にまとめて、インデントの深いコードを解消することを考える。これでいちおう解決するが、関連のある処理が別々の場所に散ってしまい、全体の凝集度が下がってしまう。</p>
</div>
</div>
<div class="section" id="promise">
<h2><a class="toc-backref" href="#id7">Promise</a><a class="headerlink" href="#promise" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/promise-basics">https://javascript.info/promise-basics</a>&gt; のノート。</p>
<p>マルチスレッド処理でよく説明される consumer/producer のパターンで理解する。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// the producing code</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> に渡す関数を executor と言う。その引数 <code class="docutils literal notranslate"><span class="pre">resolve</span></code>, <code class="docutils literal notranslate"><span class="pre">reject</span></code> がそれぞれ前項の <code class="docutils literal notranslate"><span class="pre">onload</span></code>, <code class="docutils literal notranslate"><span class="pre">onerror</span></code> に対応する。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Callback</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">resolve(value)</span></code></p></td>
<td><p>実行が成功するとその結果 <code class="docutils literal notranslate"><span class="pre">value</span></code>
を取って呼び出される</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">reject(error)</span></code></p></td>
<td><p>エラーが起こるとエラーオブジェクト <code class="docutils literal notranslate"><span class="pre">error</span></code>
を取って呼び出される</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> が返すオブジェクトには次の隠しプロパティーがある：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span></code></p>
<ul>
<li><p>初期値は文字列 “pending”</p></li>
<li><p>それから実行結果にしたがって文字列 “fulfilled” または “rejected” に変化する。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">result</span></code></p>
<ul>
<li><p>初期値は <code class="docutils literal notranslate"><span class="pre">undefined</span></code></p></li>
<li><p>それから実行結果にしたがって <code class="docutils literal notranslate"><span class="pre">resolve</span></code> の実引数である <code class="docutils literal notranslate"><span class="pre">value</span></code> または
<code class="docutils literal notranslate"><span class="pre">reject(error)</span></code> の実引数 <code class="docutils literal notranslate"><span class="pre">error</span></code> に変化する。</p></li>
</ul>
</li>
</ul>
<p>どちらのコールバックにおいても、結果オブジェクトは一つしか指定できない。</p>
<p>コールバック <code class="docutils literal notranslate"><span class="pre">reject</span></code> の実引数は <code class="docutils literal notranslate"><span class="pre">Error</span></code> 型であることが望ましい。</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> executor はふつうは非同期的な処理を行うが、直ちに処理してコールバックを呼び出して終了してもかまわない。</p>
<div class="admonition- admonition">
<p class="admonition-title">学習者ノート</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> の基本動作を確認しておくといい。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="s2">&quot;POOR&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">e</span><span class="p">));</span>

<span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="s2">&quot;POOR&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">e</span><span class="p">));</span>

<span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="s2">&quot;OK&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">e</span><span class="p">));</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">resolve()</span></code> も <code class="docutils literal notranslate"><span class="pre">reject()</span></code> も呼び出さないままでいると、内部状態は pending
のまま変わらない。</p>
<p>Python での「等価物」は <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> 周りの機能ということになるのだろう。
<code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code> も関係する。</p>
</div>
<div class="section" id="consumers-then-catch-finally">
<h3>Consumers: then, catch, finally<a class="headerlink" href="#consumers-then-catch-finally" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> のメソッド <code class="docutils literal notranslate"><span class="pre">then</span></code>, <code class="docutils literal notranslate"><span class="pre">catch</span></code>, <code class="docutils literal notranslate"><span class="pre">finally</span></code> を見ていく。</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> オブジェクトは producer と、結果やエラーを受け取る consumer の間にある。
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> のこれら三つのメソッドに渡すものが consumer だと考えられる。</p>
<div class="section" id="then">
<h4>then<a class="headerlink" href="#then" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Primise</span></code> のメソッドでいちばん基本的かつ重要なのは <code class="docutils literal notranslate"><span class="pre">then</span></code> だ。その引数リストは
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> のコンストラクター関数と同様だ：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
    <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* handle a successful result */</span> <span class="p">},</span>
    <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* handle an error */</span> <span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>第一引数のコールバックは <code class="docutils literal notranslate"><span class="pre">promise</span></code> がその <code class="docutils literal notranslate"><span class="pre">resolve</span></code> を呼び出しで終了したとき、その結果 <code class="docutils literal notranslate"><span class="pre">result</span></code> を伴って呼び出される。</p></li>
<li><p>第二引数のコールバックは <code class="docutils literal notranslate"><span class="pre">promise</span></code> が <code class="docutils literal notranslate"><span class="pre">rejecct</span></code> 呼び出しで終了したときに、その結果 <code class="docutils literal notranslate"><span class="pre">error</span></code> を伴って呼び出される。</p></li>
</ul>
<p>したがって、成功したときにしか興味がない場合には第一コールバックだけ渡せばいい。</p>
</div>
<div class="section" id="catch">
<h4>catch<a class="headerlink" href="#catch" title="Permalink to this heading">¶</a></h4>
<p>反対に、失敗したときにしか興味がない場合には <code class="docutils literal notranslate"><span class="pre">promise.catch</span></code> を呼び出す。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.catch(f)</span></code> の指定は <code class="docutils literal notranslate"><span class="pre">.then(null,</span> <span class="pre">f)</span></code> と同値。</p></li>
</ul>
</div>
<div class="section" id="finally">
<h4>finally<a class="headerlink" href="#finally" title="Permalink to this heading">¶</a></h4>
<p>成功でも失敗でも行いたい処理を <code class="docutils literal notranslate"><span class="pre">promise.finally</span></code> で呼び出す。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">finally</span></code> のコールバックには引数がない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">finally</span></code> のコールバックの結果は次のハンドラーに引き継がれる。</p></li>
</ul>
</div>
</div>
<div class="section" id="example-loadscript">
<h3>Example: loadScript<a class="headerlink" href="#example-loadscript" title="Permalink to this heading">¶</a></h3>
<p>前章の <code class="docutils literal notranslate"><span class="pre">loadScript</span></code> をコールバックベースから <code class="docutils literal notranslate"><span class="pre">Promise</span></code> ベースに書き換える。</p>
</div>
<div class="section" id="tasks">
<h3>Tasks<a class="headerlink" href="#tasks" title="Permalink to this heading">¶</a></h3>
<div class="section" id="re-resolve-a-promise">
<h4>Re-resolve a promise?<a class="headerlink" href="#re-resolve-a-promise" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">resolve()</span></code> 呼び出しは最初の一度しか意味がない。</p>
</div>
<div class="section" id="delay-with-a-promise">
<h4>Delay with a promise<a class="headerlink" href="#delay-with-a-promise" title="Permalink to this heading">¶</a></h4>
<p>さっきの <code class="docutils literal notranslate"><span class="pre">loadScript</span></code> と同じ要領で <code class="docutils literal notranslate"><span class="pre">Promise</span></code> ベースのコードを書く。</p>
</div>
<div class="section" id="animated-circle-with-promise">
<h4>Animated circle with promise<a class="headerlink" href="#animated-circle-with-promise" title="Permalink to this heading">¶</a></h4>
<p>これは後日、相当未来になるだろうが、取り組む。</p>
</div>
</div>
</div>
<div class="section" id="promises-chaining">
<h2><a class="toc-backref" href="#id8">Promises chaining</a><a class="headerlink" href="#promises-chaining" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/promise-chaining">https://javascript.info/promise-chaining</a>&gt; のノート。</p>
<p>次々と実行される非同期処理の連なりを <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を使って書くことができる。
<code class="docutils literal notranslate"><span class="pre">then</span></code> を呼び出すたびに新しい <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返すようにして、そこにメソッド
<code class="docutils literal notranslate"><span class="pre">then</span></code> 呼び出しを連鎖するのが急所だ。</p>
<p>同一の <code class="docutils literal notranslate"><span class="pre">Promise</span></code> オブジェクトに対してメソッド <code class="docutils literal notranslate"><span class="pre">then</span></code> を何度も呼び出すということは普通はない。</p>
<div class="section" id="returning-promises">
<h3>Returning promises<a class="headerlink" href="#returning-promises" title="Permalink to this heading">¶</a></h3>
<p>メソッド <code class="docutils literal notranslate"><span class="pre">then</span></code> に渡すコールバックは <code class="docutils literal notranslate"><span class="pre">Promise</span></code> オブジェクトを返すことができる。すると、次の <code class="docutils literal notranslate"><span class="pre">then</span></code> 呼び出しが書け、そのコールバックの実引数は <code class="docutils literal notranslate"><span class="pre">Promise</span></code> のコールバックの結果を取る。</p>
</div>
<div class="section" id="example-loadscript-1">
<span id="id1"></span><h3>Example: loadScript<a class="headerlink" href="#example-loadscript-1" title="Permalink to this heading">¶</a></h3>
<p>本文の二つの <code class="docutils literal notranslate"><span class="pre">loadScript</span></code> の連続呼び出しのコードを見比べること。メソッド
<cite>then`</cite> の呼び出しのケツにさらに <code class="docutils literal notranslate"><span class="pre">then</span></code> の呼び出しを重ねる方式のほうが望ましい。</p>
<ul class="simple">
<li><p>厳密には、 <code class="docutils literal notranslate"><span class="pre">then</span></code> の連鎖を形成したいならば、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返す必要はない。代わりに同じ仕様のメソッド <code class="docutils literal notranslate"><span class="pre">then</span></code> を実装したオブジェクトを生成して返すのもアリだ。</p></li>
</ul>
</div>
<div class="section" id="bigger-example-fetch">
<h3>Bigger example: fetch<a class="headerlink" href="#bigger-example-fetch" title="Permalink to this heading">¶</a></h3>
<p>ネットワークリクエストには <code class="docutils literal notranslate"><span class="pre">Promise</span></code> がよく用いられる。</p>
<p>リモートサーバーから情報を読み込むにはメソッド <code class="docutils literal notranslate"><span class="pre">fetch</span></code> を使用する。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>この <code class="docutils literal notranslate"><span class="pre">promise</span></code> は、リモートサーバーがヘッダーで応答したときに、応答オブジェクトで解決される。ただし、完全な応答がダウンロードされるよりも前だ。</p></li>
<li><p>完全な応答を読むにはメソッド <code class="docutils literal notranslate"><span class="pre">response.text()</span></code> を呼び出す。これも <code class="docutils literal notranslate"><span class="pre">Promise</span></code>
を返し、リモートサーバーからテキスト全部がダウンロードされたときに、そのテキストを結果にして解決するものだ。</p></li>
</ul>
<p>非同期処理はつねに <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返すのが good practice だ。</p>
</div>
<div class="section" id="id2">
<h3>Tasks<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<div class="section" id="promise-then-versus-catch">
<h4>Promise: then versus catch<a class="headerlink" href="#promise-then-versus-catch" title="Permalink to this heading">¶</a></h4>
<p>念のため、このコードが動作するような <code class="docutils literal notranslate"><span class="pre">promise</span></code>, <code class="docutils literal notranslate"><span class="pre">f1</span></code>, <code class="docutils literal notranslate"><span class="pre">f2</span></code> を書いて検証するのがいいと思われる。</p>
</div>
</div>
</div>
<div class="section" id="error-handling-with-promises">
<h2><a class="toc-backref" href="#id9">Error handling with promises</a><a class="headerlink" href="#error-handling-with-promises" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/promise-error-handling">https://javascript.info/promise-error-handling</a>&gt; のノート。</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> 鎖の構造はエラー処理にも向いている。</p>
<ul class="simple">
<li><p>チェインのケツで <code class="docutils literal notranslate"><span class="pre">catch()</span></code> を呼び出すと、どのステップの例外もここで捕捉される。</p></li>
</ul>
<div class="section" id="implicit-try-catch">
<h3>Implicit try…catch<a class="headerlink" href="#implicit-try-catch" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> executor やコールバックの周りには見えない <code class="docutils literal notranslate"><span class="pre">try</span></code> ブロックがあると考える。エラーが起こると、それを捕まえて reject するように扱う。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Whoops!&quot;</span><span class="p">);</span> <span class="c1">// == reject(new Error(&quot;Whoops!&quot;));</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">alert</span><span class="p">);</span>

<span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="s2">&quot;ok&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">((</span><span class="nx">result</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Whoops!&quot;</span><span class="p">);</span> <span class="c1">// == reject(new Error(&quot;Whoops!&quot;));</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">alert</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="rethrowing">
<h3>Rethrowing<a class="headerlink" href="#rethrowing" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">catch</span></code> コールバックで捕まえたエラーを処理できないことがわかったら、
<code class="docutils literal notranslate"><span class="pre">try...catch</span></code> 文と同様に、再送出すること。次の <code class="docutils literal notranslate"><span class="pre">catch</span></code> コールバックがそれを捕まえる。</p>
</div>
<div class="section" id="unhandled-rejections">
<h3>Unhandled rejections<a class="headerlink" href="#unhandled-rejections" title="Permalink to this heading">¶</a></h3>
<p>ブラウザーの場合には、 <code class="docutils literal notranslate"><span class="pre">Promise</span></code> が送出した捕捉されなかった例外を扱うイベントハンドラーがある。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;unhandledrejection&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
<span class="p">});</span>
</pre></div>
</div>
<ul class="simple">
<li><p>ハンドラーの引数 <code class="docutils literal notranslate"><span class="pre">event</span></code> にはプロパティーが二つある。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">promise</span></code>: エラーを送出した <code class="docutils literal notranslate"><span class="pre">Promise</span></code> オブジェクト</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reason</span></code>: 処理されなかったエラーオブジェクトそのもの</p></li>
</ul>
</li>
</ul>
<p>エラーが <code class="docutils literal notranslate"><span class="pre">Promise</span></code> 内で発生し、かつ処理できた <code class="docutils literal notranslate"><span class="pre">catch</span></code> がない場合、
<code class="docutils literal notranslate"><span class="pre">unhandledrejection</span></code> ハンドラーが反応し、エラーに関する情報を持つイベントオブジェクトを得る。</p>
<p>通常、このようなエラーは回復不能だ。ユーザーに問題を通知し、サーバーに事故を報告することくらいしかやることがない。</p>
<ul class="simple">
<li><p>Node.js のような非ブラウザー環境では、処理されないエラーを追跡する方法が他にある。</p></li>
</ul>
</div>
<div class="section" id="id3">
<h3>Tasks<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<div class="section" id="error-in-settimeout">
<h4>Error in setTimeout<a class="headerlink" href="#error-in-settimeout" title="Permalink to this heading">¶</a></h4>
<p>これを <code class="docutils literal notranslate"><span class="pre">catch</span></code> できないのは困ったものだ。エラー処理ごと <code class="docutils literal notranslate"><span class="pre">setTimeout</span></code> するしかない。</p>
</div>
</div>
</div>
<div class="section" id="promise-api">
<h2><a class="toc-backref" href="#id10">Promise API</a><a class="headerlink" href="#promise-api" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/promise-api">https://javascript.info/promise-api</a>&gt; のノート。</p>
<p>クラスメソッドの紹介。</p>
<div class="section" id="promise-all">
<h3>Promise.all<a class="headerlink" href="#promise-all" title="Permalink to this heading">¶</a></h3>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">iterable</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> は並行処理を join するイメージでよい。結果からなる配列を返す。エラーがなにか一つでも発生すると、すべてが無になる。また、未済処理が中断されるようなことはない。All or nothing な条件のときに利用するといい。</p>
</div>
<div class="section" id="promise-allsettled">
<h3>Promise.allSettled<a class="headerlink" href="#promise-allsettled" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Promise.allSettled()</span></code> はそのマイルド版。すべての結果を求める場合には採用する。</p>
<p>結果は次のオブジェクトからなる配列だ：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{status:</span> <span class="pre">&quot;fulfilled&quot;,</span> <span class="pre">value:</span> <span class="pre">result}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{status:</span> <span class="pre">&quot;rejected&quot;,</span> <span class="pre">reason:</span> <span class="pre">error}</span></code></p></li>
</ul>
<div class="section" id="polyfill">
<h4>Polyfill<a class="headerlink" href="#polyfill" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Promise.allSettled</span></code> の実装例。</p>
</div>
</div>
<div class="section" id="promise-race">
<h3>Promise.race<a class="headerlink" href="#promise-race" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Promise.all</span></code> と似ているが、最初に決済された promise だけを待ち、その結果またはエラーを得る。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">(</span><span class="nx">iterable</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="promise-any">
<h3>Promise.any<a class="headerlink" href="#promise-any" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Promise.race</span></code> と似ている。最初に成功した promise だけを待ち、その結果を得る。与えられた promise がすべて reject された場合、返された promise は
<code class="docutils literal notranslate"><span class="pre">AggregateError</span></code> で reject される。これにはエラー全てをが含むプロパティー
<code class="docutils literal notranslate"><span class="pre">errors</span></code> がある。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nx">iterable</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="promise-resolve-reject">
<h3>Promise.resolve/reject<a class="headerlink" href="#promise-resolve-reject" title="Permalink to this heading">¶</a></h3>
<p>現代では <code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code> 文がある。これらのメソッドはめったに用いられない。</p>
<div class="section" id="promise-resolve">
<h4>Promise.resolve<a class="headerlink" href="#promise-resolve" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Promise.resolve(value)</span></code> は次と同じ：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="promise-reject">
<h4>Promise.reject<a class="headerlink" href="#promise-reject" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Promise.reject(error)</span></code> は次と同じ：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="promisification">
<h2><a class="toc-backref" href="#id11">Promisification</a><a class="headerlink" href="#promisification" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/promisify">https://javascript.info/promisify</a>&gt; のノート。</p>
<p>コールバックを入力とする関数を <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返す関数に変換することを考える。後者のほうが便利なので、この変換は理にかなう。</p>
<p>本文では関数 <code class="docutils literal notranslate"><span class="pre">loadScript</span></code> を変更せず、それをラップする新しい関数を定義している。</p>
<p>さらに、この考えをもう一歩進めて、「コールバックを入力とする関数を <code class="docutils literal notranslate"><span class="pre">Promise</span></code>
を返す関数に変換する」関数 <code class="docutils literal notranslate"><span class="pre">promisify</span></code> を定義する。このコードを理解するのに時間を要する。</p>
<p>ただし、最初のバージョンはそこまで一般的ではない。関数 <code class="docutils literal notranslate"><span class="pre">promisify</span></code> は、元の関数がちょうど引数 <code class="docutils literal notranslate"><span class="pre">(err,</span> <span class="pre">result)</span></code> をとるコールバックを期待すると仮定している。</p>
<p>もう一度確認するが、コールバックと違って <cite>Promise</cite> は一度きり。</p>
</div>
<div class="section" id="microtasks">
<h2><a class="toc-backref" href="#id12">Microtasks</a><a class="headerlink" href="#microtasks" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/microtask-queue">https://javascript.info/microtask-queue</a>&gt; のノート。</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> のメソッド <code class="docutils literal notranslate"><span class="pre">then</span></code>, <code class="docutils literal notranslate"><span class="pre">catch</span></code>, <code class="docutils literal notranslate"><span class="pre">finally</span></code> はすべて非同期的に呼び出される。これらの呼び出しの下にある行のコードの実行が先に来る。</p>
<div class="section" id="microtasks-queue">
<h3>Microtasks queue<a class="headerlink" href="#microtasks-queue" title="Permalink to this heading">¶</a></h3>
<p>非同期タスクには適切な管理のために内部キュー <code class="docutils literal notranslate"><span class="pre">PromiseJobs</span></code> がある。これは
V8 用語で the microtask queue と呼ばれる。</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> の準備ができると、そのハンドラー各種は FIFO キューに入れられるが、実行はまだされない。現在の実行コードから解放されると、キューからタスクが取り出されて実行される。</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> ハンドラーは常にこの内部キューを通過する。</p>
<p>複数の <code class="docutils literal notranslate"><span class="pre">then</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code>/<code class="docutils literal notranslate"><span class="pre">finally</span></code> を持つ鎖があれば、その一つ一つが非同期に実行される。つまり、まずキューに入り、現在のコードが完了し、以前にキューに入ったハンドラーが終了したときに実行される。</p>
</div>
<div class="section" id="unhandled-rejection">
<h3>Unhandled rejection<a class="headerlink" href="#unhandled-rejection" title="Permalink to this heading">¶</a></h3>
<p>キューの最後に処理されていない promise エラーがあるときに <code class="docutils literal notranslate"><span class="pre">unhandledrejection</span></code>
イベントが発生する。</p>
</div>
</div>
<div class="section" id="async-await">
<h2><a class="toc-backref" href="#id13">Async/await</a><a class="headerlink" href="#async-await" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/async-await">https://javascript.info/async-await</a>&gt; のノート。</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> を効果的に利用するための構文を学ぶ。</p>
<div class="section" id="async-functions">
<h3>Async functions<a class="headerlink" href="#async-functions" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">function</span></code> 宣言された関数は、自動的に中身を resolved な <code class="docutils literal notranslate"><span class="pre">Promise</span></code> に包んで返す。</p>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">async</span></code> がついた関数は、それが <code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返すことを保証し、
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> でないものをそれに包むのだ。</p>
</div>
<div class="section" id="await">
<h3>Await<a class="headerlink" href="#await" title="Permalink to this heading">¶</a></h3>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">await</span></code> は非同期関数の中だけで機能する。例えば、下のコードは
<code class="docutils literal notranslate"><span class="pre">await</span></code> の行で一時停止することになる：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="s2">&quot;done!&quot;</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">});</span>

    <span class="c1">// wait until the promise resolves</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">await</span> <span class="nx">promise</span><span class="p">);</span> <span class="c1">// &quot;done!&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>何かを <code class="docutils literal notranslate"><span class="pre">await</span></code> すると、CPU は終了まで他のコードを実行することができるかもしれない。</p>
<p>現代的なブラウザーでは、モジュール最上位レベルでの <code class="docutils literal notranslate"><span class="pre">await</span></code> がうまく働く。開発ツールの Console でも <code class="docutils literal notranslate"><span class="pre">await</span></code> が可能だ。</p>
<p>厳密には、 <code class="docutils literal notranslate"><span class="pre">await</span></code> を呼び出しに付けたいならば、オペランドは <code class="docutils literal notranslate"><span class="pre">Promise</span></code> である必要はない。代わりに同じ仕様のメソッド <code class="docutils literal notranslate"><span class="pre">then</span></code> を実装したオブジェクトもアリだ。</p>
<p>フリー関数だけでなく、オブジェクトのメソッドに対しても <code class="docutils literal notranslate"><span class="pre">async</span></code> を付けられる。</p>
</div>
<div class="section" id="error-handling">
<h3>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">promise</span></code> は reject された場合には、その行に <code class="docutils literal notranslate"><span class="pre">throw</span></code> 文があるかのようにエラーを送出する。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Whoops!&quot;</span><span class="p">));</span> <span class="c1">// == throw new Error(&quot;Whoops!&quot;);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code> を使う場合には <code class="docutils literal notranslate"><span class="pre">then</span></code> はほとんど必要ない。
<code class="docutils literal notranslate"><span class="pre">await</span></code> が待機時間をプログラマーに代わり処理する。そして <code class="docutils literal notranslate"><span class="pre">catch</span></code> の代わりに通常の <code class="docutils literal notranslate"><span class="pre">try..catch</span></code> を使うことができる。</p>
<p>しかし、コードのトップレベルでは、非同期関数の外にいるとき、文法上 <code class="docutils literal notranslate"><span class="pre">await</span></code> を使えないので、最終結果・エラーを処理する <code class="docutils literal notranslate"><span class="pre">Promise</span></code> の <code class="docutils literal notranslate"><span class="pre">then</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code>
を追加する。これはよくあるやり方だ。</p>
</div>
<div class="section" id="id4">
<h3>Tasks<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<div class="section" id="rewrite-using-async-await">
<h4>Rewrite using async/await<a class="headerlink" href="#rewrite-using-async-await" title="Permalink to this heading">¶</a></h4>
<p>VS Code で書くと、この関数は <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">function</span></code> にできるのではと指摘される。</p>
</div>
<div class="section" id="rewrite-rethrow-with-async-await">
<h4>Rewrite “rethrow” with async/await<a class="headerlink" href="#rewrite-rethrow-with-async-await" title="Permalink to this heading">¶</a></h4>
<p>このような <code class="docutils literal notranslate"><span class="pre">Promise</span></code> の <code class="docutils literal notranslate"><span class="pre">then</span></code> や <code class="docutils literal notranslate"><span class="pre">catch</span></code> 混じりの関数を
<code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code> で書き直すのは、かなり易しい。</p>
</div>
<div class="section" id="call-async-from-non-async">
<h4>Call async from non-async<a class="headerlink" href="#call-async-from-non-async" title="Permalink to this heading">¶</a></h4>
<p>非同期関数を同期関数の内側から呼び出すにはどう書くかという問いだ。これがいちばん易しいが、おそらく念のため出題されている。</p>
</div>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="10-error-handling.html" title="Previous document">Error handling</a>
        </li>
        <li>
          <a href="12-generators-iterators.html" title="Next document">Generators, advanced iteration</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bash-v4.html">What’s New In Bash 4 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-upgrade.html">Python 移行ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power-toys.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pandoc.html">Pandoc 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">The Modern JavaScript Tutorial 読書ノート</a><ul>
  <li><a href="index.html">Part 1 The JavaScript language</a><ul>
      <li>Previous: <a href="10-error-handling.html" title="previous chapter">Error handling</a></li>
      <li>Next: <a href="12-generators-iterators.html" title="next chapter">Generators, advanced iteration</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>