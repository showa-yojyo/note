<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Objects: the basics &#8212; 読書ノート 1.6dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=c9b0a06a" />
    <script src="../../_static/documentation_options.js?v=4354bf25"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="Data types" href="05-data-types.html" />
    <link rel="prev" title="Code quality" href="03-code-quality.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
    <div class="related top">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="03-code-quality.html" title="Previous">Code quality</a>
        </li>
      
        <li>
          &uarr;
          <a href="../index.html" title="Parent">The Modern JavaScript Tutorial 読書ノート</a>
        </li>
        <li>
          &uarr;
          <a href="index.html" title="Parent">Part 1 The JavaScript language</a>
        </li>
        <li>
          <a href="05-data-types.html" title="Next">Data types</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>


          <div class="body" role="main">
            
  <section id="objects-the-basics">
<h1><a class="toc-backref" href="#id4" role="doc-backlink">Objects: the basics</a><a class="headerlink" href="#objects-the-basics" title="Link to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#objects-the-basics" id="id4">Objects: the basics</a></p>
<ul>
<li><p><a class="reference internal" href="#objects" id="id5">Objects</a></p></li>
<li><p><a class="reference internal" href="#object-references-and-copying" id="id6">Object references and copying</a></p></li>
<li><p><a class="reference internal" href="#garbage-collection" id="id7">Garbage collection</a></p></li>
<li><p><a class="reference internal" href="#object-methods-this" id="id8">Object methods, <code class="docutils literal notranslate"><span class="pre">this</span></code></a></p></li>
<li><p><a class="reference internal" href="#constructor-operator-new" id="id9">Constructor, operator <code class="docutils literal notranslate"><span class="pre">new</span></code></a></p></li>
<li><p><a class="reference internal" href="#optional-chaining" id="id10">Optional chaining <code class="docutils literal notranslate"><span class="pre">?.</span></code></a></p></li>
<li><p><a class="reference internal" href="#symbol-type" id="id11">Symbol type</a></p></li>
<li><p><a class="reference internal" href="#object-to-primitive-conversion" id="id12">Object to primitive conversion</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="objects">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Objects</a><a class="headerlink" href="#objects" title="Link to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/object">https://javascript.info/object</a>&gt; のノート。</p>
<p><code class="docutils literal notranslate"><span class="pre">Object</span></code> の基本的構成要素を学ぶ。プロパティーの集まりと考えられる。</p>
<section id="literals-and-properties">
<h3>Literals and properties<a class="headerlink" href="#literals-and-properties" title="Link to this heading">¶</a></h3>
<p>中括弧を用いて定義されたオブジェクトを object literal と呼ぶ。中括弧の内部に
<code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">value</span></code> の列をカンマ区切りで記す。</p>
<ul class="simple">
<li><p>プロパティー値を参照するには <code class="docutils literal notranslate"><span class="pre">obj.key</span> <span class="pre">=</span> <span class="pre">value;</span></code> のようにドット記法を用いる。</p></li>
<li><p>プロパティーを削除するには演算子 <code class="docutils literal notranslate"><span class="pre">delete</span></code> を作用させる。<code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">obj.key;</span></code></p></li>
</ul>
</section>
<section id="square-brackets">
<h3>Square brackets<a class="headerlink" href="#square-brackets" title="Link to this heading">¶</a></h3>
<p>プロパティー値を参照するにはドット記法の他に、角括弧を用いる方法もある。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">obj</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">value</span><span class="p">;</span>
<span class="ow">delete</span><span class="w"> </span><span class="nx">obj</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">];</span>
</pre></div>
</div>
<p>プロパティー名に空白文字が含まれていたり、名前が動的に決定されたりする状況で用いられる。</p>
</section>
<section id="computed-properties">
<h3>Computed properties<a class="headerlink" href="#computed-properties" title="Link to this heading">¶</a></h3>
<p>キーのほうが動的に定義される仕組みがある。これを computed property という。この応用が後ほどたくさん出てくる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">fruit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">prompt</span><span class="p">(</span><span class="s2">&quot;Which fruit to buy?&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;apple&quot;</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">bag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="nx">fruit</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="c1">// e.g. bag.apple == 5</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="property-value-shorthand">
<h3>Property value shorthand<a class="headerlink" href="#property-value-shorthand" title="Link to this heading">¶</a></h3>
<p>属性値の略記法が存在することを確認。キー識別子と値識別子が一致する場合に適用される。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;John&quot;</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">name</span><span class="p">,</span>
<span class="w">    </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="mf">30</span><span class="p">,</span>
<span class="p">};</span>
<span class="c1">// user.name == &quot;John&quot;;</span>
</pre></div>
</div>
</section>
<section id="property-names-limitations">
<h3>Property names limitations<a class="headerlink" href="#property-names-limitations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>キーの型は必要に応じて文字列型に変換される。特に数値。</p></li>
<li><p>便宜上 <code class="docutils literal notranslate"><span class="pre">__proto__</span></code> をここで紹介。</p></li>
</ul>
</section>
<section id="property-existence-test-in-operator">
<h3>Property existence test, “in” operator<a class="headerlink" href="#property-existence-test-in-operator" title="Link to this heading">¶</a></h3>
<p>プロパティーキーの存在テストに演算子 <code class="docutils literal notranslate"><span class="pre">in</span></code> を用いることができる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;key&quot;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">obj</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="the-for-in-loop">
<h3>The <code class="docutils literal notranslate"><span class="pre">for</span></code> … <code class="docutils literal notranslate"><span class="pre">in</span></code> loop<a class="headerlink" href="#the-for-in-loop" title="Link to this heading">¶</a></h3>
<p>オブジェクトのキーを <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">in</span></code> 文で順次アクセスできる。構文：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">object</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// executes the body for each key among object properties</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="ordered-like-an-object">
<h4>Ordered like an object<a class="headerlink" href="#ordered-like-an-object" title="Link to this heading">¶</a></h4>
<p>オブジェクトのキーは特別方法で順序付けられている。</p>
<ul class="simple">
<li><p>キーが数のプロパティーについては、小さい順に配列されている。</p></li>
<li><p>それ以外のプロパティーについては、作成順に配列されている。</p></li>
</ul>
<p>数を引用符で囲んで文字列に見せかけても、小さい順ルールが適用される。</p>
</section>
</section>
<section id="tasks">
<h3>Tasks<a class="headerlink" href="#tasks" title="Link to this heading">¶</a></h3>
<section id="hello-object">
<h4>Hello, object<a class="headerlink" href="#hello-object" title="Link to this heading">¶</a></h4>
<p>省略。</p>
</section>
<section id="check-for-emptiness">
<h4>Check for emptiness<a class="headerlink" href="#check-for-emptiness" title="Link to this heading">¶</a></h4>
<p>これはもっと良い方法がないものか？</p>
</section>
<section id="sum-object-properties">
<h4>Sum object properties<a class="headerlink" href="#sum-object-properties" title="Link to this heading">¶</a></h4>
<p>省略。</p>
</section>
<section id="multiply-numeric-property-values-by-2">
<h4>Multiply numeric property values by 2<a class="headerlink" href="#multiply-numeric-property-values-by-2" title="Link to this heading">¶</a></h4>
<p>ヒントに <code class="docutils literal notranslate"><span class="pre">typeof</span></code> を使えとあるから問題はないに等しい。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="ow">typeof</span><span class="w"> </span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;number&#39;</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="object-references-and-copying">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Object references and copying</a><a class="headerlink" href="#object-references-and-copying" title="Link to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/object-copy">https://javascript.info/object-copy</a>&gt; のノート。</p>
<p>Python のオブジェクトモデルに似ている気がする。</p>
<section id="comparison-by-reference">
<h3>Comparison by reference<a class="headerlink" href="#comparison-by-reference" title="Link to this heading">¶</a></h3>
<p>二つのオブジェクトが等しいのは、オブジェクト同士が同じ場合に限られる。例えば、二つのオブジェクトのどのプロパティーも等しいとしても、オブジェクト同士が別物ならば、等しくない。</p>
</section>
<section id="cloning-and-merging-object-assign">
<h3>Cloning and merging, <code class="docutils literal notranslate"><span class="pre">Object.assign</span></code><a class="headerlink" href="#cloning-and-merging-object-assign" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Object.assign()</span></code> の意味はメンバーごとの代入が基本。浅いコピーを行う。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> オブジェクトの属性の値を（参照でなくても）単純な代入式で変更することができる。</p></li>
</ul>
<div class="admonition- admonition">
<p class="admonition-title">学習者ノート</p>
<p>オブジェクトの複製方法を理解しておく。対象オブジェクトのプロパティーは指示されなければ保存されるので、実態としてはマージと言いたい。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">dest</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">src1</span><span class="p">,</span><span class="w"> </span><span class="nx">src2</span><span class="p">,</span><span class="w"> </span><span class="nx">src3</span><span class="p">...]);</span>
</pre></div>
</div>
<p>キーと値の集合ではなく、オブジェクトを <code class="docutils literal notranslate"><span class="pre">src</span></code> としてもよい。その場合には元オブジェクトのプロパティーのキーと値がマージされる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span><span class="w"> </span><span class="nx">user</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Object.assign()</span></code> を使わない方法もある：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{...</span><span class="nx">user</span><span class="p">};</span>
</pre></div>
</div>
<p>深い複製をするにはより巧妙な手段を講じる必要がある。</p>
</div>
</section>
<section id="nested-cloning">
<h3>Nested cloning<a class="headerlink" href="#nested-cloning" title="Link to this heading">¶</a></h3>
<p>オブジェクトが入れ子の構造である場合、複製は再帰的に実現される。</p>
</section>
</section>
<section id="garbage-collection">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Garbage collection</a><a class="headerlink" href="#garbage-collection" title="Link to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/garbage-collection">https://javascript.info/garbage-collection</a>&gt; のノート。</p>
<section id="reachability">
<h3>Reachability<a class="headerlink" href="#reachability" title="Link to this heading">¶</a></h3>
<p>値が到達可能であるとは、値が何らかの方法でアクセスできる、つまり使用できるということだ。到達可能な値はすべてメモリーに格納されていることが保証されている。</p>
<ul class="simple">
<li><p>まず、到達可能な値の基本集合があり、明白な理由により削除することができない。例えばグローバル変数、現在実行中の関数とその局所変数、実引数。現在ネストしている関数とその局所変数、実引数。このような値をルートと呼ぶ。</p></li>
<li><p>他の値は、ルートから参照、または参照の連鎖により到達可能ならば、その値は到達可能だ。</p></li>
</ul>
<p>例えば、グローバル変数にオブジェクトがあり、そのオブジェクトに他のオブジェクトを参照するプロパティーがある場合、そのオブジェクトは到達可能だ。さらに、そのオブジェクトが参照するオブジェクトも到達可能だ。</p>
</section>
<section id="a-simple-example">
<h3>A simple example<a class="headerlink" href="#a-simple-example" title="Link to this heading">¶</a></h3>
<p>この例がゴミ収集の考え方の基本だ。</p>
</section>
<section id="two-references">
<h3>Two references<a class="headerlink" href="#two-references" title="Link to this heading">¶</a></h3>
<p>これは参照カウンターのような考え方だ。</p>
</section>
<section id="interlinked-objects">
<h3>Interlinked objects<a class="headerlink" href="#interlinked-objects" title="Link to this heading">¶</a></h3>
<p>これは循環参照のもっとも原始的な例だ。<code class="docutils literal notranslate"><span class="pre">John</span></code> は <code class="docutils literal notranslate"><span class="pre">Ann</span></code> を参照しているものの、
<code class="docutils literal notranslate"><span class="pre">John</span></code> はどこからも参照されていないので、ゴミ収集される。</p>
</section>
<section id="unreachable-island">
<h3>Unreachable island<a class="headerlink" href="#unreachable-island" title="Link to this heading">¶</a></h3>
<p>これは到達可能性の概念で、ルートが重要な意味を示す例だ。ルート系からの参照が切れたことにより、一連のオブジェクトがゴミ収集される。</p>
<p>オブジェクト参照関係が構成するグラフの連結成分がまるごと到達不能になると、その連結成分にあるオブジェクトすべてがゴミ収集の対象となると考えていい。</p>
</section>
<section id="internal-algorithms">
<h3>Internal algorithms<a class="headerlink" href="#internal-algorithms" title="Link to this heading">¶</a></h3>
<p>プロならば知っておくべき事実だが、ここは読まなくてもなんとかなる。</p>
</section>
<section id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h3>
<p>興味深いことが書かれている。やる気があれば取り組め。</p>
</section>
</section>
<section id="object-methods-this">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Object methods, <code class="docutils literal notranslate"><span class="pre">this</span></code></a><a class="headerlink" href="#object-methods-this" title="Link to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/object-methods">https://javascript.info/object-methods</a>&gt; のノート。</p>
<div class="admonition- admonition">
<p class="admonition-title">学習者ノート</p>
<p>二点だけ押さえる。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">this</span></code> の意味が他言語とかなり異なる。</p></li>
<li><p>矢関数に <code class="docutils literal notranslate"><span class="pre">this</span></code> はない。</p></li>
</ul>
<p>オブジェクトのメソッドが、そのオブジェクトのメンバーにアクセスすることを考える。その前にオブジェクト自身にアクセスする必要がある。この状況でキーワード
<code class="docutils literal notranslate"><span class="pre">this</span></code> を用いることができる。<code class="docutils literal notranslate"><span class="pre">this</span></code> の値は、メソッドを呼び出すために使用されるオブジェクトのドット以前が指すものに等しい。</p>
<p>JavaScript に慣れていない段階では、<code class="docutils literal notranslate"><span class="pre">this</span></code> が <code class="docutils literal notranslate"><span class="pre">undefined</span></code> を指す状況によく陥る。こういうときには <code class="docutils literal notranslate"><span class="pre">call()</span></code>/<code class="docutils literal notranslate"><span class="pre">apply()</span></code>, <code class="docutils literal notranslate"><span class="pre">bind()</span></code> の適用や、
<code class="docutils literal notranslate"><span class="pre">function</span></code> 型関数を矢関数に置き換えることを調べるようにする。</p>
</div>
<section id="method-examples">
<h3>Method examples<a class="headerlink" href="#method-examples" title="Link to this heading">¶</a></h3>
<p>オブジェクトのプロパティーの値を関数にすれば、それはメソッドに他ならない。</p>
<section id="method-shorthand">
<h4>Method shorthand<a class="headerlink" href="#method-shorthand" title="Link to this heading">¶</a></h4>
<p>オブジェクトリテラルの形でメソッドを定義するために、略記法が用意されている：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sayHi</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// same as &quot;sayHi: function(){...}&quot;</span>
<span class="w">        </span><span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">function</span></code> を書かないで済むことに注意。</p>
</section>
</section>
<section id="this-in-methods">
<h3><code class="docutils literal notranslate"><span class="pre">this</span></code> in methods<a class="headerlink" href="#this-in-methods" title="Link to this heading">¶</a></h3>
<p>メソッドの中からオブジェクトを参照するためのキーワードが <code class="docutils literal notranslate"><span class="pre">this</span></code> だ。例えば
<code class="docutils literal notranslate"><span class="pre">user.sayHi()</span></code> の呼び出し中では <code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">==</span> <span class="pre">user</span></code> が成り立つ。</p>
</section>
<section id="this-is-not-bound">
<h3><code class="docutils literal notranslate"><span class="pre">this</span></code> is not bound<a class="headerlink" href="#this-is-not-bound" title="Link to this heading">¶</a></h3>
<p>JavaScript の <code class="docutils literal notranslate"><span class="pre">this</span></code> は、他のオブジェクト指向プログラミング諸言語と意味がかなり異なる。オブジェクトのメソッドではない関数の中でも <code class="docutils literal notranslate"><span class="pre">this</span></code> を参照することができる。<code class="docutils literal notranslate"><span class="pre">this</span></code> が何であるかは、実行時に評価される。</p>
<p>“use strict” モードである場合には、最悪でも <code class="docutils literal notranslate"><span class="pre">this</span></code> は <code class="docutils literal notranslate"><span class="pre">undefined</span></code> になる。ゆるいモードの場合には、外側のスコープの <code class="docutils literal notranslate"><span class="pre">this</span></code> が参照される。おそらくグローバルオブジェクトだろう。</p>
</section>
<section id="arrow-functions-have-no-this">
<h3>Arrow functions have no “this”<a class="headerlink" href="#arrow-functions-have-no-this" title="Link to this heading">¶</a></h3>
<p>矢関数は特別であり、この関数に依存する <code class="docutils literal notranslate"><span class="pre">this</span></code> は存在しない。矢関数の内部で
<code class="docutils literal notranslate"><span class="pre">this</span></code> を参照すると、外側のスコープの <code class="docutils literal notranslate"><span class="pre">this</span></code> が参照される。</p>
</section>
<section id="id1">
<h3>Tasks<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<section id="using-this-in-object-literal">
<h4>Using <code class="docutils literal notranslate"><span class="pre">this</span></code> in object literal<a class="headerlink" href="#using-this-in-object-literal" title="Link to this heading">¶</a></h4>
<p>問題の答は易しいが、少し内容を変えてエラーが出ないように <code class="docutils literal notranslate"><span class="pre">ref</span></code> の値を決めることを考えるといい。</p>
</section>
<section id="create-a-calculator">
<h4>Create a calculator<a class="headerlink" href="#create-a-calculator" title="Link to this heading">¶</a></h4>
<p>和の計算があるので、<code class="docutils literal notranslate"><span class="pre">prompt()</span></code> からの入力を数に明示的に変換する必要がある。</p>
</section>
<section id="chaining">
<h4>Chaining<a class="headerlink" href="#chaining" title="Link to this heading">¶</a></h4>
<p>オブジェクト指向プログラミング言語を何か一つでも知っているプログラマーならこれは問題にならない。</p>
</section>
</section>
</section>
<section id="constructor-operator-new">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Constructor, operator <code class="docutils literal notranslate"><span class="pre">new</span></code></a><a class="headerlink" href="#constructor-operator-new" title="Link to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/constructor-new">https://javascript.info/constructor-new</a>&gt; のノート。</p>
<ul class="simple">
<li><p>まだ <code class="docutils literal notranslate"><span class="pre">class</span></code> 文を知らない状態でコンストラクターを定義する。</p>
<ul>
<li><p>構文上は通常の関数定義とまったく変わらない。</p></li>
<li><p>関数本体に <code class="docutils literal notranslate"><span class="pre">this</span></code> が現れる。</p></li>
<li><p>呼び出し時に <code class="docutils literal notranslate"><span class="pre">new</span></code> を伴うと、戻り値、すなわち <code class="docutils literal notranslate"><span class="pre">this</span></code> に相当するオブジェクトを暗黙に生成するので、この関数をコンストラクターと呼ぶのがふさわしい。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">new.target</span></code> は知らないままでも問題ないだろう。</p></li>
</ul>
<p>現代的な <code class="docutils literal notranslate"><span class="pre">class</span></code> 構文はもっと後になってやるのだが、この言語仕様がその根底にある。</p>
<section id="constructor-function">
<h3>Constructor function<a class="headerlink" href="#constructor-function" title="Link to this heading">¶</a></h3>
<p>まず、文法外の規約を二つ取り決める：</p>
<ul class="simple">
<li><p>コンストラクターという特別な関数を定義するが、関数名を大文字で始める。</p></li>
<li><p>演算子 <code class="docutils literal notranslate"><span class="pre">new</span></code> を必ず伴って呼び出す。</p></li>
</ul>
<p>演算子 <code class="docutils literal notranslate"><span class="pre">new</span></code> を使って呼び出された関数は、次のような手順に従う：</p>
<ol class="arabic simple">
<li><p>新しい空のオブジェクトを作成して <code class="docutils literal notranslate"><span class="pre">this</span></code> に割り当てられる。</p></li>
<li><p>関数本体を実行する。ふつうは <code class="docutils literal notranslate"><span class="pre">this</span></code> を更新して新しいプロパティーを追加する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">this;</span></code> を書かずに <code class="docutils literal notranslate"><span class="pre">this</span></code> を返す。</p></li>
</ol>
</section>
<section id="constructor-mode-test-new-target">
<h3>Constructor mode test: <code class="docutils literal notranslate"><span class="pre">new.target</span></code><a class="headerlink" href="#constructor-mode-test-new-target" title="Link to this heading">¶</a></h3>
<p>読み飛ばしても構わないと言うので、そうする。</p>
</section>
<section id="return-from-constructors">
<h3>Return from constructors<a class="headerlink" href="#return-from-constructors" title="Link to this heading">¶</a></h3>
<p>コンストラクターで明示的に <code class="docutils literal notranslate"><span class="pre">return</span></code> 文を書くと何が起こるかを述べている。しかし、そのようなことはしないので、見なくていい。</p>
</section>
<section id="methods-in-constructor">
<h3>Methods in constructor<a class="headerlink" href="#methods-in-constructor" title="Link to this heading">¶</a></h3>
<p>コンストラクターでは、プロパティーだけでなく、メソッドを追加することもできる。</p>
</section>
<section id="id2">
<h3>Tasks<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<section id="two-functions-one-object">
<h4>Two functions - one object<a class="headerlink" href="#two-functions-one-object" title="Link to this heading">¶</a></h4>
<p>これは想像どおりの解答だ。</p>
</section>
<section id="create-new-calculator">
<h4>Create new Calculator<a class="headerlink" href="#create-new-calculator" title="Link to this heading">¶</a></h4>
<p>問題ない。</p>
</section>
<section id="create-new-accumulator">
<h4>Create new Accumulator<a class="headerlink" href="#create-new-accumulator" title="Link to this heading">¶</a></h4>
<p>これも <code class="docutils literal notranslate"><span class="pre">prompt()</span></code> の戻り値を数に明示的に変換する必要がある。</p>
</section>
</section>
</section>
<section id="optional-chaining">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Optional chaining <code class="docutils literal notranslate"><span class="pre">?.</span></code></a><a class="headerlink" href="#optional-chaining" title="Link to this heading">¶</a></h2>
<p>既存の <code class="docutils literal notranslate"><span class="pre">?</span></code> 系演算子に比べるとそれほど便利ではないようだ。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">address</span><span class="o">?</span><span class="p">.</span><span class="nx">street</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.elem&#39;</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">;</span>
</pre></div>
</div>
<section id="the-non-existing-property-problem">
<h3>The “non-existing property” problem<a class="headerlink" href="#the-non-existing-property-problem" title="Link to this heading">¶</a></h3>
<p>演算子 <code class="docutils literal notranslate"><span class="pre">?.</span></code> が導入された理由を長々と述べている。</p>
</section>
<section id="id3">
<h3>Optional chaining<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h3>
<p>式 <code class="docutils literal notranslate"><span class="pre">value?.prop</span></code> は次のように評価される：</p>
<ul class="simple">
<li><p>式 <code class="docutils literal notranslate"><span class="pre">value</span></code> が <code class="docutils literal notranslate"><span class="pre">null</span></code> でもなく <code class="docutils literal notranslate"><span class="pre">undefined</span></code> でもなければ <code class="docutils literal notranslate"><span class="pre">value.prop</span></code></p></li>
<li><p>それ以外は <code class="docutils literal notranslate"><span class="pre">undefined</span></code></p></li>
</ul>
</section>
<section id="short-circuiting">
<h3>Short-circuiting<a class="headerlink" href="#short-circuiting" title="Link to this heading">¶</a></h3>
<p>演算子 <code class="docutils literal notranslate"><span class="pre">?.</span></code> は short-circuit 評価が適用される。</p>
</section>
<section id="other-variants">
<h3>Other variants: <code class="docutils literal notranslate"><span class="pre">?.()</span></code>, <code class="docutils literal notranslate"><span class="pre">?.[]</span></code><a class="headerlink" href="#other-variants" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>演算子 <code class="docutils literal notranslate"><span class="pre">?.()</span></code> は <code class="docutils literal notranslate"><span class="pre">?.</span></code> のメソッド呼び出し版</p></li>
<li><p>演算子 <code class="docutils literal notranslate"><span class="pre">?.[]</span></code> は <code class="docutils literal notranslate"><span class="pre">?.</span></code> の角括弧版</p></li>
</ul>
<p>オブジェクト <code class="docutils literal notranslate"><span class="pre">userAdmin</span></code> と <code class="docutils literal notranslate"><span class="pre">`userGuest</span></code> があり、もしかしたらメソッド
<code class="docutils literal notranslate"><span class="pre">admin()</span></code> があるかもしれない場合に次のようなコードがあり得る：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">userAdmin</span><span class="p">.</span><span class="nx">admin</span><span class="o">?</span><span class="p">.();</span>
<span class="nx">userGuest</span><span class="p">.</span><span class="nx">admin</span><span class="o">?</span><span class="p">.();</span>
</pre></div>
</div>
<p>オブジェクト <code class="docutils literal notranslate"><span class="pre">user1</span></code> と <code class="docutils literal notranslate"><span class="pre">user2</span></code> があり、もしかしたらプロパティー
<code class="docutils literal notranslate"><span class="pre">firstName</span></code> があるかもしれない場合に次のようなコードがあり得る：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">user1</span><span class="o">?</span><span class="p">.[</span><span class="s2">&quot;firstName&quot;</span><span class="p">];</span>
<span class="nx">user2</span><span class="o">?</span><span class="p">.[</span><span class="s2">&quot;firstName&quot;</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">学習者ノート</p>
<p>ハテナドット系演算子が評価する値を、左辺値として参照してはいけない。</p>
</div>
</section>
</section>
<section id="symbol-type">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Symbol type</a><a class="headerlink" href="#symbol-type" title="Link to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/symbol">https://javascript.info/symbol</a>&gt; のノート。</p>
<p><code class="docutils literal notranslate"><span class="pre">Object</span></code> のキーの型は <code class="docutils literal notranslate"><span class="pre">string</span></code> または <code class="docutils literal notranslate"><span class="pre">Symbol</span></code> に限られる。ここでは後者が説明される。</p>
<p>シンボルの考え方がこのあとたくさん出てくる。</p>
<section id="symbols">
<h3>Symbols<a class="headerlink" href="#symbols" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Symbol</span></code> は一意的な識別子を実現するのに用意された組み込み型だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Symbol</span></code> オブジェクトは他の型のオブジェクトとは異なり、文字列への自動変換がなされない。</p></li>
</ul>
</section>
<section id="hidden-properties">
<h3>“Hidden” properties<a class="headerlink" href="#hidden-properties" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Symbol</span></code> でオブジェクトのキーを定義すると、その属性は「隠される」。例えば
<code class="docutils literal notranslate"><span class="pre">for</span></code> … <code class="docutils literal notranslate"><span class="pre">in</span></code> 文でそのような属性にはアクセスされない。</p>
<section id="symbols-in-an-object-literal">
<h4>Symbols in an object literal<a class="headerlink" href="#symbols-in-an-object-literal" title="Link to this heading">¶</a></h4>
<p>オブジェクトリテラル形式で定義する際には角括弧を要する。</p>
</section>
<section id="symbols-are-skipped-by-for-in">
<h4>Symbols are skipped by <code class="docutils literal notranslate"><span class="pre">for</span></code> … <code class="docutils literal notranslate"><span class="pre">in</span></code><a class="headerlink" href="#symbols-are-skipped-by-for-in" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>シンボルプロパティーは <code class="docutils literal notranslate"><span class="pre">for</span></code> … <code class="docutils literal notranslate"><span class="pre">in</span></code> で無視される。これは
<code class="docutils literal notranslate"><span class="pre">Object.keys()</span></code> が無視することによる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Object.assign()</span></code> は <code class="docutils literal notranslate"><span class="pre">Symbol</span></code> による属性を考慮する。</p></li>
</ul>
</section>
</section>
<section id="global-symbols">
<h3>Global symbols<a class="headerlink" href="#global-symbols" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Symbol.for()</span></code> で、定義済みのシンボルを検索する。</p>
<section id="symbol-keyfor">
<h4><code class="docutils literal notranslate"><span class="pre">Symbol.keyFor</span></code><a class="headerlink" href="#symbol-keyfor" title="Link to this heading">¶</a></h4>
<p>逆に <code class="docutils literal notranslate"><span class="pre">Symbol.keyFor()</span></code> は既存のシンボルから名前を得る。</p>
</section>
</section>
<section id="system-symbols">
<h3>System symbols<a class="headerlink" href="#system-symbols" title="Link to this heading">¶</a></h3>
<p>システムシンボル、言語が規定するシンボルが大量に定義されている。
<code class="docutils literal notranslate"><span class="pre">Symbol.iterator</span></code> が有名だ。</p>
</section>
</section>
<section id="object-to-primitive-conversion">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Object to primitive conversion</a><a class="headerlink" href="#object-to-primitive-conversion" title="Link to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/object-toprimitive">https://javascript.info/object-toprimitive</a>&gt; のノート。</p>
<p>それにしても、このチュートリアルはオブジェクトの変換についての記述が細かくて信頼できる。</p>
<p>前にも出てきたが、組み込み型への変換が必要なときにオブジェクトからの自動変換が引き起こされる。</p>
<section id="conversion-rules">
<h3>Conversion rules<a class="headerlink" href="#conversion-rules" title="Link to this heading">¶</a></h3>
<p>オブジェクトからの自動変換に関する規則を述べている。</p>
<ol class="arabic simple">
<li><p>Boolean への変換は <code class="docutils literal notranslate"><span class="pre">true</span></code> とする。</p></li>
<li><p>Number への変換は、オブジェクトの減算や数学関数を適用するときに起こる。例えば
<code class="docutils literal notranslate"><span class="pre">Date</span></code> オブジェクトは差が考えられ、その結果は二つの日付の時間差だ。</p></li>
<li><p>String への変換は <code class="docutils literal notranslate"><span class="pre">alert(obj)</span></code> など、出力時に起こる。</p></li>
</ol>
<p>このうち、2. と 3. については自動変換を実装できる。</p>
</section>
<section id="hints">
<h3>Hints<a class="headerlink" href="#hints" title="Link to this heading">¶</a></h3>
<p>前半がよくわからないが、自動変換が必要そうなときにヒントという文字列情報が発生するらしい。それから、次の手順で実際の変換が決定する：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj[Symbol.toPrimitive](hint)</span></code> が存在すれば、それを呼び出そうとする。</p></li>
<li><p>存在しないで、ヒントが <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> であれば <code class="docutils literal notranslate"><span class="pre">obj.toString()</span></code> または
<code class="docutils literal notranslate"><span class="pre">obj.valueOf()</span></code> を、存在すれば何でもいいから呼び出そうとする。</p></li>
<li><p>ヒントが “number” または <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> であれば <code class="docutils literal notranslate"><span class="pre">obj.valueOf()</span></code> または
<code class="docutils literal notranslate"><span class="pre">obj.toString()</span></code> を、存在すれば何でもいいから呼び出そうとする。</p></li>
</ol>
</section>
<section id="symbol-toprimitive">
<h3><code class="docutils literal notranslate"><span class="pre">Symbol.toPrimitive</span></code><a class="headerlink" href="#symbol-toprimitive" title="Link to this heading">¶</a></h3>
<p>オブジェクトにメソッド <code class="docutils literal notranslate"><span class="pre">[Symbol.toPrimitive]()</span></code> があれば、それが優先的に採用される。</p>
</section>
<section id="tostring-valueof">
<h3><code class="docutils literal notranslate"><span class="pre">toString</span></code>/<code class="docutils literal notranslate"><span class="pre">valueOf</span></code><a class="headerlink" href="#tostring-valueof" title="Link to this heading">¶</a></h3>
<p>あるいはオブジェクトの <code class="docutils literal notranslate"><span class="pre">toString()</span></code>, <code class="docutils literal notranslate"><span class="pre">valueOf()</span></code> が用意されていれば、それが採用される。文字列が必要な場合は前者が、数やデフォルトが必要な場合は後者がそれぞれ優先され、前者がその次に採用される。</p>
<section id="a-conversion-can-return-any-primitive-type">
<h4>A conversion can return any primitive type<a class="headerlink" href="#a-conversion-can-return-any-primitive-type" title="Link to this heading">¶</a></h4>
<p>ここで述べたメソッドを実装する際には、ヒントの指す型そのものの値を必ずしも返す必要はない。</p>
</section>
</section>
<section id="further-conversions">
<h3>Further conversions<a class="headerlink" href="#further-conversions" title="Link to this heading">¶</a></h3>
<p>演算や関数にオブジェクトを渡すと、変換が二段階で生じる可能性がある。まずはオブジェクトを原子型に変換し、それから演算や関数が必要とする原子型に変換する。</p>
</section>
</section>
</section>


          </div>
    <div class="related bottom">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="03-code-quality.html" title="Previous">Code quality</a>
        </li>
      
        <li>
          &uarr;
          <a href="../index.html" title="Parent">The Modern JavaScript Tutorial 読書ノート</a>
        </li>
        <li>
          &uarr;
          <a href="index.html" title="Parent">Part 1 The JavaScript language</a>
        </li>
        <li>
          <a href="05-data-types.html" title="Next">Data types</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>

      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="../../index.html" title="読書ノート Home"><img src="../../_images/logo.svg"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2024, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>