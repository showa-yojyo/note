
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Network requests &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/mermaid.js"></script>
    <link rel="next" title="Storing data in the browser" href="04-data-storage.html" />
    <link rel="prev" title="Binary data, files" href="02-binary.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="02-binary.html" title="Previous document">Binary data, files</a>
        </li>
        <li>
          <a href="04-data-storage.html" title="Next document">Storing data in the browser</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="network-requests">
<h1><a class="toc-backref" href="#id6" role="doc-backlink">Network requests</a><a class="headerlink" href="#network-requests" title="Permalink to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#network-requests" id="id6">Network requests</a></p>
<ul>
<li><p><a class="reference internal" href="#fetch" id="id7">Fetch</a></p></li>
<li><p><a class="reference internal" href="#formdata" id="id8"><code class="docutils literal notranslate"><span class="pre">FormData</span></code></a></p></li>
<li><p><a class="reference internal" href="#fetch-download-progress" id="id9">Fetch: Download progress</a></p></li>
<li><p><a class="reference internal" href="#fetch-abort" id="id10">Fetch: Abort</a></p></li>
<li><p><a class="reference internal" href="#fetch-cross-origin-requests" id="id11">Fetch: Cross-Origin Requests</a></p></li>
<li><p><a class="reference internal" href="#fetch-api" id="id12">Fetch API</a></p></li>
<li><p><a class="reference internal" href="#url-objects" id="id13"><code class="docutils literal notranslate"><span class="pre">URL</span></code> objects</a></p></li>
<li><p><a class="reference internal" href="#xmlhttprequest" id="id14"><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code></a></p></li>
<li><p><a class="reference internal" href="#resumable-file-upload" id="id15">Resumable file upload</a></p></li>
<li><p><a class="reference internal" href="#long-polling" id="id16">Long polling</a></p></li>
<li><p><a class="reference internal" href="#websocket" id="id17">WebSocket</a></p></li>
<li><p><a class="reference internal" href="#server-sent-events" id="id18">Server Sent Events</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="fetch">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Fetch</a><a class="headerlink" href="#fetch" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/fetch">https://javascript.info/fetch</a>&gt; のノート。</p>
<p>JavaScript からのネットワーク要求には AJAX という包括的な用語がある。最後の X は
XML を意味するが、別にそれを使う必要はない。古い時代の名残だ。</p>
<p>ネットワーク要求を送信して、サーバーから情報を取得する方法は複数ある。現代的で汎用性が高いメソッド <code class="docutils literal notranslate"><span class="pre">fetch()</span></code> から始める。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">options</span><span class="p">])</span>
</pre></div>
</div>
<p>オプションがない場合、単純な GET 要求で URL の内容をダウンロードする。</p>
<p>ブラウザーはリクエストをすぐに開始し、呼び出し側のコードが結果を取得するための
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> を返す。</p>
<p>応答の取得は通常二段階で行われる。まず、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> が返す <code class="docutils literal notranslate"><span class="pre">response</span></code> はサーバーがヘッダーで応答すると同時に、組み込みクラス <code class="docutils literal notranslate"><span class="pre">Response</span></code> のオブジェクトで
resolve される。この段階では HTTP 状態のチェック、成功かどうかの確認、ヘッダーのチェックはできるものの、本文 (body) がまだない。</p>
<p>ネットワークに問題がある、またはそのようなサイトがないなど、HTTP 要求を果たせなかった場合 <code class="docutils literal notranslate"><span class="pre">promise</span></code> は reject される。 404 や 500 のような異常な HTTP 状態はエラーにならない。</p>
<p>HTTP 状態は <code class="docutils literal notranslate"><span class="pre">response</span></code> の次のプロパティーで見える：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">status</span></code>: HTTP 状態コード。例えば 200 など。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ok</span></code>: HTTP 状態コードが 200 から 299 までの値であるかどうか。</p></li>
</ul>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;HTTP-Error: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>二段階目に、応答本体を取得するために、メソッドを追加的に呼び出す必要がある。
<code class="docutils literal notranslate"><span class="pre">Response</span></code> には、さまざまな形式で本文にアクセスするための複数の <code class="docutils literal notranslate"><span class="pre">Promise</span></code>
ベースのメソッドがある。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">response.text()</span></code></p></td>
<td><p>テキストとして返す</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">response.json()</span></code></p></td>
<td><p>JSON として解釈する</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">response.formData()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">FormData</span></code> オブジェクトとして返す</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">response.blob()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Blob</span></code> として返す</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">response.arrayBuffer()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ArrayBuffer</span></code> として返す</p></td>
</tr>
</tbody>
</table>
<p>さらに、プロパティー <code class="docutils literal notranslate"><span class="pre">response.body</span></code> という <code class="docutils literal notranslate"><span class="pre">ReadableStream</span></code> オブジェクトがある。これによって本文を一定の塊ごとに読むことができる。</p>
<p>本書では JSON 読み込みの例として、次のようなコードを紹介している：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&#39;</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">commits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
</pre></div>
</div>
<p>プレーンテキストとして読み込むには：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">();</span>
</pre></div>
</div>
<p>あとは参考として <code class="docutils literal notranslate"><span class="pre">Blob</span></code> オブジェクトの扱いも例がある。画像をロードして動的に
DOM に追加して描画させるという、高級なものだ。</p>
<p>重要な点として、本文を読み取る方法はひとつしか選べないことを理解しておく。例えばすでに <code class="docutils literal notranslate"><span class="pre">response.text()</span></code> で応答を取得している場合は <code class="docutils literal notranslate"><span class="pre">body</span></code> の内容がすでに処理されているので <code class="docutils literal notranslate"><span class="pre">response.json()</span></code> は使えない、といった具合だ。</p>
<section id="response-headers">
<h3>Response headers<a class="headerlink" href="#response-headers" title="Permalink to this heading">¶</a></h3>
<p>応答ヘッダーは <code class="docutils literal notranslate"><span class="pre">response.headers</span></code> にある <code class="docutils literal notranslate"><span class="pre">Map</span></code> 風のオブジェクトで利用できる。これは厳密には <code class="docutils literal notranslate"><span class="pre">Map</span></code> ではないものの、個々のヘッダーを名前で取得したり、ヘッダーを反復処理したりするための類似のメソッドがある。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// get one header</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">debug</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">));</span><span class="w"> </span><span class="c1">// application/json; charset=utf-8</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="p">[</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">headers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">debug</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> = </span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="request-headers">
<h3>Request headers<a class="headerlink" href="#request-headers" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">fetch</span></code> で要求ヘッダーを設定するには、オプションの引数 <code class="docutils literal notranslate"><span class="pre">headers</span></code> を使用する。次のコードのようにして、オブジェクトに発信ヘッダーを持たせる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">protectedUrl</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">headers</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">Authentication</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;secret&#39;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>禁じられた HTTP ヘッダーというのがあり、それを指定することは許されていない。これらのヘッダーは、適切かつ安全な HTTP を保証するため、ブラウザー専用とされる。</p>
</section>
<section id="post-requests">
<h3>POST requests<a class="headerlink" href="#post-requests" title="Permalink to this heading">¶</a></h3>
<p>GET 以外の POST や他の要求を行うには <code class="docutils literal notranslate"><span class="pre">options</span></code> を使用する必要がある。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">method</span></code></p></td>
<td><p>“POST” などの HTTP 方式</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">body</span></code></p></td>
<td><p>要求本文</p></td>
</tr>
</tbody>
</table>
<p>要求本文というのは、次のうちの一つだ：</p>
<ul class="simple">
<li><p>文字列の値。例えば JSON オブジェクトを文字列化したもの。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FormData</span></code> オブジェクト。データを multipart/form-data として提出する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Blob</span></code>/<code class="docutils literal notranslate"><span class="pre">BufferSource</span></code> オブジェクト。バイナリーデータを送信する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">URLSearchParams</span></code> オブジェクト。データを x-www-form-urlencoded という、めったに使われない符号方式で提出する。</p></li>
</ul>
<p>ほとんどの場合で JSON 形式が採用される。本書のコード例の
<code class="docutils literal notranslate"><span class="pre">options.headers['Content-Type']</span></code> の値に注目する。</p>
</section>
<section id="sending-an-image">
<h3>Sending an image<a class="headerlink" href="#sending-an-image" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Blob</span></code> や <code class="docutils literal notranslate"><span class="pre">BufferSource</span></code> を使って、バイナリーデータを <code class="docutils literal notranslate"><span class="pre">fetch</span></code> で送信することもできる。本書の例では <code class="docutils literal notranslate"><span class="pre">CANVAS</span></code> 要素上の描画をデータ化して、画像をサーバーに送信する。</p>
<p>コードを分析すると、JavaScript はキャンバス DOM ノードの <code class="docutils literal notranslate"><span class="pre">toBlob()</span></code> で所定の形式で画像を生成できるようだ。これを単純な <code class="docutils literal notranslate"><span class="pre">options</span></code> で <code class="docutils literal notranslate"><span class="pre">fetch()</span></code> したのち
<code class="docutils literal notranslate"><span class="pre">json()</span></code> する。<code class="docutils literal notranslate"><span class="pre">Blob</span></code> オブジェクトの場合、その型が Content-Type の値になる。<code class="docutils literal notranslate"><span class="pre">Blob</span></code> オブジェクトには組み込みの型 image/png があるため、Content-Type
ヘッダーを手動で設定しないで済む。</p>
</section>
<section id="tasks">
<h3>Tasks<a class="headerlink" href="#tasks" title="Permalink to this heading">¶</a></h3>
<section id="fetch-users-from-github">
<h4>Fetch users from GitHub<a class="headerlink" href="#fetch-users-from-github" title="Permalink to this heading">¶</a></h4>
<p>GitHub のログイン名の配列を入力とし、GitHub からユーザーを取得してその配列を出力とする非同期関数 <code class="docutils literal notranslate"><span class="pre">getUsers(names)</span></code> を書く演習だ。</p>
<p>指定された USERNAME の情報を持つ GitHub の URL は
&lt;<a class="reference external" href="https://api.github.com/users/USERNAME">https://api.github.com/users/USERNAME</a>&gt; だ。</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fetch</span></code> 要求はユーザーごとに一回だけとする。</p></li>
<li><p>要求は互いに待機してはいけない。</p></li>
<li><p>要求が失敗したり、ユーザーが存在しない場合、この関数は配列の対応要素に
<code class="docutils literal notranslate"><span class="pre">null</span></code> を置くものとする。</p></li>
</ol>
<p>この要件の急所は 2. であって、<code class="docutils literal notranslate"><span class="pre">Promise.all()</span></code> を使うタイミングを慎重に決めることになる。本質的に同じ処理とするが、見てくれは異なるコードが解答例以外にありそうだ。</p>
</section>
</section>
</section>
<section id="formdata">
<h2><a class="toc-backref" href="#id8" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">FormData</span></code></a><a class="headerlink" href="#formdata" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/formdata">https://javascript.info/formdata</a>&gt; のノート。</p>
<p>HTML フォームの送信について習う。<code class="docutils literal notranslate"><span class="pre">FormData</span></code> から始める。フォームデータを表すオブジェクトだ。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">formData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">FormData</span><span class="p">([</span><span class="nx">form</span><span class="p">]);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">FORM</span></code> 要素 <code class="docutils literal notranslate"><span class="pre">form</span></code> が与えられると、そのフィールドを自動的に取り込む。</p>
<p><code class="docutils literal notranslate"><span class="pre">FormData</span></code> の特別な点は、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> などのネットワークメソッドが <code class="docutils literal notranslate"><span class="pre">FormData</span></code>
オブジェクトを本文として受け取ることができることにある。これは符号化されて
<code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">multipart/form-data</span></code> で送信される。</p>
<p>サーバーからはこれが通常の提出と同じように見える。</p>
<section id="sending-a-simple-form">
<h3>Sending a simple form<a class="headerlink" href="#sending-a-simple-form" title="Permalink to this heading">¶</a></h3>
<p>単純なフォームを POST で送信するコード例。</p>
<ul class="simple">
<li><p>ハンドラーは <code class="docutils literal notranslate"><span class="pre">FORM</span></code> 要素の <code class="docutils literal notranslate"><span class="pre">onsubmit</span></code> に実装する。この関数は <code class="docutils literal notranslate"><span class="pre">async</span></code> であるはずだ。</p></li>
<li><p>おそらく <code class="docutils literal notranslate"><span class="pre">e.preventDefault()</span></code> 呼び出しは必須。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">fetch</span></code> の呼び出しで <code class="docutils literal notranslate"><span class="pre">options.body</span></code> の値を上述のように指定する。</p></li>
</ul>
</section>
<section id="formdata-methods">
<h3>FormData Methods<a class="headerlink" href="#formdata-methods" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">FormData</span></code> のフィールドをメソッドで変更することができる。GUI 以外の手段でもフォームの内容を操作できるということだ。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">append(name,</span> <span class="pre">value)</span></code></p></td>
<td><p>フィールドを追加する</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">append(name,</span> <span class="pre">blob,</span> <span class="pre">fileName)</span></code></p></td>
<td><p>あたかも <code class="docutils literal notranslate"><span class="pre">&lt;input</span> <span class="pre">type=&quot;file&quot;&gt;</span></code>
であるかのようなフィールドを追加する</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">delete(name)</span></code></p></td>
<td><p>フィールドを削除する</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">get(name)</span></code></p></td>
<td><p>フィールドの値を得る</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">has(name)</span></code></p></td>
<td><p>フィールドがあるかどうかを得る</p></td>
</tr>
</tbody>
</table>
<p>フォームには同じ名前のフィールドをいくつも持つことが技術的には許されているので、メソッド <code class="docutils literal notranslate"><span class="pre">append</span></code> を何度も呼び出すと同じ名前のフィールドがどんどん追加される。引数リストが <code class="docutils literal notranslate"><span class="pre">append</span></code> と同じであるメソッド <code class="docutils literal notranslate"><span class="pre">set</span></code> もある。与えられた名前のフィールドをすべて削除し、新しいフィールドを追加する。</p>
<p>本書のコードは、無からフォームデータを生成する例だろう。</p>
</section>
<section id="sending-a-form-with-a-file">
<h3>Sending a form with a file<a class="headerlink" href="#sending-a-form-with-a-file" title="Permalink to this heading">¶</a></h3>
<p>フォームはいつでも <code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">multipart/form-data</span></code> として送信され、この符号化によってファイルを送信することができる。したがって、<code class="docutils literal notranslate"><span class="pre">&lt;input</span> <span class="pre">type=&quot;file&quot;&gt;</span></code>
フィールドも通常のものと同じように送信される。</p>
<p>ハンドラー部分のコードがさっきのものと同じであることに注意する。</p>
</section>
<section id="sending-a-form-with-blob-data">
<h3>Sending a form with Blob data<a class="headerlink" href="#sending-a-form-with-blob-data" title="Permalink to this heading">¶</a></h3>
<p>画像など、動的に生成されるバイナリーデータを <code class="docutils literal notranslate"><span class="pre">Blob</span></code> として送信するのは前章で見たように簡単だ。<code class="docutils literal notranslate"><span class="pre">fetch</span></code> 呼び出しで引数 <code class="docutils literal notranslate"><span class="pre">body</span></code> として直接与えることができる。実際には、画像を個別に送信するのではなく、名前などの追加フィールドやメタデータとともに、フォームの一部として送信するのが便利な場合が多い。また、サーバーは通常、生のバイナリーデータよりも multipart 符号化されたフォームを受け入れるのに適している。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">formData</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s2">&quot;image&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">imageBlob</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;image.png&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>これで、フォームに <code class="docutils literal notranslate"><span class="pre">&lt;input</span> <span class="pre">type=&quot;file&quot;</span> <span class="pre">name=&quot;image&quot;&gt;</span></code> があり、訪問者がファイルシステムから image.png という名前のファイルと <code class="docutils literal notranslate"><span class="pre">imageBlob</span></code> というデータを送信したのと同じことになる。サーバーは、通常のフォーム提出と同じように、フォームデータとファイルを読み取る。</p>
</section>
</section>
<section id="fetch-download-progress">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Fetch: Download progress</a><a class="headerlink" href="#fetch-download-progress" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/fetch-progress">https://javascript.info/fetch-progress</a>&gt; のノート。</p>
<p>メソッド <code class="docutils literal notranslate"><span class="pre">fetch</span></code> では、ダウンロードの進捗を追跡することができる。戻り値オブジェクト <code class="docutils literal notranslate"><span class="pre">response</span></code> のプロパティー <code class="docutils literal notranslate"><span class="pre">body</span></code> を使用する。これは
<code class="docutils literal notranslate"><span class="pre">ReadableStream</span></code> 型で、ボディーを塊単位で供給する特殊なオブジェクトだ。
<code class="docutils literal notranslate"><span class="pre">response.text()</span></code> や <code class="docutils literal notranslate"><span class="pre">response.json()</span></code> などとは異なり、<code class="docutils literal notranslate"><span class="pre">response.body</span></code> では読み込み処理を完全に制御でき、どれだけ消費されたかをどんな瞬間にも数えることができる。</p>
<p>出力 <code class="docutils literal notranslate"><span class="pre">response</span></code> を得た後に次のようにすることができるとある：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">reader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">getReader</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// done is true for the last chunk</span>
<span class="w">    </span><span class="c1">// value is Uint8Array of the chunk bytes</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">done</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">reader</span><span class="p">.</span><span class="nx">read</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">done</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Received </span><span class="si">${</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="sb"> bytes`</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このコードだけ見ると <code class="docutils literal notranslate"><span class="pre">reader</span></code> は反復可能オブジェクトを備えていないのかと疑問に思うが、事実、用意されているらしい。本書ではその機能が広くサポートされていないから、あえて素のループを採用したと述べている。</p>
<p>勝手に調べてみたところ、次のように書けるはずらしい（手許の Chrome では動かず）：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">body</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Received </span><span class="si">${</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="sb"> bytes`</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>読み込みが終了するまで、すなわち <code class="docutils literal notranslate"><span class="pre">done</span></code> が真になるまで、ループ内で応答の塊を受信する。進捗を記録するには、受信した欠片の値ごとに、その長さをカウンターに追加する。</p>
<p>本書では <code class="docutils literal notranslate"><span class="pre">response.headers.get('Content-Length')</span></code> などを利用した実用的なコードを実装している。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">response.headers.get('Content-Length')</span></code> でダウンロードするデータ量を得る（数に変換すること）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code> を作業用の配列に <code class="docutils literal notranslate"><span class="pre">push</span></code> しておき、あとで <code class="docutils literal notranslate"><span class="pre">Uint8Array</span></code> オブジェクトに復元する。この処理がやや泥臭い。</p></li>
<li><p>このバイナリーデータは実はテキストなので、<code class="docutils literal notranslate"><span class="pre">TextDecoder</span></code> を利用して文字列に変換する。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">TextDecoder(encoding)</span></code> でオブジェクト生成。符号は UTF-8 などを指定する。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">decode()</span></code> で変換。</p></li>
</ul>
</li>
</ul>
<p>受信バイト数は必ずチェックする。一定の限界に達したらループを打ち切るなどして、メモリーが枯渇することを防止することだ。</p>
</section>
<section id="fetch-abort">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Fetch: Abort</a><a class="headerlink" href="#fetch-abort" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/fetch-abort">https://javascript.info/fetch-abort</a>&gt; のノート。</p>
<p><code class="docutils literal notranslate"><span class="pre">Promise</span></code> には「中止する」という概念が一般的にはない。進行中の <code class="docutils literal notranslate"><span class="pre">fetch</span></code> を中止するにはどうすればよいか。このような目的のために <code class="docutils literal notranslate"><span class="pre">AbortController</span></code> が使える。これは <code class="docutils literal notranslate"><span class="pre">fetch</span></code> の他にも、非同期タスクを中断させることができる。</p>
<section id="the-abortcontroller-object">
<h3>The <code class="docutils literal notranslate"><span class="pre">AbortController</span></code> object<a class="headerlink" href="#the-abortcontroller-object" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AbortController</span></code> は構造が単純だ。メソッド <code class="docutils literal notranslate"><span class="pre">abort()</span></code> と、イベントリスナーを設定するためのプロパティー <code class="docutils literal notranslate"><span class="pre">signal</span></code> がある。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">controller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">AbortController</span><span class="p">();</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">controller.abort()</span></code> すると、<code class="docutils literal notranslate"><span class="pre">controller.signal</span></code> がイベント <code class="docutils literal notranslate"><span class="pre">&quot;abort&quot;</span></code> を放つ。プロパティー <code class="docutils literal notranslate"><span class="pre">controller.signal.aborted</span></code> が <code class="docutils literal notranslate"><span class="pre">true</span></code> になる。</p>
<p>キャンセル可能な操作を行う側は、<code class="docutils literal notranslate"><span class="pre">controller.signal</span></code> のリスナーを設定する。
<code class="docutils literal notranslate"><span class="pre">controller.signal.addEventListener(&quot;abort&quot;,</span> <span class="pre">...)</span></code> による。キャンセルする側は、必要な時に <code class="docutils literal notranslate"><span class="pre">controller.abort()</span></code> を呼び出す。</p>
</section>
<section id="using-with-fetch">
<h3>Using with <code class="docutils literal notranslate"><span class="pre">fetch</span></code><a class="headerlink" href="#using-with-fetch" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">fetch</span></code> 呼び出しのオプションに <code class="docutils literal notranslate"><span class="pre">signal</span></code> を指定することで中止可能になる。次のように書いておき、適当なタイミングで <code class="docutils literal notranslate"><span class="pre">controller.abort()</span></code> を呼び出すことになる：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">controller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">AbortController</span><span class="p">();</span>
<span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">signal</span><span class="o">:</span><span class="w"> </span><span class="nx">controller</span><span class="p">.</span><span class="nx">signal</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fetch</span></code> が中止されると、その promise は <code class="docutils literal notranslate"><span class="pre">AbortError</span></code> を送出して reject する。<code class="docutils literal notranslate"><span class="pre">try</span></code> … <code class="docutils literal notranslate"><span class="pre">catch</span></code> などで処理する必要がある。</p>
</section>
<section id="abortcontroller-is-scalable">
<h3><code class="docutils literal notranslate"><span class="pre">AbortController</span></code> is scalable<a class="headerlink" href="#abortcontroller-is-scalable" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AbortController</span></code> は複数の非同期タスクを一度に中止することができる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">urls</span><span class="p">;</span><span class="w"> </span><span class="c1">// a list of urls to fetch in parallel</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">controller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">AbortController</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">fetchJobs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">urls</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">url</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">signal</span><span class="o">:</span><span class="w"> </span><span class="nx">controller</span><span class="p">.</span><span class="nx">signal</span>
<span class="p">}));</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">fetchJobs</span><span class="p">);</span>

<span class="c1">// if controller.abort() is called from anywhere,</span>
<span class="c1">// it aborts all fetches</span>
</pre></div>
</div>
</section>
</section>
<section id="fetch-cross-origin-requests">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Fetch: Cross-Origin Requests</a><a class="headerlink" href="#fetch-cross-origin-requests" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/fetch-crossorigin">https://javascript.info/fetch-crossorigin</a>&gt; のノート。</p>
<p>もし他のウェブサイトに <code class="docutils literal notranslate"><span class="pre">fetch</span></code> 要求を送ると、まず失敗するだろう。</p>
<p>核となる概念は domain/port/protocol の三つ組からなる origin だ。</p>
<p>Origin をまたぐ要求はリモート側から特別なヘッダーを要求される。そのような方針は
CORS: Cross-Origin Resource Sharing と呼ばれる。</p>
<section id="why-is-cors-needed-a-brief-history">
<h3>Why is CORS needed? A brief history<a class="headerlink" href="#why-is-cors-needed-a-brief-history" title="Permalink to this heading">¶</a></h3>
<p>CORS は邪悪なハッカーからインターネットを保護するために存在する。</p>
<p>あるサイトのスクリプトが他のサイトの内容にアクセスすることはできない。古のこの単純かつ強力な規則は、インターネット安全保障の基礎だった。例えば、ウェブサイト
hacker.com の悪質なスクリプトは、ウェブサイト gmail.com の利用者のメールボックスにアクセスできない。</p>
<p>また、JavaScript には当時、ネットワークへの要求を実行するための特別な手段がなかった。しかし、ウェブ開発者はもっと強力なものを求めた。そこで、この制約を回避し、他のWeb サイトに要求するためのさまざまな小細工を考案した。</p>
<section id="using-forms">
<h4>Using forms<a class="headerlink" href="#using-forms" title="Permalink to this heading">¶</a></h4>
<p>他のサーバーと通信する方法の一つは、そこに FORM を送信することだった。人々は、現在のページにとどまるために、<code class="docutils literal notranslate"><span class="pre">IFRAME</span></code> にそれを <code class="docutils literal notranslate"><span class="pre">submit</span></code> した。</p>
<p>そのため、ネットワークメソッドがなくても、フォームはどこにでもデータを送ることができるため、他のサイトに GET/POST 要求をすることは可能だった。しかし、<code class="docutils literal notranslate"><span class="pre">IFRAME</span></code>
の内容に他のサイトからアクセスすることは禁じられているため、応答を読むことはできなかった。</p>
<p>正確には、そのための仕掛けがあったが、それは <code class="docutils literal notranslate"><span class="pre">IFRAME</span></code> とページの両方で特別なスクリプトを必要とした。つまり、<code class="docutils literal notranslate"><span class="pre">IFRAME</span></code> との通信は技術的には可能だった。</p>
</section>
<section id="using-scripts">
<h4>Using scripts<a class="headerlink" href="#using-scripts" title="Permalink to this heading">¶</a></h4>
<p>もう一つの方法は <code class="docutils literal notranslate"><span class="pre">SCRIPT</span></code> タグを使うことだ。スクリプトは</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;http://another.com/...&quot;</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>のように、任意の <code class="docutils literal notranslate"><span class="pre">src</span></code> とドメインを持てる。どのウェブサイトからでもスクリプトを実行できる。</p>
<p>ウェブサイト、例えば another.com がこのようなアクセスのためにデータを公開しようとする場合、いわゆる JSONP (JSON with padding) プロトコルが使われた。</p>
<p>詳しい説明は本書のとおりで、リモート側で JavaScript コードを動的に生成することが急所になっている。生成コードはクライアント側で定義された JavaScript 関数を呼び出すようなものらしい。</p>
<p>両者がこの方法でデータを渡すことに合意しているので、うまくいくし、安全保障に違反もしない。そして、双方が同意している場合、それは間違いなくハッキングではない。古いブラウザーでも動作するため、このようなアクセスを供与するサービスはまだ存在する。</p>
<p>やがて、ブラウザーの JavaScript にネットワーク方式が登場した。</p>
<p>当初、origin をまたぐ要求は禁じられていたが、長い議論の結果、それが許可されました。新しい機能は、特別なヘッダーで表現された、サーバーによる明示的な許可が必要だ。</p>
</section>
</section>
<section id="safe-requests">
<h3>Safe requests<a class="headerlink" href="#safe-requests" title="Permalink to this heading">¶</a></h3>
<p>オリジン横断要求には安全な要求とそれ以外に分類できる。前者は作るのがより簡単なので、まずはそれから始める。</p>
<p>要求は次の二つの条件を満たすと安全だ：</p>
<ol class="arabic simple">
<li><p>メソッドが安全であること：GET, POST, HEAD のいずれかである。</p></li>
<li><p>ヘッダーが安全であること：カスタムヘッダーとして認められるのは次のいずれかだ：</p>
<ul class="simple">
<li><p>Accept</p></li>
<li><p>Accept-Language</p></li>
<li><p>Content-Language</p></li>
<li><p>Content-Type であり、その値が次のいずれかであるもの：</p>
<ul>
<li><p>application/x-www-form-urlencoded</p></li>
<li><p>multipart/form-data</p></li>
<li><p>text/plain</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>上記以外の要求は「安全でない」とみなされる。本質的な違いは、安全な要求は特別なメソッドなしに <code class="docutils literal notranslate"><span class="pre">FORM</span></code> や <code class="docutils literal notranslate"><span class="pre">SCRIPT</span></code> で行なえるということだ。したがって、古いサーバーでも安全な要求を受け入れることができるはずだ。それとは逆に、非標準のヘッダーや、例えば DELETE メソッドを持つ要求を、この方法で作成することはできない。</p>
<p>安全でない要求を行おうとすると、ブラウザーは特別な preflight 要求を送信し、このようなオリジン横断的要求を受け入れることに同意するかどうかをサーバーに問う。そして、サーバーがヘッダーで明示的に確認しない限り、安全でない要求は送信されない。</p>
</section>
<section id="cors-for-safe-requests">
<h3>CORS for safe requests<a class="headerlink" href="#cors-for-safe-requests" title="Permalink to this heading">¶</a></h3>
<p>要求がオリジンを横断する場合はいつでも、ブラウザーは <code class="docutils literal notranslate"><span class="pre">Origin</span></code> ヘッダーを追加する。例では <code class="docutils literal notranslate"><span class="pre">https://javascript.info/page</span></code> から <code class="docutils literal notranslate"><span class="pre">https://anywhere.com/request</span></code>
を要求するときのヘッダーを示している。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>GET /request
Host: anywhere.com
Origin: https://javascript.info
...
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Origin</span></code> ヘッダーには要求側の domain/protocol/port すなわち origin を含むことに注意する。これはパスを含まない。</p>
<p>サーバーは <code class="docutils literal notranslate"><span class="pre">Origin</span></code> を検査することができ、要求を受け入れることに同意すれば、特別なヘッダー <code class="docutils literal notranslate"><span class="pre">Access-Control-Allow-Origin</span></code> を応答に追加する。そのヘッダーは、許可された origin または星印 <code class="docutils literal notranslate"><span class="pre">*</span></code> を含むべきである。そうなれば応答は成功であり、下記のような応答がサーバーから得られる。そうでない場合は失敗だ。本書ではこの説明を Sequence diagram で表現している。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: https://javascript.info
</pre></div>
</div>
</section>
<section id="id1">
<h3>Response headers<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<p>オリジン横断的要求では、JavaScript はいわゆる「安全な」応答ヘッダーにしかアクセスすることができない。次の六つしかないようだ：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Cache-Control</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Content-Language</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Content-Type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Expires</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Last-Modified</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pragma</span></code></p></li>
</ul>
<p>それ以外の応答ヘッダーへのアクセスはエラーとなる。</p>
<p>JavaScript に他の応答ヘッダーへのアクセスを許可するには、サーバーは
<code class="docutils literal notranslate"><span class="pre">Access-Control-Expose-Headers</span></code> ヘッダーを送信する必要がある。これには、アクセスしたいヘッダー名をカンマで区切ったリストが入っている。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>200 OK
Content-Type:text/html; charset=UTF-8
Content-Length: 12345
API-Key: 2c9de507f2c54aa1
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Expose-Headers: Content-Length,API-Key
</pre></div>
</div>
<p>このような <code class="docutils literal notranslate"><span class="pre">Access-Control-Expose-Headers</span></code> ヘッダーを得て、要求側のスクリプトが応答の <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> および <code class="docutils literal notranslate"><span class="pre">API-Key</span></code> ヘッダーを読み取ることを許される。</p>
</section>
<section id="unsafe-requests">
<h3>“Unsafe” requests<a class="headerlink" href="#unsafe-requests" title="Permalink to this heading">¶</a></h3>
<p>GET, POST, PATCH, DELETE など、あらゆる HTTP method を利用することができる。</p>
<p>少し前までは、ウェブページがそのような要求をするという想定がなかった。そのため、非標準のメソッドを「それはブラウザーではない」と警戒して扱うウェブサービスがまだ存在する可能性がある。アクセス権をチェックするときに、それを考慮することができる。</p>
<p>そこで、サービスからの誤解を避けるために、「安全でない」どんな要求でも、ブラウザーはそのような要求をすぐにはしない。まず、予備的要求を送り、許可を得る。</p>
<p>予備要求では、HTTP method OPTIONS を使用し、主文はなく、ヘッダーを三つ使用する：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Access-Control-Request-Method</span></code>: 安全でない要求の HTTP method</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Access-Control-Request-Headers</span></code>: それの安全でない HTTP ヘッダーからなるカンマ区切りリスト</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Origin</span></code>: 要求元であるオリジン</p></li>
</ul>
<p>サーバーが要求の処理に同意した場合、空の主文、ステータス 200、次のヘッダーで応答してしかるべきだ：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Access-Control-Allow-Origin</span></code>: 文字 <code class="docutils literal notranslate"><span class="pre">*</span></code> または許可をする要求しているオリジン</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Access-Control-Allow-Methods</span></code>: 許可した HTTP method</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Access-Control-Allow-Headers</span></code>: 許可した HTTP ヘッダーのリスト</p></li>
</ul>
<p>さらに、ヘッダー <code class="docutils literal notranslate"><span class="pre">Access-Control-Max-Age</span></code> で、許可をキャッシュする秒数を指定できる。そのため、ブラウザーは与えられた許可を満たす後続の要求に対して予備要求を送信する必要がなくなる。</p>
<p>本書では、オリジン横断的 PATCH 要求を例に、その仕組みを順を追って解説している。
PATCH method というのはデータの更新によく使われる HTTP method とのことだ。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://site.com/service.json&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">method</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;PATCH&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">headers</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;application/json&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="s1">&#39;API-Key&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;secret&#39;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>当要求が安全でない理由は三つある（一つでもある時点でこの仕組を要する）：</p>
<ul>
<li><p>PATCH method それ自体</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> の値が次のどれでもない：</p>
<blockquote>
<div><ul class="simple">
<li><p>application/x-www-form-urlencoded</p></li>
<li><p>multipart/form-data</p></li>
<li><p>text/plain</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">API-Key</span></code> ヘッダーは安全でないとされる</p></li>
</ul>
<section id="step-1-preflight-request">
<h4>Step 1 (preflight request)<a class="headerlink" href="#step-1-preflight-request" title="Permalink to this heading">¶</a></h4>
<p>このような要求を送信する前に、ブラウザーが独自に次のような予備要求を送信する：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>OPTIONS /service.json
Host: site.com
Origin: https://javascript.info
Access-Control-Request-Method: PATCH
Access-Control-Request-Headers: Content-Type,API-Key
</pre></div>
</div>
<p>OPTIONS は要求側のスクリプトのパスからなる。Host は先方のドメイン？残り三つは先述のものだ。</p>
</section>
<section id="step-2-preflight-response">
<h4>Step 2 (preflight response)<a class="headerlink" href="#step-2-preflight-response" title="Permalink to this heading">¶</a></h4>
<p>成功すれば、予備応答は上の残り三つと記したヘッダーを部分的に含む。これをもって将来の通信が可能になる。もしサーバーが将来的に他のメソッドやヘッダーを期待するのであれば、それらをリストに追加することで事前に許可するのが自然だ。たとえば、次の応答例は PUT, DELETE, さらなるヘッダーも許可していると取れる：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400
</pre></div>
</div>
<p>以上でブラウザーが本要求を送信することができるようになった。</p>
<p>ヘッダー <code class="docutils literal notranslate"><span class="pre">Access-Control-Max-Age</span></code> に秒数があれば、指定された時間だけ予備要求の許可がキャッシュされる。上記の応答では、86400 秒キャッシュされる。この時間枠内であれば、それ以降の予備要求が発生することはない。キャッシュされた許容範囲内であれば、直接の送信が起こる。</p>
</section>
<section id="step-3-actual-request">
<h4>Step 3 (actual request)<a class="headerlink" href="#step-3-actual-request" title="Permalink to this heading">¶</a></h4>
<p>予備要求が成功したら、今度はブラウザーが主要求を行う。オリジン横断的要求ゆえ、本要求には <code class="docutils literal notranslate"><span class="pre">Origin</span></code> ヘッダーがあるが、処理は安全な要求と違いはない。</p>
</section>
<section id="step-4-actual-response">
<h4>Step 4 (actual response)<a class="headerlink" href="#step-4-actual-response" title="Permalink to this heading">¶</a></h4>
<p>サーバーは <code class="docutils literal notranslate"><span class="pre">Access-Control-Allow-Origin</span></code> を主応答に追加することを忘れてはならない。予備要求が成立しても、それから解放されるわけではない。</p>
<p>これで <code class="docutils literal notranslate"><span class="pre">JavaScript</span></code> はサーバーの主応答を読むことができる。</p>
</section>
</section>
<section id="credentials">
<h3>Credentials<a class="headerlink" href="#credentials" title="Permalink to this heading">¶</a></h3>
<p>JavaScript コードによって開始されたオリジン横断的要求には、Cookie や HTTP 認証などといった資格証が何もない。それは HTTP 要求では珍しいことだ。通常、あるドメインへの要求は、そのドメインからのすべての Cookies を伴う。一方、JavaScript のメソッドによって行われるオリジン横断的要求は例外だ。たとえば</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://another.com&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>はドメイン <code class="docutils literal notranslate"><span class="pre">another.com</span></code> に属するものでさえ、どんな Cookie も送らない。</p>
<p>それはなぜかというと、資格証付きの要求ははるかに強力だからだ。もし許可されれば、利用者の代理として行動し、その資格証を使って機密情報にアクセスする全権限を
JavaScript に供与することになる。サーバーはスクリプトを本当にそこまで信頼しているだろうか。ならば、追加ヘッダーで資格証付き要求を明示的に許可しなければならない。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://another.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">credentials</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;include&quot;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>これで <code class="docutils literal notranslate"><span class="pre">fetch</span></code> は <code class="docutils literal notranslate"><span class="pre">another.com</span></code> から発信された Cookie をそのサイトへの要求と一緒に送る。</p>
<p>サーバーが認証情報を含む要求を受け入れることに同意した場合、
<code class="docutils literal notranslate"><span class="pre">Access-Control-Allow-Origin</span></code> に加えて、応答に</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Access-Control-Allow-Credentials: true
</pre></div>
</div>
<p>というヘッダーを追加する必要がある。</p>
<p>注意として、<code class="docutils literal notranslate"><span class="pre">Access-Control-Allow-Origin</span></code> では、資格情報を含むリクエストに星印
<code class="docutils literal notranslate"><span class="pre">*</span></code> を使用することは禁止されている。正確なオリジンをそこに記さなければならない。これは追加的な安全対策であって、そのような要求をするために誰が信頼できるかをサーバーが本当に知っているかを確認するのが目的だ。</p>
</section>
<section id="id2">
<h3>Tasks<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<section id="why-do-we-need-origin">
<h4>Why do we need Origin?<a class="headerlink" href="#why-do-we-need-origin" title="Permalink to this heading">¶</a></h4>
<p>HTTPS から HTTP のページを取得する場合など、Referer が存在しない場合がある。このため Origin が必須となる。Content Security Policy で Referer を送ることが禁止されている場合もある。</p>
<p>まさに Referer が信頼できないからこそ Origin が発明された。ブラウザーはオリジン横断的要求に対して正しい Origin を保証している。</p>
</section>
</section>
</section>
<section id="fetch-api">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Fetch API</a><a class="headerlink" href="#fetch-api" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/fetch-api">https://javascript.info/fetch-api</a>&gt; のノート。</p>
<p>ここで学ぶオプションのほとんどはめったに使用されない。それでも、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> で何ができるかを知っておくのは良いことだ。</p>
<p>冒頭のコード片は <code class="docutils literal notranslate"><span class="pre">fetch</span></code> の引数 <code class="docutils literal notranslate"><span class="pre">options</span></code> の既定値をすべて列挙している。このうち <code class="docutils literal notranslate"><span class="pre">method</span></code>, <code class="docutils literal notranslate"><span class="pre">headers</span></code>, <code class="docutils literal notranslate"><span class="pre">body</span></code>, <code class="docutils literal notranslate"><span class="pre">signal</span></code> はすでに習ったので、残りをここでやる。</p>
<section id="referrer-referrerpolicy">
<h3><code class="docutils literal notranslate"><span class="pre">referrer</span></code>, <code class="docutils literal notranslate"><span class="pre">referrerPolicy</span></code><a class="headerlink" href="#referrer-referrerpolicy" title="Permalink to this heading">¶</a></h3>
<p>これらのオプションは HTTP Referer ヘッダーをどのように設定するかを制御する。通常、このヘッダーは自動的に設定され、要求元のページの URL が含まれる。ほとんどの場合、このヘッダーは重要ではないが、安全保障上、削除したり短くしたりすることが意味を持つ場合もある。</p>
<p>オプション <code class="docutils literal notranslate"><span class="pre">referrer</span></code> は（現在のオリジン内で）任意の Referer を設定したり、削除したりできる。送信しない場合は空文字列を指定する。</p>
<p>オプション <code class="docutils literal notranslate"><span class="pre">referrerPolicy</span></code> は Referer に関する一般的な規則を設ける。要求は三つに分類される：</p>
<ol class="arabic simple">
<li><p>同じオリジンへの要求</p></li>
<li><p>別のオリジンへの要求</p></li>
<li><p>HTTPS から HTTP へのリクエスト（安全なプロトコルから危険なプロトコルへの要求）</p></li>
</ol>
<p>正確な Referer 値を設定できる <code class="docutils literal notranslate"><span class="pre">referrer</span></code> とは異なり、<code class="docutils literal notranslate"><span class="pre">referrerPolicy</span></code> はブラウザーに各要求分類に対する一般的な規則を伝える。設定可能な値は Referrer Policy
仕様書に記述がある。</p>
<p>本書のここにある一覧は、取り得る値と意味の対応だ。</p>
<p>本書のここにある表は、取りうる値と要求分類の有効な組み合わせを示している？</p>
<hr class="docutils" />
<p>例えば、サイトの外から知られてはいけない URL 構造を持つ管理ゾーンがあるとする。
<code class="docutils literal notranslate"><span class="pre">fetch</span></code> を呼び出すと、既定ではページの完全な URL を含む Referer ヘッダーがつねに送信される。なお、HTTPS から HTTP への要求ではないと仮定する。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Referer: https://javascript.info/admin/secret/paths
</pre></div>
</div>
<p>もし、他のウェブサイトが URL パスではなく、オリジン部分のみを知りたい場合は、オプションを設定することができる：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://another.com/page&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">referrerPolicy</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;origin-when-cross-origin&quot;</span><span class="w"> </span><span class="c1">// Referer: https://javascript.info</span>
<span class="p">});</span>
</pre></div>
</div>
<p>すべての <code class="docutils literal notranslate"><span class="pre">fetch</span></code> 呼び出しにこれを適用することができる。おそらく、要求のすべてを処理するプロジェクトのJavaScript ライブラリーにこれを統合し、内部で <code class="docutils literal notranslate"><span class="pre">fetch</span></code>
を使用する感じになる。</p>
<p>既定動作との唯一の違いは、他のオリジンへの要求に対して、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> は URL のオリジン部分しか送信しない点にある（以前の記述を参照）。こちら側でのオリジンへの要求では、やはり完全な <code class="docutils literal notranslate"><span class="pre">Referer</span></code> を取得するというのもある。デバッグの助けになるかもしれないから。</p>
<p>Referer-Policy に関するひとくちメモはよくわからない。</p>
</section>
<section id="mode">
<h3><code class="docutils literal notranslate"><span class="pre">mode</span></code><a class="headerlink" href="#mode" title="Permalink to this heading">¶</a></h3>
<p>オプション <code class="docutils literal notranslate"><span class="pre">mode</span></code> は、時折発生するオリジン横断的要求を防ぐためのセーフガードだ。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“cors”</p></td>
<td><p>許可する</p></td>
</tr>
<tr class="row-odd"><td><p>“same-origin”</p></td>
<td><p>オリジン横断的要求は禁止とする</p></td>
</tr>
<tr class="row-even"><td><p>“no-cors”</p></td>
<td><p>安全なオリジン横断的要求しか許可しない</p></td>
</tr>
</tbody>
</table>
<p>オプション <code class="docutils literal notranslate"><span class="pre">mode</span></code> が便利であるのは、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> 用の URL がサードパーティーから来て、オリジン横断的要求を制限するための電源オフスイッチが欲しいときだ。</p>
</section>
<section id="id3">
<h3><code class="docutils literal notranslate"><span class="pre">credentials</span></code><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<p>オプション <code class="docutils literal notranslate"><span class="pre">credentials</span></code> は Cookie と HTTP-Authorization ヘッダーを要求とともに送信するべきかどうかを指定する。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“same-origin”</p></td>
<td><p>オリジン横断的要求に対して送信しない</p></td>
</tr>
<tr class="row-odd"><td><p>“include”</p></td>
<td><p>つねに送信する</p></td>
</tr>
<tr class="row-even"><td><p>“omit”</p></td>
<td><p>同一オリジン要求であったとしても送信しない</p></td>
</tr>
</tbody>
</table>
<p>つねに送信する場合、JavaScript が応答にアクセスするためには、別サーバーからの
Access-Control-Allow-Credentials が必要だ。</p>
</section>
<section id="cache">
<h3><code class="docutils literal notranslate"><span class="pre">cache</span></code><a class="headerlink" href="#cache" title="Permalink to this heading">¶</a></h3>
<p>何も指定しなければ、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> は標準的な HTTP-caching を利用する。つまり、通常の
HTTP 要求がするのと同じように、Expires と Cache-Control ヘッダーを考慮し、If-Modified-Since などの情報を送信する。オプション <code class="docutils literal notranslate"><span class="pre">cache</span></code> は HTTP-cache
を無視できたり、その使用方法を細かく設定したりできる。</p>
<p>表は略。</p>
</section>
<section id="redirect">
<h3><code class="docutils literal notranslate"><span class="pre">redirect</span></code><a class="headerlink" href="#redirect" title="Permalink to this heading">¶</a></h3>
<p>通常、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> は 301 や 302 などの HTTP リダイレクトには透過的に従う。オプション <code class="docutils literal notranslate"><span class="pre">redirect</span></code> はそれを変えることができる：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“follow”</p></td>
<td><p>HTTP-redirects に従う</p></td>
</tr>
<tr class="row-odd"><td><p>“error”</p></td>
<td><p>HTTP-redirects の場合にエラーとする</p></td>
</tr>
<tr class="row-even"><td><p>“manual”</p></td>
<td><p>HTTP-redirects を手動で処理する</p></td>
</tr>
</tbody>
</table>
<p>手動で処理するときには、リダイレクトの場合 <code class="docutils literal notranslate"><span class="pre">response.type=&quot;opaqueredirect&quot;</span></code> の特別な応答オブジェクトを取得し、そこにはゼロ・空ステータスと他のほとんどのプロパティーがある。</p>
</section>
<section id="integrity">
<h3><code class="docutils literal notranslate"><span class="pre">integrity</span></code><a class="headerlink" href="#integrity" title="Permalink to this heading">¶</a></h3>
<p>オプション <code class="docutils literal notranslate"><span class="pre">integrity</span></code> は応答が <code class="docutils literal notranslate"><span class="pre">known-ahead</span></code> チェックサムに一致するかどうかを調べることができる。仕様によると、サポートされているハッシュ関数は SHA-256,
SHA-384, SHA-512 であり、ブラウザーによっては他の関数もあるかもしれない。</p>
<p>例えば、あるファイルをダウンロードするとき、そのファイルの SHA-256 チェックサムが
abcdef であることがわかったとする。それをオプション <code class="docutils literal notranslate"><span class="pre">integrity</span></code> に書くと、次のようになる：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://site.com/file&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">integrity</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;sha256-abcdef&#39;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>すると、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> は独自に SHA-256 を計算し、与えられた情報と比較する。不一致の場合、エラーが発生する。</p>
</section>
<section id="keepalive">
<h3><code class="docutils literal notranslate"><span class="pre">keepalive</span></code><a class="headerlink" href="#keepalive" title="Permalink to this heading">¶</a></h3>
<p>オプション <code class="docutils literal notranslate"><span class="pre">keepalive</span></code> は、要求を開始したウェブページよりもそれが長生きする可能性があることを示唆する。例えば、ユーザー体験を分析し、改善するために、現在の閲覧者がどのようにページ（マウスクリック、見られているページ断片）を使用するかについての統計を収集する。閲覧者がページを離れるとき、そのデータをサーバーに保存したい。そのためにイベント <code class="docutils literal notranslate"><span class="pre">window.onunload</span></code> が使える：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nb">window</span><span class="p">.</span><span class="nx">onunload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/analytics&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">method</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;POST&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">body</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;statistics&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">keepalive</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">};</span>
</pre></div>
</div>
<p>通常、ドキュメントがアンロードされると、関連するネットワーク要求はすべて中止される。しかしオプション <code class="docutils literal notranslate"><span class="pre">keepalive</span></code> はブラウザーがページを離れた後もバックグラウンドで要求を実行するように指示する。したがって、このオプションは上のような要求が成功するために必要不可欠だ。</p>
<p>いくぶんかの制約がある：</p>
<ul class="simple">
<li><p>要求の本文の制限は 64KB だ。</p>
<ul>
<li><p>訪問に関する多くの統計情報を収集する必要がある場合、最後の <code class="docutils literal notranslate"><span class="pre">onunload</span></code> に多くが残らないように、パケットで定期的に送信するべきだ。</p></li>
<li><p>この制限はすべての <code class="docutils literal notranslate"><span class="pre">keepalive</span></code> 要求にまとめて適用される。つまり、複数の
<code class="docutils literal notranslate"><span class="pre">keepalive</span></code> 要求を並行して実行することもできるが、それらの本文の長さの和が
64KB を超えてはならない。</p></li>
</ul>
</li>
<li><p>ドキュメントがアンロードされると、サーバーからの応答を処理することができない。このため、この例では <code class="docutils literal notranslate"><span class="pre">keepalive</span></code> に対する <code class="docutils literal notranslate"><span class="pre">fetch</span></code> は成功するが、その後の関数は機能しない。</p>
<ul>
<li><p>ほとんどの場合、サーバーはデータを受け取るだけで、そのような要求には通常空の応答を送信するので、問題にはならない。</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="url-objects">
<h2><a class="toc-backref" href="#id13" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">URL</span></code> objects</a><a class="headerlink" href="#url-objects" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/url">https://javascript.info/url</a>&gt; のノート。</p>
<p>組み込みクラス <code class="docutils literal notranslate"><span class="pre">URL</span></code> には URL の作成と解析のための便利なインターフェイスがある。ただし、<code class="docutils literal notranslate"><span class="pre">URL</span></code> オブジェクトをまさに必要とするネットワークメソッドはなく、文字列で事足りる。</p>
<section id="creating-a-url">
<h3>Creating a <code class="docutils literal notranslate"><span class="pre">URL</span></code><a class="headerlink" href="#creating-a-url" title="Permalink to this heading">¶</a></h3>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="ow">new</span><span class="w"> </span><span class="nx">URL</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nx">base</span><span class="p">])</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">url</span></code>: 完全 URL か、または <code class="docutils literal notranslate"><span class="pre">base</span></code> が与えられている場合にはパスのみ</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base</span></code>: 相対パスから完全 URL を組み立てるための 基準 URL</p></li>
</ul>
<p>既存の URL からの相対パスに基づいて、新しい URL を簡単に作成できる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">URL</span><span class="p">(</span><span class="s1">&#39;https://javascript.info/profile/admin&#39;</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">newUrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">URL</span><span class="p">(</span><span class="s1">&#39;tester&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">url</span><span class="p">);</span><span class="w"> </span><span class="c1">// &quot;https://javascript.info/profile/tester&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">URL</span></code> オブジェクトはすぐにその構成要素にアクセスすることができる。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Specification</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">href</span></code></p></td>
<td><p>完全 URL に等しい文字列</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">protocol</span></code></p></td>
<td><p>プロトコルに等しく、コロンで終わる文字列</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">search</span></code></p></td>
<td><p>引数の文字列に等しく、疑問符記号から始まる文字列</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hash</span></code></p></td>
<td><p>記号 <code class="docutils literal notranslate"><span class="pre">#</span></code> から始まる文字列</p></td>
</tr>
</tbody>
</table>
<p>HTTP 認証がある場合にはプロパティー <code class="docutils literal notranslate"><span class="pre">user</span></code>, <code class="docutils literal notranslate"><span class="pre">password</span></code> もある。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>`http://login:password@site.com`
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">URL</span></code> オブジェクトを文字列の代わりにネットワーク（および他のほとんどの）メソッドに渡すことができる。<code class="docutils literal notranslate"><span class="pre">fetch</span></code> や <code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> など、URL 文字列が期待される場所のほどんとで使用できる。一般に、<code class="docutils literal notranslate"><span class="pre">URL</span></code> オブジェクトは文字列の代わりにどのようなメソッドにも渡すことができる。ほとんどのメソッドは文字列変換を行い、<code class="docutils literal notranslate"><span class="pre">URL</span></code> オブジェクトを完全な URL を含む文字列に変換する。</p>
</section>
<section id="searchparams">
<h3>SearchParams <code class="docutils literal notranslate"><span class="pre">?...</span></code><a class="headerlink" href="#searchparams" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">https://google.com/search?query=JavaScript</span></code> のような、検索引数を指定した
URL を 作成したい。<code class="docutils literal notranslate"><span class="pre">URL</span></code> の引数でそれらを直接指定してもいいが、引数に空白や非ラテン文字などが含まれている場合は、符号化する必要がある。そこで、そのためのプロパティー <code class="docutils literal notranslate"><span class="pre">url.searchParams</span></code> がある。このプロパティーは <code class="docutils literal notranslate"><span class="pre">URLSearchParams</span></code> という型のオブジェクトを値に取る。これには、検索引数用の便利なメソッドが用意されている。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Parameters</p></th>
<th class="head"><p>Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">append</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name,</span> <span class="pre">value</span></code></p></td>
<td><p>引数を <code class="docutils literal notranslate"><span class="pre">name</span></code> によって加える</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">delete</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></td>
<td><p>引数を <code class="docutils literal notranslate"><span class="pre">name</span></code> によって除く</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">get</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></td>
<td><p>引数を <code class="docutils literal notranslate"><span class="pre">name</span></code> によって得る</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">getAll</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></td>
<td><p>同じ名前の引数すべてを得る</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">has</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></td>
<td><p>引数が存在するかどうかを <code class="docutils literal notranslate"><span class="pre">name</span></code>
によって確かめる</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">set</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name,</span> <span class="pre">value</span></code></p></td>
<td><p>引数を割り当てるか上書きする</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sort</span></code></p></td>
<td></td>
<td><p>引数を <code class="docutils literal notranslate"><span class="pre">name</span></code> によって並び替える</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">URLSearchParams</span></code> は <code class="docutils literal notranslate"><span class="pre">Map</span></code> と同様に反復可能だ。</p>
<p>本書の Google に検索クエリーを送信する例は実用的だ。</p>
</section>
<section id="encoding">
<h3>Encoding<a class="headerlink" href="#encoding" title="Permalink to this heading">¶</a></h3>
<p>RFC3986 という規格があり、URL で利用が許される文字が定義されている。例えば、非ラテン文字や空白は UTF-8 コードに置き換えられ、<code class="docutils literal notranslate"><span class="pre">%20</span></code> のように記号 <code class="docutils literal notranslate"><span class="pre">%</span></code> で始まる（歴史的な理由から記号 <code class="docutils literal notranslate"><span class="pre">+</span></code> で符号化できる）。<code class="docutils literal notranslate"><span class="pre">URL</span></code> はこれらすべてを自動的に処理する。すべての引数を生で与え、<code class="docutils literal notranslate"><span class="pre">URL</span></code> を文字列に変換すればよい。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">URL</span><span class="p">(</span><span class="s1">&#39;https://ru.wikipedia.org/wiki/Тест&#39;</span><span class="p">);</span><span class="w"> </span><span class="c1">// &quot;https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82&quot;</span>
</pre></div>
</div>
<p>UTF-8 ではキリル文字が 2 バイトで表現されるため、<code class="docutils literal notranslate"><span class="pre">%xx</span></code> が一文字に対して二つ存在することになり、文字列が長くなる。</p>
<section id="encoding-strings">
<h4>Encoding strings<a class="headerlink" href="#encoding-strings" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">URL</span></code> が登場する前は、文字列が使われていた。現在でも文字列もまだ使うことができる。文字列を使った方が多くの場合コードが短くなる。文字列を使う場合、特殊文字を手動で符号化、復号化する必要がある。そのための組み込み関数：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">encodeURI</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decodeURI</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">encodeURIComponent</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decodeURIComponent</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">encodeURI</span></code> は URL で完全に禁止されている文字だけを符号化する。
<code class="docutils literal notranslate"><span class="pre">encodeURIComponent</span></code> は、同じ文字に加えて、<code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">$</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">,</span></code>,
<code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">:</span></code>, <code class="docutils literal notranslate"><span class="pre">;</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> を符号化する。</p>
<p>つまり、URL 全体に対しては <code class="docutils literal notranslate"><span class="pre">encodeURI</span></code> を使うことができるが、URL 引数に対しては <code class="docutils literal notranslate"><span class="pre">encodeURIComponent</span></code> を代わりに使用するべきなのだ。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">music</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">encodeURIComponent</span><span class="p">(</span><span class="s1">&#39;Rock&amp;Roll&#39;</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`https://google.com/search?q=</span><span class="si">${</span><span class="nx">music</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;https://google.com/search?q=Rock%26Roll&quot;</span>
</pre></div>
</div>
<p>クラス <code class="docutils literal notranslate"><span class="pre">URL</span></code> と <code class="docutils literal notranslate"><span class="pre">URLSearchParams</span></code> は、最新の URI 仕様に基づいている。一方、
<code class="docutils literal notranslate"><span class="pre">encode</span></code> 系関数は廃止された規格 RFC2396 に基づいている。 1998 年当時存在しなかった IPv6 アドレスの符号化が異なるなど、相違点がいくつかある。このような場合はまれで、<code class="docutils literal notranslate"><span class="pre">encode</span></code> 系関数はほとんどの場合うまく動作する。</p>
</section>
</section>
<section id="comments">
<h3>Comments<a class="headerlink" href="#comments" title="Permalink to this heading">¶</a></h3>
<p>このページのコメント欄は面白い。</p>
</section>
</section>
<section id="xmlhttprequest">
<h2><a class="toc-backref" href="#id14" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code></a><a class="headerlink" href="#xmlhttprequest" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/xmlhttprequest">https://javascript.info/xmlhttprequest</a>&gt; のノート。</p>
<p><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> は JavaScript で HTTP 要求を行うためのブラウザー組み込み型だ。名前に XML という単語を含むが、XML だけでなく、あらゆるデータに対して操作可能だ。ファイルのアップロード、ダウンロード、進捗状況の確認など、さまざまなことが可能だ。</p>
<p>現在では <code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> をやや非推奨とする、より現代的なメソッド <code class="docutils literal notranslate"><span class="pre">fetch</span></code>
がもう存在する。</p>
<p><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> が使用される理由は三つ：</p>
<ol class="arabic simple">
<li><p>歴史的な理由：既存のスクリプトを <code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> で対応し続ける必要がある。</p></li>
<li><p>古いブラウザーをサポートする必要があり、スクリプトを小さく保ちたいなどの理由で polyfill が欲しくない。</p></li>
<li><p>アップロードの進行状況を追跡するなど、<code class="docutils literal notranslate"><span class="pre">fetch</span></code> ではまだできないことをする必要がある。</p></li>
</ol>
<section id="the-basics">
<h3>The basics<a class="headerlink" href="#the-basics" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> には、動作モードに同期と非同期とがある。多くの場合に非同期が使用されるので非同期を先に見ていく。</p>
<p>要求を行うには三段階が必要だ。</p>
<ol class="arabic simple">
<li><p>オブジェクトを生成する。</p></li>
<li><p>オブジェクトを初期化する。</p></li>
<li><p>送信する。</p></li>
</ol>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">xhr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span><span class="w"> </span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="p">,</span><span class="w"> </span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">password</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
</pre></div>
</div>
<p>コンストラクターは引数を取らない。</p>
<p>メソッド <code class="docutils literal notranslate"><span class="pre">open</span></code> は要求の主要な引数を指定する。後ろ三つは optional だ。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>: ふつうは “GET” か “POST” を指定する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">URL</span></code>: 文字列でも、先述のように <code class="docutils literal notranslate"><span class="pre">URL</span></code> オブジェクトをそのまま渡してもいい。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">async</span></code>: 明示的に <code class="docutils literal notranslate"><span class="pre">false</span></code> を与えた場合には要求は同期的だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">user</span></code>, <code class="docutils literal notranslate"><span class="pre">password</span></code>: 基本的な HTTP 認証のためのログインユーザーとパスワード。</p></li>
</ul>
<p>メソッド <code class="docutils literal notranslate"><span class="pre">open</span></code> はその名前に反して接続はしない。要求を設定するだけで、ネットワーク活動は <code class="docutils literal notranslate"><span class="pre">send</span></code> の呼び出しによって開始する。</p>
<p>メソッド <code class="docutils literal notranslate"><span class="pre">send</span></code> は接続を開始し、サーバーに要求を送信する。オプション引数
<code class="docutils literal notranslate"><span class="pre">body</span></code> は要求本文だ。</p>
<p>GET のような要求メソッドには本文がないものもある一方、POST のように <code class="docutils literal notranslate"><span class="pre">body</span></code> を使用してデータをサーバーに送信するものもある。</p>
<hr class="docutils" />
<p>その後の段階としては <code class="docutils literal notranslate"><span class="pre">xhr</span></code> イベントに耳を傾けて応答する。これらのイベントがもっとも広く用いられる：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">load</span></code>: 要求が完了し、HTTP ステータスが 400 や 500 であっても、応答が完全にダウンロードされたとき。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code>: ネットワークダウンや無効な URL など、要求がうまくいかなかった。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">progress</span></code>: 応答がダウンロードされている間じゅう定期的に呼び出され、ダウンロード量が報告される。</p></li>
</ul>
<p>基本的に <code class="docutils literal notranslate"><span class="pre">xhr.addEventListener('load',</span> <span class="pre">...)</span></code> のようにして設定できると思われる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">onload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">200</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">alert</span><span class="p">(</span><span class="sb">`Error </span><span class="si">${</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span><span class="w"> </span><span class="c1">// e.g. 404: Not Found</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">alert</span><span class="p">(</span><span class="sb">`Done, got </span><span class="si">${</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="sb"> bytes`</span><span class="p">);</span><span class="w"> </span><span class="c1">// response is the server response</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>サーバーが応答したら、その結果を次の <code class="docutils literal notranslate"><span class="pre">xhr</span></code> のプロパティーから受け取る：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">status</span></code>: HTTP ステータスコードを表す数値。HTTP 以外の失敗の場合は 0 があり得る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">statusText</span></code>: HTTP ステータスメッセージを表す文字列値。404 なら <code class="docutils literal notranslate"><span class="pre">&quot;Not</span>
<span class="pre">Found&quot;</span></code> のように。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">response</span></code>: サーバー応答本文。</p></li>
</ul>
<p>また、プロパティーを用いてタイムアウトを指定することもできる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10000</span><span class="p">;</span><span class="w"> </span><span class="c1">// timeout in ms, 10 seconds</span>
</pre></div>
</div>
<p>与えられた時間内に要求が成功しない場合、キャンセルされてイベント <code class="docutils literal notranslate"><span class="pre">timeout</span></code> が発生する。</p>
<p>囲み記事については前ページ参照。</p>
</section>
<section id="response-type">
<h3>Response Type<a class="headerlink" href="#response-type" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">xhr.responseType</span></code> を使用して、応答フォーマットを設定することができる。この値を <code class="docutils literal notranslate"><span class="pre">send</span></code> 呼び出しまでに変えると、<code class="docutils literal notranslate"><span class="pre">xhr.response</span></code> の値が対応する内容になる。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Specification</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“”</p></td>
<td><p>文字列で得る</p></td>
</tr>
<tr class="row-odd"><td><p>“text”</p></td>
<td><p>文字列で得る</p></td>
</tr>
<tr class="row-even"><td><p>“arraybuffer”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ArrayBuffer</span></code> として得る</p></td>
</tr>
<tr class="row-odd"><td><p>“blob”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Blob</span></code> として得る</p></td>
</tr>
<tr class="row-even"><td><p>“document”</p></td>
<td><p>XML 文書または HTML 文書として得る</p></td>
</tr>
<tr class="row-odd"><td><p>“json”</p></td>
<td><p>JSON として得る</p></td>
</tr>
</tbody>
</table>
</section>
<section id="ready-states">
<h3>Ready states<a class="headerlink" href="#ready-states" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> はその進行に応じて状態が変化する。現在の状態はプロパティー
<code class="docutils literal notranslate"><span class="pre">xhr.readyState</span></code> だ。状態値は 0 → 1 → 2 → 3 → … → 3 → 4 の順に移動する。ネットワーク上でデータパケットを受信するたびに状態 3 を 反復する。</p>
<p>イベント <code class="docutils literal notranslate"><span class="pre">readstatechange</span></code> を使って追跡することができるが、これは古い。現在では <code class="docutils literal notranslate"><span class="pre">load</span></code>/<code class="docutils literal notranslate"><span class="pre">error</span></code>/<code class="docutils literal notranslate"><span class="pre">progress</span></code> ハンドラーがある。</p>
</section>
<section id="aborting-request">
<h3>Aborting request<a class="headerlink" href="#aborting-request" title="Permalink to this heading">¶</a></h3>
<p>要求はいつでも終了させることができる。これにより、<code class="docutils literal notranslate"><span class="pre">abort</span></code> イベントが発生して
<code class="docutils literal notranslate"><span class="pre">xhr.status</span></code> の値が 0 になる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">abort</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="synchronous-requests">
<h3>Synchronous requests<a class="headerlink" href="#synchronous-requests" title="Permalink to this heading">¶</a></h3>
<p>メソッド <code class="docutils literal notranslate"><span class="pre">open</span></code> には第三の引数 <code class="docutils literal notranslate"><span class="pre">async</span></code> がある。これを <code class="docutils literal notranslate"><span class="pre">false</span></code> とすると、要求が同期的に行われる。つまり、JavaScript の実行は <code class="docutils literal notranslate"><span class="pre">send()</span></code> 呼び出しでブロックされ、応答を受信した時点で復帰する。</p>
<p>読み込みが完了するまでページ内の JavaScript をブロックしてしまうので、ほとんど使われない。ブラウザーによっては、スクロール不能になるまである。同期呼び出しに時間がかかり過ぎる場合、ブラウザーはハングアップしたページを閉じるよう案内することがある。</p>
<p><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> の高度な機能の多くは、同期的要求では使用できない。進行状況の表示もない。以上のような理由から、同期的要求はあまり用いられない。</p>
</section>
<section id="http-headers">
<h3>HTTP-headers<a class="headerlink" href="#http-headers" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> ではカスタムヘッダーの送信と、応答からヘッダーを読み取ることのどちらも可能だ。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Parameters</p></th>
<th class="head"><p>Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">setRequestHeader</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code></p></td>
<td><p>指定された <code class="docutils literal notranslate"><span class="pre">name</span></code> と <code class="docutils literal notranslate"><span class="pre">value</span></code> を持つ要求ヘッダーを与える</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">getResponseHeader</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></td>
<td><p>指定された <code class="docutils literal notranslate"><span class="pre">name</span></code> の応答ヘッダーを得る</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">getAllResponseHeaders</span></code></p></td>
<td></td>
<td><p>すべての応答ヘッダーを得る</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">Referer</span></code> や <code class="docutils literal notranslate"><span class="pre">Host</span></code> など、ブラウザー専用管理ヘッダーもある。
<code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> は利用者の安全と要求の正確さのために、これらを変更することが許されていない。</p>
<p><code class="docutils literal notranslate"><span class="pre">setRequestHeader</span></code> での設定内容を元に戻すことができないという特徴もある。ヘッダーが設定されると、それは設定されたままだ。追加の呼び出しはヘッダーに情報を追加し、上書きはしない。</p>
<p>ここで言う応答ヘッダーには Set-Cookie および Set-Cookie2 は含まれない。</p>
<p>複数ヘッダーは一行で返される。</p>
<p>ヘッダーとヘッダーの間の改行は OS に依らず <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> なので、個々のヘッダーに分割することは容易だ。名前と値のセパレーターはコロンの後に空白文字が必ず入る。</p>
</section>
<section id="post-formdata">
<h3>POST, <code class="docutils literal notranslate"><span class="pre">FormData</span></code><a class="headerlink" href="#post-formdata" title="Permalink to this heading">¶</a></h3>
<p>POST 要求を行うには <code class="docutils literal notranslate"><span class="pre">FormData</span></code> を用いる。オブジェクト <code class="docutils literal notranslate"><span class="pre">formData</span></code> を用意したら次の手順で：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xhr.open('POST',</span> <span class="pre">...)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xhr.send(formData)</span></code></p></li>
</ol>
<p>フォームは multipart/form-data 符号様式で送信される。</p>
<p>JSON が好みなら <code class="docutils literal notranslate"><span class="pre">JSON.stringify</span></code> して得られる文字列を送信する。ただ、Content-Type: application/json というヘッダーを設定するのを忘れてはいけない。サーバーサイドフレームワークの多くは、これで自動的に JSON を復号してくれる。</p>
</section>
<section id="upload-progress">
<h3>Upload progress<a class="headerlink" href="#upload-progress" title="Permalink to this heading">¶</a></h3>
<p>イベント <code class="docutils literal notranslate"><span class="pre">progress</span></code> はダウンロードの段階でだけ発射される。つまり、何かを POST
する場合、<code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> はまずデータ（要求本文）をアップロードし、次に応答をダウンロードする。何か大きなデータをアップロードする場合、その進行状況を追跡することに関心があるはずだ。しかし、<code class="docutils literal notranslate"><span class="pre">xhr.onprogress</span></code> はここで役に立たない。</p>
<p>イベントを追跡するためのメソッドを持たない別のオブジェクト <code class="docutils literal notranslate"><span class="pre">xhr.upload</span></code> がある。このオブジェクトは <code class="docutils literal notranslate"><span class="pre">xhr</span></code> と同様にイベントを生成するが、<code class="docutils literal notranslate"><span class="pre">xhr.upload</span></code> はアップロード時にだけイベントを発射する。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">loadstart</span></code>: アップロード開始された</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">progress</span></code>: アップロード中に定期的に</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abort</span></code>: アップロードが中断された</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code>: HTTP 以外のエラー</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">load</span></code>: アップロードが正常に終了した</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timeout</span></code>: アップロードがタイムアウトした</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loadend</span></code>: 成功またはエラーでアップロードが終了した</p></li>
</ul>
</section>
<section id="cross-origin-requests">
<h3>Cross-origin requests<a class="headerlink" href="#cross-origin-requests" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> は <code class="docutils literal notranslate"><span class="pre">fetch</span></code> と同じ CORS 方針を使用して、オリジン横断的要求を行うことができる。<code class="docutils literal notranslate"><span class="pre">fetch</span></code> 同様に、既定では Cookie と HTTP 認証を別のオリジンに送信しない。これらを有効にするには、次のようにする：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="resumable-file-upload">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Resumable file upload</a><a class="headerlink" href="#resumable-file-upload" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/resume-upload">https://javascript.info/resume-upload</a>&gt; のノート。</p>
<p>メソッド <code class="docutils literal notranslate"><span class="pre">fetch</span></code> を使用すると、ファイルをアップロードするのはかなり簡単だ。接続が切れた後にアップロードを再開するための組み込みのオプションはないが、それを実装するための部品はある。</p>
<p>再開可能なアップロードには、アップロードの進行状況表示が必要だ。<code class="docutils literal notranslate"><span class="pre">fetch</span></code> では進捗を追跡できないので <code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> を使用する。</p>
<section id="not-so-useful-progress-event">
<h3>Not-so-useful progress event<a class="headerlink" href="#not-so-useful-progress-event" title="Permalink to this heading">¶</a></h3>
<p>アップロードを再開するには、接続が切断されるまでにどれだけの量がアップロードされたかを知っていなければならない。</p>
<p>アップロードの進行状況を追跡するために <code class="docutils literal notranslate"><span class="pre">xhr.upload.onprogress</span></code> がある。これはデータが送信されたときに発射されるため、アップロードを再開する助けにはならない。このイベントはプログレスバーを表示するのにしか有用でない。</p>
<p>アップロードを再開するには、サーバーが受信したバイト数を正確に把握する必要がある。それはサーバーしか知り得ないので、追加の要求を行うことになる。</p>
</section>
<section id="algorithm">
<h3>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this heading">¶</a></h3>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">fileId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">file</span><span class="p">.</span><span class="nx">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">file</span><span class="p">.</span><span class="nx">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">file</span><span class="p">.</span><span class="nx">lastModified</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;status&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">headers</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s1">&#39;X-File-Id&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">fileId</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>

<span class="c1">// The server has that many bytes</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">startByte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="k">await</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;POST&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;upload&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s1">&#39;X-File-Id&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">fileId</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s1">&#39;X-Start-Byte&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">startByte</span><span class="p">);</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">upload</span><span class="p">.</span><span class="nx">onprogress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Uploaded </span><span class="si">${</span><span class="nx">startByte</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">e</span><span class="p">.</span><span class="nx">loaded</span><span class="si">}</span><span class="sb"> of </span><span class="si">${</span><span class="nx">startByte</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">e</span><span class="p">.</span><span class="nx">total</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// file can be from input.files[0] or another source</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">file</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">startByte</span><span class="p">));</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>アップロードするファイルを特定するために、ファイル ID を作成する。</p></li>
<li><p>サーバーに対して、すでに何バイト持っているかという要求を送る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Blob</span></code> の <code class="docutils literal notranslate"><span class="pre">slice</span></code> を使って位置 <code class="docutils literal notranslate"><span class="pre">startByte</span></code> からファイルを送信する。</p></li>
</ol>
<p>ファイル ID を <code class="docutils literal notranslate"><span class="pre">fileId</span></code> と呼ぶ。これは再開アップロードに必要なもので、サーバーに何を再開しているのかを伝えるためのものだ。名前、サイズ、最終更新日などが変更された場合は、別の <code class="docutils literal notranslate"><span class="pre">fileId</span></code> を指定する必要がある。</p>
<p>サーバーがヘッダー <code class="docutils literal notranslate"><span class="pre">X-File-Id</span></code> によってファイルアップロードを追跡することを想定している。サーバーサイドで実装する必要がある。もしファイルがまだサーバーに存在しない場合は、サーバーからの応答は 0 になるはずだ。</p>
<p>ここでは、サーバーにファイル ID を <code class="docutils literal notranslate"><span class="pre">X-File-Id</span></code> として送信し、どのファイルをアップロードしているかを認識させ、開始バイトを <code class="docutils literal notranslate"><span class="pre">X-Start-Byte</span></code> として送信し、最初にアップロードしたのではなく、再開していることを認識させるようにしている。</p>
<p>サーバーは記録をチェックし、そのファイルのアップロードがあり、現在アップロードされているサイズがちょうど <code class="docutils literal notranslate"><span class="pre">X-Start-Byte</span></code> であれば、そのデータを追加する必要がある。</p>
<hr class="docutils" />
<p>本書のここには Node.js で書かれたクライアントとサーバーの両方のコードを掲載したデモが来る。 Node.js は Nginx の背後で稼働し、アップロードをバッファリングし、完了したら Node.js に渡す。このコードを読者がダウンロードしてローカルで実行すると、デモが完全に動作するとある。</p>
<ul class="simple">
<li><p><code class="file docutils literal notranslate"><span class="pre">client.js</span></code>: これまでのコードをカプセル化したクラスの定義</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">server.js</span></code>: 未知のコード群</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">index.html</span></code>: フォームおよび一部イベントハンドラーの実装や設定</p></li>
</ul>
<div class="admonition- admonition">
<p class="admonition-title">学習者ノート</p>
<p>本書のリンクからファイルをダウンロード、解凍したら、動作確認を次のようにする。まず、必要なサードパーティー製パッケージをダウンロードしたディレクトリーでインストールする。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bash$ npm install node-static</span>
</pre></div>
</div>
<p>そして <code class="file docutils literal notranslate"><span class="pre">server.js</span></code> をサーバーとして稼動させる。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bash$ node server.js</span>
</pre></div>
</div>
<p>ブラウザーで &lt;<a class="reference external" href="http://localhost:8080">http://localhost:8080</a>&gt; を開くようにする。すると、本書デモと同じ見てくれのページが開く。</p>
<p>本章ではこのような Node.js を必要とするデモが以降にあと二つはある。基本的には同じようにして（必要パッケージが違うくらい）動作を確認する。</p>
</div>
<p>最近のネットワーク方式は、ヘッダーの制御、進捗状況の表示、部分ファイルの送信など、ファイルマネージャーに近い機能を備えている。再開可能なアップロードやその他多くの機能を実装することができる。</p>
</section>
</section>
<section id="long-polling">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Long polling</a><a class="headerlink" href="#long-polling" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/long-polling">https://javascript.info/long-polling</a>&gt; のノート。</p>
<p>Long polling とは手法であって、WebSocket や Server Side Events のような特定のプロトコルを使用せず、サーバーとの持続的な接続を行う最も単純なものだ。ひじょうに簡単に実装でき、多くの場合に十分な効果を得られる。</p>
<section id="regular-polling">
<h3>Regular Polling<a class="headerlink" href="#regular-polling" title="Permalink to this heading">¶</a></h3>
<p>サーバーから新しい情報を取得する最も簡単な方法は、定期的な polling だ。つまり、サーバーへの定期的な（例えば十秒に一回）「私はここだ。何か私に情報があるか」要求だ。これに対してサーバーは、まずクライアントがオンラインであることを自分自身に通知し、それから、その時点までに受け取ったメッセージのパケットを送信する。</p>
<p>しかし、これには欠点がある。</p>
<ul class="simple">
<li><p>メッセージは上記の場合、最大で十秒遅れて渡される。</p></li>
<li><p>メッセージがなかったり、ユーザーが別の場所に移動していたり、寝ていたりしたとしても、サーバーは十秒ごとに要求で爆撃される。</p></li>
</ul>
<p>ごく小さなサービスの話でなければ、この方法には改善が必要だ。</p>
</section>
<section id="id4">
<h3>Long polling<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<p>いわゆる long polling とは、より良い polling だ。実装も簡単で、メッセージを遅延なく送信することができる。処理の流れは次のようになる：</p>
<ol class="arabic simple">
<li><p>サーバーに要求が送信される。</p></li>
<li><p>サーバーは送信するためのメッセージがあるまで接続を閉じない。</p></li>
<li><p>メッセージが出現すると、サーバーはそのメッセージで要求に応答する。</p></li>
<li><p>ブラウザーはすぐに新しい要求をする。</p></li>
</ol>
<p>ネットワークエラーなどで接続が切れると、ブラウザーはすぐに新しいリクエストを送信する。</p>
<p>本書ではクライアント側の実装コード概要がここに来る。</p>
<p>非同期関数 <code class="docutils literal notranslate"><span class="pre">subscribe</span></code> を書いて、それを呼ぶ。この関数は <code class="docutils literal notranslate"><span class="pre">fetch</span></code> を行い、応答を待ち、それを処理し、再び自分自身を呼び出す。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">response.status</span></code> が 200 の場合が正常ケース。本来欲しいデータを処理して
<code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">subscribe()</span></code> する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">response.status</span> <span class="pre">==</span> <span class="pre">502</span></code> の場合にはタイムアウトなので、単に <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">subscribe()</span></code> する。</p></li>
<li><p>それ以外のステータスの場合には一秒待って再び自分自身を呼び出す。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">await</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="w"> </span><span class="mf">1000</span><span class="p">));</span>
<span class="k">await</span><span class="w"> </span><span class="nx">subscribe</span><span class="p">();</span>
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<p>囲み記事の概要：</p>
<p>サーバー様式は多数の接続を保留しても動作するものでなければならない。ある種のサーバー様式では、接続一つに対してプロセス一つを実行するため、接続の数と同じだけのプロセスが存在することになる。各プロセスはかなりの量のメモリーを消費することになる。そのため、接続があまりにも多いと、メモリーが枯れてしまう。</p>
<p>PHP や Ruby などの言語で書かれたバックエンドでは、このようなことがよくある。
Node.js で書かれたサーバーは、そのような問題は通常、発生しない。</p>
<p>これはプログラミング言語の問題ではない。PHP や Ruby を含むほとんどの現代の言語では、適切なバックエンドを実装することができる。それでも、サーバー様式が、多数同時接続に問題なく動作することを確認することだ。</p>
</section>
<section id="demo-a-chat">
<h3>Demo: a chat<a class="headerlink" href="#demo-a-chat" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="file docutils literal notranslate"><span class="pre">browser.js</span></code>: ページ側機能。コンストラクター関数 <code class="docutils literal notranslate"><span class="pre">PublishForm</span></code> と
<code class="docutils literal notranslate"><span class="pre">SubscribePane</span></code> の定義。前者はフォームの submit イベントハンドラーと POST 送信を、後者は long polling をそれぞれ実装している。</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">server.js</span></code>: Node.js ベースの未知のコード。</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">index.js</span></code>: 簡易チャットページ。</p></li>
</ul>
<div class="admonition- admonition">
<p class="admonition-title">学習者ノート</p>
<p>デモの再現方法は上述の学習者ノートを参照。</p>
</div>
</section>
<section id="area-of-usage">
<h3>Area of usage<a class="headerlink" href="#area-of-usage" title="Permalink to this heading">¶</a></h3>
<p>Long polling はメッセージがめったに来ないような状況では効果的だ。もしメッセージが頻繁に来るようなら、上に描いた要求と受信の図は鋭いノコギリのような折れ線になる。すべてのメッセージは個別の要求であり、ヘッダーや認証のオーバヘッドが付随する。こういう場合には Websocket や Server Sent Events など、別の方法が望ましい。</p>
</section>
</section>
<section id="websocket">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">WebSocket</a><a class="headerlink" href="#websocket" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/websocket">https://javascript.info/websocket</a>&gt; のノート。</p>
<p>仕様 RFC 6455 にある WebSocket プロトコルは、ブラウザーとサーバーの間で持続的な接続を介してデータを交換する方法を規定している。接続を切断したり、HTTP 要求を追加したりすることなしに、データをパケットとして双方向に渡すことができる。</p>
<p>WebSocket はオンラインゲームやリアルタイム取引システムなど、継続的なデータ交換が必要なサービスに特に適している。</p>
<section id="a-simple-example">
<h3>A simple example<a class="headerlink" href="#a-simple-example" title="Permalink to this heading">¶</a></h3>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">WebSocket</span><span class="p">(</span><span class="s2">&quot;ws://javascript.info&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>WebSocket 接続を開始するには、特別なプロトコル ws:// を使用して新しい
<code class="docutils literal notranslate"><span class="pre">WebSocket</span></code> を生成する必要がある。また、暗号化された wss:// プロトコルもある。HTTP に対する HTTPS の類比で考えていいだろう。</p>
<hr class="docutils" />
<p>wss:// は暗号化されているというだけでなく、信頼性がより高いプロトコルだ。これは、ws:// データが暗号化されておらず、どの中間媒体からも見えるからだ。古いプロキシーサーバーは WebSocket について知らないので、奇妙なヘッダーを見て接続を中断することがある。一方、HTTPS が TLS 上の HTTP であるのと同じく、wss:// は TLS 上の
WebSocket であり、トランスポートセキュリティー層は、送信側でデータを暗号化し、受信側で復号する。つまり、データパケットはプロキシーを経由して暗号化されて渡されるのだ。中身を見ずに通すことができるのだ。</p>
<hr class="docutils" />
<p>ソケットを作成したら、そのイベントを listen する必要がある。イベントは全部で四つだ：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">open</span></code>: 接続成立</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">message</span></code>: 受信</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code>: エラー</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">close</span></code>: 接続終了</p></li>
</ul>
<p>本書ではここにコード例が来る。この構造はどこかで見覚えがある。</p>
<p>デモサーバーから “Hello from server, John” と応答があり、五秒待って接続を閉じる。つまり、open → message → close というイベントが表示される。実はこれだけで、もう WebSocket を話すことができるのだ。</p>
</section>
<section id="opening-a-websocket">
<h3>Opening a websocket<a class="headerlink" href="#opening-a-websocket" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">WebSocket(url)</span></code> が生成されると、すぐに接続を開始する。接続中、ブラウザーは（ヘッダーを使って）サーバーに対して WebSocket に対応しているかと質問する。サーバーが Yes と答えた場合には、HTTP ではなく、WebSocket プロトコルで話を続ける。</p>
<p>本書ではここに <code class="docutils literal notranslate"><span class="pre">WebSocket(&quot;wss://javascript.info/chat&quot;)</span></code> が生成するブラウザーヘッダーを掲載している。注目すべきヘッダーを説明している。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Origin</span></code>: クライアントページのオリジン。WebSocket オブジェクトは元々オリジン横断的だ。このヘッダーによって、サーバーはこのウェブサイトと WebSocket を話すかどうかを決定することができる。重要なヘッダーだ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Connection:</span> <span class="pre">Upgrade</span></code>: クライアントがプロトコルの更新を望んでいることを合図する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Upgrade:</span> <span class="pre">websocket</span></code>: 要求プロトコルは websocket であることを表す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Key</span></code>: 安全保障のためにブラウザーが生成したランダムな鍵。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Version</span></code>: WebSocket プロトコルバージョン。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> や <code class="docutils literal notranslate"><span class="pre">fetch</span></code> では、このような HTTP 要求を行うことはできない。
JavaScript はこれらのヘッダーを設定することができないのだ。</p>
<p>本書では応答例がここに来る。</p>
<p>サーバーが WebSocket への切り替えに同意した場合、コード 101 の応答を送信するべきだ。<code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Accept</span></code> は <code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Key</span></code> であり、特別なアルゴリズムで再暗号化されている。ブラウザーはこれを利用して、応答が要求に対応していることを確認する。その後、データは WebSocket プロトコルを使用して転送される。HTTP では全然ない。</p>
<section id="extensions-and-subprotocols">
<h4>Extensions and subprotocols<a class="headerlink" href="#extensions-and-subprotocols" title="Permalink to this heading">¶</a></h4>
<p>さらに、拡張やサブプロトコルを記述するヘッダー <code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Extensions</span></code> や
<code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Protocol</span></code> が存在するかもしれない。</p>
<p>例えば <code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Extensions:</span> <span class="pre">deflate-frame</span></code> があるとすると、これは、ブラウザーがデータ圧縮を対応していることを意味する。ここでいう extension とは、データの転送に関連するもので、WebSocket プロトコルを拡張する機能だ。ヘッダー
<code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Extensions</span></code> は、ブラウザーが対応するすべての拡張機能一覧とともに自動的に送信される。</p>
<p>例えば <code class="docutils literal notranslate"><span class="pre">Sec-WebSocket-Protocol:</span> <span class="pre">soap,</span> <span class="pre">wamp</span></code> というヘッダーがあるとすると、ただのデータではなく、SOAP や WAMP のデータを転送したいことを意味する。 WebSocket のサブプロトコルは IANA 目録に登録されている。つまり、このヘッダーには、これから使用するデータ書式が記述されている。このオプションのヘッダーは、新しい WebSocket
の第二引数で設定される：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">WebSocket</span><span class="p">(</span><span class="s2">&quot;wss://javascript.info/chat&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;soap&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;wamp&quot;</span><span class="p">]);</span>
</pre></div>
</div>
<p>サーバーは、使用することに同意するプロトコルと拡張子の一覧を応答するはずだ。</p>
<p>本書ではここに要求例と応答例が来る。SOAP と WAMP は対応しているかと問われて、
SOAP は対応していると応答していると読める。</p>
</section>
</section>
<section id="data-transfer">
<h3>Data transfer<a class="headerlink" href="#data-transfer" title="Permalink to this heading">¶</a></h3>
<p>WebSocket 通信は、コマ（データの断片）で構成されており、どちらからでも送信され、いくつかの種類のものを持つことができる：</p>
<ul class="simple">
<li><p>テキスト。当事者が互いに送信するテキストデータを含む。</p></li>
<li><p>バイナリデータ。当事者が互いに送信するバイナリデータを含む。</p></li>
<li><p>ピンポン。接続を確認するためにサーバーから送信され、ブラウザーはこれに対して自動的に応答する。</p></li>
<li><p>接続終了および他のいくつかのサービスコマもある。</p></li>
</ul>
<p>ブラウザーではテキストフレームまたはバイナリフレームだけを直接操作している。</p>
<p>WebSocket のメソッド <code class="docutils literal notranslate"><span class="pre">send()</span></code> は、テキストデータまたはバイナリデータのどちらか一方を送信できる。<code class="docutils literal notranslate"><span class="pre">socket.send(body)</span></code> 呼び出しで、<code class="docutils literal notranslate"><span class="pre">Blob</span></code>, <code class="docutils literal notranslate"><span class="pre">ArrayBuffer``な</span>
<span class="pre">どの文字列またはバイナリー形式の</span> <span class="pre">``body</span></code> を送信できる。設定は不要で、任意の書式で送信するだけだ。</p>
<p>データを受け取るとき、テキストは常に文字列でやって来る。また、バイナリーデータについては、<code class="docutils literal notranslate"><span class="pre">Blob</span></code> 形式と <code class="docutils literal notranslate"><span class="pre">ArrayBuffer</span></code> 形式のうちどちらかを選択できる。</p>
<p>これをプロパティー <code class="docutils literal notranslate"><span class="pre">socket.binaryType</span></code> で設定する。既定値は <code class="docutils literal notranslate"><span class="pre">&quot;blob&quot;</span></code> なので、バイナリーデータは <code class="docutils literal notranslate"><span class="pre">Blob</span></code> オブジェクトとして送られる。<code class="docutils literal notranslate"><span class="pre">Blob</span></code> は高水準なバイナリーオブジェクトであり、 A や IMG などのタグと直接統合できるので、既定値としてはまともなものだ。バイナリー処理に対しては、個々のデータバイトにアクセスするのに <code class="docutils literal notranslate"><span class="pre">&quot;arraybuffer&quot;</span></code> に変更するとよい。</p>
</section>
<section id="rate-limiting">
<h3>Rate limiting<a class="headerlink" href="#rate-limiting" title="Permalink to this heading">¶</a></h3>
<p>大量のデータを生成して送信しているサービスがあるとする。ユーザーはネットワーク接続が遅く、モバイルインターネットや都市部以外の場所にいる可能性がある。
<code class="docutils literal notranslate"><span class="pre">socket.send(data)</span></code> を何度も何度も呼び出すこともできるが、データはメモリーにバッファリング（保存）され、ネットワーク速度が許す範囲でしか送出されない。</p>
<p>プロパティー <code class="docutils literal notranslate"><span class="pre">socket.bufferedAmount</span></code> からは、今現在、何バイトがバッファリングされ、ネットワーク上で送信されるのを待っているかを得られる。そのソケットが実際に送信可能かどうかを確認できる。</p>
<p>その値が 0 であるならば <code class="docutils literal notranslate"><span class="pre">send</span></code> すればいい。本書では <code class="docutils literal notranslate"><span class="pre">setInterval</span></code> を利用して、0.1 秒ごとに値をテストして可能ならば送信するコード片を示している。</p>
</section>
<section id="connection-close">
<h3>Connection close<a class="headerlink" href="#connection-close" title="Permalink to this heading">¶</a></h3>
<p>接続を閉じたい側は、数字コードとテキストによる理由を書いた接続終了フレームを送信するのが普通だ。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">socket</span><span class="p">.</span><span class="nx">close</span><span class="p">([</span><span class="nx">code</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="nx">reason</span><span class="p">]);</span>
</pre></div>
</div>
<p>引数は全部オプショナル。引数 <code class="docutils literal notranslate"><span class="pre">code</span></code> は特別な WebSocket コード。引数 <code class="docutils literal notranslate"><span class="pre">reason</span></code>
は閉じる理由を述べる文字列。</p>
<p>相手はイベントハンドラー <code class="docutils literal notranslate"><span class="pre">close</span></code> の引数のプロパティーからそれらの値が得られる。</p>
<ul class="simple">
<li><p>1000: 通常の接続終了（コードが提供されない場合に使用）</p></li>
<li><p>1006: このようなコードを手動で設定する方法がない。接続が失われた（接続終了フレームがない）。</p></li>
</ul>
<p>WebSocket のコードは HTTP のそれとどこか似ているようだが、異なる。特に、1000 未満のコードは予約されており、そのようなコードを設定しようとするとエラーになる。</p>
</section>
<section id="connection-state">
<h3>Connection state<a class="headerlink" href="#connection-state" title="Permalink to this heading">¶</a></h3>
<p>接続状態を取得するために、さらに、値を持つプロパティー <code class="docutils literal notranslate"><span class="pre">socket.readyState</span></code> がある。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Code</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>State</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;CONNECTING&quot;</span></code></p></td>
<td><p>接続がまだ確立されていない</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;OPEN&quot;</span></code></p></td>
<td><p>通信中</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;CLOSING&quot;</span></code></p></td>
<td><p>接続を閉じている</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;CLOSED&quot;</span></code></p></td>
<td><p>接続が閉じた</p></td>
</tr>
</tbody>
</table>
</section>
<section id="chat-example">
<h3>Chat example<a class="headerlink" href="#chat-example" title="Permalink to this heading">¶</a></h3>
<p>ブラウザーの WebSocket API と Node.js の WebSocketモジュール
&lt;<a class="reference external" href="https://github.com/websockets/ws">https://github.com/websockets/ws</a>&gt; を使ったチャットの例。ここではクライアント側に主に注目する。</p>
<ul class="simple">
<li><p>グローバルに <code class="docutils literal notranslate"><span class="pre">WebSocket</span></code> を wss:// で生成する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">document.forms.publish.onsubmit</span></code> ハンドラーでソケットの <code class="docutils literal notranslate"><span class="pre">send</span></code> を呼び出す。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">socket.onmessage</span></code> ハンドラーでサーバーからの受信メッセージをページ内に追加する。</p></li>
</ul>
<p>このデモをダウンロードしてローカルで実行することもできる。<strong class="command">npm install
ws</strong> しておくことが必要だ。</p>
</section>
</section>
<section id="server-sent-events">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Server Sent Events</a><a class="headerlink" href="#server-sent-events" title="Permalink to this heading">¶</a></h2>
<p>&lt;<a class="reference external" href="https://javascript.info/server-sent-events">https://javascript.info/server-sent-events</a>&gt; のノート。</p>
<p>Server-Sent Events 仕様では、サーバーとの接続を維持し、サーバーからのイベントを受信することができる組み込みクラス <code class="docutils literal notranslate"><span class="pre">EventSource</span></code> を記述している。 WebSocket と同様に、接続は永続的だ。しかし、本書の表のように、いくつかの重要な違いがある。</p>
<p><code class="docutils literal notranslate"><span class="pre">WebSocket</span></code> と比べると <code class="docutils literal notranslate"><span class="pre">EventSource</span></code> はサーバーと通信するための方法としては強力さで劣る。なぜそれを使わなければならないのか。最大の理由はより単純であることだ。多くのアプリケーションでは <code class="docutils literal notranslate"><span class="pre">WebSocket</span></code> の力はやや過剰だ。</p>
<p>サーバーからデータのストリームを受信する必要がある。それはチャットメッセージ、市場価格、その他かもしれない。こういうことは <code class="docutils literal notranslate"><span class="pre">EventSource</span></code> が得意とするところだ。また、<code class="docutils literal notranslate"><span class="pre">WebSocket</span></code> では手動で実装する必要がある自動再接続も対応している。その上、それはれっきとした HTTP であり、新しいプロトコルではない。</p>
<section id="getting-messages">
<h3>Getting messages<a class="headerlink" href="#getting-messages" title="Permalink to this heading">¶</a></h3>
<p>メッセージの受信を開始するには、新しい <code class="docutils literal notranslate"><span class="pre">EventSource(url)</span></code> を生成する。ブラウザは <code class="docutils literal notranslate"><span class="pre">url</span></code> に接続し、接続を開いたままイベントを待つ。サーバーはステータス 200 と
<code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">text/event-stream</span></code> というヘッダーで応答し、接続を維持したまま、次のように特別な書式でメッセージを書き込むはずだ：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>data: Message 1

data: Message 2

data: Message 3
data: of two lines
</pre></div>
</div>
<ul class="simple">
<li><p>メッセージテキストは <code class="docutils literal notranslate"><span class="pre">data:</span></code> の後に続く。コロンの後の空白はオプショナルだ。</p></li>
<li><p>メッセージの区切りは二重の改行 <code class="docutils literal notranslate"><span class="pre">\n\n</span></code> だ。</p></li>
<li><p>単なる <code class="docutils literal notranslate"><span class="pre">\n</span></code> を送るには、すぐにもう一つ <code class="docutils literal notranslate"><span class="pre">data:</span></code> を送る。</p></li>
</ul>
<p>実際には、複雑なメッセージは通常 JSON に変換して送信する。改行はその中で <code class="docutils literal notranslate"><span class="pre">\n</span></code>
として符号化されるので、複数行の <code class="docutils literal notranslate"><span class="pre">data:</span></code> メッセージは必要ではない。ゆえに、<code class="docutils literal notranslate"><span class="pre">data:</span></code> 一つがちょうどメッセージ一つを保持していると仮定できる。そのようなメッセージごとに、イベント <code class="docutils literal notranslate"><span class="pre">message</span></code> が発生する。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">eventSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">EventSource</span><span class="p">(</span><span class="s2">&quot;/events/subscribe&quot;</span><span class="p">);</span>
<span class="c1">// or eventSource.addEventListener(&#39;message&#39;, function(event){ ... })</span>
<span class="nx">eventSource</span><span class="p">.</span><span class="nx">onmessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;New message&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// will log 3 times for the data stream above</span>
<span class="p">};</span>
</pre></div>
</div>
<section id="id5">
<h4>Cross-origin requests<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">EventSource</span></code> は <code class="docutils literal notranslate"><span class="pre">fetch</span></code> やその他のネットワークメソッドのように、オリジン横断的要求を対応している。任意の URL を使用できる。</p>
<p>リモートサーバーはヘッダー <code class="docutils literal notranslate"><span class="pre">Origin</span></code> を取得し、処理を続行するにはヘッダー
<code class="docutils literal notranslate"><span class="pre">Access-Control-Allow-Origin</span></code> で応答しなければならない。</p>
<p>証明証を渡すには、追加オプションの <code class="docutils literal notranslate"><span class="pre">withCredentials</span></code> を設定しなくてはならない。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">EventSource</span><span class="p">(</span><span class="s2">&quot;https://another-site.com/events&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">withCredentials</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="p">});</span>
</pre></div>
</div>
</section>
</section>
<section id="reconnection">
<h3>Reconnection<a class="headerlink" href="#reconnection" title="Permalink to this heading">¶</a></h3>
<p>生成時に、新しい <code class="docutils literal notranslate"><span class="pre">EventSource</span></code> はサーバーに接続し、接続が切れた場合は再接続する。これはたいへん便利で、接続切れを気にする必要はない。再接続の間にはわずかな遅延があり、既定では 3, 4 秒だ。</p>
<p>サーバーは <code class="docutils literal notranslate"><span class="pre">retry:</span></code> を応答に使って推奨遅延時間を設定できる。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>retry: 15000
data: Hello, I set the reconnection delay to 15 seconds
</pre></div>
</div>
<p>ヘッダー <code class="docutils literal notranslate"><span class="pre">retry:</span></code> はデータと一緒に送られてくることもあれば、単体メッセージとして送られてくることもある。</p>
<p>ブラウザーは再接続する前に、その時間だけ待たねばならない。もっと長い場合もある。たとえば、ブラウザーが現在ネットワーク接続がないことを OS から知っている場合、接続が現れるまで待つことができ、それから再試行する。</p>
<p>サーバーがブラウザーに再接続を停止させたい場合は、HTTP ステータス 204 で応答するはずだ。ブラウザーが接続を終了させたい場合には、<code class="docutils literal notranslate"><span class="pre">eventSource.close()</span></code> を呼び出すのがいい。</p>
<p>また、応答の <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> が正しくない場合や、HTTP ステータスが 301, 307,
200, 204 と異なる場合は、再接続はないはずだ。このような場合、イベント <code class="docutils literal notranslate"><span class="pre">&quot;error&quot;</span></code>
が発生し、ブラウザーは再接続しようとしない。</p>
<hr class="docutils" />
<p>最終的に接続を閉じた場合、それを再開する方法はない。再び接続したいならば新しい
<code class="docutils literal notranslate"><span class="pre">EventSource</span></code> を生成するだけだ。</p>
</section>
<section id="message-id">
<h3>Message <code class="docutils literal notranslate"><span class="pre">id</span></code><a class="headerlink" href="#message-id" title="Permalink to this heading">¶</a></h3>
<p>ネットワーク問題で接続が切れた場合、どちらの側もどのメッセージが受信されてどのメッセージが受信されていないのかを確認できない。接続を正しく再開するために、メッセージそれぞれには <code class="docutils literal notranslate"><span class="pre">id</span></code> フィールドがあるといい：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>data: Message 1
id: 1

data: Message 2
id: 2

data: Message 3
data: of two lines
id: 3
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">id:</span></code> があるメッセージを受信した場合、ブラウザーは</p>
<ul class="simple">
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">eventSource.lastEventId</span></code> の値をそれにする。</p></li>
<li><p>再接続時にヘッダー <code class="docutils literal notranslate"><span class="pre">Last-Event-ID</span></code> をその <code class="docutils literal notranslate"><span class="pre">id</span></code> で送信し、サーバーが次に続くメッセージを再送信できるようにする。</p></li>
</ul>
<hr class="docutils" />
<p>メッセージ受信後、<code class="docutils literal notranslate"><span class="pre">lastEventId</span></code> を確実に更新するために、サーバーは <code class="docutils literal notranslate"><span class="pre">id</span></code> をメッセージデータの下に付加する。</p>
</section>
<section id="connection-status-readystate">
<h3>Connection status: <code class="docutils literal notranslate"><span class="pre">readyState</span></code><a class="headerlink" href="#connection-status-readystate" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">EventSource</span></code> はプロパティー <code class="docutils literal notranslate"><span class="pre">readyState</span></code> を持ち、その値は三つのうちの一つだ：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">EventSource</span><span class="p">.</span><span class="nx">CONNECTING</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// connecting or reconnecting</span>
<span class="nx">EventSource</span><span class="p">.</span><span class="nx">OPEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w">       </span><span class="c1">// connected</span>
<span class="nx">EventSource</span><span class="p">.</span><span class="nx">CLOSED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span><span class="p">;</span><span class="w">     </span><span class="c1">// connection closed</span>
</pre></div>
</div>
<p>オブジェクトが生成したときや、接続が切れたときは、<code class="docutils literal notranslate"><span class="pre">EventSource.CONNECTING</span></code> につねに等しい。このプロパティーを照会することで、<code class="docutils literal notranslate"><span class="pre">EventSource</span></code> の状態を知ることができる。</p>
</section>
<section id="event-types">
<h3>Event types<a class="headerlink" href="#event-types" title="Permalink to this heading">¶</a></h3>
<p>既定では、<code class="docutils literal notranslate"><span class="pre">EventSource</span></code> オブジェクトはイベント三つを発生させる：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">message</span></code>: 受信したメッセージ。<code class="docutils literal notranslate"><span class="pre">event.data</span></code> として利用可能。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">open</span></code>: 接続が開いた。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code>: 接続を確立できなかった。例えばサーバーが 500 を返した。</p></li>
</ul>
<p>イベント開始時に、サーバーは <code class="docutils literal notranslate"><span class="pre">event:</span> <span class="pre">...</span></code> で別の型のイベントを指定してもよい。たとえば：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>event: join
data: Bob

data: Hello

event: leave
data: Bob
</pre></div>
</div>
<p>カスタムイベントを処理するには、<code class="docutils literal notranslate"><span class="pre">onmessage</span></code> ではなく、<code class="docutils literal notranslate"><span class="pre">addEventListener</span></code> を使用する必要がある。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">eventSource</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;join&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">event</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">alert</span><span class="p">(</span><span class="sb">`Joined </span><span class="si">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</section>
<section id="full-example">
<h3>Full example<a class="headerlink" href="#full-example" title="Permalink to this heading">¶</a></h3>
<p>これはメッセージ <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">bye</span></code> を送信してから、接続を切断するサーバーだ。その後、ブラウザーが自動的に再接続する。</p>
<p><code class="file docutils literal notranslate"><span class="pre">server.js</span></code> のコードを見ると、この直前に述べられているように、ヘッダーを定義しているのがなんとかわかる。</p>
<p><code class="file docutils literal notranslate"><span class="pre">index.html</span></code> のコードでは <code class="docutils literal notranslate"><span class="pre">EventSource</span></code> を生成して、この直前に述べられているように、イベントハンドラーを定義していることがわかる。</p>
<div class="admonition- admonition">
<p class="admonition-title">学習者ノート</p>
<p>デモの再現方法は上述の学習者ノートを参照。</p>
</div>
</section>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="02-binary.html" title="Previous document">Binary data, files</a>
        </li>
        <li>
          <a href="04-data-storage.html" title="Next document">Storing data in the browser</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ou23/index.html">Modern C++ Tutorial: C++ 11/14/17/20 On the Fly 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bash-v4.html">What’s New In Bash 4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bash-v5.html">What’s New In Bash 5 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../youtube-dl.html">youtube-dl 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-upgrade.html">Python 移行ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../google-ime.html">Google 日本語入力利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wslg.html">Windows Subsystem for Linux GUI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oh-my-posh.html">Oh My Posh 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ffmpeg/index.html">FFmpeg 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pandoc.html">Pandoc 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zoom.html">Zoom Cloud Meetings 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">The Modern JavaScript Tutorial 読書ノート</a><ul>
  <li><a href="index.html">Part 3 Additional articles</a><ul>
      <li>Previous: <a href="02-binary.html" title="previous chapter">Binary data, files</a></li>
      <li>Next: <a href="04-data-storage.html" title="next chapter">Storing data in the browser</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2023, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>