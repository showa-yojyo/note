<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Effective STL 読書ノート &#8212; 読書ノート 1.6dev documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=1a9a5cd9" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=5a6f99c4"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="_static/mathjax-v3.js?v=bf1ec211"></script>
    <script src="_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="More Exceptional C++ 読書ノート" href="sutter02.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート 3/3" href="alexandrescu01/note3.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="alexandrescu01/note3.html" title="Previous document">Modern C++ Design 読書ノート 3/3</a>
        </li>
        <li>
          <a href="sutter02.html" title="Next document">More Exceptional C++ 読書ノート</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="effective-stl">
<h1><a class="toc-backref" href="#id60" role="doc-backlink">Effective STL 読書ノート</a><a class="headerlink" href="#effective-stl" title="Permalink to this heading">¶</a></h1>
<p>三大 C++ Effective 本の一つ。記者が初めて購入した C++ 関連書籍なので、とっくの昔に読書ノートがない。改めて作成する。</p>
<dl class="field-list simple">
<dt class="field-odd">著者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Scott Meyers</p>
</dd>
<dt class="field-even">訳者<span class="colon">:</span></dt>
<dd class="field-even"><p>細谷昭</p>
</dd>
<dt class="field-odd">出版社<span class="colon">:</span></dt>
<dd class="field-odd"><p>ピアソン・エデュケーション</p>
</dd>
<dt class="field-even">発行年<span class="colon">:</span></dt>
<dd class="field-even"><p>2002 年</p>
</dd>
<dt class="field-odd">ISBN<span class="colon">:</span></dt>
<dd class="field-odd"><p>978-4-89471-410-6</p>
</dd>
</dl>
<nav class="contents" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#effective-stl" id="id60">Effective STL 読書ノート</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id61">はじめに</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id62">コンテナ</a></p>
<ul>
<li><p><a class="reference internal" href="#id4" id="id63">第 1 項</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id64">第 2 項</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id65">第 3 項</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id66">第 4 項</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id67">第 5 項</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id68">第 6 項</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id69">第 7 項</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id70">第 8 項</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id71">第 9 項</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id72">第 10 項</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id73">第 11 項</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id74">第 12 項</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#vector-string" id="id75"><code class="docutils literal notranslate"><span class="pre">vector</span></code> と <code class="docutils literal notranslate"><span class="pre">string</span></code></a></p>
<ul>
<li><p><a class="reference internal" href="#id16" id="id76">第 13 項</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id77">第 14 項</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id78">第 15 項</a></p></li>
<li><p><a class="reference internal" href="#id19" id="id79">第 16 項</a></p></li>
<li><p><a class="reference internal" href="#id20" id="id80">第 17 項</a></p></li>
<li><p><a class="reference internal" href="#id21" id="id81">第 18 項</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id22" id="id82">連想コンテナ</a></p>
<ul>
<li><p><a class="reference internal" href="#id23" id="id83">第 19 項</a></p></li>
<li><p><a class="reference internal" href="#id24" id="id84">第 20 項</a></p></li>
<li><p><a class="reference internal" href="#id25" id="id85">第 21 項</a></p></li>
<li><p><a class="reference internal" href="#id26" id="id86">第 22 項</a></p></li>
<li><p><a class="reference internal" href="#id27" id="id87">第 23 項</a></p></li>
<li><p><a class="reference internal" href="#id28" id="id88">第 24 項</a></p></li>
<li><p><a class="reference internal" href="#id29" id="id89">第 25 項</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id30" id="id90">反復子</a></p>
<ul>
<li><p><a class="reference internal" href="#id31" id="id91">第 26 項</a></p></li>
<li><p><a class="reference internal" href="#id32" id="id92">第 27 項</a></p></li>
<li><p><a class="reference internal" href="#id33" id="id93">第 28 項</a></p></li>
<li><p><a class="reference internal" href="#id34" id="id94">第 29 項</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id35" id="id95">アルゴリズム</a></p>
<ul>
<li><p><a class="reference internal" href="#id36" id="id96">第 30 項</a></p></li>
<li><p><a class="reference internal" href="#id37" id="id97">第 31 項</a></p></li>
<li><p><a class="reference internal" href="#id38" id="id98">第 32 項</a></p></li>
<li><p><a class="reference internal" href="#id39" id="id99">第 33 項</a></p></li>
<li><p><a class="reference internal" href="#id40" id="id100">第 34 項</a></p></li>
<li><p><a class="reference internal" href="#id41" id="id101">第 35 項</a></p></li>
<li><p><a class="reference internal" href="#id42" id="id102">第 36 項</a></p></li>
<li><p><a class="reference internal" href="#id43" id="id103">第 37 項</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id44" id="id104">ファンクタ、ファンクタクラス、関数など</a></p>
<ul>
<li><p><a class="reference internal" href="#id45" id="id105">第 38 項</a></p></li>
<li><p><a class="reference internal" href="#id46" id="id106">第 39 項</a></p></li>
<li><p><a class="reference internal" href="#id47" id="id107">第 40 項</a></p></li>
<li><p><a class="reference internal" href="#id48" id="id108">第 41 項</a></p></li>
<li><p><a class="reference internal" href="#id49" id="id109">第 42 項</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#stl" id="id110">STL を使ったプログラミング</a></p>
<ul>
<li><p><a class="reference internal" href="#id50" id="id111">第 43 項</a></p></li>
<li><p><a class="reference internal" href="#id51" id="id112">第 44 項</a></p></li>
<li><p><a class="reference internal" href="#id52" id="id113">第 45 項</a></p></li>
<li><p><a class="reference internal" href="#id53" id="id114">第 46 項</a></p></li>
<li><p><a class="reference internal" href="#id54" id="id115">第 47 項</a></p></li>
<li><p><a class="reference internal" href="#id55" id="id116">第 48 項</a></p></li>
<li><p><a class="reference internal" href="#id56" id="id117">第 49 項</a></p></li>
<li><p><a class="reference internal" href="#id57" id="id118">第 50 項</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id58" id="id119">参考文献</a></p></li>
<li><p><a class="reference internal" href="#id59" id="id120">ロケールと大文字小文字を区別しない文字列比較</a></p></li>
<li><p><a class="reference internal" href="#microsoft-stl" id="id121">Microsoft の STL プラットフォームについて</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="id2">
<h2><a class="toc-backref" href="#id61" role="doc-backlink">はじめに</a><a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>本書の対象を &lt;STL の使い方は知っているが、 「効果的に」使用しているかどうか確信が持てない&gt; (p. 1) 読者としている。</p></li>
<li><p>本書では、STL (Standard Template Library) の定義を次のように独自に規定している。 &lt;反復子を利用する C++ の標準ライブラリの部分&gt; (p. 2) この定義を与えることで、本書のカバー領域をも明確に宣言している。</p></li>
<li><p>STL を扱う際には、コンパイラとライブラリの両方を区別できることが重要とある。原著を執筆していた当時は、コンパイラもライブラリも標準に準拠し切れていないものが多かったはず。著者の苦労が窺い知れる。</p></li>
<li><p>用語</p>
<ul>
<li><p>シーケンスコンテナと連想コンテナのおさらい。</p></li>
<li><p>反復子の 5 カテゴリのおさらい。</p></li>
<li><p>&lt;関数呼び出し演算子 <code class="docutils literal notranslate"><span class="pre">operator()</span></code> をオーバーロードするクラスは「ファンクタクラス」と呼ばれている&gt; (p. 5)</p></li>
<li><p>アルゴリズム等のコストを「定数時間」「対数時間」「線形時間」の三つにザックリ分類している。そういえば本書は <span class="math notranslate nohighlight">\(O(1)\)</span> とか <span class="math notranslate nohighlight">\(O(\log N)\)</span> とかの記法は用いていないようだ。</p></li>
</ul>
</li>
<li><p>コード例</p>
<ul>
<li><p>著者は <code class="docutils literal notranslate"><span class="pre">typename</span></code> 派。</p></li>
<li><p>著者は <code class="docutils literal notranslate"><span class="pre">operator==</span></code> などの二項演算子の関数パラメータに <code class="docutils literal notranslate"><span class="pre">lhs</span></code> と <code class="docutils literal notranslate"><span class="pre">rhs</span></code>
という名前を付ける習慣がある。習慣化しておくと、関数を定義するときに変数名をつけるのに悩む時間をゼロにできて素晴らしい。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id62" role="doc-backlink">コンテナ</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<section id="id4">
<h3><a class="toc-backref" href="#id63" role="doc-backlink">第 1 項</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>デフォルトで使用すべきシーケンス型は <code class="docutils literal notranslate"><span class="pre">vector</span></code> だ。</p></li>
<li><p>「連続メモリコンテナ」と「ノードベースコンテナ」という分類の方法がある。</p></li>
</ul>
</section>
<section id="id5">
<h3><a class="toc-backref" href="#id64" role="doc-backlink">第 2 項</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>&lt;たとえば <code class="docutils literal notranslate"><span class="pre">vector</span></code> を使っているが、コンテナを使用するコードを変更せずに、後で <code class="docutils literal notranslate"><span class="pre">deque</span></code> や <code class="docutils literal notranslate"><span class="pre">list</span></code> などに置き換えられるようにしようとする。つまり、「コンテナに依存しないコード」を書こうとするのである。ほとんどの場合、よかれと思ってなされるこの種の汎用化は間違っている&gt; (p. 15)</p>
<p>例えば異なるシーケンスコンテナに適用する反復子を無効化する規則が異なる。異なるコンテナは「異なる」のであって、互いを交換するようには設計されていない。といった議論を展開している。かなり丁寧に（誰かを）説得している。</p>
</li>
<li><p>コーディングテクニックとして、<code class="docutils literal notranslate"><span class="pre">typedef</span></code> の効用を説いている。</p></li>
</ul>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id65" role="doc-backlink">第 3 項</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>この項目はタイトルが全て。コンテナにオブジェクトを追加するときは、必ずそのオブジェクトのコピーが入る。取得も基本的にはコピーを出す。</p></li>
</ul>
</section>
<section id="id7">
<h3><a class="toc-backref" href="#id66" role="doc-backlink">第 4 項</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">empty</span></code> はすべての標準コンテナに対して定数時間処理だが、<code class="docutils literal notranslate"><span class="pre">size</span></code> の場合、一部の <code class="docutils literal notranslate"><span class="pre">list</span></code> の実装には線形時間がかかる&gt; (p. 22)</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code> 実装者が <code class="docutils literal notranslate"><span class="pre">size</span></code> を定数時間処理にしようとすると、今度は <code class="docutils literal notranslate"><span class="pre">splice</span></code>
が線形時間処理にならざるを得ない。</p></li>
</ul>
</li>
<li><p>コンテナに要素があるか否かをテストするには、常に <code class="docutils literal notranslate"><span class="pre">empty</span></code> を呼びだす。</p></li>
</ul>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id67" role="doc-backlink">第 5 項</a><a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<p>この本を買って、一番最初に感動を覚えた項目。</p>
<ul>
<li><p>「<code class="docutils literal notranslate"><span class="pre">vector</span></code> <code class="docutils literal notranslate"><span class="pre">v1</span></code> と <code class="docutils literal notranslate"><span class="pre">v2</span></code> があり、 <code class="docutils literal notranslate"><span class="pre">v1</span></code> を <code class="docutils literal notranslate"><span class="pre">v2</span></code> の後半部分と同じ内容にする」という処理を実装するのに、for などのループを使わずに書ければ及第点。</p></li>
<li><p>「範囲メンバ関数」という用語を導入し、その効用を説明している。</p>
<ul class="simple">
<li><p>コーティングの作業量が少ない。</p></li>
<li><p>簡単でわかりやすい傾向がある。</p></li>
</ul>
</li>
<li><p>&lt;開発者は、どのエディタが「最高のエディタ」かについての議論を好むように（Emacs
であることに疑問の余地はないのだが）&gt; (p. 26)</p>
<p>これは本気かギャグか判断つきかねる。</p>
</li>
<li><p>範囲メンバ関数として、次のものをとりあえず意識しておく。</p>
<ul class="simple">
<li><p>コンストラクタ</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">insert</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">erase</span></code> （後述の項目で <code class="docutils literal notranslate"><span class="pre">remove</span></code> アルゴリズムとのコンボ技を紹介している）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assign</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="id9">
<h3><a class="toc-backref" href="#id68" role="doc-backlink">第 6 項</a><a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h3>
<p>「関数宣言として解析できるものは関数宣言とみなす」ルールによって、コンストラクタから iterator を生成するコードがコンパイルエラーになることがある。</p>
</section>
<section id="id10">
<h3><a class="toc-backref" href="#id69" role="doc-backlink">第 7 項</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new</span></code> によるポインタを抱えるコンテナを取り扱うことの難しさを説明している。</p></li>
<li><p>&lt;仮想デストラクタなしにクラスから公開で継承することは、 C++ でやってはいけないことの 1 つである&gt; (p. 36)</p></li>
</ul>
</section>
<section id="id11">
<h3><a class="toc-backref" href="#id70" role="doc-backlink">第 8 項</a><a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h3>
<p>そういえば <code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> に <code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> を代入すると、右辺側は null になるのだった。
<code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> にコピーコンストラクタとコピー代入演算子があるのは、どういう理由からだったろうか。</p>
</section>
<section id="id12">
<h3><a class="toc-backref" href="#id71" role="doc-backlink">第 9 項</a><a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h3>
<p>コンテナから要素を消去する方法について。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">remove_if</span></code> 方式で条件を満たす要素を連想コンテナから削除する場合が少しややこしいか。</p></li>
<li><p>削除しながら、何か別のことをする処理を書くには、やはり手でループするしかない。</p></li>
</ul>
</section>
<section id="id13">
<h3><a class="toc-backref" href="#id72" role="doc-backlink">第 10 項</a><a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h3>
<p>アロケータに関する話題。</p>
</section>
<section id="id14">
<h3><a class="toc-backref" href="#id73" role="doc-backlink">第 11 項</a><a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h3>
<p>カスタムアロケータに関する話題。</p>
</section>
<section id="id15">
<h3><a class="toc-backref" href="#id74" role="doc-backlink">第 12 項</a><a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<p>コンテナのスレッドセーフティ（安全性）について。あまりうれしいことは書いていない。</p>
<ul class="simple">
<li><p>&lt;クラスを使ってリソースの有効期限を管理する考え方は、一般的に「リソース取得は初期化である」として知られており、 C++ の総合的な教科書では、必ず説明を読むことができる。 Stroustrup がこの慣用句を有名にした&gt; (p. 59) こういうクラスを利用する方法は、&lt;例外に対して堅牢である。C++ では、例外が発生すると、ローカルオブジェクトは破棄されることが保証されている&gt; (p. 60) 取得してあるリソースが、確実に呼び出されるデストラクタが解放するからだ。</p></li>
</ul>
</section>
</section>
<section id="vector-string">
<h2><a class="toc-backref" href="#id75" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">vector</span></code> と <code class="docutils literal notranslate"><span class="pre">string</span></code></a><a class="headerlink" href="#vector-string" title="Permalink to this heading">¶</a></h2>
<section id="id16">
<h3><a class="toc-backref" href="#id76" role="doc-backlink">第 13 項</a><a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>動的に割り当てる配列よりは、<code class="docutils literal notranslate"><span class="pre">vector</span></code> や <code class="docutils literal notranslate"><span class="pre">string</span></code> を使う。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code> の実装が参照カウンタ方式かを調べるには、コピーコンストラクタを見ればよい。</p></li>
</ul>
</section>
<section id="id17">
<h3><a class="toc-backref" href="#id77" role="doc-backlink">第 14 項</a><a class="headerlink" href="#id17" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vector::reserve</span></code> に関する話題。でもこの例のコードならば、<code class="docutils literal notranslate"><span class="pre">resize</span></code> して
<code class="docutils literal notranslate"><span class="pre">operator[]</span></code> で要素を代入したほうがパフォーマンスがいいのではないか。</p></li>
</ul>
</section>
<section id="id18">
<h3><a class="toc-backref" href="#id78" role="doc-backlink">第 15 項</a><a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;申し訳ないが、そこまでソースコードを読み込んでいなかった&gt; (p.70) がウケた。</p></li>
</ul>
</section>
<section id="id19">
<h3><a class="toc-backref" href="#id79" role="doc-backlink">第 16 項</a><a class="headerlink" href="#id19" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>配列を受け取る関数に <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">v</span></code> を渡すには <code class="docutils literal notranslate"><span class="pre">&amp;v[0]</span></code> を使う。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> を受け取る関数に <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">s</span></code> を渡すには <code class="docutils literal notranslate"><span class="pre">s.c_str()</span></code> を使う。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> の付かない <code class="docutils literal notranslate"><span class="pre">char*</span></code> を受け取る関数に対しては、<code class="docutils literal notranslate"><span class="pre">s</span></code> を
<code class="docutils literal notranslate"><span class="pre">vector&lt;char&gt;</span> <span class="pre">v</span></code> に一旦作り直してから、その関数に <code class="docutils literal notranslate"><span class="pre">&amp;v[0]</span></code> を渡す。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id20">
<h3><a class="toc-backref" href="#id80" role="doc-backlink">第 17 項</a><a class="headerlink" href="#id20" title="Permalink to this heading">¶</a></h3>
<p>この本を買って、二番目に感動した項目。スワップはやはりいい。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">vector</span></code>/<code class="docutils literal notranslate"><span class="pre">string</span></code> で <code class="docutils literal notranslate"><span class="pre">erase</span></code> を呼んだ後でも、容量 (<code class="docutils literal notranslate"><span class="pre">capacity</span></code>) は通常そのまま保たれる。それを強制的に削るため、<code class="docutils literal notranslate"><span class="pre">swap</span></code> をトリッキーな呼び出し方をして、<code class="docutils literal notranslate"><span class="pre">vector</span></code>/<code class="docutils literal notranslate"><span class="pre">string</span></code> から余分な容量を削除することができる。著者はこの技法を “shrink to fit” 方法と呼んでいる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>あるいは</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id21">
<h3><a class="toc-backref" href="#id81" role="doc-backlink">第 18 項</a><a class="headerlink" href="#id21" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code> はいらない。状況に応じて次のいずれかで対応する。</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">deque&lt;bool&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bitset</span></code></p></li>
</ol>
</div></blockquote>
</section>
</section>
<section id="id22">
<h2><a class="toc-backref" href="#id82" role="doc-backlink">連想コンテナ</a><a class="headerlink" href="#id22" title="Permalink to this heading">¶</a></h2>
<p>再読して気付いたことがある。この章が最も記憶に定着していなかった項目が多い。</p>
<section id="id23">
<h3><a class="toc-backref" href="#id83" role="doc-backlink">第 19 項</a><a class="headerlink" href="#id23" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>長いが重要なので引用する。
&lt;<code class="docutils literal notranslate"><span class="pre">find</span></code> アルゴリズムと <code class="docutils literal notranslate"><span class="pre">set</span></code> の <code class="docutils literal notranslate"><span class="pre">insert</span></code> メンバ関数は、 2 つの値が同じかどうかを調べる多くの関数を代表している。しかし、<code class="docutils literal notranslate"><span class="pre">find</span></code> と <code class="docutils literal notranslate"><span class="pre">insert</span></code> が行う方法は異なっている。<code class="docutils literal notranslate"><span class="pre">find</span></code> の「同一」の定義は「等値」(equality) であり、
<code class="docutils literal notranslate"><span class="pre">operator==</span></code> に基づいている。<code class="docutils literal notranslate"><span class="pre">set::insert</span></code> の「同一」の定義は「等価」
(equivalence) であり、通常は <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code> に基づいている。 2 つの定義は異なるため、一方の定義では 2 つのオブジェクトの値が同一とし、他方の定義では同一としないことがある。したがって、STL を効果的に利用するには、等値と等価の違いを理解しなければならない&gt; (p. 82)</p></li>
<li><p>ここは読み落としていた。 &lt;すべての標準連想コンテナでは、<code class="docutils literal notranslate"><span class="pre">key_comp</span></code> メンバ関数によって、ソート述語を利用できる&gt; (p. 83)</p></li>
</ul>
</section>
<section id="id24">
<h3><a class="toc-backref" href="#id84" role="doc-backlink">第 20 項</a><a class="headerlink" href="#id24" title="Permalink to this heading">¶</a></h3>
<p>ポインタを格納した連想コンテナは、デフォルトではアドレス順にソートされる。これが困る場合だけ、本項のアドバイスに従えばいいだろう。</p>
</section>
<section id="id25">
<h3><a class="toc-backref" href="#id85" role="doc-backlink">第 21 項</a><a class="headerlink" href="#id25" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">set</span></code> の比較関数として <code class="docutils literal notranslate"><span class="pre">less_equal</span></code> を使うと、その <code class="docutils literal notranslate"><span class="pre">set</span></code> はあっさり壊れる。</p></li>
<li><p>&lt;読者による面白さの定義は著者とは違うかもしれない&gt; (p. 91)</p></li>
<li><p>連想コンテナの比較関数の要件とは、その比較関数が strict weak ordering を定義すること。比較関数が同じ値を比較すると、false を返す必要があることを憶えておく。</p></li>
</ul>
</section>
<section id="id26">
<h3><a class="toc-backref" href="#id86" role="doc-backlink">第 22 項</a><a class="headerlink" href="#id26" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code>/<code class="docutils literal notranslate"><span class="pre">multimap</span></code> のキーは変更できない。<code class="docutils literal notranslate"><span class="pre">const</span></code> だから。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set</span></code>/<code class="docutils literal notranslate"><span class="pre">multiset</span></code> のキーは変更できる。しかしコンテナを破壊する可能性大ゆえ変更してはならない。</p>
<ul>
<li><p>ただし「キー以外の部分」については変更することに問題はない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
<span class="w">    </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&quot;Corpolate Deity&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>安全で移植性のある形で書きたければ、<code class="docutils literal notranslate"><span class="pre">erase</span></code> と <code class="docutils literal notranslate"><span class="pre">insert</span></code> を使う。</p>
</li>
</ul>
</li>
</ul>
</section>
<section id="id27">
<h3><a class="toc-backref" href="#id87" role="doc-backlink">第 23 項</a><a class="headerlink" href="#id27" title="Permalink to this heading">¶</a></h3>
<p>ソート済み <code class="docutils literal notranslate"><span class="pre">vector</span></code> のパフォーマンスを知らしめる内容。この項は実務の上でも重要。</p>
<ul>
<li><p>多くの場合、対数時間探索かかる標準連想コンテナよりは、定数時間探索が期待できるハッシュコンテナのほうがよい。</p></li>
<li><p>&lt;直感に反して、標準連想コンテナのパフォーマンスは低速の <code class="docutils literal notranslate"><span class="pre">vector</span></code> に劣ることは珍しくない&gt; (p. 99)</p></li>
<li><p>二分探索木を二分探索するより、ソート済み <code class="docutils literal notranslate"><span class="pre">vector</span></code> を二分探索するほうがパフォーマンスが優れている理由を議論している。</p>
<ol class="arabic simple">
<li><p>サイズ。<code class="docutils literal notranslate"><span class="pre">vector</span></code> が優れていることは明白。</p></li>
<li><p>参照の局所性。ノードベースのコンテナでは、コンテナ内の順序では近くにあるコンテナ要素同士が、物理メモリ的にも近くにあるとは限らない。</p></li>
</ol>
<p>総合的に考えて、ソート済み <code class="docutils literal notranslate"><span class="pre">vector</span></code> の二分探索に軍配を上げているだけ。</p>
</li>
</ul>
</section>
<section id="id28">
<h3><a class="toc-backref" href="#id88" role="doc-backlink">第 24 項</a><a class="headerlink" href="#id28" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">map::operator[]</span></code> vs <code class="docutils literal notranslate"><span class="pre">map::insert</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">insert</span></code>:</dt><dd><p>map に要素を追加するとき（名前どおりだ）。効率の観点からもよい。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">operator[]</span></code>:</dt><dd><p>map に既に存在する要素を更新するとき。効率的かつ美的。</p>
</dd>
</dl>
</section>
<section id="id29">
<h3><a class="toc-backref" href="#id89" role="doc-backlink">第 25 項</a><a class="headerlink" href="#id29" title="Permalink to this heading">¶</a></h3>
<p>再読して気付いたが、本書はハッシュを猛烈にプッシュしている気がする。</p>
<ul class="simple">
<li><p>標準 C++ ライブラリにはハッシュテーブルはない。</p></li>
<li><p>STLport には <code class="docutils literal notranslate"><span class="pre">hash_set</span></code>, <code class="docutils literal notranslate"><span class="pre">hash_map</span></code> のようなものがある。</p></li>
</ul>
</section>
</section>
<section id="id30">
<h2><a class="toc-backref" href="#id90" role="doc-backlink">反復子</a><a class="headerlink" href="#id30" title="Permalink to this heading">¶</a></h2>
<section id="id31">
<h3><a class="toc-backref" href="#id91" role="doc-backlink">第 26 項</a><a class="headerlink" href="#id31" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">const_iterator</span></code> から <code class="docutils literal notranslate"><span class="pre">iterator</span></code> へ変換する方法がない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const_reverse_iterator</span></code> から <code class="docutils literal notranslate"><span class="pre">reverse_iterator</span></code> へ変換する方法がない。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">const</span></code> の正確さという観点からすれば（確かに価値ある観点であるのだが）、実際に欠陥があるかもしれないというだけで（解決方法はあるのだから）、
<code class="docutils literal notranslate"><span class="pre">const_iterator</span></code> を使わないことは不当に思えるかもしれない。しかし、コンテナの一部のメンバ関数では <code class="docutils literal notranslate"><span class="pre">iterator</span></code> が選別されている状況を考え合わせると、実際上、<code class="docutils literal notranslate"><span class="pre">const_iterator</span></code> は <code class="docutils literal notranslate"><span class="pre">iterator</span></code> ほど役に立たないだけでなく、あえて使う理由がないという結論に達せざるを得ない&gt; (pp. 116-117)</p></li>
</ul>
</section>
<section id="id32">
<h3><a class="toc-backref" href="#id92" role="doc-backlink">第 27 項</a><a class="headerlink" href="#id32" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">const_iterator</span></code> を <code class="docutils literal notranslate"><span class="pre">iterator</span></code> に変換する技法として、<code class="docutils literal notranslate"><span class="pre">advance</span></code> と
<code class="docutils literal notranslate"><span class="pre">distance</span></code> を組み合わせて利用する方法を紹介している。しかし、どう考えてもこの方法は時間的コストがかかる。本項の結論もそう認めているので、この項は前項のガイドラインを補強するために書かれたのかな。</p>
</section>
<section id="id33">
<h3><a class="toc-backref" href="#id93" role="doc-backlink">第 28 項</a><a class="headerlink" href="#id33" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">reverse_iterator::base</span></code> について。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">find</span></code> 等のアルゴリズムに <code class="docutils literal notranslate"><span class="pre">reverse_iterator</span></code> を与えると、その戻り値の型もまた <code class="docutils literal notranslate"><span class="pre">reverse_iterator</span></code> になる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span><span class="w"> </span><span class="n">ri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">((</span><span class="o">++</span><span class="n">ri</span><span class="p">).</span><span class="n">base</span><span class="p">());</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id34">
<h3><a class="toc-backref" href="#id94" role="doc-backlink">第 29 項</a><a class="headerlink" href="#id34" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">istream_iterator</span></code> は <code class="docutils literal notranslate"><span class="pre">operator&gt;&gt;</span></code> に依存する。これは書式付き入力を行うため、遅いのを承知の上で利用すること。</p></li>
<li><p>書式などどうでもよい場合、入力ストリームから次の文字を取得したいだけならば、
<code class="docutils literal notranslate"><span class="pre">istreambuf_iterator</span></code> の利用を検討する。入力と同様に、出力ストリームの処理でも <code class="docutils literal notranslate"><span class="pre">ostreambuf_iterator</span></code> の方がよい場合がある。</p></li>
</ul>
</section>
</section>
<section id="id35">
<h2><a class="toc-backref" href="#id95" role="doc-backlink">アルゴリズム</a><a class="headerlink" href="#id35" title="Permalink to this heading">¶</a></h2>
<section id="id36">
<h3><a class="toc-backref" href="#id96" role="doc-backlink">第 30 項</a><a class="headerlink" href="#id36" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transform</span></code> 等、出力反復子を指定するアルゴリズムには、出力先範囲が適切に確保されている、または確保してくれる反復子を渡す。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">back_inserter</span></code>, <code class="docutils literal notranslate"><span class="pre">front_inserter</span></code>, <code class="docutils literal notranslate"><span class="pre">inserter</span></code> ならば、出力先サイズを自動的に拡張してくれる。</p></li>
<li><p>出力先のサイズがわかっている場合は、対象コンテナに対して <code class="docutils literal notranslate"><span class="pre">reserve</span></code> や
<code class="docutils literal notranslate"><span class="pre">resize</span></code> を先に使うと効率がよい。<code class="docutils literal notranslate"><span class="pre">inserter</span></code> 系を用いる場合は <code class="docutils literal notranslate"><span class="pre">resize</span></code>
ではなく <code class="docutils literal notranslate"><span class="pre">reserve</span></code> を使う。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id37">
<h3><a class="toc-backref" href="#id97" role="doc-backlink">第 31 項</a><a class="headerlink" href="#id37" title="Permalink to this heading">¶</a></h3>
<p>この本を読んで、4 番目に感動した項目はこれだった。</p>
<ul class="simple">
<li><p>まずはこの鉄則を頭に叩き込む。&lt;確かに <code class="docutils literal notranslate"><span class="pre">sort</span></code> はすばらしいアルゴリズムだが、不必要なところで使う理由はない。場合によっては、一部をソートするだけで済む&gt;
(p. 130)</p></li>
<li><p>ベスト N が欲しい場合は <code class="docutils literal notranslate"><span class="pre">partial_sort</span></code> で十分。</p></li>
<li><p>ベスト N が「順序に関係なく」欲しい場合は <code class="docutils literal notranslate"><span class="pre">nth_element</span></code> で十分。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">partial_sort</span></code> も <code class="docutils literal notranslate"><span class="pre">nth_element</span></code> も stable ではない。特に問題はないだろう。</p></li>
<li><p>全体を二種類に分類するような目的ならば <code class="docutils literal notranslate"><span class="pre">partition</span></code> が利用できる。</p></li>
<li><p>ソート系アルゴリズムは &lt;ランダムアクセス反復子を必要とする&gt; (p. 133)。</p>
<ul>
<li><p>問題は <code class="docutils literal notranslate"><span class="pre">list</span></code> をソートしたい場合だ。状況によって、内容を <code class="docutils literal notranslate"><span class="pre">vector</span></code> に移植してから所望のソート、分類をすることになるかもしれない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code> 系は <code class="docutils literal notranslate"><span class="pre">list::iterator</span></code> を受け付ける。</p></li>
</ul>
</li>
<li><p>&lt;ソートアルゴリズムを選ぶ際には、パフォーマンスを基準にするのではなく、目的に適しているかどうかに基づいて選択することをお勧めする。必要な処理しかしないアルゴリズムを選べば、必要な処理がはっきり表現されるだけでなく、 STL を使って最も効率的な方法で目的を達成できる&gt; (p. 135)</p></li>
</ul>
</section>
<section id="id38">
<h3><a class="toc-backref" href="#id98" role="doc-backlink">第 32 項</a><a class="headerlink" href="#id38" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">remove</span></code> アルゴリズムの誤解を解くところから始めている。指定範囲の末尾付近にゴミが溜まるだけ。</p></li>
<li><p>&lt;コンテナのメンバ関数だけがコンテナの要素を削除できる。そこに本項の要点がある。つまり、本当に削除する場合は、<code class="docutils literal notranslate"><span class="pre">remove</span></code> の後に <code class="docutils literal notranslate"><span class="pre">erase</span></code> を実行しなければならない&gt; (pp. 138-139)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="mi">99</span><span class="p">),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
<p>&lt;範囲形式の <code class="docutils literal notranslate"><span class="pre">erase</span></code> の第 1 引数に <code class="docutils literal notranslate"><span class="pre">remove</span></code> の戻り値を渡すことが多く、一種の慣用句になっている&gt; (p. 139)</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">unique</span></code> も <code class="docutils literal notranslate"><span class="pre">remove</span></code> のように末尾付近にゴミを寄せるアルゴリズムだ。
<code class="docutils literal notranslate"><span class="pre">erase</span></code> と組み合わせて利用する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code> に関しては、アルゴリズムではなくメンバ関数の <code class="docutils literal notranslate"><span class="pre">remove</span></code>, <code class="docutils literal notranslate"><span class="pre">unique</span></code>
により、本当に削除できる。</p></li>
</ul>
</section>
<section id="id39">
<h3><a class="toc-backref" href="#id99" role="doc-backlink">第 33 項</a><a class="headerlink" href="#id39" title="Permalink to this heading">¶</a></h3>
<p>生のポインタを格納したコンテナに対する <code class="docutils literal notranslate"><span class="pre">remove</span></code> 風アルゴリズムの適用は危険。</p>
</section>
<section id="id40">
<h3><a class="toc-backref" href="#id100" role="doc-backlink">第 34 項</a><a class="headerlink" href="#id40" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>ソート済み範囲を入力要件とするアルゴリズムがあるので、注意すること。</p>
<dl class="simple">
<dt>二分探索系</dt><dd><p><code class="docutils literal notranslate"><span class="pre">binary_search</span></code>, <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code>, <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code>, <code class="docutils literal notranslate"><span class="pre">equal_range</span></code></p>
</dd>
<dt>重複要素検索系</dt><dd><p><code class="docutils literal notranslate"><span class="pre">set_union</span></code>, <code class="docutils literal notranslate"><span class="pre">set_intersection</span></code>, <code class="docutils literal notranslate"><span class="pre">set_difference</span></code>,
<code class="docutils literal notranslate"><span class="pre">set_symmetric_difference</span></code>, <code class="docutils literal notranslate"><span class="pre">merge</span></code>, <code class="docutils literal notranslate"><span class="pre">inplace_merge</span></code>, <code class="docutils literal notranslate"><span class="pre">includes</span></code></p>
</dd>
</dl>
</li>
<li><p>&lt;Unix 開発者なら、STL の <code class="docutils literal notranslate"><span class="pre">unique</span></code> とUnix の <code class="docutils literal notranslate"><span class="pre">uniq</span></code> が驚くほど似ていることに気付くだろう。筆者が思うに、この類似は決して偶然の一致ではない&gt; (p. 145)</p></li>
<li><p>次のタイプのコードは、業務時に見落とす可能性が大なのでノートをとっておく。望ましくない理由と望ましいコードを、読み返したときに思い出せ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
<span class="c1">// ...</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">a5exists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id41">
<h3><a class="toc-backref" href="#id101" role="doc-backlink">第 35 項</a><a class="headerlink" href="#id41" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mismatch</span></code> アルゴリズムを利用する事前条件として、違う長さの範囲を与える場合は、短い範囲のほうを先に与えることになっている。</p></li>
<li><p>次の事実により <code class="docutils literal notranslate"><span class="pre">lexicographical_compare</span></code> は <code class="docutils literal notranslate"><span class="pre">strcmp</span></code> の汎用版だと言える。</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">strcmp</span></code> は文字配列にしか適用できないが、<code class="docutils literal notranslate"><span class="pre">lexicographical_compare</span></code> は任意の型の値の範囲に適用できる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strcmp</span></code> は比較手段が一定である。一方、<code class="docutils literal notranslate"><span class="pre">lexicographical_compare</span></code> は任意の述語を与えられる。</p></li>
</ol>
</li>
<li><p>&lt;速度が重要である場合、STL の標準アルゴリズムの代わりに標準以外の C 関数を使っても問題ないだろう&gt; (p. 150)</p></li>
</ul>
</section>
<section id="id42">
<h3><a class="toc-backref" href="#id102" role="doc-backlink">第 36 項</a><a class="headerlink" href="#id42" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">copy_if</span></code> ネタ。</p>
</section>
<section id="id43">
<h3><a class="toc-backref" href="#id103" role="doc-backlink">第 37 項</a><a class="headerlink" href="#id43" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;numeric&gt;</span></code> ヘッダに置かれているアルゴリズムにも注目してやろう。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for_each</span></code> と <code class="docutils literal notranslate"><span class="pre">accumulate</span></code> に渡す関数パラメータ（述語）について、余分な作用が一方では認められていて、他方では認められていないことが、本書著者は気に食わないようだ。</p></li>
</ul>
</section>
</section>
<section id="id44">
<h2><a class="toc-backref" href="#id104" role="doc-backlink">ファンクタ、ファンクタクラス、関数など</a><a class="headerlink" href="#id44" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>関数風オブジェクト＝ファンクタ</p></li>
</ul>
<section id="id45">
<h3><a class="toc-backref" href="#id105" role="doc-backlink">第 38 項</a><a class="headerlink" href="#id45" title="Permalink to this heading">¶</a></h3>
<p>ファンクタは値渡しが鉄則。</p>
<ul class="simple">
<li><p>&lt;第一に、関数オブジェクトは小さくする必要がある。さもないと、コピーの負担が大きくなりすぎる。第二に、関数オブジェクトは単相（非多相）でなければならない。つまり、仮想関数を使ってはいけない。基本クラス型のパラメータに派生クラスオブジェクトを値で渡すと、スライシングの問題が発生するためである。つまり、コピー中に派生部分が削除されてしまう&gt; (p. 161)</p></li>
</ul>
</section>
<section id="id46">
<h3><a class="toc-backref" href="#id106" role="doc-backlink">第 39 項</a><a class="headerlink" href="#id46" title="Permalink to this heading">¶</a></h3>
<p>述語の戻り値は、関数の実引数からだけで決めるようにというガイド。本項では、そのようなものを純粋関数と呼んでいる。</p>
</section>
<section id="id47">
<h3><a class="toc-backref" href="#id107" role="doc-backlink">第 40 項</a><a class="headerlink" href="#id47" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>ファンクタクラスを自分で書く場合、それを <code class="docutils literal notranslate"><span class="pre">unary_function</span></code> または
<code class="docutils literal notranslate"><span class="pre">binary_function</span></code> からの派生型として定義しようという話。このように定義しておいて初めて標準関数アダプタ (<code class="docutils literal notranslate"><span class="pre">not1</span></code>, <code class="docutils literal notranslate"><span class="pre">not2</span></code>, <code class="docutils literal notranslate"><span class="pre">bind1st</span></code>, <code class="docutils literal notranslate"><span class="pre">bind2nd</span></code>) に咬ませることができる。</p></li>
<li><p>STL では各ファンクタクラスには一つの <code class="docutils literal notranslate"><span class="pre">operator()</span></code> しかないと暗黙の内に仮定している。</p></li>
</ul>
</section>
<section id="id48">
<h3><a class="toc-backref" href="#id108" role="doc-backlink">第 41 項</a><a class="headerlink" href="#id48" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;STL コンポーネントにメンバ関数を渡すときは常に <code class="docutils literal notranslate"><span class="pre">mem_fun</span></code> と <code class="docutils literal notranslate"><span class="pre">mem_fun_ref</span></code>
を使わなければならない&gt; (p. 174)</p></li>
</ul>
</section>
<section id="id49">
<h3><a class="toc-backref" href="#id109" role="doc-backlink">第 42 項</a><a class="headerlink" href="#id49" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>「最小意外性の原則」は守ること。<code class="docutils literal notranslate"><span class="pre">less</span></code> に <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code> を呼び出す以外の処理をさせぬこと。</p></li>
<li><p>特定の状況における比較を行うには、<code class="docutils literal notranslate"><span class="pre">less</span></code> でないファンクタクラスを作成して、それを利用すること。</p></li>
</ul>
</section>
</section>
<section id="stl">
<h2><a class="toc-backref" href="#id110" role="doc-backlink">STL を使ったプログラミング</a><a class="headerlink" href="#stl" title="Permalink to this heading">¶</a></h2>
<section id="id50">
<h3><a class="toc-backref" href="#id111" role="doc-backlink">第 43 項</a><a class="headerlink" href="#id50" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>アルゴリズムのおかげで、プログラマーが独自にループを書く作業が減る。さらに、効率、正確さ、保守性も得られる。</p></li>
<li><p>&lt;反復子はアルゴリズムに渡し、反復子の複雑な操作は「アルゴリズム」に任せよう&gt;
(p. 184)</p></li>
<li><p>自作ループは、それをパッと見てすぐに何をしているものなのかがわからない。一方、アルゴリズムの呼び出しは、関数名を見れば少なくとも処理の意図はわかる。</p></li>
<li><p>場合によっては、アルゴリズムに渡すファンクタを定義するコードのほうが、自作ループを書くよりもコード量がかさむことがある。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">while</span></code>, <code class="docutils literal notranslate"><span class="pre">do</span></code> などの低水準の語を <code class="docutils literal notranslate"><span class="pre">insert</span></code>, <code class="docutils literal notranslate"><span class="pre">find</span></code>,
<code class="docutils literal notranslate"><span class="pre">for_each</span></code> などの高水準の語に置き換える&gt; (p. 187)</p></li>
</ul>
</section>
<section id="id51">
<h3><a class="toc-backref" href="#id112" role="doc-backlink">第 44 項</a><a class="headerlink" href="#id51" title="Permalink to this heading">¶</a></h3>
<p>同名のアルゴリズムとメンバ関数が存在する場合は、当然メンバ関数を優先する。特に連想コンテナの <code class="docutils literal notranslate"><span class="pre">find</span></code> 系の処理について説明している。</p>
</section>
<section id="id52">
<h3><a class="toc-backref" href="#id113" role="doc-backlink">第 45 項</a><a class="headerlink" href="#id52" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>あるコンテナについて、特定の値を持つかどうかを調べるには、 <code class="docutils literal notranslate"><span class="pre">find</span></code> アルゴリズムを用いる。そして、戻り値とコンテナの <code class="docutils literal notranslate"><span class="pre">end</span></code> が違うかどうかをテストする。</p>
<ul>
<li><p>ただし、ソート済み範囲では <code class="docutils literal notranslate"><span class="pre">binary_search</span></code> のほうが効率がよい（ただし、存在する位置はわからない）。</p></li>
<li><p>ソート済み範囲で、どの位置にまであるか調べたいときには <code class="docutils literal notranslate"><span class="pre">equal_range</span></code> を用いる（ただし等値ではなく等価に基づいている）。 <code class="docutils literal notranslate"><span class="pre">equal_range</span></code> の戻り値ペアが違う位置を指していれば（一つ以上）存在する。</p></li>
</ul>
</li>
<li><p>ソート済み範囲で「ある値より小さくない最初の要素」を探索するには
<code class="docutils literal notranslate"><span class="pre">lower_bound</span></code> を用いる。</p></li>
<li><p>連想コンテナの場合、以上のルールに基づいてメンバ関数版を利用する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">map</span></code> に関しては、特定の値を持つかどうかを調べるのに <code class="docutils literal notranslate"><span class="pre">find</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">count</span></code> を使っても（効率が落ちないので）構わない。</p></li>
<li><p>&lt;multi コンテナでは、特定の値を持つ要素が複数存在する場合、<code class="docutils literal notranslate"><span class="pre">find</span></code> がコンテナの中で特定の値を持つ「最初の」要素を識別することは保証されない&gt; (p. 197)</p></li>
</ul>
</section>
<section id="id53">
<h3><a class="toc-backref" href="#id114" role="doc-backlink">第 46 項</a><a class="headerlink" href="#id53" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;高水準言語を使ったプログラミングに関する不満の一つは、抽象の度合いが高まるにつれ、生成されるコードの効率が低くなることである&gt; (p. 198)</p></li>
<li><p>インライン展開可能性の関係で、アルゴリズムには関数（＝ポインタ）を渡すよりも、関数オブジェクトを渡したほうが、コンパイラが効率のよいコードを生成する。&lt;関数ポインタパラメータはインライン化されない。そのため、経験豊富な多くのC プログラマにとって信じがたいことだが、ほとんどの場合、C++ の <code class="docutils literal notranslate"><span class="pre">sort</span></code> の方が C の
<code class="docutils literal notranslate"><span class="pre">qsort</span></code> より高速になる&gt; (p. 200)</p></li>
</ul>
</section>
<section id="id54">
<h3><a class="toc-backref" href="#id115" role="doc-backlink">第 47 項</a><a class="headerlink" href="#id54" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>冒頭で次のコードを提示しておき、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span>
<span class="w">  </span><span class="n">remove_if</span><span class="p">(</span><span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span>
<span class="w">                    </span><span class="n">bind_2nd</span><span class="p">(</span><span class="n">greater_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">y</span><span class="p">)).</span><span class="n">base</span><span class="p">(),</span>
<span class="w">            </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="w">            </span><span class="n">bind_2nd</span><span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">)),</span>
<span class="w">  </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
<p>これはやり過ぎだと断りつつ、&lt;しかし、Scheme などの関数型言語に慣れたプログラマが感じることは違っているだろう&gt; (p. 203) と言ってのけるのには参った。</p>
</li>
<li><p>アルゴリズムを多用すると、どうしても先のコードのようにネスト・バインダ・アダプタが増える。</p></li>
<li><p>&lt;理解できないソフトウェアは保守できない&gt; (p. 205) は「理解できないものは所持できない」だ。</p></li>
</ul>
</section>
<section id="id55">
<h3><a class="toc-backref" href="#id116" role="doc-backlink">第 48 項</a><a class="headerlink" href="#id55" title="Permalink to this heading">¶</a></h3>
<p>インクルードのコツをまとめている。</p>
</section>
<section id="id56">
<h3><a class="toc-backref" href="#id117" role="doc-backlink">第 49 項</a><a class="headerlink" href="#id56" title="Permalink to this heading">¶</a></h3>
<p>コンパイルエラー時に現れる &lt;猫がキーボードの上を歩いて入力された&gt; (p. 207) ようなメッセージの解読方法のコツ。</p>
</section>
<section id="id57">
<h3><a class="toc-backref" href="#id118" role="doc-backlink">第 50 項</a><a class="headerlink" href="#id57" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>&lt;<a class="reference external" href="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>&gt;</p></li>
<li><p>&lt;<a class="reference external" href="http://www.stlport.org/">http://www.stlport.org/</a>&gt;</p></li>
<li><p>&lt;<a class="reference external" href="http://www.boost.org/">http://www.boost.org/</a>&gt;</p></li>
</ul>
</section>
</section>
<section id="id58">
<h2><a class="toc-backref" href="#id119" role="doc-backlink">参考文献</a><a class="headerlink" href="#id58" title="Permalink to this heading">¶</a></h2>
<p>ノートをとらない。</p>
</section>
<section id="id59">
<h2><a class="toc-backref" href="#id120" role="doc-backlink">ロケールと大文字小文字を区別しない文字列比較</a><a class="headerlink" href="#id59" title="Permalink to this heading">¶</a></h2>
<ul>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> が <code class="docutils literal notranslate"><span class="pre">std::string</span></code> 型であれば、式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> は次の式と等価である。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">lexicographical_compare</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
<p>この式で、<code class="docutils literal notranslate"><span class="pre">lexicographical_compare</span></code> は <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code> を使って個々の文字を比較する&gt; (p. 227)</p>
</li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">toupper</span></code> は一つの引数を取る単純な関数のようだが、グローバル変数にも依存する&gt; (p. 229)</p></li>
<li><p>&lt;C++ 標準ライブラリのロケールは、ライブラリの実装の中に深く埋め込まれたグローバルデータではなく、 <code class="docutils literal notranslate"><span class="pre">std::locale</span></code> 型のオブジェクトである&gt; (p. 229)</p></li>
<li><p>&lt;ロケールの名前は標準化されていない&gt; (p. 230)</p></li>
<li><p>&lt;C++ のロケールは「ファセット」に分割される。各ファセットは国際化の異なる面を処理する。関数 <code class="docutils literal notranslate"><span class="pre">std::use_facet</span></code> は、ロケールオブジェクトから特定のファセットを抽出する。ファセット <code class="docutils literal notranslate"><span class="pre">ctype</span></code> は、大文字小文字の変換を含め、文字の分類を処理する&gt; (p. 230)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// L をロケールとして</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ctype</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">use_facet</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ctype</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ct</span><span class="p">.</span><span class="n">toupper</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ct</span><span class="p">.</span><span class="n">toupper</span><span class="p">(</span><span class="n">c2</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">use_facet</span></code> を呼び出すには負担が大きいことがあるため、<code class="docutils literal notranslate"><span class="pre">use_facet</span></code> の呼び出し回数は少なくした方がよい&gt; (p. 230)</p></li>
</ul>
</section>
<section id="microsoft-stl">
<h2><a class="toc-backref" href="#id121" role="doc-backlink">Microsoft の STL プラットフォームについて</a><a class="headerlink" href="#microsoft-stl" title="Permalink to this heading">¶</a></h2>
<p>仕事で経験があるのでよく承知しているが、名前に .NET の付かない VC 環境では一部コンテナのメンバ関数がおかしい。この付録ではその回避策、代替案を紹介している。</p>
<p>STL のメンバ関数テンプレート、特に型の違うコンテナから <code class="docutils literal notranslate"><span class="pre">insert</span></code> や <code class="docutils literal notranslate"><span class="pre">assign</span></code>
する場合、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vw</span><span class="p">;</span>
<span class="n">list</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lw</span><span class="p">;</span>
<span class="n">set</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sw</span><span class="p">;</span>

<span class="c1">// ...</span>

<span class="n">vw</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">lw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">lw</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="n">vw</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">sw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">sw</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
<p>最後に書いた <code class="docutils literal notranslate"><span class="pre">insert</span></code> の行が MSVC6 以前ではコンパイルできない。その対応策として、</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">copy</span></code> と <code class="docutils literal notranslate"><span class="pre">back_inserter</span></code>, <code class="docutils literal notranslate"><span class="pre">inserter</span></code> を組み合わせる（ただし効率が悪い）</p></li>
<li><p>STL を入れ替える（ただしコンパイラがメンバ関数テンプレートに耐えられる MSVC6
のみ可能）</p></li>
</ol>
<p>ことを挙げている。</p>
<p>&lt;MSVC6 に付属する STL の実装以外は使用できない場合でも、 Dinkumware Web サイトは利用する価値があるだろう。このサイトには、MSVC6 ライブラリ実装で知られているバグのリストが掲載されており、使用しているライブラリを変更して不具合を減らす方法が説明されている&gt; (p. 240) 変更云々は仕事ではできないが、バグリストは見る価値がありそうだ。</p>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="alexandrescu01/note3.html" title="Previous document">Modern C++ Design 読書ノート 3/3</a>
        </li>
        <li>
          <a href="sutter02.html" title="Next document">More Exceptional C++ 読書ノート</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2024, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>