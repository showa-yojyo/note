
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>OpenGL: A Primer Second Edition 読書ノート 4/4 &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/prefab.css" />
    
    <script src="../_static/mathjax-v3.js"></script>
    
    <link rel="next" title="入門 xyzzy 読書ノート" href="../yamamoto05/index.html" />
    <link rel="prev" title="OpenGL: A Primer Second Edition 読書ノート 3/4" href="note3.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../yamamoto05/index.html" title="入門 xyzzy 読書ノート"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="note3.html" title="OpenGL: A Primer Second Edition 読書ノート 3/4"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">OpenGL: A Primer Second Edition 読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">OpenGL: A Primer Second Edition 読書ノート 4/4</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="opengl-a-primer-second-edition-4-4">
<h1><a class="toc-backref" href="#id2">OpenGL: A Primer Second Edition 読書ノート 4/4</a><a class="headerlink" href="#opengl-a-primer-second-edition-4-4" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">著者</dt>
<dd class="field-odd"><p>Edward Angel</p>
</dd>
<dt class="field-even">出版社</dt>
<dd class="field-even"><p>Addison Wesley</p>
</dd>
<dt class="field-odd">発行年</dt>
<dd class="field-odd"><p>2004 年</p>
</dd>
<dt class="field-even">ISBN</dt>
<dd class="field-even"><p>978-0-321-23762-0</p>
</dd>
</dl>
<div class="contents topic" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#opengl-a-primer-second-edition-4-4" id="id2">OpenGL: A Primer Second Edition 読書ノート 4/4</a></p>
<ul>
<li><p><a class="reference internal" href="#texture-mapping" id="id3">Texture Mapping</a></p>
<ul>
<li><p><a class="reference internal" href="#what-is-a-texture-map" id="id4">What Is a Texture Map?</a></p></li>
<li><p><a class="reference internal" href="#constructing-a-texture-map" id="id5">Constructing a Texture Map</a></p></li>
<li><p><a class="reference internal" href="#texture-coordinates" id="id6">Texture Coordinates</a></p></li>
<li><p><a class="reference internal" href="#texture-parameters" id="id7">Texture Parameters</a></p></li>
<li><p><a class="reference internal" href="#a-rotating-cube-with-texture" id="id8">A Rotating Cube with Texture</a></p></li>
<li><p><a class="reference internal" href="#applying-textures-to-surfaces" id="id9">Applying Textures to Surfaces</a></p></li>
<li><p><a class="reference internal" href="#borders-and-sizing" id="id10">Borders and Sizing</a></p></li>
<li><p><a class="reference internal" href="#mipmaps" id="id11">Mipmaps</a></p></li>
<li><p><a class="reference internal" href="#automatic-texture-coorinate-generation" id="id12">Automatic Texture Coorinate Generation</a></p></li>
<li><p><a class="reference internal" href="#texture-objects" id="id13">Texture Objects</a></p></li>
<li><p><a class="reference internal" href="#texture-maps-for-image-manipulation" id="id14">Texture Maps for Image Manipulation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#curves-and-surfaces" id="id15">Curves and Surfaces</a></p>
<ul>
<li><p><a class="reference internal" href="#parameteric-curves" id="id16">Parameteric Curves</a></p></li>
<li><p><a class="reference internal" href="#parameteric-surfaces" id="id17">Parameteric Surfaces</a></p></li>
<li><p><a class="reference internal" href="#bezier-curves-and-surfaces" id="id18">Bezier Curves and Surfaces</a></p></li>
<li><p><a class="reference internal" href="#one-dimensional-opengl-evaluators" id="id19">One-Dimensional OpenGL Evaluators</a></p></li>
<li><p><a class="reference internal" href="#two-dimensional-evaluators" id="id20">Two-Dimensional Evaluators</a></p></li>
<li><p><a class="reference internal" href="#other-types-of-curves" id="id21">Other Types of Curves</a></p>
<ul>
<li><p><a class="reference internal" href="#b-splines" id="id22">B-Splines</a></p></li>
<li><p><a class="reference internal" href="#nurbs" id="id23">NURBS</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-utah-teapot" id="id24">The Utah Teapot</a></p></li>
<li><p><a class="reference internal" href="#normals-and-shading" id="id25">Normals and Shading</a></p></li>
<li><p><a class="reference internal" href="#texturing-surfaces" id="id26">Texturing Surfaces</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#putting-it-together-and-moving-on" id="id27">Putting It Together and Moving On</a></p>
<ul>
<li><p><a class="reference internal" href="#a-demo-program" id="id28">A Demo Program</a></p>
<ul>
<li><p><a class="reference internal" href="#a-virtual-trackball" id="id29">A Virtual Trackball</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-opengl-features" id="id30">Other OpenGL Features</a></p></li>
<li><p><a class="reference internal" href="#buffers" id="id31">Buffers</a></p>
<ul>
<li><p><a class="reference internal" href="#the-accumulation-buffer" id="id32">The Accumulation Buffer</a></p></li>
<li><p><a class="reference internal" href="#the-stencil-buffer" id="id33">The Stencil Buffer</a></p></li>
<li><p><a class="reference internal" href="#fragment-tests" id="id34">Fragment Tests</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#writing-portable-efficient-robust-code" id="id35">Writing Portable, Efficient, Robust Code</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#looking-to-the-future" id="id36">Looking to the Future</a></p>
<ul>
<li><p><a class="reference internal" href="#versions-and-extensions" id="id37">Versions and Extensions</a></p>
<ul>
<li><p><a class="reference internal" href="#opengl-version-1-1" id="id38">OpenGL Version 1.1</a></p></li>
<li><p><a class="reference internal" href="#opengl-version-1-2" id="id39">OpenGL Version 1.2</a></p></li>
<li><p><a class="reference internal" href="#opengl-version-1-3" id="id40">OpenGL Version 1.3</a></p></li>
<li><p><a class="reference internal" href="#opengl-version-1-4" id="id41">OpenGL Version 1.4</a></p></li>
<li><p><a class="reference internal" href="#opengl-version-1-5" id="id42">OpenGL Version 1.5</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#opengl-extensions" id="id43">OpenGL Extensions</a></p></li>
<li><p><a class="reference internal" href="#going-beyond-read-time-graphics" id="id44">Going Beyond Read-Time Graphics</a></p></li>
<li><p><a class="reference internal" href="#programmable-pipelines" id="id45">Programmable Pipelines</a></p>
<ul>
<li><p><a class="reference internal" href="#vertex-shaders" id="id46">Vertex Shaders</a></p></li>
<li><p><a class="reference internal" href="#fragment-shaders" id="id47">Fragment Shaders</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#shading-languages" id="id48">Shading Languages</a></p>
<ul>
<li><p><a class="reference internal" href="#renderman-shading-language" id="id49">RenderMan Shading Language</a></p></li>
<li><p><a class="reference internal" href="#the-opengl-shading-language" id="id50">The OpenGL Shading Language</a></p></li>
<li><p><a class="reference internal" href="#cg" id="id51">Cg</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="texture-mapping">
<h2><a class="toc-backref" href="#id3">Texture Mapping</a><a class="headerlink" href="#texture-mapping" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>&lt;Texture mapping combines pixels with geometric objects&gt; (p. 169)</p></li>
</ul>
<section id="what-is-a-texture-map">
<h3><a class="toc-backref" href="#id4">What Is a Texture Map?</a><a class="headerlink" href="#what-is-a-texture-map" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>ピクセル配列を二次元のパラメータ区間に写像する。このパラメータ区間から、三次元空間上の曲面に写像する。この合成写像がテクスチャーマッピングだと大雑把に読み取れた。</p></li>
<li><p>テクスチャー座標は記号 (s, t) で表現する。</p></li>
</ul>
</section>
<section id="constructing-a-texture-map">
<h3><a class="toc-backref" href="#id5">Constructing a Texture Map</a><a class="headerlink" href="#constructing-a-texture-map" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>テクスチャーのイメージを準備する。イメージの表現については前章参照。</p></li>
<li><p>テクスチャーマッピングのためのパラメータを指定する。</p></li>
<li><p>頂点に対してテクスチャー座標を定義する。</p></li>
</ol>
<ul>
<li><p>&lt;Two dimensional texture mapping is the most familiar case&gt; (p. 171)</p></li>
<li><p>二次元的なイメージは、二次元多様体にマップするのが自然だろう。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span><span class="w"></span>
<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">myimage</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>イメージの縦横サイズは、2 のベキ乗の形をしていなければならない。註によると、新しいグラフィックカードは任意の縦横サイズを許しているようだ。</p></li>
<li><p>&lt;It may take a significant amount of time to move a texture image from
processor memory to texture memory&gt; (p. 173)</p></li>
</ul>
</section>
<section id="texture-coordinates">
<h3><a class="toc-backref" href="#id6">Texture Coordinates</a><a class="headerlink" href="#texture-coordinates" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>&lt;Just as with vertices, texture coordinates are represented internally
in four dimensions that conventionally use the letters (s, t, r, q) to
denote the coordinates&gt; (p. 173)</p></li>
<li><p>テクスチャーマッピングを試すためのコツを以下のように述べている。
&lt;Checkerboards are especially useful for demonstrating the various
options and seeing how OpenGL implements texture mapping&gt; (p. 174)</p></li>
<li><p>&lt;We see that OpenGL renders the quadrilateral as two triangles&gt; (p. 174)</p></li>
<li><p>頂点座標と同様に、テクスチャー座標を行列を用いて変換することができる。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">GL_TEXTURE</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="texture-parameters">
<h3><a class="toc-backref" href="#id7">Texture Parameters</a><a class="headerlink" href="#texture-parameters" title="Permalink to this headline">¶</a></h3>
<p>テクスチャー座標やテクスチャー画像以外にも、テクスチャーマッピングが要求するパラメータがいくつもある。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">glTexParameter(target,</span> <span class="pre">name,</span> <span class="pre">value)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">target</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_2D</span></code></p>
</dd>
<dt class="field-even">name</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_xxx</span></code></p>
</dd>
</dl>
</li>
<li><p>&lt;The required parameters determine what happens when values of
s, t, r, or q go outside the range (0, 1) and how sampling and
filtering are applied&gt; (p. 176)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_WRAP_(S|T)</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_(REPEAT|CLAMP)</span></code> を憶える。</p></li>
<li><p>magnification と minification の考え方を習得する。一つのテクスチャー画素が複数のピクセルに写像する方が magnification</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_(MAG|MIN)_FILTER</span></code> を <code class="docutils literal notranslate"><span class="pre">GL_NEAREST</span></code> にすると速い。</p></li>
<li><p>透視図法でシーンを描いている場合、テクスチャーが歪む場合がよくある。そういう場合は <code class="docutils literal notranslate"><span class="pre">glHint</span></code> を呼ぶ。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glHint</span><span class="p">(</span><span class="n">GL_PERSPECTIVE_CORRECTION_HINT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_NICEST</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">glHint</span></code> は他のレンダリングオプションにも利用できる。調べる。</p>
</li>
</ul>
</section>
<section id="a-rotating-cube-with-texture">
<h3><a class="toc-backref" href="#id8">A Rotating Cube with Texture</a><a class="headerlink" href="#a-rotating-cube-with-texture" title="Permalink to this headline">¶</a></h3>
<p>省略。</p>
</section>
<section id="applying-textures-to-surfaces">
<h3><a class="toc-backref" href="#id9">Applying Textures to Surfaces</a><a class="headerlink" href="#applying-textures-to-surfaces" title="Permalink to this headline">¶</a></h3>
<p>ポリゴンの地の色とテクスチャーマッピングをミックスする方法について。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">glTexEnv(target,</span> <span class="pre">param,</span> <span class="pre">value)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">target</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_ENV</span></code></p>
</dd>
<dt class="field-even">param</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_ENV_MODE</span></code> とか <code class="docutils literal notranslate"><span class="pre">GL_TEX_ENV_COLOR</span></code> とか。</p>
</dd>
<dt class="field-odd">value</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_(MODULATE|REPLACE|BLEND|DECAL)</span></code> とか色とか。</p>
</dd>
</dl>
</li>
<li><p>&lt;The default mode of operation is called modulation.
Here the texture color multiplies the color computed for each face&gt;
(p. 181)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glTexEnvi</span><span class="p">(</span><span class="n">GL_TEXTURE_ENV</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_ENV_MODE</span><span class="p">,</span><span class="w"> </span><span class="n">GL_MODULATE</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="borders-and-sizing">
<h3><a class="toc-backref" href="#id10">Borders and Sizing</a><a class="headerlink" href="#borders-and-sizing" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>テクスチャーマッピングは、テクスチャーイメージ境界付近の処理が難しい。</p></li>
<li><p>&lt;One difficulty that arises when we use linear filtering is what happens
at the edges of the texture where we lack one or more texels to use
in the filtering&gt; (p. 181)</p></li>
<li><p>テクスチャーに枠を付加するという仕様がある。もし枠を指示するのなら、テクスチャーの縦横サイズを 2 のベキ乗 + 2 の形にする。</p></li>
<li><p>枠の色を別途指示することができる。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glTexParameter3fv</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_BORDER_COLOR</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>フレームバッファ内のイメージからテクスチャーマップを得ることができる。ただし「出力先」はテクスチャーメモリー。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glCopyTexImage2D</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">iformat</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">border</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>既に存在するテクスチャーから、その部分のコピーを（バイナリの形で）得ることもできる。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glTexSubImage2D</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">xoffset</span><span class="p">,</span><span class="w"> </span><span class="n">yoffset</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">texels</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>応用例がちょっと思いつかないが、テクスチャーメモリ内でコピーすることもできる。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glCopyTexSubImage2D</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">xoffset</span><span class="p">,</span><span class="w"> </span><span class="n">yoffset</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="mipmaps">
<h3><a class="toc-backref" href="#id11">Mipmaps</a><a class="headerlink" href="#mipmaps" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Mipmap とはテクスチャーマッピングの LOD の技法。広い領域にマップするデータと、狭い領域にマップするデータを使い分ける。</p></li>
<li><p>&lt;What we would prefer is to have a texture value that is the average of
the texels values over a large area of the texture&gt; (p. 183)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glTexImage2D</span></code> の第二引数 (<code class="docutils literal notranslate"><span class="pre">level</span></code>) に応じて、イメージを変える。本文の例では、レベルが低いほど詳細なイメージを指示している。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_NEAREST_MIPMAP_NEAREST</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>&lt;This is the lowest quality option&gt; (p. 183)</p>
</li>
<li><p>ミップマップセットを生成し、テクスチャーメモリに格納してくれる GLU の関数がある。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gluBuild2DMipmaps</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">iformat</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">texels</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="automatic-texture-coorinate-generation">
<h3><a class="toc-backref" href="#id12">Automatic Texture Coorinate Generation</a><a class="headerlink" href="#automatic-texture-coorinate-generation" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>頂点に対してテクスチャー座標を決める作業は一般的には難しい。しかし、GLU 二次曲面はテクスチャー座標を生成する関数が提供されている。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gluQuadricTexture(obj,</span> <span class="pre">mode)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">mode</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_(TRUE|FALSE)</span></code></p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p>&lt;OpenGL allows us to generate texture coordinates that are measured as
distances from a plane in either object space or eye space&gt; (p. 186)
だそうだが、平面からの距離で決まる座標というのが解りにくい。</p></li>
<li><p>&lt;The value <span class="math notranslate nohighlight">\(ax + by + cz + dw\)</span> is proportional to the distance from
<span class="math notranslate nohighlight">\((x, y, z, w)\)</span> to the plane determined by <span class="math notranslate nohighlight">\((a, b, c, d)\)</span>&gt; (p. 186)</p></li>
<li><p>テクスチャー座標自動生成には、例えば (s, t) の場合は以下の呼び出しが必要。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_GEN_S</span><span class="p">);</span><span class="w"></span>
<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_GEN_T</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">glTexGen(texcoord,</span> <span class="pre">param,</span> <span class="pre">value)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">texcoord</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_[STRQ]</span></code></p>
</dd>
<dt class="field-even">param</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_GENMODE</span></code> か <code class="docutils literal notranslate"><span class="pre">GL_(OBJECT|EYE)_LINEAR</span></code></p>
</dd>
<dt class="field-odd">value</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_(OBJECT|EYE)_LINEAR</span></code> か平面の係数配列</p>
</dd>
</dl>
</li>
<li><p>視点座標でテクスチャーを貼る：
&lt;If we use the <code class="docutils literal notranslate"><span class="pre">GL_EYE_LINEAR</span></code> mode, texture coordinates are based on
the vertex positions in eye space so that when we move the object,
the texture coordinates assigned to vertices change&gt; (p. 188)</p></li>
</ul>
</section>
<section id="texture-objects">
<h3><a class="toc-backref" href="#id13">Texture Objects</a><a class="headerlink" href="#texture-objects" title="Permalink to this headline">¶</a></h3>
<p>テクスチャーもまた OpenGL の「状態」の一部だ。
glTexImage を実行するときに、システムメモリからテクスチャーメモリへ移動する。テクスチャーを何種類も利用する場合は、移動にコストをつけたくない。そこで texture object というものを提供している。</p>
<ul class="simple">
<li><p>&lt;If there is not sufficient memory for all the textures that we need,
we can prioritize the texture objects to minimize the amount of
data movement from the processor to texture memory&gt; (p. 188)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glGenTextures(n,</span> <span class="pre">name)</span></code> で <code class="docutils literal notranslate"><span class="pre">n</span></code> 個の texture objects を新規作成する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glIsTexture(name)</span></code> で <code class="docutils literal notranslate"><span class="pre">name</span></code> が texture object か否かをテストする。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">glBindTexture()</span></code>, that both switches between texture objects and
forms new texture objects&gt; (p. 189)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glBindTexture(target,</span> <span class="pre">name)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">target</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_[123]D</span></code></p>
</dd>
<dt class="field-even">name</dt>
<dd class="field-even"><p>texture object の ID</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">glBindTexture</span></code> の振る舞いは、次の三つのどれか。</p>
<ul>
<li><p>case 1: &lt;If we call <code class="docutils literal notranslate"><span class="pre">glBindTexture()</span></code> with name and name has not been
used before, the subsequent calls to the various texture functions
define the texture object with the id name&gt;</p></li>
<li><p>case 2: &lt;If name already exists from a previous call to <code class="docutils literal notranslate"><span class="pre">glBindTexture()</span></code>,
then that texture object becomes the present texture and is applied
to surfaces until the next call to <code class="docutils literal notranslate"><span class="pre">glBindTexture()</span></code>&gt;</p></li>
<li><p>case 3: &lt;If <code class="docutils literal notranslate"><span class="pre">glBindTexture()</span></code> is called with name set to 0, then the
normal texture calls apply and the present texture that is part of
the OpenGL state and the current values of the texture parameters
both apply&gt;</p></li>
</ul>
</li>
<li><p>テクスチャーオブジェクトを破棄したい場合は <code class="docutils literal notranslate"><span class="pre">glDeleteTextures</span></code> を呼ぶ。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">glDeleteTextures(n,</span> <span class="pre">namearray)</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="texture-maps-for-image-manipulation">
<h3><a class="toc-backref" href="#id14">Texture Maps for Image Manipulation</a><a class="headerlink" href="#texture-maps-for-image-manipulation" title="Permalink to this headline">¶</a></h3>
<p>テクスチャーパラメータのセットだけだが、サンプルコードのラストが参考になる。</p>
</section>
</section>
<section id="curves-and-surfaces">
<h2><a class="toc-backref" href="#id15">Curves and Surfaces</a><a class="headerlink" href="#curves-and-surfaces" title="Permalink to this headline">¶</a></h2>
<p>ベジエ中心の話題。</p>
<section id="parameteric-curves">
<h3><a class="toc-backref" href="#id16">Parameteric Curves</a><a class="headerlink" href="#parameteric-curves" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>この本にしては例外的に数学の話が多くなるが、「コンピューターには区分的パラメトリック曲線が相性がいい」のようなことを述べている。</p></li>
<li><p>&lt;Parametric curves give a point in homogeneous coordinate space
<span class="math notranslate nohighlight">\((x(u), y(u), z(u), w(u))\)</span> for each value of u&gt; (p. 193)</p></li>
<li><p>簡単にするため、当分 <span class="math notranslate nohighlight">\(w = 1\)</span> と固定して話を進める。</p></li>
<li><p>指定した点を通過するような n 次多項式を決めるには、
<span class="math notranslate nohighlight">\(3(n + 1)\)</span> 個の係数を求める必要があるので、
<span class="math notranslate nohighlight">\(3(n + 1)\)</span> 個の独立した条件を与える必要がある。</p></li>
<li><p>以降、基本的に 3 次式の話になる。4 つの点を決めれば、多項式の係数が求まる。</p></li>
<li><p>&lt;However, in computer graphics, interpolating curves usually
are not the most useful type due to their lack of smoothness&gt;
(p. 194) 通過点を指定する曲線の決め方は、コントロールが難しい。</p></li>
</ul>
</section>
<section id="parameteric-surfaces">
<h3><a class="toc-backref" href="#id17">Parameteric Surfaces</a><a class="headerlink" href="#parameteric-surfaces" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>曲面を二変数関数で表現する。
CG での曲面関数は通常は bicubic polynomial だと言っている。曲線を curve segment の継ぎはぎで表現したのと同じ発想で、曲面を surface patch で表現する。</p></li>
</ul>
</section>
<section id="bezier-curves-and-surfaces">
<h3><a class="toc-backref" href="#id18">Bezier Curves and Surfaces</a><a class="headerlink" href="#bezier-curves-and-surfaces" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>三次ベジエ多項式の性質についてザッと説明している。</p>
<ul>
<li><p>コントロールポイントが 4 つ (Q0, Q1, Q2, Q3) ある。</p></li>
<li><p>Q0 と Q3 は曲線の始点と終点にそれぞれ一致する。</p></li>
<li><p>直線 Q0Q1 と Q2Q3 は、それぞれ曲線の始点と終点の接線だ。</p></li>
<li><p>曲線全体は多角形 Q0Q1Q2Q3 に内包される。これを convex hull property という。</p></li>
<li><p>Bernstein 多項式として知られる多項式の族である。
Bernstein 多項式はとても効率的に実装できる。</p></li>
</ul>
</li>
<li><p>任意の多項式曲線、多項式曲面はベジエ曲線、ベジエ曲面から得られる。</p></li>
<li><p>&lt;OpenGL implements Bezier curves and surfaces through a mechanism known
as <strong>evaluators</strong>&gt; (p. 197)</p></li>
<li><p>&lt;such as line segments and polygons that approximate the curve or surface&gt;
(p. 197)</p></li>
</ul>
</section>
<section id="one-dimensional-opengl-evaluators">
<h3><a class="toc-backref" href="#id19">One-Dimensional OpenGL Evaluators</a><a class="headerlink" href="#one-dimensional-opengl-evaluators" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>まず <code class="docutils literal notranslate"><span class="pre">glMap1</span></code> 関数の紹介から始まる。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">glMap1(entity,</span> <span class="pre">u0,</span> <span class="pre">u1,</span> <span class="pre">stride,</span> <span class="pre">order,</span> <span class="pre">data)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">entity</dt>
<dd class="field-odd"><p>この曲線が何の値を表現しているのかを指定する。
&lt;If we want a curve, we set entity to <code class="docutils literal notranslate"><span class="pre">GL_MAP1_VERTEX_3</span></code>&gt; (p. 198)
ただし <code class="docutils literal notranslate"><span class="pre">glEnable(GL_MAP1_VERTEX_3)</span></code> の呼び出しが別途必要。</p>
</dd>
<dt class="field-even">order</dt>
<dd class="field-even"><p>ベジエ曲線の次数プラス 1 を与える。すなわち、制御点の総数を意味する。</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">glMap1</span></code> で曲線を定義したら、その計算をし、結果を取得する。それには <code class="docutils literal notranslate"><span class="pre">glEvalCoord1</span></code> を用いる。今までは <code class="docutils literal notranslate"><span class="pre">glVertex</span></code> 等を利用していたところを <code class="docutils literal notranslate"><span class="pre">glEvalCoord1</span></code> に置き換わる感じ。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">glEvalCoord1(u)</span></code></p></li>
</ul>
</li>
<li><p>ところで、パラメータ u をいちいち手計算して与えるのは面倒だ。そんなときには
&lt;OpenGL provides an alternative for equally spaced values of u&gt;
(p. 199)</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">glMapGrid1(n,</span> <span class="pre">u0,</span> <span class="pre">u1)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">n</dt>
<dd class="field-odd"><p>区分数を意味する。</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">glEvalMesh1(mode,</span> <span class="pre">first,</span> <span class="pre">last)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">mode</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_(LINE|POINT)</span></code></p>
</dd>
<dt class="field-even">first, last</dt>
<dd class="field-even"><p>0 以上 <code class="docutils literal notranslate"><span class="pre">glMapGrid1</span></code> で与えた n 以下の数。</p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<section id="two-dimensional-evaluators">
<h3><a class="toc-backref" href="#id20">Two-Dimensional Evaluators</a><a class="headerlink" href="#two-dimensional-evaluators" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>次の関数を利用して二次元 Bernstein 多項式を評価することができる。すなわち、ベジエ曲面を描画できる。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">glMap2(entity,</span> <span class="pre">u0,</span> <span class="pre">u1,</span> <span class="pre">ustride,</span> <span class="pre">uorder,</span> <span class="pre">v0,</span> <span class="pre">v1,</span> <span class="pre">vstride,</span> <span class="pre">vorder,</span> <span class="pre">data)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glEvalCoord2(u,</span> <span class="pre">v)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glMapGrid(n,</span> <span class="pre">u0,</span> <span class="pre">u1,</span> <span class="pre">m,</span> <span class="pre">v0,</span> <span class="pre">v1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glEvalMesh2(mode,</span> <span class="pre">ufirst,</span> <span class="pre">ulast,</span> <span class="pre">vfirst,</span> <span class="pre">vlast)</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="other-types-of-curves">
<h3><a class="toc-backref" href="#id21">Other Types of Curves</a><a class="headerlink" href="#other-types-of-curves" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>&lt;In other words, a cubic polynomial is both a Bezier curve and
an interpolating curve for different set of control points&gt; (p. 203)</p></li>
<li><p>通過点から制御点を求める行列を紹介している。憶えなくてよい。</p></li>
</ul>
<section id="b-splines">
<h4><a class="toc-backref" href="#id22">B-Splines</a><a class="headerlink" href="#b-splines" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>まず、ベジエ曲線・曲面はスプライン曲線・曲面の一種であることをおさえる。</p></li>
<li><p>B スプラインもキュービックが基本。
&lt;The most popular type of spline is the cubic B-spline&gt; (p. 204)</p></li>
<li><p>キュービックスプラインの制御点を、同一形状のベジエ曲線の制御点に変換する行列を紹介している。憶えなくてよい。</p></li>
</ul>
</section>
<section id="nurbs">
<h4><a class="toc-backref" href="#id23">NURBS</a><a class="headerlink" href="#nurbs" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>OpenGL では GLU が NURBS をサポートしている。</p></li>
<li><p>NURBS のキモは w 成分にあるようだ。</p></li>
</ul>
</section>
</section>
<section id="the-utah-teapot">
<h3><a class="toc-backref" href="#id24">The Utah Teapot</a><a class="headerlink" href="#the-utah-teapot" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>例のティーポットの構成を説明。
&lt;The teapot is composed of 32 cubic Bezier surface patches, defined
by 306 distinct control points.  The data set is widely available
and usually is given as 32 lines, each of 16 integers in the range
of 1-192.  Each integer is a pointer to one of the 306 (x, y, z)
values&gt; (p. 207)</p></li>
</ul>
</section>
<section id="normals-and-shading">
<h3><a class="toc-backref" href="#id25">Normals and Shading</a><a class="headerlink" href="#normals-and-shading" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>曲面 evaluator が内部的に生成する頂点に対して法線を指定するには、</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_AUTO_NORMAL</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>するだけでよい。</p>
</li>
</ul>
</section>
<section id="texturing-surfaces">
<h3><a class="toc-backref" href="#id26">Texturing Surfaces</a><a class="headerlink" href="#texturing-surfaces" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>&lt;We can also use evaluators to generate normals for shading and
texture coordinates&gt; (p. 213)</p>
<p>どうするかというと、<code class="docutils literal notranslate"><span class="pre">glMap2</span></code> で実現できる。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glMap2f</span><span class="p">(</span><span class="n">GL_MAP2_TEXTURE_COORD_2</span><span class="p">,</span><span class="w"> </span><span class="n">u0</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="putting-it-together-and-moving-on">
<h2><a class="toc-backref" href="#id27">Putting It Together and Moving On</a><a class="headerlink" href="#putting-it-together-and-moving-on" title="Permalink to this headline">¶</a></h2>
<p>今まで紹介した機能プラスアルファで、デモプログラムを作る。目玉はトラックボールとフォグか。</p>
<section id="a-demo-program">
<h3><a class="toc-backref" href="#id28">A Demo Program</a><a class="headerlink" href="#a-demo-program" title="Permalink to this headline">¶</a></h3>
<section id="a-virtual-trackball">
<h4><a class="toc-backref" href="#id29">A Virtual Trackball</a><a class="headerlink" href="#a-virtual-trackball" title="Permalink to this headline">¶</a></h4>
<p>マウスの動きから仮想的なトラックボールを作る。方針は
&lt;by projecting the position of the mouse upward to the virtual
hemisphere, as in Figure 10.2.  As the mouse moves, the program
tracks the change in position on the hemisphere.  Two positions
on the hemisphere determine both an axis of rotation and an
angle to rotate about this axis, as shown in Figure 10.3&gt; (p. 216)</p>
</section>
</section>
<section id="other-opengl-features">
<h3><a class="toc-backref" href="#id30">Other OpenGL Features</a><a class="headerlink" href="#other-opengl-features" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>OpenGL tessellator で凸多角形制限をかわすことができる。</p></li>
<li><p>&lt;the use of NURBS requires more understanding of their mathematical
underpinnings than we can present here&gt; (pp. 230-231)</p></li>
</ul>
</section>
<section id="buffers">
<h3><a class="toc-backref" href="#id31">Buffers</a><a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>OpenGL は色々なバッファをサポートしているが &lt;not all of these buffers
need be available on all implementations&gt; (p. 231) だ。</p></li>
<li><p>accumulation バッファや stencil バッファを利用するプログラムでは、
<code class="docutils literal notranslate"><span class="pre">glutInitDisplayMode</span></code> の引数に、そのことを明示的に指示する。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glutInitDisplayMode</span><span class="p">(</span><span class="n">GL_XXX</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_STENCIL</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_ACCUM</span><span class="p">);</span><span class="w"></span>

<span class="n">glClear</span><span class="p">(</span><span class="n">GL_XXX</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_ACCUM_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_STENCIL_BUFFER_BIT</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>auxiliary バッファはマルチパスレンダリングに利用するかもしれない。</p></li>
</ul>
<section id="the-accumulation-buffer">
<h4><a class="toc-backref" href="#id32">The Accumulation Buffer</a><a class="headerlink" href="#the-accumulation-buffer" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>カラーバッファの精度に不足がある場合にこのバッファが役に立つらしい。まさに CPU レジスタの accumulator のような働きをするようだ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glAccum(operation,</span> <span class="pre">value)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">operation</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">GL_(ACCUM|LOAD|RETURN|ADD|MULT)</span></code></p>
</dd>
</dl>
</li>
<li><p>カメラがブレているような画像効果を狙ったマルチパスレンダリングに応用することが考えられる。</p></li>
</ul>
</section>
<section id="the-stencil-buffer">
<h4><a class="toc-backref" href="#id33">The Stencil Buffer</a><a class="headerlink" href="#the-stencil-buffer" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>&lt;Stencils are masks that we can use to determine where to draw&gt; (p. 232)</p></li>
</ul>
</section>
<section id="fragment-tests">
<h4><a class="toc-backref" href="#id34">Fragment Tests</a><a class="headerlink" href="#fragment-tests" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>&lt;in OpenGL the rasterizer produces <strong>fragments</strong>, which contain all the
information needed to update pixels in the frame buffer pixel&gt; (p. 233)</p></li>
<li><p>&lt;Fragments that are produced by the rasterizer go through a sequence of
tests–scissor, alpha, stencil, depth–and operations–blending,
dithering, logical–on their way to the color buffer&gt; (p. 233)</p></li>
</ul>
</section>
</section>
<section id="writing-portable-efficient-robust-code">
<h3><a class="toc-backref" href="#id35">Writing Portable, Efficient, Robust Code</a><a class="headerlink" href="#writing-portable-efficient-robust-code" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>OpenGL はポータブルとはいえ、当然その実装によっては制限がある。</p></li>
<li><p>&lt;One is that once we start using advanced features, such as the
accumulation and stencil buffers, we often lose portability,
as these features are not supported on all implementations&gt; (p. 233)</p></li>
<li><p>&lt;We do not know–nor do we usually need to know&gt; (p. 234)</p></li>
</ul>
</section>
</section>
<section id="looking-to-the-future">
<h2><a class="toc-backref" href="#id36">Looking to the Future</a><a class="headerlink" href="#looking-to-the-future" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>&lt;OpenGL version 1.0 was released in 1992&gt; (p. 235)</p></li>
</ul>
<section id="versions-and-extensions">
<h3><a class="toc-backref" href="#id37">Versions and Extensions</a><a class="headerlink" href="#versions-and-extensions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>&lt;extensions may apply to only some systems&gt;</p></li>
</ul>
<section id="opengl-version-1-1">
<h4><a class="toc-backref" href="#id38">OpenGL Version 1.1</a><a class="headerlink" href="#opengl-version-1-1" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>1995 年に登場。このバージョンが特に重要な理由は
&lt;Version 1.1 is still the most widely used version&gt; (p.235)
だから。</p></li>
<li><p>頂点配列、テクスチャー操作、RGBA 色に対する論理演算、ポリゴンオフセットが導入された。</p></li>
</ul>
</section>
<section id="opengl-version-1-2">
<h4><a class="toc-backref" href="#id39">OpenGL Version 1.2</a><a class="headerlink" href="#opengl-version-1-2" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>1998 年に登場。三次元テクスチャーマッピング機能。</p></li>
<li><p>imaging subset の追加</p></li>
</ul>
</section>
<section id="opengl-version-1-3">
<h4><a class="toc-backref" href="#id40">OpenGL Version 1.3</a><a class="headerlink" href="#opengl-version-1-3" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>2001 年に登場。テクスチャー処理性能を向上させる目的の機能追加。</p></li>
<li><p>転置行列関数もこのバージョンで登場した機能。これで Fortran 式の column order な配列だけでなく、
C 言語風の row order 配列もそのまま使えるようになった。</p></li>
</ul>
</section>
<section id="opengl-version-1-4">
<h4><a class="toc-backref" href="#id41">OpenGL Version 1.4</a><a class="headerlink" href="#opengl-version-1-4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>2002 年に登場。かつての拡張機能がコアに追加された。</p></li>
</ul>
</section>
<section id="opengl-version-1-5">
<h4><a class="toc-backref" href="#id42">OpenGL Version 1.5</a><a class="headerlink" href="#opengl-version-1-5" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>2003 年に登場。コアにマイナーチェンジを施しただけ。</p></li>
</ul>
</section>
</section>
<section id="opengl-extensions">
<h3><a class="toc-backref" href="#id43">OpenGL Extensions</a><a class="headerlink" href="#opengl-extensions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>&lt;Individual manufacturers can propose and implement extensions&gt; (p. 237)</p></li>
<li><p>&lt;As hardware evolves, high-end features that were only available
as extensions become part of later versions of OpenGL&gt; (p. 237)</p></li>
</ul>
</section>
<section id="going-beyond-read-time-graphics">
<h3><a class="toc-backref" href="#id44">Going Beyond Read-Time Graphics</a><a class="headerlink" href="#going-beyond-read-time-graphics" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>&lt;Pixar’s RenderMan interface&gt;</p></li>
<li><p>&lt;we cannot edit OpenGL display lists&gt; (p. 238)</p></li>
<li><p>&lt;all the information about the image is in the tree of Figure 11.1.
This tree is known as a <strong>scene graph</strong>&gt; (p. 238)</p></li>
<li><p>シーングラフを設計するのは難しい。
&lt;The answer today should be a set of atomic primitives that can take
advantage of the existing hardware and APIs&gt; (p. 239)</p></li>
<li><p>&lt;an application programer who wants to use scene graphs can often
avoid writing a program using the scene graph API by specifying
the scene through a text file that provides an alternate method
of describing the tree&gt; (p.239)</p></li>
</ul>
</section>
<section id="programmable-pipelines">
<h3><a class="toc-backref" href="#id45">Programmable Pipelines</a><a class="headerlink" href="#programmable-pipelines" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>パイプラインの一部をユーザープログラムで置き換えるような造りを考える。</p></li>
<li><p>&lt;Graphics processors have become programmable&gt; (p. 240)</p></li>
<li><p>vertex shader と fragment shader の 2 ブロックがそうだ。</p></li>
</ul>
<section id="vertex-shaders">
<h4><a class="toc-backref" href="#id46">Vertex Shaders</a><a class="headerlink" href="#vertex-shaders" title="Permalink to this headline">¶</a></h4>
<p>例えば Phong モデル以外の照光モデルで頂点の色を計算できる。</p>
</section>
<section id="fragment-shaders">
<h4><a class="toc-backref" href="#id47">Fragment Shaders</a><a class="headerlink" href="#fragment-shaders" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>&lt;In particular, the fragment shader can access one or more texture
coordinates, light properties, normals, and camera properties&gt;
(p. 241)</p></li>
</ul>
</section>
</section>
<section id="shading-languages">
<h3><a class="toc-backref" href="#id48">Shading Languages</a><a class="headerlink" href="#shading-languages" title="Permalink to this headline">¶</a></h3>
<section id="renderman-shading-language">
<h4><a class="toc-backref" href="#id49">RenderMan Shading Language</a><a class="headerlink" href="#renderman-shading-language" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>&lt;Once we realize that the Phong shader can be written as a tree data
structure, it is fairly simple to extend this concept to other shaders
by adding nodes to the tree and altering the contents of its node.
This concept of a <strong>shading tree</strong> is fundamental to much recent work
on shading languages&gt; (pp. 242-243)</p></li>
</ul>
</section>
<section id="the-opengl-shading-language">
<h4><a class="toc-backref" href="#id50">The OpenGL Shading Language</a><a class="headerlink" href="#the-opengl-shading-language" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>2003 年に ARB が extension として採用したのが OpenGL シェーディング言語。
C 言語がベースで、vertex shader と fragment shader の両方に用いられる。</p></li>
</ul>
</section>
<section id="cg">
<h4><a class="toc-backref" href="#id51">Cg</a><a class="headerlink" href="#cg" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>&lt;Rather than have separate APIs for accessing programmable hardware
for OpenGL and Direct3D, NVIDIA and Microsoft developed the Cg
(C for graphics) language&gt; (p. 244)</p></li>
</ul>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../yamamoto05/index.html" title="入門 xyzzy 読書ノート"
             >next</a></li>
        <li class="right" >
          <a href="note3.html" title="OpenGL: A Primer Second Edition 読書ノート 3/4"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >OpenGL: A Primer Second Edition 読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">OpenGL: A Primer Second Edition 読書ノート 4/4</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>