<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Functions &#8212; 読書ノート 1.6dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=c9b0a06a" />
    <script src="../_static/documentation_options.js?v=4354bf25"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="../_static/mathjax-v3.js?v=bf1ec211"></script>
    <script src="../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="Data Structures: Objects and Arrays" href="chapter04.html" />
    <link rel="prev" title="Program Structure" href="chapter02.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
    <div class="related top">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="chapter02.html" title="Previous">Program Structure</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">Eloquent JavaScript 読書ノート</a>
        </li>
        <li>
          <a href="chapter04.html" title="Next">Data Structures: Objects and Arrays</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>


          <div class="body" role="main">
            
  <section id="functions">
<h1><a class="toc-backref" href="#id2" role="doc-backlink">Functions</a><a class="headerlink" href="#functions" title="Link to this heading">¶</a></h1>
<p><a class="reference external" href="https://eloquentjavascript.net/">Eloquent JavaScript</a> Chapter 3 の読書ノート。</p>
<p>他のプログラミングと同様に JavaScript でも関数概念は基本的だ。大規模なプログラムを構造化し、反復を減らし、部分プログラムに分割して全体を管理することができる。</p>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#functions" id="id2">Functions</a></p>
<ul>
<li><p><a class="reference internal" href="#defining-a-function" id="id3">Defining a function</a></p></li>
<li><p><a class="reference internal" href="#bindings-and-scopes" id="id4">Bindings and scopes</a></p>
<ul>
<li><p><a class="reference internal" href="#nested-scope" id="id5">Nested scope</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#functions-as-values" id="id6">Functions as values</a></p></li>
<li><p><a class="reference internal" href="#declaration-notation" id="id7">Declaration notation</a></p></li>
<li><p><a class="reference internal" href="#arrow-functions" id="id8">Arrow functions</a></p></li>
<li><p><a class="reference internal" href="#the-call-stack" id="id9">The call stack</a></p></li>
<li><p><a class="reference internal" href="#optional-arguments" id="id10">Optional Arguments</a></p></li>
<li><p><a class="reference internal" href="#closure" id="id11">Closure</a></p></li>
<li><p><a class="reference internal" href="#recursion" id="id12">Recursion</a></p></li>
<li><p><a class="reference internal" href="#growing-functions" id="id13">Growing functions</a></p></li>
<li><p><a class="reference internal" href="#functions-and-side-effects" id="id14">Functions and side effects</a></p></li>
<li><p><a class="reference internal" href="#summary" id="id15">Summary</a></p></li>
<li><p><a class="reference internal" href="#exercises" id="id16">Exercises</a></p>
<ul>
<li><p><a class="reference internal" href="#minimum" id="id17">Minimum</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id18">Recursion</a></p></li>
<li><p><a class="reference internal" href="#bean-counting" id="id19">Bean counting</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="defining-a-function">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Defining a function</a><a class="headerlink" href="#defining-a-function" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>関数定義とは、変数定義であって、変数の値が関数であるものだ。</p></li>
<li><p>関数はキーワード <code class="docutils literal notranslate"><span class="pre">function</span></code> で始まる式で作成される。</p></li>
</ul>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">square</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>他のプログラミング言語同様に、引数リスト、本体、返り値などの概念も通用する。</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">return</span></code> の後に式がない場合、その関数は値 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> を返す。また、<code class="docutils literal notranslate"><span class="pre">return</span></code> 文を持たない関数も同様に値 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> を返す。</p></li>
</ul>
</section>
<section id="bindings-and-scopes">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Bindings and scopes</a><a class="headerlink" href="#bindings-and-scopes" title="Link to this heading">¶</a></h2>
<p>スコープの基本的な考え方は他のプログラミングと同様のようだ。</p>
<ul class="simple">
<li><p>他のプログラミング同様に、関数も含む変数にはスコープがある。</p></li>
<li><p>スコープの概念によって、関数間の分離が実現され、各関数の呼び出しはそれぞれの局所的な世界で動作する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">let</span></code> や <code class="docutils literal notranslate"><span class="pre">const</span></code> で宣言された変数は、実際にはそれが宣言されたブロック内での局所的な実体だ。ループ内でこれらの変数を作成した場合、ループの前のコードも後のコードもそれを「見る」ことはできない。</p></li>
<li><p>2015 年以前の JavaScript では新しいスコープを作るのは関数しかなかった。それゆえキーワード <code class="docutils literal notranslate"><span class="pre">var</span></code> で作成された旧式の変数は、それが登場する関数全体に加えて、大域スコープから見ることができる。</p></li>
<li><p>同じ名前の変数が複数ある場合は、コードは一番内側の変数しか見ることができない。</p></li>
</ul>
<section id="nested-scope">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Nested scope</a><a class="headerlink" href="#nested-scope" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>ブロックや関数は、他のブロックや関数の内部に作成することができる。局所性を複数持つ。</p></li>
<li><p>ブロック内で見える変数の集合は、プログラムテキスト内のそのブロックの位置によって決定する。各局所スコープからは、それを含むすべての局所スコープも見ることができ、すべてのスコープは大域スコープを見ることができる。このように変数を可視化する方法をレキシカルスコープと呼ぶ。</p></li>
</ul>
<p>レキシカルスコープの概念をしっかりと理解すること。</p>
</section>
</section>
<section id="functions-as-values">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Functions as values</a><a class="headerlink" href="#functions-as-values" title="Link to this heading">¶</a></h2>
<p>特になし。</p>
</section>
<section id="declaration-notation">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Declaration notation</a><a class="headerlink" href="#declaration-notation" title="Link to this heading">¶</a></h2>
<p>次の形式の関数定義も認められている。そのようなものは先ほどの形式のそれと動作が異なる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">square</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>関数の後にセミコロンを入れる必要がないので、若干書きやすい。</p></li>
<li><p>関数がそれを呼び出すコードの下に定義してもプログラムは動作する。この形式の関数の定義は通常の上から下への制御の流れには含まれない、このような関数定義は概念的にはそのスコープの最上部にあるかのように扱われ、そのスコープ内のすべてのコードが使用することができる。</p></li>
</ul>
</section>
<section id="arrow-functions">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Arrow functions</a><a class="headerlink" href="#arrow-functions" title="Link to this heading">¶</a></h2>
<p>他プログラム言語でいうラムダ式に相当する関数定義の様式もある。キーワード
<code class="docutils literal notranslate"><span class="pre">function</span></code> の代わりに、記号 <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> を使う。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">power</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">base</span><span class="p">,</span><span class="w"> </span><span class="nx">exponent</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">exponent</span><span class="p">;</span><span class="w"> </span><span class="nx">count</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="nx">base</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">square1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">square2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>引数がただ一つの場合は、引数リストを囲む丸括弧を省略してもよい。</p></li>
<li><p>関数本体が単一の式の場合、中括弧で囲まれたブロックではなく、その式が関数から返される。</p></li>
<li><p>矢印関数は 2015 年に追加されたものだ。小さな関数をより簡潔に書くことを目的としている。</p></li>
</ul>
</section>
<section id="the-call-stack">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">The call stack</a><a class="headerlink" href="#the-call-stack" title="Link to this heading">¶</a></h2>
<p>これも JavaScript というよりは、プログラミング言語全般の基本的な概念だ。</p>
<p>関数は終了するときに呼び出し元にジャンプして戻る必要がある。つまり、コンピューターは呼び出しが行われたときのコンテキストを記憶していなければならない。このコンテキストを保存する場所をコールスタックという。関数が呼び出されるたびに、その時点のコンテキストがこのスタックのいちばん上に格納される。</p>
<p>スタックが大きくなりすぎると、コンピューターは out of stack space や too much
recursion などのメッセージを出して失敗する。</p>
</section>
<section id="optional-arguments">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Optional Arguments</a><a class="headerlink" href="#optional-arguments" title="Link to this heading">¶</a></h2>
<p>JavaScript は関数に渡す引数の個数についてはひじょうにに寛大だ。</p>
<ul class="simple">
<li><p>多すぎる数の引数を渡しても、余分なものは無視される少なすぎると、足りない引数には <code class="docutils literal notranslate"><span class="pre">undefined</span></code> という値が割り当てられる。</p></li>
<li><p>他のプログラミング言語におけるデフォルト引数やキーワード引数の概念と同様のものがある。仮引数の後ろに演算子 <code class="docutils literal notranslate"><span class="pre">=</span></code> を書き、式を記述すると実引数が与えられていない場合にはその式の値が実引数となる。</p></li>
</ul>
<p>次の章で、引数のリスト全体を関数本体が取得する方法を見ていく。</p>
</section>
<section id="closure">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Closure</a><a class="headerlink" href="#closure" title="Link to this heading">¶</a></h2>
<p>局所変数の特定のオブジェクトを、それを囲むスコープの中で参照することができる機能を <em class="dfn">クロージャー</em> と呼ぶ。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">wrapValue</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">local</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">local</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">wrap1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">wrapValue</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">wrap2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">wrapValue</span><span class="p">(</span><span class="mf">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">wrap1</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">wrap2</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">2</span><span class="p">);</span>
</pre></div>
</div>
<p>関数 <code class="docutils literal notranslate"><span class="pre">wrapValue</span></code> の変数 <code class="docutils literal notranslate"><span class="pre">local</span></code> のような明示的な定義は実は必要ない。引数それ自体が局所変数だ。</p>
</section>
<section id="recursion">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Recursion</a><a class="headerlink" href="#recursion" title="Link to this heading">¶</a></h2>
<p>他のプログラミング言語と同様に、関数を再帰的に呼び出すことが許される。</p>
<ul class="simple">
<li><p>自分自身を呼び出す関数を再帰関数と呼ぶ。</p></li>
<li><p>再帰関数はループの形で書くことができるのがふつうだ。</p></li>
<li><p>一般的な JavaScript の実装では、ループに比べて約 3 倍遅くなる。単純なループを実行する方が関数を何度も呼び出すよりも一般的に安上がりだ。</p></li>
<li><p>再帰は必ずしもループの代わりになる非効率なものばかりではない。問題によってはループよりも再帰の方が解決しやすいものもある。</p></li>
</ul>
</section>
<section id="growing-functions">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Growing functions</a><a class="headerlink" href="#growing-functions" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>同じようなコードを何度も書いてしまうことがあれば、それは関数を導入する兆候だ。</p></li>
<li><p>まだ書いていない必要な機能があり、それが関数であることがふさわしいように思える場合もそうだ。</p></li>
<li><p>関数の良い命名を見つける難しさは、定義しようとしている概念のわかりやすさと関係する。</p></li>
<li><p>絶対に必要だと確信できる場合を除き、小賢しいことをしないのが原則だ。</p></li>
</ul>
</section>
<section id="functions-and-side-effects">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">Functions and side effects</a><a class="headerlink" href="#functions-and-side-effects" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>値を生成する関数は、副作用がある関数よりも、新しい方法で組み合わせることが容易だ。</p></li>
<li><p><em class="dfn">純粋関数</em> とは、値を返す関数であって、副作用がないだけでなく、他のコードからの副作用にも依存しないものをいう。</p></li>
<li><p>純粋関数は、同じ引数で呼び出された場合、常に同じ値を返すといううれしい性質がある。</p></li>
</ul>
</section>
<section id="summary">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Summary</a><a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">function</span></code> を式として使うと、関数を定義する。</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">function</span></code> を文として使うと、変数を宣言して、その値として関数を定義する。</p></li>
<li><p>矢関数は、関数を定義するもう一つの方法だ。</p></li>
<li><p>関数を理解する上で重要なのはスコープを理解することだ。</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">var</span></code> により定義された変数のスコープはそれ以外のキーワードにより定義されたものとかなり異なる。</p></li>
</ul>
</section>
<section id="exercises">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Exercises</a><a class="headerlink" href="#exercises" title="Link to this heading">¶</a></h2>
<section id="minimum">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Minimum</a><a class="headerlink" href="#minimum" title="Link to this heading">¶</a></h3>
<p><strong>問題</strong>：標準関数 <code class="docutils literal notranslate"><span class="pre">Math.min</span></code> のようなものを作れ：引数を二つ取り、それらの最小値を返す関数 <code class="docutils literal notranslate"><span class="pre">min</span></code> を書け。</p>
<p><strong>解答</strong>：C++ 標準の <code class="docutils literal notranslate"><span class="pre">std::max</span></code> をパクる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">){</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="o">!</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">a</span><span class="p">));</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="o">!</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">b</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">max</span><span class="p">(</span><span class="mf">100</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">100</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">max</span><span class="p">(</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">100</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">100</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">max</span><span class="p">(</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">5</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>この仕様の関数は <code class="docutils literal notranslate"><span class="pre">Math.min</span></code> のそれとは全然違うことに注意。</p></li>
</ul>
</section>
<section id="id1">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Recursion</a><a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<p><strong>問題</strong>：ここでは、正の整数が偶数か奇数かを次で定義する：</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(0\)</span> は偶数であるとする。</p></li>
<li><p><span class="math notranslate nohighlight">\(1\)</span> は奇数であるとする。</p></li>
<li><p>その他の数 <span class="math notranslate nohighlight">\(n\)</span> については、その偶数性は <span class="math notranslate nohighlight">\(n - 2\)</span> と同じとする</p></li>
</ul>
<p>この記述に対応する再帰関数 <code class="docutils literal notranslate"><span class="pre">isEven</span></code> を定義しろ。この関数は正の整数である引数を一つ取り、真偽値を返すものとする。</p>
<p><strong>解答</strong>：教科書の演習問題の解答としてはこの程度の品質でいいと思われる：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">isEven</span><span class="p">(</span><span class="nx">n</span><span class="p">){</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isSafeInteger</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">isEven</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">isEven</span><span class="p">(</span><span class="mf">50</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="o">!</span><span class="nx">isEven</span><span class="p">(</span><span class="mf">75</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="o">!</span><span class="nx">isEven</span><span class="p">(</span><span class="mf">1</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="bean-counting">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Bean counting</a><a class="headerlink" href="#bean-counting" title="Link to this heading">¶</a></h3>
<p><strong>問題</strong>：文字列を唯一の引数として受け取り、その文字列に含まれる大文字の <code class="docutils literal notranslate"><span class="pre">B</span></code>
の個数を返す関数 <code class="docutils literal notranslate"><span class="pre">countBs</span></code> を書け。その後、関数 <code class="docutils literal notranslate"><span class="pre">countBs</span></code> を次のように書き換えて関数 <code class="docutils literal notranslate"><span class="pre">countChar</span></code> を定義しろ。この関数は、数える文字を第二引数として取ることを除いては、<code class="docutils literal notranslate"><span class="pre">countBs</span></code> と同様に動作するものとする。</p>
<p><strong>解答</strong>：題意を無視して後半からやる：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">countChar</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="kr">char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;B&quot;</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Array</span><span class="p">.</span><span class="kr">from</span><span class="p">(</span><span class="nx">s</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kr">char</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以上</p>
</section>
</section>
</section>


          </div>
    <div class="related bottom">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="chapter02.html" title="Previous">Program Structure</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">Eloquent JavaScript 読書ノート</a>
        </li>
        <li>
          <a href="chapter04.html" title="Next">Data Structures: Objects and Arrays</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>

      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="../index.html" title="読書ノート Home"><img src="../_images/logo.svg"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2024, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>