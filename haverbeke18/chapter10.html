<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Modules &#8212; 読書ノート 1.6dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=c9b0a06a" />
    <script src="../_static/documentation_options.js?v=4354bf25"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="Asynchronous Programming" href="chapter11.html" />
    <link rel="prev" title="Regular Expressions" href="chapter09.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
    <div class="related top">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="chapter09.html" title="Previous">Regular Expressions</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">Eloquent JavaScript 読書ノート</a>
        </li>
        <li>
          <a href="chapter11.html" title="Next">Asynchronous Programming</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>


          <div class="body" role="main">
            
  <section id="modules">
<h1><a class="toc-backref" href="#id3" role="doc-backlink">Modules</a><a class="headerlink" href="#modules" title="Link to this heading">¶</a></h1>
<p><a class="reference external" href="https://eloquentjavascript.net/">Eloquent JavaScript</a> Chapter 10 の読書ノート。</p>
<p>巨大な泥団子はすべてがくっついていて、部分を切り取ろうとすると全体がバラバラになり手が汚れる。プログラムにもそういうものがある。</p>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#modules" id="id3">Modules</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id4">Modules</a></p></li>
<li><p><a class="reference internal" href="#packages" id="id5">Packages</a></p></li>
<li><p><a class="reference internal" href="#improvised-modules" id="id6">Improvised modules</a></p></li>
<li><p><a class="reference internal" href="#evaluating-data-as-code" id="id7">Evaluating data as code</a></p></li>
<li><p><a class="reference internal" href="#commonjs" id="id8">CommonJS</a></p></li>
<li><p><a class="reference internal" href="#ecmascript-modules" id="id9">ECMAScript modules</a></p></li>
<li><p><a class="reference internal" href="#building-and-bundling" id="id10">Building and bundling</a></p></li>
<li><p><a class="reference internal" href="#module-design" id="id11">Module design</a></p></li>
<li><p><a class="reference internal" href="#summary" id="id12">Summary</a></p></li>
<li><p><a class="reference internal" href="#exercises" id="id13">Exercises</a></p>
<ul>
<li><p><a class="reference internal" href="#a-modular-robot" id="id14">A modular robot</a></p></li>
<li><p><a class="reference internal" href="#roads-module" id="id15">Roads module</a></p></li>
<li><p><a class="reference internal" href="#circular-dependencies" id="id16">Circular dependencies</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="id1">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Modules</a><a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>モジュールとは、プログラムの部分であって、他のモジュールがその機能を使用できるようにインターフェイスを備えるものだ。</p></li>
<li><p>モジュールのインターフェイスもオブジェクトのそれと多くの共通点がある。モジュールの一部は外部に公開し、残りは非公開にする。するとシステムはレゴブロックのようにモジュールの組み合わせになる。</p></li>
<li><p>モジュール間の関係を <strong>依存関係</strong> という。あるモジュールが他のモジュールの断片を必要とする場合、そのモジュールに依存しているという。</p></li>
<li><p>モジュールを分けるためには、それぞれにプライベートスコープが必要になるのだが、
JavaScript のコードを別のファイルに分けただけではダメだ。ファイルは同じ大域名前空間を共有している。また、依存関係の構造も明瞭になるわけではない。</p></li>
<li><p>プログラムに適したモジュール構造を設計するのは難しい。</p></li>
</ul>
</section>
<section id="packages">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Packages</a><a class="headerlink" href="#packages" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>いったんコードを複製し始めると、オリジナルとその複製（複数あるだろう）の維持に時間と労力を浪費することになる。そこでパッケージの出番となる。</p></li>
<li><p><em class="dfn">パッケージ</em> とは、配布（コピーやインストール）が可能なコードの塊だ。</p>
<ul>
<li><p>パッケージはモジュールで構成されていて、依存する外部パッケージが何であるかという情報を持っている。</p></li>
<li><p>パッケージには通常、それが何をするものなのかを説明する文書が付属する。これにより、パッケージの著者ではない人でも利用できるようになる。</p></li>
</ul>
</li>
<li><p>パッケージに問題が発見されたり、新しい機能が追加されたりすると、それは更新されるという。更新すれば、そのパッケージに依存しているプログラムは、新しいバージョンにアップグレードできる。</p></li>
<li><p>JavaScript の世界ではパッケージを <strong>NPM</strong> &lt;<a class="reference external" href="https://npmjs.org">https://npmjs.org</a>&gt; というもので管理する。</p>
<ul>
<li><p><a class="reference external" href="https://npmjs.org">NPM</a> はパッケージのダウンロードサービスと、インストール管理を支援するプログラムの二つの要素がある。</p></li>
<li><p>本書執筆時点で <a class="reference external" href="https://npmjs.org">NPM</a> には 50 万以上のパッケージがある。一般公開されている有用なパッケージのほとんどは <a class="reference external" href="https://npmjs.org">NPM</a> で見つかる。</p>
<ul>
<li><p>例えば前章で作成したような INI ファイル読み込み機能を提供するパッケージもある。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>第 20 章で <strong class="program">npm</strong> コマンドラインプログラムを使ってパッケージをローカルにインストールする方法を習得する。</p>
</div>
<ul class="simple">
<li><p>多くのパッケージは、他の人が使用することを明示的に許可するライセンスの下で公開されている。<a class="reference external" href="https://npmjs.org">NPM</a> のほとんどのコードはこのようなライセンスで公開されている。</p></li>
<li><p>パッケージに依存するコードを同じライセンスで公開することを要求するライセンスもある。他のライセンスはそれほど厳しくなく、コードを配布する際にそのコードと一緒にライセンスを保持することを要求するだけだ。JavaScript のコミュニティーでは、ほとんどが後者のライセンスだ。</p></li>
<li><p>他人のパッケージを使用する際には、そのライセンスを確認することだ。</p></li>
</ul>
</section>
<section id="improvised-modules">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Improvised modules</a><a class="headerlink" href="#improvised-modules" title="Link to this heading">¶</a></h2>
<ul>
<li><p>2015 年まで、JavaScript言語にはモジュールシステムがなかった。そこでモジュールを所望する人々が独自のモジュールシステムを設計した。</p></li>
<li><p>次のコードは曜日名と対応する数字を変換する機能があるモジュールだ：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">weekDay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;Sunday&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Monday&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Tuesday&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Wednesday&quot;</span><span class="p">,</span>
<span class="w">                   </span><span class="s2">&quot;Thursday&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Friday&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Saturday&quot;</span><span class="p">];</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">name</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">names</span><span class="p">[</span><span class="nx">number</span><span class="p">];</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nx">number</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">names</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}();</span>
</pre></div>
</div>
<ul class="simple">
<li><p>インターフェイスは <code class="docutils literal notranslate"><span class="pre">weekDay.name</span></code> と <code class="docutils literal notranslate"><span class="pre">weekDay.number</span></code> の二つ。</p></li>
<li><p>ローカル変数はすぐに呼び出される関数式のスコープにあるため、外部からは見えない。</p></li>
</ul>
</li>
<li><p>このモジュールはある程度は分離されているものの、依存関係が宣言されていない。自身のインターフェイスを大域名前空間に入れており、依存するものに対しては、同じようにそれらも大域名前空間にあることを想定している。</p></li>
<li><p>この方式は現在ではほとんど使われていない。</p></li>
<li><p>依存関係をコードの一部にするには、依存関係のロードを制御する必要がある。それには文字列を JavaScript のコードとして実行する機能が必要だ。</p></li>
</ul>
</section>
<section id="evaluating-data-as-code">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Evaluating data as code</a><a class="headerlink" href="#evaluating-data-as-code" title="Link to this heading">¶</a></h2>
<ul>
<li><p>特別な演算子 <code class="docutils literal notranslate"><span class="pre">eval</span></code> を使うと、与えられた文字列を現在のスコープ内で実行することになる。よその言語の同等の機能と同様に、これを使うのは良くない。いろいろなものを破壊する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Function</span></code> コンストラクターを使う方法は <code class="docutils literal notranslate"><span class="pre">eval</span></code> よりは怖くない。これは
<code class="docutils literal notranslate"><span class="pre">,</span></code> 区切りの引数リストからなる文字列と、関数本体からなる文字列を受け取ってコード化し、結果を返すというものだ。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">plusOne</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Function</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;return n + 1;&quot;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">plusOne</span><span class="p">(</span><span class="mf">4</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">5</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Function</span></code> を利用してモジュールを構成していく。</p></li>
</ul>
</section>
<section id="commonjs">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">CommonJS</a><a class="headerlink" href="#commonjs" title="Link to this heading">¶</a></h2>
<p>JavaScript モジュールを追加するのに最も広く使われている方法は <strong>CommonJS</strong> モジュールというものだ。Node.js はこれを採用しており、<a class="reference external" href="https://npmjs.org">NPM</a> のパッケージのほとんどで採用されているシステムだ。</p>
<ul class="simple">
<li><p>CommonJS モジュールでは <code class="docutils literal notranslate"><span class="pre">require</span></code> という機能が重要だ。これを依存モジュールの名前を指定して呼び出すと、当該モジュールがロードされて、そのインターフェイスを返す。</p></li>
<li><p>ローダーがモジュールコードを関数にラップするので、モジュールは固有のローカススコープを自動的に得る。あとは <code class="docutils literal notranslate"><span class="pre">require</span></code> を呼び出して依存関係にアクセスして、インターフェイスをオブジェクト <code class="docutils literal notranslate"><span class="pre">exports</span></code> に置くだけだ。</p></li>
</ul>
<p>依存モジュールが二つあるモジュールの作成例が示されている。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">ordinal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;ordinal&quot;</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">days</span><span class="p">,</span><span class="w"> </span><span class="nx">months</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;date-names&quot;</span><span class="p">);</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">formatDate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">date</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">format</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/YYYY|M(MMM)?|Do?|dddd/g</span><span class="p">,</span><span class="w"> </span><span class="nx">tag</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;YYYY&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">date</span><span class="p">.</span><span class="nx">getFullYear</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;M&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">date</span><span class="p">.</span><span class="nx">getMonth</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;MMMM&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">months</span><span class="p">[</span><span class="nx">date</span><span class="p">.</span><span class="nx">getMonth</span><span class="p">()];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;D&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">date</span><span class="p">.</span><span class="nx">getDate</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;Do&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">ordinal</span><span class="p">(</span><span class="nx">date</span><span class="p">.</span><span class="nx">getDate</span><span class="p">());</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;dddd&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">days</span><span class="p">[</span><span class="nx">date</span><span class="p">.</span><span class="nx">getDay</span><span class="p">()];</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">};</span>
</pre></div>
</div>
<ul>
<li><p>この自作モジュールは外部パッケージ <code class="docutils literal notranslate"><span class="pre">ordinal</span></code> と <code class="docutils literal notranslate"><span class="pre">date-names</span></code> に依存している。</p>
<ul class="simple">
<li><p>前者は <code class="docutils literal notranslate"><span class="pre">1st</span></code> や <code class="docutils literal notranslate"><span class="pre">2nd</span></code> のような序数を示す文字列を数に変換するのに使う。</p></li>
<li><p>後者は曜日名や月名に対する英単語を得るのに使う。</p></li>
</ul>
</li>
<li><p>この自作モジュールがエクスポート（外部に公開、提供）するのは関数
<code class="docutils literal notranslate"><span class="pre">formatDate</span></code> だけだ。</p></li>
<li><p>パッケージ <code class="docutils literal notranslate"><span class="pre">ordinal</span></code> のインターフェイスは関数一つ。ここでは定数 <code class="docutils literal notranslate"><span class="pre">ordinal</span></code>
として参照する。</p></li>
<li><p>パッケージ <code class="docutils literal notranslate"><span class="pre">date-names</span></code> のインターフェイスはオブジェクト一つであって、そこには曜日名や月名を表す英単語の配列がある。ここでは定数 <code class="docutils literal notranslate"><span class="pre">days</span></code> と <code class="docutils literal notranslate"><span class="pre">months</span></code> として参照する。</p></li>
<li><p>この自作にモジュールが公開するインターフェイスとして、オブジェクト <code class="docutils literal notranslate"><span class="pre">exports</span></code>
に <code class="docutils literal notranslate"><span class="pre">formatDate</span></code> を追加する。</p></li>
<li><p>この自作モジュールを使うには次のようにする：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">formatDate</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;./format-date&quot;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">formatDate</span><span class="p">(</span><span class="ow">new</span><span class="w"> </span><span class="nb">Date</span><span class="p">(</span><span class="mf">2017</span><span class="p">,</span><span class="w"> </span><span class="mf">9</span><span class="p">,</span><span class="w"> </span><span class="mf">13</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;dddd the Do&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// → Friday the 13th</span>
</pre></div>
</div>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">require</span></code> をもっとも最小の形式で定義するには本書のコード (p. 178) のようにする。</p>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">readFile</span></code> が標準 JavaScript に存在しないものであることに注意。
Node.js をインストールしてからこの章を読む必要があった。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">require</span></code> はロード済みモジュールをキャッシュする。</p></li>
</ul>
<p>CommonJS モジュールには癖がある。モジュールシステムが空のインターフェイス用オブジェクト <code class="docutils literal notranslate"><span class="pre">exports</span></code> を作成してくれるにもかかわらず、<code class="docutils literal notranslate"><span class="pre">exports</span></code> を上書きすることでどんな値でも置き換えることが可能だというものだ。多くのモジュールでは、インターフェイスオブジェクトの代わりに単一の値をエクスポートするために、この置換の手法が横行している。</p>
<ul>
<li><p>生成されたラッパー関数の引数として <code class="docutils literal notranslate"><span class="pre">require</span></code>, <code class="docutils literal notranslate"><span class="pre">exports</span></code>, <code class="docutils literal notranslate"><span class="pre">module</span></code> を定義する（呼び出すときに適切な値を渡す）ことで、ローダーはこれらの変数がモジュールのスコープで利用可能であることを保証する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">require</span></code> に与えられた文字列が実際のファイル名やウェブアドレスに変換される方法はシステムによって異なる。</p>
<ul class="simple">
<li><p>文字列が <code class="docutils literal notranslate"><span class="pre">./</span></code> や <code class="docutils literal notranslate"><span class="pre">../</span></code> で始まっている場合は、一般に現在のモジュールとの相対パスとして処理される。</p></li>
<li><p>名前が相対的でない場合、Node.js はその名前でインストールされたパッケージを探す。本章のサンプルコードでは、このような名前は <a class="reference external" href="https://npmjs.org">NPM</a> パッケージを参照していると解釈している。</p></li>
</ul>
</li>
<li><p>前章のような INI ファイルの読み取り機能を自作する代わりに、<a class="reference external" href="https://npmjs.org">NPM</a> にあるものを使うことができる：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">parse</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;ini&quot;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s2">&quot;x = 10\ny = 20&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// → {x: &quot;10&quot;, y: &quot;20&quot;}</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="ecmascript-modules">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">ECMAScript modules</a><a class="headerlink" href="#ecmascript-modules" title="Link to this heading">¶</a></h2>
<p>2015年 からの JavaScript 標準では CommonJS とは異なるモジュールシステムを導入した。それは通常 ES モジュールと呼ばれる。</p>
<ul>
<li><p>ES は ECMAScriptの略。</p></li>
<li><p>依存関係やインターフェイスといった主要な概念は CommonJS と変わらないまま、細部が異なる。</p></li>
<li><p>表記法が言語に統合された。依存関係にアクセスするために関数を呼び出すのではなく、特別なキーワード <code class="docutils literal notranslate"><span class="pre">import</span></code> を使う。</p></li>
<li><p>キーワード <code class="docutils literal notranslate"><span class="pre">export</span></code> はモジュール要素をエクスポートするのに使う。このキーワードは関数、クラス、変数各種の前に現れることがある。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nx">ordinal</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;ordinal&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="nx">days</span><span class="p">,</span><span class="w"> </span><span class="nx">months</span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;date-names&quot;</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">formatDate</span><span class="p">(</span><span class="nx">date</span><span class="p">,</span><span class="w"> </span><span class="nx">format</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>ES モジュールのインターフェイスは単一の値ではなく、名前のある変数の集合だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">default</span></code> を使うと、エクスポートする要素を指定できる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;Winter&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Spring&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Summer&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Autumn&quot;</span><span class="p">];</span>
</pre></div>
</div>
</li>
<li><p>Python のようにキーワード <code class="docutils literal notranslate"><span class="pre">as</span></code> を用いてインポート名を指定することができる。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="nx">days</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">dayNames</span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;date-names&quot;</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>ES モジュールのインポートは、スクリプトの実行を開始する前に起こるという違いがある。<code class="docutils literal notranslate"><span class="pre">import</span></code> 文を関数やブロックの中に記述することはできない。</p></li>
</ul>
</section>
<section id="building-and-bundling">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Building and bundling</a><a class="headerlink" href="#building-and-bundling" title="Link to this heading">¶</a></h2>
<p>JavaScript のコードがあっても、それが元々 JavaScript で書かれたものであるとは限らない。</p>
</section>
<section id="module-design">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Module design</a><a class="headerlink" href="#module-design" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>モジュールのデザインには、使いやすさという側面もある。</p></li>
<li><p>標準的な機能や広く使われているパッケージがなくても、単純なデータ構造を使い、単一の集中的な作業を行うことで、モジュールを予測可能なものにできる。</p></li>
<li><p>副作用のある複雑な動作をする大きなモジュールよりも、値を計算する集中的なモジュールの方が、より幅広いプログラムに適用できる。</p></li>
<li><p>関数でできることは関数を使え。</p></li>
<li><p>配列で十分な場合は配列を使え。</p></li>
<li><p>合成し易さを考慮して設計したい場合は、他の人がどのようなデータ構造を使用しているかを調べ、可能であればその例に従え。</p></li>
</ul>
</section>
<section id="summary">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Summary</a><a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>モジュールは、大規模なプログラムに構造を与えるために、コードを明確なインターフェイスと依存関係を持つ断片に分離する。</p></li>
<li><p>インターフェースとは、他のモジュールから見えるモジュールの部分であり、依存関係とは、そのモジュールが利用する他のモジュールだ。</p></li>
<li><p>歴史的に JavaScript はモジュールシステムを提供していなかったので、CommonJS システムはその上に構築された。その後、ある時点で組み込みのシステムが導入されたが、現在は CommonJS とよく共存している。</p></li>
<li><p>パッケージとは、単体で配布可能なコードの塊だ。</p></li>
<li><p><a class="reference external" href="https://npmjs.org">NPM</a> は JavaScript パッケージのリポジトリーだ。</p></li>
</ul>
</section>
<section id="exercises">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Exercises</a><a class="headerlink" href="#exercises" title="Link to this heading">¶</a></h2>
<section id="a-modular-robot">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">A modular robot</a><a class="headerlink" href="#a-modular-robot" title="Link to this heading">¶</a></h3>
<p>第 7 章では次の定数、変数、関数、クラスを導入した：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">roads</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">buildGraph</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">roadGraph</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VillageState</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">runRobot</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">randomPick</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">randomRobot</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mailRoute</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">routeRobot</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findRoute</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">goalOrientedRobot</span></code></p></li>
</ul>
<p><strong>問題</strong> このプロジェクトをモジュラープログラムとして書くとしたら、どのようなモジュールを作るか。また、どのモジュールがどのモジュールに依存しているだろうか。そのインターフェイスはどのようになっているだろうか。</p>
<p><a class="reference external" href="https://npmjs.org">NPM</a> であらかじめ書かれたものはどのようなものがあるか。</p>
<p><strong>解答</strong> まず依存関係をまとめる。Graphviz などで図式化するといい：</p>
<ul class="simple">
<li><p>定数 <code class="docutils literal notranslate"><span class="pre">roads</span></code> は独立して存在している。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">buildGraph</span></code> は独立して存在している。</p></li>
<li><p>定数 <code class="docutils literal notranslate"><span class="pre">roadGraph</span></code> は次のものに依存している：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">roads</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">buildGraph</span></code></p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">VillageState</span></code> は <code class="docutils literal notranslate"><span class="pre">roadGraph</span></code> に依存している。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">runRobot</span></code> は引数のインターフェイスに依存している。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">randomPick</span></code> は標準モジュール <code class="docutils literal notranslate"><span class="pre">Math</span></code> に依存している。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">randomRobot</span></code> は次のものに依存している：</p>
<ul>
<li><p>引数 <code class="docutils literal notranslate"><span class="pre">state</span></code> のインターフェイス</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">roadGraph</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">randomPick</span></code></p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">VillageState.random</span></code> のため <code class="docutils literal notranslate"><span class="pre">randomPick</span></code> に依存する。</p></li>
<li><p>定数 <code class="docutils literal notranslate"><span class="pre">mailRoute</span></code> は独立して存在しているが、値は <code class="docutils literal notranslate"><span class="pre">roads</span></code> から決まる。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">routeRobot</span></code> は <code class="docutils literal notranslate"><span class="pre">mailRoute</span></code> に依存している。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">findRoute</span></code> は引数のインターフェイスに依存する。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">goalOrientedRobot</span></code> は次のものに依存している：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">roadGraph</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findRoute</span></code></p></li>
</ul>
</li>
</ul>
<p>次のようにモジュール群を編成できる：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>モジュール</p></th>
<th class="head"><p>内容</p></th>
<th class="head"><p>～に依存する</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mailRoute.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mailRoute</span></code></p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">graph.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">buildGraph</span></code></p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">randomPick.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">randomPick</span></code></p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">roadGraph.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">roadGraph</span></code>, <code class="docutils literal notranslate"><span class="pre">roads</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">graph.js</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">randomRobot.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">randomRobot</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">roadGraph.js</span></code>, <code class="docutils literal notranslate"><span class="pre">randomPick.js</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">routeRobot.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">routeRobot</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mailRoute.js</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">goalOrientedRobot.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">goalOrientedRobot</span></code>, <code class="docutils literal notranslate"><span class="pre">findRoute</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">roadGraph</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">runRobot.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">runRobot</span></code></p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">village.js</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">VillageState</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">roadGraph.js</span></code>, <code class="docutils literal notranslate"><span class="pre">randomPick.js</span></code></p></td>
</tr>
</tbody>
</table>
<p><a class="reference external" href="https://npmjs.org">NPM</a> は調べていないが、ありそうなのはランダムピック機能か。</p>
</section>
<section id="roads-module">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Roads module</a><a class="headerlink" href="#roads-module" title="Link to this heading">¶</a></h3>
<p><strong>問題</strong> 第 7 章の例をもとに、道路の配列を格納し、道路を表すグラフデータ構造
<code class="docutils literal notranslate"><span class="pre">roadGraph</span></code> をエクスポートする CommonJS モジュールを書け。</p>
<p>このモジュールは、グラフを構築するために使用される関数 <code class="docutils literal notranslate"><span class="pre">buildGraph</span></code> をエクスポートするモジュール <code class="docutils literal notranslate"><span class="pre">./graph</span></code> に依存するものとする。この関数は、二要素（道路の始点と終点）の配列を引数に取る。</p>
<p><strong>解答</strong> 前問のようにモジュール群を編成するとして：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">buildGraph</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;./graph&quot;</span><span class="p">);</span>

<span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">roads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="s2">&quot;Alice&#39;s House-Bob&#39;s House&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Alice&#39;s House-Cabin&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Alice&#39;s House-Post Office&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Bob&#39;s House-Town Hall&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Daria&#39;s House-Ernie&#39;s House&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Daria&#39;s House-Town Hall&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Ernie&#39;s House-Grete&#39;s House&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Grete&#39;s House-Farm&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Grete&#39;s House-Shop&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Marketplace-Farm&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Marketplace-Post Office&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Marketplace-Shop&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Marketplace-Town Hall&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Shop-Town Hall&quot;</span>
<span class="p">];</span>

<span class="w"> </span><span class="nx">exports</span><span class="p">.</span><span class="nx">roadGraph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">buildGraph</span><span class="p">(</span><span class="nx">roads</span><span class="p">);</span>
</pre></div>
</div>
<p>なお、関数 <code class="docutils literal notranslate"><span class="pre">require</span></code> は Node.js のものを想定している。</p>
</section>
<section id="circular-dependencies">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Circular dependencies</a><a class="headerlink" href="#circular-dependencies" title="Link to this heading">¶</a></h3>
<p><em class="dfn">循環依存</em> とは、モジュール A が B に依存し、B も直接または間接的に A に依存している状況だ。多くのモジュールシステムでは単純にこれを禁じている。このようなモジュールをロードする順序をどのように選択しても、実行前に各モジュールの依存関係がロードされていることを確認できないからだ。</p>
<p>CommonJS のモジュールでは、限られた形での周期的な依存関係を認めている。モジュールがデフォルトの <code class="docutils literal notranslate"><span class="pre">exports</span></code> オブジェクトを置き換えず、ロードが完了するまでお互いのインターフェイスにアクセスしない限り、周期的な依存関係は問題にならない。</p>
<p><strong>問題</strong> この章の序盤で与えた関数 <code class="docutils literal notranslate"><span class="pre">require</span></code> は、この種の依存関係の循環をサポートしている。どのように循環を処理しているか。循環内のモジュールがデフォルトの
<code class="docutils literal notranslate"><span class="pre">exports</span></code> オブジェクトを置き換えた場合、何が問題になるか。</p>
<p><strong>解答</strong> <code class="docutils literal notranslate"><span class="pre">require.cache</span></code> があるおかげで、二度目以降のロードを無視する。C/C++でいうところのインクルードガード（この技術は古いが）のような働きをする。</p>
<p>以上</p>
</section>
</section>
</section>


          </div>
    <div class="related bottom">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="chapter09.html" title="Previous">Regular Expressions</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">Eloquent JavaScript 読書ノート</a>
        </li>
        <li>
          <a href="chapter11.html" title="Next">Asynchronous Programming</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>

      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="../index.html" title="読書ノート Home"><img src="../_images/logo.svg"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2024, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>