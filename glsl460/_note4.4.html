
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4.4. Layout Qualifiers &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/prefab.css" />
    
    <script src="../_static/mathjax-v3.js"></script>
     
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">4.4. Layout Qualifiers</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="layout-qualifiers">
<h1>4.4. Layout Qualifiers<a class="headerlink" href="#layout-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>レイアウト修飾子は宣言形式がいくつかある。前節の文法で示したように、インターフェイスブロックの定義やブロックメンバーの一部として現れることがある。一つの <em>layout-qualifier</em> だけで、その修飾子を使った他の宣言のレイアウトを設定することもできる。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> <em>interface-qualifier</em> ;</div>
</div>
<p>また、インターフェイス修飾子で宣言された個別の変数で出現することもある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> <em>interface-qualifier</em> <em>declaration</em> ;</div>
</div>
<p>レイアウトの宣言は、大域スコープまたはブロックメンバーでしか行えず、以下の節で示される場所でしか行えない。</p>
<p>レイアウト修飾子は次のように展開する：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">layout</span> <span class="pre">(</span></code> <em>layout-qualifier-id-list</em> <code class="docutils literal notranslate"><span class="pre">)</span></code></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-id-list</em> :</div>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em></div>
<div class="line"><em>layout-qualifier-id</em> , <em>layout-qualifier-id-list</em></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>layout-qualifier-name</em></div>
<div class="line"><em>layout-qualifier-name</em> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">shared</span></code></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-value</em> :</div>
<div class="line-block">
<div class="line"><em>integer-constant-expression</em></div>
</div>
</div>
<p><em>layout-qualifier-name</em> に使用されるトークンは、キーワードではなく識別子で、
<em>layout-qualifier-id</em> としてキーワード <strong>shared</strong> を使用することができる。一般的に、これらはどのような順序でも並べてよい。順序に依存する意味は、下で明示されている場合に限り存在する。同様に、これらの識別子は、明示的に別段の記載がない限り、大文字と小文字を区別しない。</p>
<p>単一の宣言にレイアウト修飾子を複数含めることができる。また、同じ <em>layout-qualifier-name</em> が、一つのレイアウト修飾子の中で複数回現れたり、同じ宣言の中で複数のレイアウト修飾子にまたがって現れたりすることがある。同じ <em>layout-qualifier-name</em> が単一の宣言の中で複数回出現する場合、最後に出現したものがそれ以前に出現したものよりも優先される。さらに、このような <em>layout-qualifier-name</em> が後続の宣言やその他の観察可能な挙動に影響する場合、影響を与えるのは最後に出現するものだけであり、以前に出現したものは存在しないかのように振る舞う。これは <em>layout-qualifier-name</em> を上書きする場合にも当てはまり、一方が他方を上書き場合 (e.g. <code class="docutils literal notranslate"><span class="pre">row_major</span></code> vs. <code class="docutils literal notranslate"><span class="pre">column_major</span></code>) には、最後に出現するものだけが影響を及ぼす。</p>
<p><em>integer-constant-expression</em> は <a class="reference internal" href="note4.html#constant-expressions"><span class="std std-ref">4.3.3. Constant Expressions</span></a> で
<em>constant integral expression</em> として定義されており、
<em>integer-constant-expression</em> が特殊化定数であることはコンパイルエラーになる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>仕様書本文ではレイアウト修飾子の使用法の概要が表になって掲載されている。巨大なデータなので引用は控える。</p>
</div>
<section id="input-layout-qualifiers">
<h2>4.4.1. Input Layout Qualifiers<a class="headerlink" href="#input-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>計算シェーダーを除くすべてのシェーダーでは、入力変数宣言、入力ブロック宣言、入力ブロックメンバー宣言に対してレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">location</span></code> を使うことができる。このうち、変数とブロックメンバー（ブロックは不可）には、さらにレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> が使用できる。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">component</span></code> = <em>layout-qualifier-value</em></div>
</div>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="kt">int</span> <span class="kt">vec4</span> <span class="n">v</span><span class="p">;</span>
</pre></div>
</div>
<p>これにより、シェーダー入力の <code class="docutils literal notranslate"><span class="pre">normal</span></code> はベクトル位置番号 3 に、
<code class="docutils literal notranslate"><span class="pre">v</span></code> は位置番号 8 に割り当てられる。頂点シェーダー入力の場合、位置を入力値を取得する頂点属性の番号で指定する。他のすべてのシェーダー型の入力では、そのシェーダーが別のプログラムオブジェクト内にあったとしても、位置を以前のシェーダー段階からの出力との照合に使用できるベクトル番号で指定する。</p>
<p>続く言語では、特定の型で消費される位置の数を記述する。ただし、幾何シェーダー入力、多角形分割制御シェーダー入出力、多角形分割評価入力はすべて、他のシェーダー入出力に対して追加の配列レベルを持っている。この外側の配列レベルは、型が消費する位置の数を考慮する前に、型から取り除かれる。</p>
<p>Vulkan を対象にしている場合を除き、頂点シェーダー入力が任意のスカラーまたはベクトル型である場合、位置を一つを消費する。非頂点シェーダーの入力や Vulkan を対象にしている場合の段階入力が
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 以外のスカラー型やベクトル型の場合は、位置を一つを消費するが、
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 型の場合は連続した二つの位置を消費する。
<code class="docutils literal notranslate"><span class="pre">double</span></code> 型や <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> 型の入力は、段階すべてで一つの位置しか消費しない。</p>
<p>上述のように外側の配列レベルを削除した後、宣言された入力がサイズ n の配列で、各要素が m 個の位置を取る場合、指定された位置から始まる m × n 個の連続した位置が割り当てられる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</pre></div>
</div>
<p>これにより、シェーダーの入力色がベクトルの位置番号 6, 7, 8 に割り当てられることが確定する。</p>
<p>宣言された入力が n × m 行列の場合は、指定された位置から始まる複数の位置が割り当てられる。各行列に割り当てられる位置の数は、m 成分のベクトルの n 要素の配列と同じになる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">9</span><span class="p">)</span> <span class="k">in</span> <span class="kt">mat4</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>これにより、シェーダー入力 <code class="docutils literal notranslate"><span class="pre">transforms</span></code> がベクトルの 9～16番に割り当てられる：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transforms[0]</span></code> が 9, 10, 11, 12 番に、</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">transforms[1]</span></code> が 13, 14, 15, 16 番に</p></li>
</ul>
<p>割り当てられる。</p>
<hr class="docutils" />
<p>宣言された入力が構造体やブロックの場合、そのメンバーには宣言順に連続した位置が割り当てられ、最初のメンバーにはレイアウト修飾子で指定された位置が割り当てられる。構造体の場合、この処理は構造体全体に適用される。
<code class="docutils literal notranslate"><span class="pre">layout</span></code> 修飾子を構造体のメンバーに使用するとコンパイルエラーとなる。ブロックの場合、この処理はブロック全体に適用される。つまり <code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子を持つ最初のメンバーに到達するまで適用される。</p>
<p>ブロックのメンバーが <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子付きで宣言されている場合、そのメンバーの位置はその修飾子に由来し、メンバーの <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子がブロックレベルの宣言よりも優先される。後続のメンバーには、次の <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子が宣言されたメンバーまで、最新の位置に基づいて連続した位置が再び割り当てられる。位置に使用される値は、昇順に宣言する必要はない。</p>
<p>ブロックレベルの <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子がないブロックでは、そのメンバーのすべてが <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子を持つか、またはそれを一つも持たないことが要求される。さもないとコンパイルエラーとなる。配列として宣言されたブロックには <code class="docutils literal notranslate"><span class="pre">location</span></code> がブロックレベルでしか適用できないものがある。ブロックが配列として宣言されていて、ブロックの配列要素ごとに各メンバーに追加の位置が必要な場合、ブロックのメンバーに位置を指定するとコンパイルエラーになる。つまり、ブロックメンバー上に位置を適用することで指定不足になる場合、それは認められない。配列されたインターフェイス（一般にインターフェイスの拡張により余計な配列を持つもの）では、この規則を適用する前に外側の配列が取り除かれる。</p>
<p>ブロックや構造体のメンバーが消費する位置は、構造体のメンバーが同じ型の入力変数として宣言されているかのように、上記の規則を再帰的に適用して決定される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">vec3</span> <span class="n">a</span><span class="p">;</span>                      <span class="c1">// gets location 3</span>
    <span class="kt">mat2</span> <span class="n">b</span><span class="p">;</span>                      <span class="c1">// gets locations 4 and 5</span>
    <span class="kt">vec4</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>                   <span class="c1">// gets locations 6 and 7</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="kt">vec2</span> <span class="n">A</span><span class="p">;</span> <span class="c1">// ERROR, can&#39;t use on struct member</span>
<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">in</span> <span class="n">block</span>
<span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">d</span><span class="p">;</span>                      <span class="c1">// gets location 4</span>
    <span class="kt">vec4</span> <span class="n">e</span><span class="p">;</span>                      <span class="c1">// gets location 5</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">7</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// gets location 7</span>
    <span class="kt">vec4</span> <span class="n">g</span><span class="p">;</span>                      <span class="c1">// gets location 8</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">h</span><span class="p">;</span> <span class="c1">// gets location 1</span>
    <span class="kt">vec4</span> <span class="n">i</span><span class="p">;</span>                      <span class="c1">// gets location 2</span>
    <span class="kt">vec4</span> <span class="n">j</span><span class="p">;</span>                      <span class="c1">// gets location 3</span>
    <span class="kt">vec4</span> <span class="n">k</span><span class="p">;</span>                      <span class="c1">// ERROR, location 4 already used</span>
<span class="p">};</span>
</pre></div>
</div>
<p>シェーダーが利用できる入力位置の数には制限がある。頂点シェーダーでは、その制限は公示された頂点属性の数だ。その他のシェーダーでは、制限は実装に依存し、公示された最大入力成分数の
1/4 以上でなければならない。</p>
<p>取り付けられたシェーダーが対処されている個数を超える位置を使用している場合、デバイス依存最適化がプログラムに利用可能なハードウェア資源内に収まるようにさせない限り、プログラムはリンクに失敗する。</p>
<p>明示的な位置割り当てにより、リンカーが他の明示的割り当てのない変数のための空間を見つけられない場合、プログラムはリンクに失敗する。</p>
<p>非頂点入力が以前のシェーダー段階の出力と一致するかどうかを判断するためには、
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子がもしあれば一致していなければならない。</p>
<p>シェーダーテキストに位置が割り当てられていない頂点シェーダー入力変数に
OpenGL API で指定された位置がある場合は、その指定位置が使用される。そうでなければ、そのような変数はリンカーによって場所が割り当てられる。入力変数が同じ言語の複数のシェーダーで宣言されていて、位置が競合している場合、リンクエラー。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> を使用すると、スカラーやベクトルの位置をより細かく指定することができ、消費される位置内の個々の成分まで指定することができる修飾子 <code class="docutils literal notranslate"><span class="pre">location</span></code> を指定せずに <code class="docutils literal notranslate"><span class="pre">component</span></code> を使用すると、コンパイルエラーになる（順序は重要でない）。位置内の成分は 0, 1, 2, 3 だ。成分 N で始まる変数やブロックメンバーは、そのサイズまでの成分 N, N+1, N+2, …を消費する。この成分の並びが 3 より大きくなると、コンパイルエラーになる。スカラー <code class="docutils literal notranslate"><span class="pre">double</span></code> はこれらの成分のうち二つを消費し、
<code class="docutils literal notranslate"><span class="pre">dvec2</span></code> はある位置で利用可能な四つの成分全てを消費する。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> は成分指定なしでしか宣言できない。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> は一つ目の位置の四つの成分と、二つ目の位置の成分 0 と 1 をすべて消費する。これにより、成分 2 と 3 は他の成分修飾された宣言に使用できる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// a consumes components 2 and 3 of location 4</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">a</span><span class="p">;</span>

<span class="c1">// b consumes component 1 of location 4</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">// ERROR: c overflows component 3</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">c</span><span class="p">;</span>

<span class="c1">// d consumes components 2 and 3 of location 5</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>

<span class="c1">// ERROR: e overflows component 3 of location 6</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">dvec2</span> <span class="n">e</span><span class="p">;</span>

<span class="c1">// ERROR: f overlaps with g</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">double</span> <span class="n">f</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">float</span> <span class="n">g</span><span class="p">;</span>

<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="k">in</span> <span class="kt">dvec3</span> <span class="n">h</span><span class="p">;</span> <span class="c1">// components 0,1,2 and 3 of location 8</span>
                                 <span class="c1">// and components 0 and 1 of location 9</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// okay, compts 2 and 3</span>
</pre></div>
</div>
<p>変数が配列の場合、配列の各要素は順番に連続した位置に割り当てられるが、各位置の中ですべて同じ指定された成分になる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// component 3 in 6 locations are consumed</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">d</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</pre></div>
</div>
<p>この場合、位置 2 の成分 3 は <code class="docutils literal notranslate"><span class="pre">d[0]</span></code> を、位置 3 の成分 3 は <code class="docutils literal notranslate"><span class="pre">d[1]</span></code> を、…位置 7 の成分 3 に <code class="docutils literal notranslate"><span class="pre">d[5]</span></code> を格納する。</p>
<p>これにより二つの配列を同じ位置にまとめることができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// e consumes beginning (components 0, 1 and 2) of each of 6 slots</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">e</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

<span class="c1">// f consumes last component of the same 6 slots</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">f</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</pre></div>
</div>
<p>これを配列の配列に適用する場合は、すべてのレベルの配列性が取り除かれ、指定された成分に位置ごとに割り当てられた要素になる。これらの非配列要素は <a class="reference internal" href="note4.html#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> が指定する順序で配列の配列に対する位置を埋める。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> を行列、構造体、ブロック、またはこれらを含む配列に適用するとコンパイルエラーになる。
<code class="docutils literal notranslate"><span class="pre">component</span></code> 1 または 3 を <code class="docutils literal notranslate"><span class="pre">double</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> の先頭に使用するとコンパイルエラーになる。プログラム内で同じ変数に異なる成分を指定すると、リンクエラーになる。</p>
<hr class="docutils" />
<p><strong>位置エイリアシング</strong> (location aliasing) とは、二つの変数やブロックメンバーに同じ位置番号を持たせることだ。
<strong>成分エイリアシング</strong> (component aliasing) とは、二つの位置エイリアスに同じ（つまり重複する）成分番号を割り当てることだ（
<code class="docutils literal notranslate"><span class="pre">component</span></code> を使用しない場合は 0 から始まる成分が割り当てられることを思い出せ）。一つの例外を除いて、位置エイリアシングは成分エイリアシングを起こさない場合に限り許される。さらに、位置エイリアシングを行う場合、その位置を共有するエイリアスは、内在する数値型とビット幅が同じでなければならず、補助格納修飾子と補間修飾子も同じでなければならない。成分エイリアシングが許可される例外とは、頂点シェーダーへの二つの入力変数（ブロックメンバーではない）に対して OpenGL を対象にする場合で、これらは成分エイリアシングが許されている。この頂点変数の成分エイリアシングは、各実行パスがエイリアシングされた各成分ごとに高々一つの入力にアクセスする頂点シェーダーをサポートすることしか目的としていない。頂点シェーダー実行形式を通るすべての実行パスが、任意の単一成分にエイリアスされた複数の入力にアクセスすることを検出した場合、実装はこれをリンクタイムエラーとすることが許されているが、必須ではない。</p>
<section id="tessellation-evaluation-inputs">
<h3>Tessellation Evaluation Inputs<a class="headerlink" href="#tessellation-evaluation-inputs" title="Permalink to this headline">¶</a></h3>
<p>多角形分割評価シェーダーで使える追加的な入力レイアウト修飾子の識別子は次の通り：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>primitive-mode</em></div>
<div class="line"><em>vertex-spacing</em></div>
<div class="line"><em>ordering</em></div>
<div class="line"><em>point-mode</em></div>
</div>
</div>
<p>識別子 <em>primitive-mode</em> は多角形分割基本形状生成器が使用する。</p>
<div class="line-block">
<div class="line"><em>primitive-mode</em>:</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">quads</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">isolines</span></code></div>
</div>
</div>
<p><em>primitive-mode</em> がもしあれば、多角形分割基本形状生成器は三角形をより小さな三角形に、四角形を三角形に、四角形を線の集合体にそれぞれ細分するべきだと指定する。</p>
<p>レイアウト識別子の二番目のグループである頂点間隔は、多角形分割基本形状生成器が辺を細分化する際の間隔を指定するために用いられる。</p>
<div class="line-block">
<div class="line"><em>vertex-spacing</em>:</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">equal_spacing</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">fractional_even_spacing</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">fractional_odd_spacing</span></code></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">equal_spacing</span></code> は辺を同じ大きさのセグメントの集まりに分割することを指定する。</p>
<p><code class="docutils literal notranslate"><span class="pre">fractional_even_spacing</span></code> は、辺を偶数個の同じ長さのセグメントとさらに二つのより短い「小数」のセグメントに分割することを指定する。</p>
<p><code class="docutils literal notranslate"><span class="pre">fractional_odd_spacing</span></code> は、辺を奇数個の同じ長さのセグメントとさらに二つのより短い「小数」セグメントに分割することを指定する。</p>
<p>三番目のレイアウト識別子である <em>ordering</em> は、多角形分割基本形状生成器が、
OpenGL 仕様にある座標系に従い、時計回りまたは反時計回りのどちらの順序で三角形を生成するのかを指定する。</p>
<div class="line-block">
<div class="line"><em>ordering</em>:</div>
<div class="line-block">
<div class="line">cw</div>
<div class="line">ccw</div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">cw</span></code> と <code class="docutils literal notranslate"><span class="pre">ccw</span></code> は、それぞれ時計回りと反時計回りの三角形を示す。多角形分割基本形状生成器が三角形を生成しない場合、この順序は無視される。</p>
<p>最後の <em>point-mode</em> は、多角形分割基本形状生成器が、線や三角形を生成するのではなく、細分化された基本形状のそれぞれの紛れのない頂点に対して一点を生成するべきであることを示す。</p>
<div class="line-block">
<div class="line"><em>point-mode</em>:</div>
<div class="line-block">
<div class="line">point_mode</div>
</div>
</div>
<hr class="docutils" />
<p>これらの識別子は、単一の入力レイアウト宣言の中で、一回またはそれ以上指定することができる。プログラムの多角形分割評価シェーダーの中で、
<em>primitive-mode</em>, <em>vertex-spacing</em>, <em>ordering</em> が複数回宣言されている場合、そのような宣言はすべて同じ識別子を使用しなければならない。</p>
<p>プログラム内の少なくとも一つの多角形分割評価シェーダー（コンパイル単位）は、その入力レイアウトで <em>primitive-mode</em> を宣言しなければならない。
<em>vertex-spacing</em>, <em>ordering</em>, <em>point_mode</em> 識別子の宣言はオプションだ。プログラム内の多角形分割評価シェーダーすべてが <em>primitive_mode</em> を宣言するということは必須ではない。
<em>vertex-spacing</em> や <em>ordering</em> の宣言が省略された場合、多角形分割基本形状生成器は、それぞれ等間隔または反時計回りの頂点順序を採用する。
<em>point-mode</em> の宣言が省略された場合、多角形分割基本形状生成器は、
<em>primitive-mode</em> に従って線分または三角形を生成する。</p>
</section>
<section id="geometry-shader-inputs">
<h3>Geometry Shader Inputs<a class="headerlink" href="#geometry-shader-inputs" title="Permalink to this headline">¶</a></h3>
<p>幾何シェーダー入力に対する追加のレイアウト修飾子識別子には、基本形状 (primitive) 識別子と呼び出し回数 (invocation count) 識別子がある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">points</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">lines</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">invocations</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">points</span></code>, <code class="docutils literal notranslate"><span class="pre">lines</span></code>, <code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code>, <code class="docutils literal notranslate"><span class="pre">triangles</span></code>, <code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code>
は、幾何シェーダーが受け付ける入力基本形状の種類を指定するためのもので、これらのうちただ一つを受け付ける。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、この入力基本形状のレイアウトを宣言しなければならず、プログラム内の幾何シェーダーすべての入力レイアウト宣言は同じレイアウトを宣言しなければならない。プログラム内のすべての幾何シェーダーが入力基本形状レイアウトを宣言することは必須ではない。</p>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">invocations</span></code> は、受けとった入力基本形状それぞれに対して幾何シェーダー実行形式が呼び出される回数を指定するために用いられる。回数の宣言はオプションだ。プログラム内のどの幾何シェーダーでも回数が宣言されていない場合、幾何シェーダーは入力基本形状それぞれに対して一度実行される。宣言されている場合は、すべての宣言で同じ回数を指定しなければならない。シェーダーが実装依存の最大値を超える呼び出し回数を指定したり、ゼロ以下の呼び出し回数を指定したりすると、コンパイルエラーとなる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">invocations</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>例えば上の宣言では、幾何シェーダーへの入力はすべて三角形であり、幾何シェーダーの実行形式は、処理される三角形ごとに 6 回実行される。</p>
<p>幾何シェーダー入力サイズなし配列宣言のすべてで、以前の入力基本形状レイアウト修飾子がある場合、サイズが変更される：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">points</span></code>: 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lines</span></code>: 2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code>: 4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangles</span></code>: 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code>: 6</p></li>
</ul>
<p>内在的に宣言された入力配列 <code class="docutils literal notranslate"><span class="pre">gl_in[]</span></code> は、任意の入力基本形状レイアウト宣言によってもサイズが決定される。そのため、式 <code class="docutils literal notranslate"><span class="pre">gl_in.length()</span></code> 式は上にある値を返す。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_in</span></code> などの内在的に宣言された入力、配列サイズを持たずに宣言された入力については、メソッド <code class="docutils literal notranslate"><span class="pre">length()</span></code> を使用する前か、配列サイズを知る必要のあるその他の配列使用の前にレイアウトを宣言しなければならない。</p>
<p>レイアウト宣言の配列サイズが、同じシェーダー内の入力変数の宣言で指定されている明示的な配列サイズすべてと一致しない場合はコンパイルエラーとなる。コンパイルエラーの例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// code sequence within one shader...</span>
<span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color1</span><span class="p">[];</span>     <span class="c1">// legal, size still unknown</span>
<span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="c1">// legal, size is 2</span>
<span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>    <span class="c1">// illegal, input sizes are inconsistent</span>
<span class="k">layout</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>     <span class="c1">// legal for Color2, input size is 2, matching Color2</span>
<span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color4</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>    <span class="c1">// illegal, contradicts layout of lines</span>
<span class="k">layout</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>     <span class="c1">// legal, matches other layout() declaration</span>
<span class="k">layout</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span> <span class="c1">// illegal, does not match earlier layout() declaration</span>
</pre></div>
</div>
<p>プログラム内の幾何シェーダーすべてにおいて、提供されたサイズのすべて（サイズ付き入力配列とレイアウトサイズ）が一致しない場合は、リンクエラーとなる。</p>
</section>
<section id="fragment-shader-inputs">
<h3>Fragment Shader Inputs<a class="headerlink" href="#fragment-shader-inputs" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> には以下のような追加的フラグメントレイアウト修飾子がある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code></div>
</div>
</div>
<p>OpenGL の <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> は既定ではウィンドウの座標は左下を原点とし、画素中心は半画素の座標にあるとしている。例えば、ウィンドウの左下端の画素に対しては <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> 座標 <code class="docutils literal notranslate"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></code> が返される。原点は <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> に <code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code> 修飾子を付けて再宣言することで変更することができ、
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の原点をウィンドウの左上に移動させ、
<code class="docutils literal notranslate"><span class="pre">y</span></code> はウィンドウの下に向かって値を大きくしていく。また、返される値は、<code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> によって、
<code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> の両方で半画素ずつずらすことができ、画素が整数のオフセットで中心に置かれているように見える。これは <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> で返される <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> の値が既定値が <code class="docutils literal notranslate"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></code> であるのに対し、
<code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> で <code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.0)</span></code> に移動する。</p>
<p>Vulkan を対象にする場合、<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の原点は左上で、画素中心は半画素座標に配置されていると仮定し、要求される。この原点を明示的に設定するには <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を <code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code>
識別子で再宣言する。</p>
<p>再宣言は次のように行う：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FragCoord</span><span class="p">;</span> <span class="c1">// redeclaration that changes nothing is allowed</span>

<span class="c1">// All the following are allowed redeclaration that change behavior</span>
<span class="k">layout</span><span class="p">(</span><span class="n">origin_upper_left</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FragCoord</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">pixel_center_integer</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FragCoord</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">origin_upper_left</span><span class="p">,</span> <span class="n">pixel_center_integer</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FragCoord</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> がプログラム内のいずれかのフラグメントシェーダーで再宣言された場合、そのプログラム内で <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を静的に使用しているすべてのフラグメントシェーダーで再宣言されなければならない。単一のプログラム内にあるフラグメントシェーダーすべてにおける <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code>
の再宣言はすべてが同じ修飾子の集合でなければならない。どのシェーダー内でも <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の最初の再宣言が
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> のどの使用の前にも現れなければならない。組み込み <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> はフラグメントシェーダーでしか事前に宣言されていないので、他のシェーダー言語で再宣言するとコンパイルエラーになる。</p>
<p><code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> 修飾子の両方とも、またはいずれか一方をつけて <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を再宣言しても
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord.x</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_FragCoord.y</span></code> にしか影響しない。ラスタライズ、座標変換、その他の API パイプラインや言語機能には影響しない。</p>
<p>フラグメントシェーダーでは、OpenGL 仕様書の 15.2.4 “Early Fragment Tests” に記載されているように、フラグメントシェーダーの実行前にフラグメントテストを行うことを要求するために、
<code class="docutils literal notranslate"><span class="pre">in</span></code> のみで次のレイアウト修飾子を使用することが許される（変数宣言では不可）：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line">early_fragment_tests</div>
</div>
</div>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">early_fragment_tests</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>例えば上の宣言では、フラグメントシェーダーの実行前にフラグメントごとのテストが行われるようになる。これを宣言しない場合は、フラグメントシェーダーの実行後にフラグメントごとのテストが行われる。この宣言が必要となるのは、一つのフラグメントシェーダー（コンパイル単位）だけだが、複数のフラグメントシェーダーが宣言することもできる。少なくとも一つがこれを宣言していれば有効になる。</p>
</section>
<section id="compute-shader-inputs">
<h3>Compute Shader Inputs<a class="headerlink" href="#compute-shader-inputs" title="Permalink to this headline">¶</a></h3>
<p>計算シェーダー入力にはレイアウト位置修飾子がない。</p>
<p>計算シェーダー入力に対するレイアウト修飾子の識別子は、作業グループサイズ修飾子だ：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_x</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_y</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">local_size_x</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_y</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> 各修飾子は、それぞれ 1, 2, 3 次元の計算シェーダーによる固定作業グループのサイズを宣言するために用いられる。シェーダーが次元のサイズをここから指定していない場合、その次元は 1 となる。</p>
<p>例えば、計算シェーダーで次のように宣言した場合、</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>作業グループサイズが 32×32 要素の二次元計算シェーダーを宣言するために用いられる。これは、3次元目のサイズが 1 である三次元計算シェーダーに相当する。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>上の一文は何を言っているのか。</p>
</div>
<p>もう一つ別の例として、次の宣言は、一次元の計算シェーダーがコンパイルされており、そのサイズが実質的には 8 要素であることを指定している：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>いずれかの次元におけるシェーダーの固定作業グループサイズがゼロ以下、または実装でサポートされる最大サイズよりも大きい場合、コンパイルエラー。また、このようなレイアウト修飾子が同一シェーダー内で複数回宣言されている場合、それらの宣言はすべて同じ作業グループサイズの集合を設定し、同じ値を設定しなければならない。さもなければコンパイルエラー。単一のプログラムオブジェクトに取り付けられた複数の計算シェーダーが固定作業グループサイズを宣言する場合、その宣言は同一でなければならない。さもなければリンクエラー。</p>
<p>さらに、プログラムオブジェクトが計算シェーダーを何か含む場合、少なくとも一つはプログラムの固定作業グループサイズを指定する入力レイアウト修飾子を含まなければならない。さもなければリンクエラー。</p>
</section>
</section>
<section id="output-layout-qualifiers">
<h2>4.4.2. Output Layout Qualifiers<a class="headerlink" href="#output-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>出力レイアウト修飾子には、シェーダー段階すべてに適用されるものと、特定の段階にしか適用されないものがある。ここでは前者を議論する。</p>
<p>入力レイアウト修飾子と同様に、計算シェーダーを除くすべてのシェーダーでは、出力変数宣言、出力ブロック宣言、出力ブロックメンバー宣言に対して <code class="docutils literal notranslate"><span class="pre">location</span></code>
レイアウト修飾子を許す。このうち、変数とブロックメンバー（ブロックは不可）には、さらに <code class="docutils literal notranslate"><span class="pre">component</span></code> レイアウト修飾子を許す。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">component</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>ブロックや構造体に <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子や <code class="docutils literal notranslate"><span class="pre">component</span></code> 修飾子を適用する際の使い方や規則は <a class="reference internal" href="note4.html#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a> のとおりだ。また、フラグメントシェーダーの出力では、二つの変数が同じ位置に配置される場合、それらの変数の内容される型は同じでなければならない（浮動小数点・整数）。出力変数やメンバーの成分エイリアスは許されない。</p>
<p>フラグメントシェーダーでは <code class="docutils literal notranslate"><span class="pre">index</span></code> 出力レイアウト修飾子を追加的に付けられる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">index</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらの修飾子は、それぞれ高々一度現れる。
<code class="docutils literal notranslate"><span class="pre">index</span></code> が指定された場合 <code class="docutils literal notranslate"><span class="pre">location</span></code> も指定しなければならない。
<code class="docutils literal notranslate"><span class="pre">index</span></code> が指定されていない場合は値 0 が使用される。</p>
<p>例えば次のフラグメントシェーダーでは、フラグメントシェーダー出力色を混合方程式の最初（インデックス 0）の入力としてフラグメントカラー 3 に割り当てる設定をする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">color</span><span class="p">;</span>
</pre></div>
</div>
<p>次の例は、フラグメントシェーダーの出力係数が、混合方程式の 2 番目（インデックス 1）の入力としてフラグメント色 3 に割り当てる設定をする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">factor</span><span class="p">;</span>
</pre></div>
</div>
<p>フラグメントシェーダーの出力では、位置とインデックスは、出力の値を受け取る色出力番号とインデックスを指定する。他のすべてのシェーダー段階の出力では、位置は、後続のシェーダー段階の入力と照合するために使用できるベクトル番号を指定する（シェーダーが別のプログラムオブジェクトにある場合も同様）。</p>
<p>宣言された出力が <code class="docutils literal notranslate"><span class="pre">dvec3</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 以外のスカラーまたはベクトル型である場合は、単一の位置を消費する。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 型の出力は連続した二つの場所を消費する。
<code class="docutils literal notranslate"><span class="pre">double</span></code> 型や <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> 型の出力は全ての段階で一つの位置しか消費しない。</p>
<p>宣言された出力が配列の場合は、指定された場所から連続した場所が割り当てられる。例えば、次の宣言ではベクトルの位置番号 2, 3, 4 に <code class="docutils literal notranslate"><span class="pre">colors</span></code> が割り当てられる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</pre></div>
</div>
<p>宣言された出力が n×m の行列の場合、指定された位置から始まる複数の位置が割り当てられる。割り当てられる場所の数は m 成分ベクトルの n 要素の配列と同じだ。</p>
<p>宣言された出力が構造体の場合、そのメンバーには宣言された順に連続した場所が割り当てられ、構造体に指定された場所が最初のメンバーに割り当てられる。構造体のメンバーが消費する位置の個数は、その構造体のメンバーが同じ型の出力変数として宣言されているかのように、前述の規則が再帰的に適用される。</p>
<p><code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子は、構造体として宣言された出力変数に使用することができる。ただし、構造体メンバーに <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子を使用するとコンパイルエラーとなる。
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子は出力ブロックと出力ブロックメンバーに使用できる。</p>
<p>シェーダーで使用できる出力位置の数は限界がある。フラグメントシェーダーでは、その限界は公表されたドローバッファー数だ。</p>
<p>その他のシェーダーの場合、制限は実装依存であり、公表されている最大出力成分数の
1/4 以上でなければならない（計算シェーダーには出力がない）。取り付けられたシェーダーがサポートされている個数以上の位置を使用している場合、デバイス依存最適化によってプログラムが利用可能なハードウェア資源内に収まるようにしない限り、プログラムはリンクに失敗する。</p>
<p>また、コンパイル時にリンクが失敗することがわかっている場合には、コンパイルエラーがあり得る。出力位置が負の場合は、コンパイルエラーになる。フラグメントシェーダーがレイアウトインデックスを 0 未満または 1 以上に設定した場合も、コンパイルエラーとなる。</p>
<p>次のいずれかが発生すると、コンパイルエラーまたはリンクエラー：</p>
<ul class="simple">
<li><p>フラグメントシェーダーの出力変数の二つが両者とも同じ位置とインデックスに割り当てられている。</p></li>
<li><p>同じ（頂点｜多角形分割｜幾何）シェーダー段階からの出力変数二つが同じ位置に割り当てられている。</p></li>
</ul>
<p>フラグメントシェーダー出力では <code class="docutils literal notranslate"><span class="pre">layout</span></code> 修飾子または OpenGL API を使用して位置を割り当てることができる。</p>
<p>すべてのシェーダー型において、明示的な位置の割り当てが明示的な割り当てのない他の変数のための空間をリンカーに見つけさせられなくなる場合、プログラムはリンクに失敗する。</p>
<p>シェーダーテキストで位置やインデックスが割り当てられていない出力変数が
OpenGL API を通じて位置を指定されている場合は API で指定された位置が採用される。それ以外の場合は、リンカーがそのような変数に場所を割り当てる。このような割り当てはすべて、色インデックスがゼロになる。詳細は、OpenGL 仕様書の 15.2 “Shader Execution” を参照。出力変数が同じ言語の複数のシェーダで宣言されており、位置やインデックスの値が衝突している場合、リンクエラーが発生する。</p>
<p>フラグメントではない出力が後続のあるシェーダー段階からの入力と一致するかどうかを判定するために、
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子が（もしあれば）一致しなければならない。</p>
<section id="transform-feedback-layout-qualifiers">
<h3>Transform Feedback Layout Qualifiers<a class="headerlink" href="#transform-feedback-layout-qualifiers" title="Permalink to this headline">¶</a></h3>
<p>頂点、多角形分割、幾何各段階では、シェーダーが変換反響を制御することができる。それをするときに、シェーダーはどの変換反響バッファーを使用するか、どの出力変数をどのバッファーに書き込むか、各バッファーをどのようにレイアウトするかを決定する。これを実現するために、シェーダでは出力宣言に次のレイアウト修飾子識別子を使用できる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらの <code class="docutils literal notranslate"><span class="pre">xfb_</span></code> 修飾子を（前処理後に）静的に使用するシェーダーは、変換反響捕捉モードとなり、変換反響の設定を記述する責任が生じる。このモードでは <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で選択された出力を、直接または間接的に、変換反響バッファーに取り込むことになる。</p>
<p>Shaders in the transform feedback capturing mode have an initial global default of
<code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で選択された出力をどの変換反響バッファーに取り込むかは
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子が指定する。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子、出力変数、出力ブロック、出力ブロックメンバーのどれにでも適用できる。変換反響捕捉モードのシェーダーには次の初期の大域既定がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>
</pre></div>
</div>
<p>この既定を変更するには、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> に <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> をつけて別のバッファーを宣言する。これが大域既定を変更する唯一の方法だ。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子を付けずに変数や出力ブロックを宣言した場合は、大域既定バッファーを継承する。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子をつけて変数や出力ブロックを宣言すると、その宣言されたバッファーを持る。あるブロックのメンバーすべてがそのブロックのバッファーを継承する。メンバーは <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> を宣言することができるが、そのバッファーはそのブロックから継承されたバッファーと一致しなければならない。そうでなければコンパイルエラー。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">xfb_offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="k">out</span> <span class="n">block</span> <span class="p">{</span> <span class="c1">// block&#39;s buffer is 2</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// okay, matches the inherited 2</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">u</span><span class="p">;</span> <span class="c1">// ERROR, mismatched buffer</span>
    <span class="kt">vec4</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// inherited</span>
<span class="p">};</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">t</span><span class="p">;</span>  <span class="c1">// initial default is buffer 0</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>          <span class="c1">// new global default of 1</span>
<span class="k">out</span> <span class="n">block</span> <span class="p">{</span>                        <span class="c1">// block has buffer 1</span>
    <span class="kt">vec4</span> <span class="n">x</span><span class="p">;</span>                        <span class="c1">// x has buffer 1 (not captured)</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// okay (not captured)</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// ERROR, mismatched buffer</span>
<span class="p">};</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">g</span><span class="p">;</span>   <span class="c1">// g has buffer 1</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">h</span><span class="p">;</span>   <span class="c1">// does not change global default</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">j</span><span class="p">;</span>  <span class="c1">// j has buffer 1</span>
</pre></div>
</div>
<p>これが意味するのは、ブロックのメンバーのうち、変換反響バッファーに行くものはすべて同じバッファーに行くということだ。</p>
<p>ブロックが配列として宣言されている場合、ブロックの配列要素 0 のメンバーすべては、前述のように、宣言または継承された <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> に取り込まれる。一般に、ブロックの大きさ N の配列は、N 個の連続したバッファに取り込まれ、ブロックの配列要素 E のメンバーすべては、バッファ B に取り込まれる。ここで、B は宣言または継承された <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> に E を加えたものに等しくなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> には、ブロックの配列を捕捉するために必要な追加のバッファーを含めて、
0 より小さいか、実装依存の定数 <code class="docutils literal notranslate"><span class="pre">gl_MaxTransformFeedbackBuffers</span></code> 以上の値を指定すると、コンパイルエラーかリンクエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> は、変換反響バッファー内のバイトオフセットを割り当てる。
<code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> をつけることができるのは、変数、ブロックメンバー、またはブロックしかない。ブロックが <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾されていれば、そのブロックのメンバーすべてに変換反響バッファー内のオフセットが割り当てられる。ブロックが <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾されていない場合、そのようなブロックのメンバーには変換反響バッファーのオフセットは割り当てられない。オフセットが割り当てられた変数やブロックメンバーだけが捕捉される（つまり、ブロックの適切な部分集合が捕捉される）。このような変数やブロックメンバーがシェーダー内で書き込まれるたびに、書き込まれた値は割り当てられたオフセットで捕捉される。シェーダーの呼び出し時の間にこのようなブロックメンバーや変数が書き込まれない場合、割り当てられたオフセットでのバッファーの内容は未定義となる。変換反響オフセットが割り当てられている変数やメンバーへの静的な書き込みがない場合でも、その空間はバッファーに割り当てられ、ストライドに影響を与える。</p>
<p><code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾された変数やブロックメンバーには、スカラー、ベクトル、行列、構造体、およびこれらの（サイズ付き）配列を指定できる。このオフセットは、最初に修飾された変数やブロックメンバーの第一成分のサイズの倍数でなければならない。そうでなければコンパイルエラー。さらに、 <code class="docutils literal notranslate"><span class="pre">double</span></code> を含む集合体に適用される場合、オフセットもバッファーに取られる空間も 8 の倍数でなければならない。与えられたオフセットは、修飾されたエンティティの最初のメンバーの最初の成分に適用される。その後、修飾された実体中で、後続の成分はそれぞれその成分のサイズの倍数に整列した、次に利用可能なオフセットに順に割り当てられる。集約型は成分レベルまで平坦化され、この成分の並びが得られる。サイズなし配列の宣言に <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を適用するとコンパイルエラー。</p>
<p>出力バッファーのエイリアシングは許されない。変換反響オフセットが重なり合っている変数を指定するとコンパイルエラーまたはリンクエラー。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> は、捕捉した各頂点が何バイト消費するかを指定する。その宣言の変換反響バッファーが継承されているか、明示的に宣言されているかに関わらず、これが適用される。この修飾子は、変数、ブロック、ブロックメンバー、あるいは単に修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> にも適用できる。バッファーが倍精度成分を持つ出力を捕捉する場合、バッファー幅は 8 の倍数であるか、そうでない場合は 4 の倍数でなければならず、そうでない場合はコンパイルエラーかリンクエラー。
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> をオーバーフローさせるような <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を持つことは、
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> の前後の宣言であろうと、異なるコンパイル単位であろうと、コンパイルエラーかリンクエラー。
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> は、同じバッファーに対して複数回宣言することができるが、異なる値のストライドを指定するとコンパイルエラーかリンクエラー。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// buffer 1 has 32-byte stride</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xfb_stride</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>

<span class="c1">// same as previous example; order within layout does not matter</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_stride</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>

<span class="c1">// everything in this block goes to buffer 0</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mo">0</span><span class="p">,</span> <span class="n">xfb_stride</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">out</span> <span class="n">block1</span> <span class="p">{</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// a goes to byte offset 0 of buffer 0</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// b goes to offset 16 of buffer 0</span>
<span class="p">};</span>

<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span> <span class="k">out</span> <span class="n">block2</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">v</span><span class="p">;</span>  <span class="c1">// v will be written to byte offsets 12 through 27 of buffer</span>
    <span class="kt">float</span> <span class="n">u</span><span class="p">;</span> <span class="c1">// u will be written to offset 28</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">40</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">w</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// x will be written to offset 56, the next available offset</span>
<span class="p">};</span>

<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">xfb_stride</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">out</span> <span class="n">block3</span> <span class="p">{</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span> <span class="kt">vec3</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">24</span><span class="p">)</span> <span class="kt">vec3</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// ERROR, requires stride of 36</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">vec3</span> <span class="n">g</span><span class="p">;</span>  <span class="c1">// okay, increasing order not required</span>
<span class="p">};</span>
</pre></div>
</div>
<p>バッファーに <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> が指定されていない場合、バッファー幅は、最も高いオフセットに置かれた変数を保持するのに必要な最小値となり、必要な詰め物 (padding) も含まれる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// if there no other declarations for buffer 3, it has stride 32</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">out</span> <span class="n">block4</span> <span class="p">{</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">e</span><span class="p">;</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">f</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>結果のバッファー幅（暗黙的または明示的）を 4 で割って、実装依存の定数 <code class="docutils literal notranslate"><span class="pre">gl_MaxTransformFeedbackInterleavedComponents</span></code> 以下でなければならない。</p>
</section>
<section id="tessellation-control-outputs">
<h3>Tessellation Control Outputs<a class="headerlink" href="#tessellation-control-outputs" title="Permalink to this headline">¶</a></h3>
<p>変換反響レイアウト修飾子を除き、多角形分割制御シェーダーでは、出力ブロック、ブロックメンバー、または変数宣言ではなく、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> 上でのみ出力レイアウト修飾子を使用することができる。多角形分割制御シェーダーで使用できる出力レイアウト修飾子の識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">vertices</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">vertices</span></code> は多角形分割制御シェーダーが生成する出力パッチの頂点数を指定し、多角形分割制御シェーダーの呼び出し回数も指定します。出力頂点数がゼロ以下であったり、実装依存の最大パッチサイズより大きかったりすると、コンパイルエラーやリンクエラーとなる。</p>
<p>内在的に宣言された多角形分割制御出力配列 <code class="docutils literal notranslate"><span class="pre">gl_out[]</span></code> は、任意の出力レイアウト宣言によってもサイズが決定される。したがって、次の式は以前の出力レイアウト修飾子で指定された出力パッチの頂点数を返す：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="nb">gl_out</span><span class="p">.</span><span class="n">length</span><span class="p">()</span>
</pre></div>
</div>
<p>内在的に宣言された出力を含む、配列サイズなし宣言された出力については、メソッド <code class="docutils literal notranslate"><span class="pre">length()</span></code> の使用や、サイズを知る必要のある他の配列使用の前に、レイアウトを宣言しなければならない。</p>
<p>出力レイアウト修飾子で指定された出力パッチ頂点数が、同じシェーダー内の出力変数宣言で指定された配列サイズのどれとも一致しない場合は、コンパイルエラーとなる。</p>
<p>プログラム内のすべての多角形分割制御シェーダーのレイアウト宣言は、同じ出力パッチ頂点数を指定しなければならない。多角形分割制御シェーダーを含むプログラムには、出力パッチの頂点数を指定するレイアウト修飾子が少なくとも一つ必要だが、すべての多角形分割制御シェーダーでそのような宣言が必要ということではない。</p>
</section>
<section id="geometry-outputs">
<h3>Geometry Outputs<a class="headerlink" href="#geometry-outputs" title="Permalink to this headline">¶</a></h3>
<p>幾何シェーダーは、出力基本形状型、最大出力頂点数、出力ごとのストリーム番号の三種の出力レイアウト識別子を追加的に持てる。基本形状型と頂点数の識別子は、出力ブロック、ブロックメンバー、変数宣言ではなく、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code>
でしか許されない。ストリーム識別子は、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code>,
出力ブロック、変数宣言上で許される。</p>
<p>幾何シェーダー出力に対するレイアウト修飾子の識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">points</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">line_strip</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangle_strip</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">stream</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>基本形状型識別子の <code class="docutils literal notranslate"><span class="pre">points</span></code>, <code class="docutils literal notranslate"><span class="pre">line_strip</span></code>, <code class="docutils literal notranslate"><span class="pre">triangle_strip</span></code> は、幾何シェーダーが生成する出力基本形状の型を指定するために使用され、これらのうちただ一つが受け入れられる。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、出力基本形状型を宣言しなければならず、プログラム内のすべての幾何シェーダーの出力基本形状型宣言は、同じ基本形状型を宣言しなければならない。プログラム内のすべての幾何シェーダーが出力基本形状型宣言をすることは必須ではない。</p>
<p>頂点数識別子 <code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> は、シェーダーが単一の呼び出しで出力する最大の頂点数を指定するために使用される。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、最大出力頂点数を宣言しなければならず、プログラム内のすべての幾何シェーダーの出力頂点数宣言は、同じ回数を宣言しなければならない。プログラム内のすべての幾何シェーダーが回数を宣言することは必須ではありません。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">60</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span> <span class="c1">// order does not matter</span>
<span class="k">layout</span><span class="p">(</span><span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">60</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>  <span class="c1">// redeclaration okay</span>
<span class="k">layout</span><span class="p">(</span><span class="n">triangle_strip</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>     <span class="c1">// redeclaration okay</span>
<span class="k">layout</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>             <span class="c1">// error, contradicts triangle_strip</span>
<span class="k">layout</span><span class="p">(</span><span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">30</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>  <span class="c1">// error, contradicts 60</span>
</pre></div>
</div>
<p>この例では、幾何シェーダーからの出力はすべて三角形であって、シェーダーから出力されるのは高々 60 個の頂点だ。最大の頂点数が <code class="docutils literal notranslate"><span class="pre">gl_MaxGeometryOutputVertices</span></code> よりも大きい場合はエラーとなる。</p>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">stream</span></code> は、幾何シェーダーの出力変数またはブロックが、特定の頂点ストリーム（ゼロから始まる番号）に関連付けられていることを指定するために用いられる。ストリーム番号の既定値を、次の例のようにインターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> によって大域スコープで宣言することができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">stream</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>
</pre></div>
</div>
<p>このような宣言で指定されたストリーム番号は、それまでの既定値を置き換え、新しい既定値が設定されるまで、後続のすべてのブロックおよび変数の宣言に適用される。初期設定のストリーム番号はゼロだ。</p>
<p>各出力ブロックまたは非ブロック出力変数は、頂点ストリームに関連付けられる。ブロックまたは変数がストリーム識別子とともに宣言されている場合は、指定されたストリームに関連付けられ、そうでない場合は、現在の既定ストリームに関連付けられる。ブロックメンバーはストリーム識別子を付けて宣言することができるが、指定されたストリームは含まれるブロックに関連付けられたそれと一致しなければならない。例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>           <span class="c1">// default is now stream 1</span>
<span class="k">out</span> <span class="kt">vec4</span> <span class="n">var1</span><span class="p">;</span>                  <span class="c1">// var1 gets default stream (1)</span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">out</span> <span class="n">Block1</span> <span class="p">{</span>   <span class="c1">// &quot;Block1&quot; belongs to stream 2</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">var2</span><span class="p">;</span> <span class="c1">// redundant block member stream decl</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="kt">vec2</span> <span class="n">var3</span><span class="p">;</span> <span class="c1">// ILLEGAL (must match block stream)</span>
    <span class="kt">vec3</span> <span class="n">var4</span><span class="p">;</span>                  <span class="c1">// belongs to stream 2</span>
<span class="p">};</span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>           <span class="c1">// default is now stream 0</span>
<span class="k">out</span> <span class="kt">vec4</span> <span class="n">var5</span><span class="p">;</span>                  <span class="c1">// var5 gets default stream (0)</span>
<span class="k">out</span> <span class="n">Block2</span> <span class="p">{</span>                    <span class="c1">// &quot;Block2&quot; gets default stream (0)</span>
    <span class="kt">vec4</span> <span class="n">var6</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">var7</span><span class="p">;</span> <span class="c1">// var7 belongs to stream 3</span>
</pre></div>
</div>
<p>幾何シェーダーで出力された各頂点は、特定のストリームに割り当てられ、出力された頂点の属性は、対象となるストリームに割り当てられた出力ブロックと変数の集合から取得される。各頂点が放出された後、すべての出力変数の値は未定義となる。さらに、各頂点ストリームに関連する出力変数は、格納を共有してもよい。あるストリームに関連する出力変数に書き込むと、他のストリームに関連する出力変数が上書きされることがある。幾何シェーダーは、各頂点を放出する際に、その頂点が放出されるストリームに関連するすべての出力に書き込み、他のストリームに関連する出力には書き込まない。</p>
<p>幾何シェーダー出力ブロックや同変数が複数回宣言された場合、そのような宣言のすべてで、その変数は同じ頂点ストリームに関連付けられなければならない。存在しないストリーム番号を指定したストリーム宣言がある場合、シェーダーのコンパイルは失敗する。</p>
<p>組み込み幾何シェーダー出力は頂点ストリーム 0 に常に関連付けられる。</p>
<p>プログラム内のすべての幾何シェーダー出力レイアウト宣言は、同じレイアウトと同じ <code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> 値を宣言しなければならない。幾何シェーダーがプログラムに含まれている場合、そのプログラムのどこかに少なくとも一つの幾何出力レイアウト宣言がなければならないが、すべての幾何シェーダー（コンパイル単位）がそれを宣言する必要はない。</p>
</section>
<section id="fragment-outputs">
<h3>Fragment Outputs<a class="headerlink" href="#fragment-outputs" title="Permalink to this headline">¶</a></h3>
<p>組み込みフラグメントシェーダ変数 <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> は、次のレイアウト修飾子のいずれかを使用して再宣言することができる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_any</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_greater</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_less</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_unchanged</span></code></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> に対するレイアウト修飾子は、任意のシェーダー呼び出しによって書き込まれる
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値の意図を制約する。レイアウト修飾子に整合する <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のすべての値が失敗（合格）する場合には、与えられたフラグメントに対して奥行きテストが失敗（合格）すると仮定して最適化を行うことが GL 実装はできる。これには、フラグメントがさえぎられ、シェーダーに副作用がないために廃棄される場合に、シェーダーの実行を飛ばすことが含まれる可能性がある。
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値がそのレイアウト修飾子と整合しない場合、対応するフラグメントの奥行きテストの結果は未定義となる。しかし、この場合にはエラーとはならない。奥行きテストが合格し、奥行き書き込みが有効な場合、奥行きバッファーに書き込まれる値は、レイアウト修飾子と整合しているか否かに関わらず、常に <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の値となる。</p>
<p>既定では <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> は <code class="docutils literal notranslate"><span class="pre">depth_any</span></code> として修飾される。
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のレイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_any</span></code> の場合、シェーダーコンパイラーは <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> への割り当てが未知の方法で変更されていることに留意し、奥行きテストは常にシェーダーの実行後に行われる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_greater</span></code> の場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値が <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の <code class="docutils literal notranslate"><span class="pre">z</span></code> 成分で与えられるフラグメントの補間奥行き値以上であると仮定することができる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_less</span></code> の場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> を修正してもその値が減少するだけだと考えることができる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_unchanged</span></code> の場合、シェーダーコンパイラーは
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のいかなる修正も尊重するが、他の部分は <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code>
に新しい値が割り当てられていないと仮定することができる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の再宣言は以下のように行われる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// redeclaration that changes nothing is allowed +</span>
<span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>

<span class="c1">// assume it may be modified in any way</span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_any</span><span class="p">)</span> <span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>

<span class="c1">// assume it may be modified such that its value will only increase</span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_greater</span><span class="p">)</span> <span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>

<span class="c1">// assume it may be modified such that its value will only decrease</span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_less</span><span class="p">)</span> <span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>

<span class="c1">// assume it will not be modified</span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_unchanged</span><span class="p">)</span> <span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> がプログラム内のいずれかのフラグメントシェーダーで再宣言された場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> への静的割り当てを持つそのプログラム内のフラグメントシェーダーすべてで再宣言されなければならない。単一プログラム内のフラグメントシェーダーすべてにおける
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の再宣言のすべてが同じ修飾子の集合を持たなければならない。どのシェーダー内でも、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最初の再宣言がその使用よりも前に現れなければならない。組み込み <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> はフラグメントシェーダーでのみ事前宣言されているので、他のシェーダー言語で再宣言するとコンパイルエラーになる。</p>
</section>
</section>
<section id="uniform-variable-layout-qualifiers">
<h2>4.4.3. Uniform Variable Layout Qualifiers<a class="headerlink" href="#uniform-variable-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>レイアウト修飾子は、一様変数とサブルーチン一様に使用できる。一様変数とサブルーチン一様（変数）に対するレイアウト修飾子識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>位置識別子は、既定ブロック一様変数とサブルーチン一様（変数）で使用できる。位置は、API が一様を参照し、その値を更新するための位置を指定する。一様配列の個々の要素には連続した位置が割り当てられ、最初の要素は位置 <code class="docutils literal notranslate"><span class="pre">location</span></code> だ。プログラム内でリンクされた同じ位置を共有する既定ブロック一様変数宣言は、名前、型、修飾子、配列性が一致しなければならない。配列の場合は、配列の次元と配列のサイズが一致していなければならない。構造体の場合、この規則がメンバーすべてに再帰的に適用される。サブルーチン一様変数二つが同じシェーダー段階内で同じ位置に存在することはできない。コンパイルエラーかリンクエラーとなる。既定ブロック変数の有効な位置は、0 から実装定義の一様位置の最大数から 1 を引いた範囲にある。サブルーチン一様（変数）の有効な位置は、0 から実装定義の段階ごとのサブルーチン一様（変数）の最大位置数から 1 を引いた値までの範囲にある。</p>
<p>位置は既定ブロック一様配列や構造体に割り当てることができる。最も内側にある最初のスカラー、ベクトル、行列のメンバーや要素は指定された <code class="docutils literal notranslate"><span class="pre">location</span></code> を取り、コンパイラーは次の最も内側にあるメンバーや要素に次の増分の位置値を割り当てる。それ以降の最内側のメンバーや要素は、構造体や配列全体の増分の位置を取得します。この規則は、入れ子になった構造体や配列にも適用され、最も内側にあるスカラー、ベクトル、行列の各メンバーに一意の位置を与える。明示的サイズのない配列の場合は、静的な使用量に基づいてサイズが計算される。リンカーが明示的位置のない一様（変数）の位置を生成する場合、明示的位置のある一様（変数）すべてについて、その配列要素や構造体のメンバーがすべて使用されていると仮定し、その要素やメンバーが使用されていないと判断された場合でも、リンカーは競合する位置を生成しない。</p>
<p>個々の（既定ブロック）透明一様変数を受け入れる API に対する SPIR-V を生成するとき、それらを宣言するときに位置を含めないとコンパイルエラー。</p>
<p>Vulkan を対象にしている場合、修飾子 <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> はブロック全体を宣言するために使用され、
Vulkan API で定義されているように、定数 <code class="docutils literal notranslate"><span class="pre">push</span></code> の集合を表す。これを一様ブロック宣言以外に適用したり、Vulkan を対象にしていない場合はコンパイルエラー。ブロック内の値は Vulkan API の仕様に基づいて初期化される。
<code class="docutils literal notranslate"><span class="pre">layout(push_constant)</span></code> で宣言されたブロックは、オプションで <em>instance-name</em> を含めることができる。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> ブロックは段階ごとに一つだけで、そうでない場合はコンパイルエラーやリンクエラー。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> 配列は、動的一様なインデックスでしかインデックスを付けられない。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> で宣言された一様ブロックは、宣言されていないブロックとは異なる資源を使用し、別々に計上される。</p>
</section>
<section id="subroutine-function-layout-qualifiers">
<h2>4.4.4. Subroutine Function Layout Qualifiers<a class="headerlink" href="#subroutine-function-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>レイアウト修飾子をサブルーチン関数に使用できる。サブルーチン関数のレイアウト修飾子識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">index</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>シェーダー内でインデックス修飾子を持つ各サブルーチンには、一意のインデックスが与えられなければならない。そうでない場合はコンパイルエラーまたはリンクエラー。インデックスは 0 から実装定義のサブルーチン最大数から 1 を引いた範囲でなければならない。
OpenGL サブルーチン関数列挙 API がアクティブインデックスすべてに対して空ではない名前を返すように、シェーダーは 0 から始まる飛び飛びにならないインデックス値の範囲を割り当てることを推奨するが、必須ではない。</p>
</section>
<section id="uniform-and-shader-storage-block-layout-qualifiers">
<h2>4.4.5. Uniform and Shader Storage Block Layout Qualifiers<a class="headerlink" href="#uniform-and-shader-storage-block-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>レイアウト修飾子は一様およびシェーダー格納ブロックに使用できるが、非ブロック一様宣言には使用できない。一様およびシェーダー格納ブロックのレイアウト修飾子の識別子（および <code class="docutils literal notranslate"><span class="pre">shared</span></code>
キーワード）は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">shared</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">packed</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">std140</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">std430</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">row_major</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">column_major</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">offset</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">align</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらはいずれも、宣言されている変数の使用法に意味的な影響を全く与えず、メモリー内でのデータの配置方法を示すに過ぎない。例えば、行列のセマンティクスは、どのようなレイアウト修飾子が使用されていても、この仕様の他の部分で述べられたように、常に列に基づく。</p>
<p>（一様｜シェーダー格納）ブロックレイアウト修飾子は、大域スコープ、単一の（一様｜シェーダー格納ブロック｜ブロックメンバー）宣言上で宣言することができる。</p>
<p>一様ブロックには大域スコープでの既定レイアウトが次のように設定されている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">layout</span><span class="o">-</span><span class="n">qualifier</span><span class="o">-</span><span class="n">id</span><span class="o">-</span><span class="n">list</span><span class="p">)</span> <span class="k">uniform</span><span class="p">;</span>
</pre></div>
</div>
<p>シェーダー格納ブロックの場合には：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">layout</span><span class="o">-</span><span class="n">qualifier</span><span class="o">-</span><span class="n">id</span><span class="o">-</span><span class="n">list</span><span class="p">)</span> <span class="k">buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>これが行われると、直前の既定修飾がまず継承され、それから宣言にある各修飾について、以下に述べる上書き規則に従って上書きされる。その結果、後続の（一様｜シェーダー格納）ブロックの定義に適用される新しい既定修飾となる。</p>
<p>SPIR-V を生成する際のコンパイルの初期状態は、次のように宣言されたかのようなものだ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span> <span class="k">uniform</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">std430</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span> <span class="k">buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>ところが <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> を宣言すると、バッファーの既定レイアウトは
<code class="docutils literal notranslate"><span class="pre">std430</span></code> になる。この既定を大域的に設定する方法はない。</p>
<p>SPIR-V を生成していないときのコンパイルの初期状態は、次のように宣言されたかのようなものだ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span> <span class="k">uniform</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span> <span class="k">buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>（一様｜シェーダー格納）ブロックは、オプションでレイアウト修飾子を付けて宣言することができ、その個々のメンバー宣言も同様だ。このようなブロックレイアウト修飾は、ブロックの内容にのみ適用される。大域レイアウト宣言と同様に、ブロックレイアウト修飾は、まず現在の既定の修飾を継承し、次にそれを上書きする。同様に、個々のメンバーのレイアウト修飾は、メンバー宣言だけに適用され、ブロックの修飾を継承して上書きする。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">shared</span></code> は <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>, および <code class="docutils literal notranslate"><span class="pre">packed</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。コンパイラーかリンカーは、すべての配列が明示的なサイズで宣言され、すべての行列が一致する <code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子と
<code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子の両方を、または一方を（ブロック定義外の宣言から得られる場合もある）持つ限り、この定義を含む複数のプログラムおよびプログラム可能段階が、このブロックのために同じメモリーレイアウトを共有することを保証する。これにより、異なるプログラム間で同じバッファーを使用して同じブロック定義を
back することができる。
SPIR-Vを生成する際に <code class="docutils literal notranslate"><span class="pre">shared</span></code> を使用するとコンパイルエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">packed</span></code> は <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code> のみを上書きし、その他の修飾子は継承される。
<code class="docutils literal notranslate"><span class="pre">packed</span></code> を使用した場合、共有可能なレイアウトは保証されません。コンパイラーとリンカーは、どの変数が活発的に使用されるかや、その他の条件に基づいて、メモリー使用を最適化することができる。ブロック内のどこにどの変数があるかを保証する方法が他にないため、オフセットを問い合わせる必要がある。</p>
<p>プログラム内の複数の段階で同じ充満一様ブロックやシェーダー格納ブロックにアクセスするとリンクエラー。プログラム間で同じ充満一様ブロックやシェーダー格納ブロックにアクセスしようとすると、メンバーオフセットが衝突したり、未定義の値が読み込まれたりする可能性がある。しかし、実装では充満ブロックのための標準的なレイアウトを使用することで、充満ブロックのアプリケーション管理を支援することができる。
SPIR-V の生成時に <code class="docutils literal notranslate"><span class="pre">packed</span></code> 修飾子を使用するとコンパイルエラー。</p>
<p><code class="docutils literal notranslate"><span class="pre">std140</span></code> および <code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">packed</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">std140</span></code>,
<code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。
<code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子はシェーダー格納ブロックでのみサポートされている。一様ブロックに <code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子を使用したシェーダーは、それが <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> も修飾されていない限りコンパイルエラー。</p>
<p>OpenGL 仕様書の 7.6.2.2 項 “Standard Uniform Block Layout” に記載されているように、レイアウトはこれによって明示的に決定される。したがって、上記の <code class="docutils literal notranslate"><span class="pre">shared</span></code> と同様に、結果となるレイアウトはプログラムをまたがって共有可能だ。</p>
<p>メンバー宣言のレイアウト修飾子には <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">packed</span></code>, <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>
の各修飾子は使用できない。これらの修飾子は、（オブジェクトなし）大域スコープまたはブロック宣言でのみ使用でき、使用しない場合はコンパイルエラー。</p>
<p><code class="docutils literal notranslate"><span class="pre">row_major</span></code> および <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子は、構造体や配列に含まれるすべての行列を含むすべての入れ子の深さの行列のレイアウトにしか影響を与えない。これらの修飾子は他の型にも適用できるが、効果はない。</p>
<p><code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。行列の行内の要素は、メモリー内で連続している。</p>
<p><code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子よりも優先されるが、その他の修飾子は継承される。行列の列内の要素は、メモリー内で連続しています。</p>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子は（一様｜シェーダ格納）ブロックに対応する一様バッファー束縛点を指定し、ブロックのメンバー変数の値を取得するのに使用される。大域スコープやブロックメンバーの宣言に束縛修飾子を指定することはコンパイルエラーとなる。
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子を指定せずに宣言された（一様｜シェーダー格納）ブロックは、最初はブロック束縛点 0 に割り当てられる。プログラムがリンクされた後、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子の有無にかかわらず宣言された（一様｜シェーダー格納）ブロックに使用される束縛点は API によって更新することができる。</p>
<p>OpenGL で使用する場合、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が配列としてインスタンス化された一様ブロックやシェーダー格納ブロックで使用されると、配列の最初の要素は指定されたブロック束縛を取り、それ以降の各要素は次の連続した束縛点を取る。配列の配列では、要素それぞれ（例えば <code class="docutils literal notranslate"><span class="pre">a[2][3]</span></code> の場合は 6 要素）が束縛点を得て、
<a class="reference internal" href="note4.html#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> で説明した配列の配列の順序に従って順序付けられる。</p>
<p>Vulkan を対象にした場合、配列としてインスタンス化された一様ブロックやバッファーブロックで <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が使用されると、配列全体が提供された束縛番号のみを受け取る。次の連続した束縛番号を別のオブジェクトで利用できる。配列の配列の場合、記述子集合アクセスに使用される記述子集合配列要素の番号は、
<a class="reference internal" href="note4.html#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> で説明した配列の配列の順序に従って順序付けられる。</p>
<p>（一様｜シェーダー格納）ブロックインスタンスの束縛点がゼロより小さい場合、または対応する実装依存のバッファー束縛の最大数以上の場合は、コンパイルエラーとなる。（一様｜シェーダー格納）ブロックのインスタンスをサイズ N の配列として <code class="docutils literal notranslate"><span class="pre">binding</span></code>
修飾子を使用する場合、
<em>binding</em> から <em>binding</em> + N - 1 までの配列のすべての要素は、この範囲内に収まらなければならない。同じ束縛番号を複数の一様ブロックや複数のバッファーブロックに使用するとコンパイルエラーまたはリンクエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">set</span></code> は Vulkan を対象にしている場合に限り使用できる。このオブジェクトが属する記述子集合を指定する。独立した修飾子、ブロックメンバー、または記述子集合をサポートする API を対象にしていない場合に <code class="docutils literal notranslate"><span class="pre">set</span></code> を適用するとコンパイルエラー。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> 修飾されたブロックに <code class="docutils literal notranslate"><span class="pre">set</span></code> を適用するとコンパイルエラー。既定では <code class="docutils literal notranslate"><span class="pre">set</span></code> 識別子なしで宣言された非 <code class="docutils literal notranslate"><span class="pre">push-constant</span></code>
（一様｜シェーダー格納）ブロックは、記述子集合 0 に割り当てられる。同様に、
<code class="docutils literal notranslate"><span class="pre">set</span></code> 識別子なしで一様として宣言された採取器、テクスチャー、またはサブパス入力型も、記述子集合 0 に割り当てられる。</p>
<p>配列として宣言されたオブジェクトに適用された場合、その配列のすべての要素は、指定された <code class="docutils literal notranslate"><span class="pre">set</span></code> に属する。</p>
<p>SPIR-V を生成する際に <code class="docutils literal notranslate"><span class="pre">set</span></code> または <code class="docutils literal notranslate"><span class="pre">binding</span></code> の値がフロントエンド構成で指定された最大値を超えるとコンパイルエラーとなる。</p>
<p>一つのレイアウト宣言に複数の引数がリストされている場合、左から右の順に一つずつ宣言されたのと同じ効果が得られる。それぞれが前の修飾の結果を引き継いで上書きする。例えば、次の例は <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾になる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">row_major</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span>
</pre></div>
</div>
<p>さらなる例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span> <span class="n">row_major</span><span class="p">)</span> <span class="k">uniform</span><span class="p">;</span> <span class="c1">// default is now shared and row_major</span>

<span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">Transform</span> <span class="p">{</span> <span class="c1">// layout of this block is std140</span>
    <span class="kt">mat4</span> <span class="n">M1</span><span class="p">;</span>                       <span class="c1">// row major</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">column_major</span><span class="p">)</span> <span class="kt">mat4</span> <span class="n">M2</span><span class="p">;</span>  <span class="c1">// column major</span>
    <span class="kt">mat3</span> <span class="n">N1</span><span class="p">;</span>                       <span class="c1">// row major</span>
<span class="p">};</span>

<span class="k">uniform</span> <span class="n">T2</span> <span class="p">{</span>                       <span class="c1">// layout of this block is shared</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">layout</span><span class="p">(</span><span class="n">column_major</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">T3</span> <span class="p">{</span>  <span class="c1">// shared and column major</span>
    <span class="kt">mat4</span> <span class="n">M3</span><span class="p">;</span>                       <span class="c1">// column major</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">row_major</span><span class="p">)</span> <span class="kt">mat4</span> <span class="n">m4</span><span class="p">;</span>     <span class="c1">// row major</span>
    <span class="kt">mat3</span> <span class="n">N2</span><span class="p">;</span>                       <span class="c1">// column major</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Vulkan を対象にしている場合、ブロックおよびブロックメンバーの
<code class="docutils literal notranslate"><span class="pre">offset</span></code> および <code class="docutils literal notranslate"><span class="pre">align</span></code> 修飾子は、一様ブロックおよびバッファーブロックに限り使用できる。
Vulkan を対象にしていない場合、これらの修飾子は <code class="docutils literal notranslate"><span class="pre">std140</span></code> または <code class="docutils literal notranslate"><span class="pre">std430</span></code>
レイアウトで宣言されたブロックに限り使用できる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">offset</span></code> はブロックメンバーに限り使用できる。修飾子 <code class="docutils literal notranslate"><span class="pre">offset</span></code> は、修飾されたメンバーを指定された <em>layout-qualifier-value</em>
（バッファーの先頭からのバイトオフセット）以降に強制的に開始させる。ブロックの他のメンバー内にあるオフセットを明示的または代入的に持たせるとコンパイルエラーとなる。
SPIR-V を生成しない場合、ブロック内の直前のメンバーのオフセットよりも小さいオフセットを指定するとコンパイルエラーとなる。同じプログラム内で同じブロック名でリンクされた二つのブロックは、
<code class="docutils literal notranslate"><span class="pre">offset</span></code> で修飾されたメンバーの集合が全く同じであり、それらの <em>layout-qualifier-value</em> の値が同じでなければならず、そうでなければリンクエラーとなる。指定されたオフセットは、それが修飾するブロックメンバーの型の
base alignment の倍数でなければならず、そうでなければコンパイルエラーになる。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">align</span></code> は、各ブロックメンバーの開始点を最小の byte alignment にする。各メンバー内の内部レイアウトには影響を与えず、
<code class="docutils literal notranslate"><span class="pre">std140</span></code> または <code class="docutils literal notranslate"><span class="pre">std430</span></code> の規則に従う。指定された alignment は 0 よりも大きく、かつ 2 のべき乗でなければならず、そうでない場合はコンパイルエラー。</p>
<p>メンバーの実際の alignment は、指定された <code class="docutils literal notranslate"><span class="pre">align</span></code> alignmentと、そのメンバーの型の標準（<code class="docutils literal notranslate"><span class="pre">std140</span></code> など）base alignment のうち大きい方になる。メンバーの実際のオフセットは次のように計算される：
<code class="docutils literal notranslate"><span class="pre">offset</span></code> が宣言されている場合は、そのオフセットから開始し、そうでない場合は、宣言順で先行メンバーの直後のオフセットから開始する。結果オフセットが実際の alignment の倍数でない場合は、実際の alignment の倍数である最初のオフセットまで増やす。これにより、メンバーの実際のオフセットが得られる。</p>
<p><code class="docutils literal notranslate"><span class="pre">align</span></code> が配列に適用された場合、配列の開始点のみに影響し、配列の内部幅には影響しない。宣言では <code class="docutils literal notranslate"><span class="pre">offset</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">align</span></code> 修飾子の両方を指定できる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">align</span></code> は、ブロックで使用された場合、ブロックで宣言されたのと同じ
<code class="docutils literal notranslate"><span class="pre">align</span></code> 値で各メンバーを修飾するのと同じ効果があり、これが行われた場合と同じコンパイル結果とコンパイルエラーが得られる。前述のように、個々のメンバーは独自の <code class="docutils literal notranslate"><span class="pre">align</span></code> を指定することができ、それはブロックレベルの <code class="docutils literal notranslate"><span class="pre">align</span></code> よりも優先されるが、そのメンバーに限られる。</p>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">block</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">a</span><span class="p">;</span>                         <span class="c1">// a takes offsets 0-15</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="kt">vec3</span> <span class="n">b</span><span class="p">;</span>     <span class="c1">// b takes offsets 32-43</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">40</span><span class="p">)</span> <span class="kt">vec2</span> <span class="n">c</span><span class="p">;</span>     <span class="c1">// ERROR, lies within previous member</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">48</span><span class="p">)</span> <span class="kt">vec2</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// d takes offsets 48-55</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">align</span> <span class="o">=</span> <span class="mi">16</span><span class="p">)</span> <span class="kt">float</span> <span class="n">e</span><span class="p">;</span>     <span class="c1">// e takes offsets 64-67</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">align</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="kt">double</span> <span class="n">f</span><span class="p">;</span>     <span class="c1">// f takes offsets 72-79</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">align</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="kt">double</span> <span class="n">g</span><span class="p">;</span>     <span class="c1">// ERROR, 6 is not a power of 2</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">80</span><span class="p">)</span> <span class="kt">float</span> <span class="n">h</span><span class="p">;</span>    <span class="c1">// h takes offsets 80-83</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">align</span> <span class="o">=</span> <span class="mi">64</span><span class="p">)</span> <span class="kt">dvec3</span> <span class="n">i</span><span class="p">;</span>     <span class="c1">// i takes offsets 128-151</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">164</span><span class="p">,</span> <span class="n">align</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>
    <span class="kt">float</span> <span class="n">j</span><span class="p">;</span>                        <span class="c1">// j takes offsets 168-171</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="opaque-uniform-layout-qualifiers">
<h2>4.4.6. Opaque Uniform Layout Qualifiers<a class="headerlink" href="#opaque-uniform-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>不透明な一様変数は、結合のために一様レイアウト修飾子を取ることができます。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子は、その変数が束縛される点を指定する。
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子なしで宣言された不透明変数は、既定束縛 0 になる。</p>
<p>OpenGL で使用する場合、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が配列とともに使用されると、配列の最初の要素は指定された束縛点を取り、それ以降の各要素は連続した次の束縛点を取る。配列の配列の場合は先程の <code class="docutils literal notranslate"><span class="pre">a[2][3]</span></code> の例を述べた文と同じ。</p>
<p>Vulkan を対象にした場合、配列で <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が使用されると、提供された束縛番号だけを配列全体が取る。次の連続した束縛番号は、別のオブジェクトに利用できる。</p>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> が 0 より小さい場合、または実装依存のサポートされる束縛点の最大数以上の場合は、コンパイルエラーとなる。サイズ N の配列で <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子を使う場合、番号 <em>binding</em> から番号 <em>binding</em> + N - 1 までの配列のすべての要素は、この範囲内に収まる必要がある。同じ番号 <em>binding</em> を共有する不可分カウンターのオフセットがすべて異なっていない限り、複数の不可分カウンターに同じ束縛番号を使用すると、コンパイルエラーまたはリンクエラーとなる。</p>
<p>一つのプログラム内のシェーダー二つが同じ <em>opaque-uniform</em> 名に対して異なる
<em>layout-qualifier-value</em> 束縛を指定するとリンクエラーとなる。ただし、次の例のように、同じ名前の宣言の一部に <code class="docutils literal notranslate"><span class="pre">binding</span></code> を指定しても、すべての宣言に <code class="docutils literal notranslate"><span class="pre">binding</span></code> を指定してもエラーではない：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// in one shader...</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// s bound to point 3</span>

<span class="c1">// in another shader...</span>
<span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">s</span><span class="p">;</span>                   <span class="c1">// okay, s still bound at 3</span>

<span class="c1">// in another shader...</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// ERROR: contradictory bindings</span>
</pre></div>
</div>
</section>
<section id="atomic-counter-layout-qualifiers">
<h2>4.4.7. Atomic Counter Layout Qualifiers<a class="headerlink" href="#atomic-counter-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>Vulkan を対象にした場合、不可分カウンターは使用できない。</p>
<p>不可分カウンターのレイアウト修飾子は、その宣言で使用できる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">offset</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>例えば下は、不可分カウンター <code class="docutils literal notranslate"><span class="pre">a</span></code> の不透明ハンドルを、不可分カウンターバッファーの束縛点 2 に、そのバッファーの 4 基本マシン単位のオフセットで束縛するように設定する。束縛点 2 の既定オフセットは 4（不可分カウンターのサイズ）で後置インクリメントされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">a</span><span class="p">;</span>
</pre></div>
</div>
<p>後続の不可分カウンター宣言は、直前の（インクリメントされた）オフセットを継承する。例えば次の宣言では、不可分カウンター <code class="docutils literal notranslate"><span class="pre">bar</span></code> がバッファーの束縛点 2 に 8
基本マシン単位のオフセットで束縛されるように設定する。結合点 2 のオフセットは、再び 4 だけ後置インクリメントされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">bar</span><span class="p">;</span>
</pre></div>
</div>
<p>一つのレイアウト宣言に複数の変数がリストされている場合、左から右の順に一つずつ宣言したのと同じ効果が得られる。</p>
<p>束縛点は継承されず、オフセットのみが継承される。各束縛点では、同じ束縛を使用する後続の変数の継承のために、それ自身の現在の既定オフセットを追跡する。コンパイルの初期状態では、すべての束縛点のオフセットが 0 になる。オフセットは、大域スコープで（変数を宣言せずに）束縛点ごとに設定できる。例えば、以下のようになる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span><span class="p">;</span>
</pre></div>
</div>
<p>上記は結合点 2 に対する次の <code class="docutils literal notranslate"><span class="pre">atomic_uint</span></code> 宣言がオフセット 4 を継承するように設定する（ただし、既定束縛は設定しない）。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// offset is 4</span>
<span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">bar</span><span class="p">;</span>  <span class="c1">// error, no default binding</span>
</pre></div>
</div>
<p>不可分カウンターは同じ束縛点を共有することができるが、束縛が共有されている場合、それらのオフセットは、明示的または暗黙的に一意的であり、重なり合わないことが必要だ。</p>
<p>シェーダーの先頭を想定した、有効な一様宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// offset = 4</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">b</span><span class="p">;</span>           <span class="c1">// offset = 0</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">c</span><span class="p">;</span>           <span class="c1">// offset = 8</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">d</span><span class="p">;</span>           <span class="c1">// offset = 4</span>
</pre></div>
</div>
<p>無効な一様宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="p">...</span>               <span class="c1">// error, must include binding</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="p">...</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// okay</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="p">...</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// okay</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="p">...</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// error, offsets must not be shared</span>
                                   <span class="c1">// between a and c</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="p">...</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// error, overlaps offset 0 of a</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_MaxAtomicCounterBindings</span></code> 以上の束縛値で不可分カウンターを束縛するとコンパイルエラーになる。サイズなし <code class="docutils literal notranslate"><span class="pre">atomic_uint</span></code> の配列を宣言するとコンパイルエラー。</p>
</section>
<section id="format-layout-qualifiers">
<h2>4.4.8. Format Layout Qualifiers<a class="headerlink" href="#format-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>フォーマットレイアウト修飾子は、画像変数の宣言（キーワードに <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> を持つ基本型で宣言されたもの）に使用できる。画像変数宣言のためのフォーマットレイアウト修飾子の識別子は次のとおり（一部略）：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>float-image-format-qualifier</em></div>
<div class="line"><em>int-image-format-qualifier</em></div>
<div class="line"><em>uint-image-format-qualifier</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>float-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32f</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba16f</span></code></div>
<div class="line">(etc.)</div>
<div class="line"><br /></div>
</div>
<div class="line"><em>int-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32i</span></code></div>
<div class="line">(etc.)</div>
<div class="line"><br /></div>
</div>
<div class="line"><em>uint-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32ui</span></code></div>
<div class="line">(etc.)</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">format</span></code> レイアウト修飾子は、宣言された画像変数に関連する画像表現形式を指定する。画像変数宣言一個につき、フォーマット修飾子を一つだけ指定できる。浮動小数点成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> で始まるキーワード）、符号付き整数成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;iimage&quot;</span></code> で始まるキーワード）、または符号なし整数成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;uimage&quot;</span></code> で始まるキーワード）の画像変数では、使用するフォーマット修飾子は、それぞれ
<em>float-image-format-qualifier</em>,
<em>int-image-format-qualifier</em>, <em>uint-image-format-qualifier</em>
文法規則に一致しなければならない。フォーマット修飾子が画像変数の型と一致しない画像変数を宣言するとコンパイルエラーとなる。</p>
<p>画像読み込みや不可分操作に使用される画像変数は、フォーマットレイアウト修飾子を指定しなければならない。フォーマットレイアウト修飾子なしで宣言された画像一様変数や関数引数を画像読み込みや不可分関数に渡すとコンパイルエラーとなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">writeonly</span></code> で修飾されていない一様（変数）はフォーマットレイアウト修飾子を持たなければならない。読み込みアクセスのために関数に渡された画像変数を <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> として宣言することはできないので、フォーマットレイアウト修飾子を付けて宣言しなければならないことに注意を要する。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">binding</span></code> については
<a class="reference internal" href="note4.html#opaque-uniform-layout-qualifiers"><span class="std std-ref">4.4.6. Opaque Uniform Layout Qualifiers</span></a> に記述がある。</p>
</section>
<section id="subpass-input-qualifier">
<h2>4.4.9. Subpass Input Qualifier<a class="headerlink" href="#subpass-input-qualifier" title="Permalink to this headline">¶</a></h2>
<p>サブパス入力は Vulkan を対象にしている場合に限り利用可能だ。</p>
<p>サブパス入力は、基本 <code class="docutils literal notranslate"><span class="pre">subpassInput</span></code> 型で宣言される。これらはレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> を付けて宣言しないとコンパイルエラー。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">input_attachment_index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">subpassInput</span> <span class="n">t</span><span class="p">;</span>
</pre></div>
</div>
<p>これはどのサブパスから入力が読み込まれるかを選択する。
<code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> に割り当てられた値、たとえば i とする
(<code class="docutils literal notranslate"><span class="pre">input_attachment_index</span> <span class="pre">=</span> <span class="pre">i</span></code>) と、パスの入力リストの中のその i 番目のエントリーを選択する。</p>
<p>サイズ N の配列が宣言されている場合は、提供されたものから始まる N 個の連続した
<code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> 値を消費する。</p>
<p>同じ <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> を異なる変数に宣言すると、コンパイルエラーまたはリンクエラーとなる。これには、配列宣言で消費される暗黙の <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> の重複も含まれる。</p>
<p><code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> に割り当てられた値が <code class="docutils literal notranslate"><span class="pre">gl_MaxInputAttachments</span></code>
以上の場合、コンパイルエラーとなる。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">4.4. Layout Qualifiers</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2021, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>