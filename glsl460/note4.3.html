
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4.3. Storage Qualifiers &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/prefab.css" />
    
    <script src="../_static/mathjax-v3.js"></script>
    
    <link rel="next" title="GLSL 4.60 仕様書 読書ノート 5 of ?" href="note5.html" />
    <link rel="prev" title="GLSL 4.60 仕様書 読書ノート 4 of ?" href="note4.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="note5.html" title="GLSL 4.60 仕様書 読書ノート 5 of ?"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="note4.html" title="GLSL 4.60 仕様書 読書ノート 4 of ?"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">GLSL 4.60 仕様書 読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">4.3. Storage Qualifiers</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="storage-qualifiers">
<h1>4.3. Storage Qualifiers<a class="headerlink" href="#storage-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>変数宣言では、型の前に高々一つの格納修飾子を指定することができる。詳しくは本書の表を参照。名前だけ列挙すると：
<code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">attribute</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">varying</span></code>,
<code class="docutils literal notranslate"><span class="pre">buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, 以上。</p>
<p>入出力修飾変数の中には、高々一つの補助格納修飾子を追加できるものがある。詳しくは本書の表を参照。名前だけ列挙すると：
<code class="docutils literal notranslate"><span class="pre">centroid</span></code>, <code class="docutils literal notranslate"><span class="pre">sample</span></code>, <code class="docutils literal notranslate"><span class="pre">patch</span></code>, 以上。</p>
<p>すべての修飾子の組み合わせが許されるわけではない。補助格納修飾子は <code class="docutils literal notranslate"><span class="pre">in</span></code> または <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子と一緒にしか使用できない。その他の修飾子の規則については、以降の節で説明。</p>
<p>局所変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子のみ使用できる（または格納修飾子を使用しない）。</p>
<p>関数の引数には <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code> を使用できるが、引数修飾子としては使用できないことに注意。引数修飾子については
<a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> を参照。</p>
<p>関数の戻り値の型や構造体のメンバーには格納修飾子を使用しない。</p>
<p>大域宣言の初期化子は、格納修飾子がないか、
<code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子があるか、または <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 修飾子がある大域変数の宣言でしか使用できない。</p>
<p>格納修飾子のない大域変数は、その宣言またはアプリケーションで初期化されないと、初期化されずに未定義の値で <code class="docutils literal notranslate"><span class="pre">main()</span></code> に入る。</p>
<p>あるシェーダー段階の出力と後続のシェーダー段階の入力を比較するとき、補助修飾子（またはその欠落）が同じでない場合、入力と出力は一致しない。</p>
<section id="default-storage-qualifier">
<h2>4.3.1. Default Storage Qualifier<a class="headerlink" href="#default-storage-qualifier" title="Permalink to this headline">¶</a></h2>
<p>大域変数に修飾子がない場合、その変数はアプリケーションや他のパイプライン段階で実行されるシェーダーとはリンクしていない。大域変数でも局所変数でも、修飾されていない変数では、宣言は対象となる処理器に関連するメモリーが割り当てられているように見える。この変数は、この割り当てられたメモリーへの読み取り・書き込みアクセスを提供する。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>意味不明。</p>
</div>
</section>
<section id="constant-qualifier">
<h2>4.3.2. Constant Qualifier<a class="headerlink" href="#constant-qualifier" title="Permalink to this headline">¶</a></h2>
<p>It is a compile-time error to write to a const variable outside of its declaration, so they must be initialized when declared. For example,
名前付きのコンパイル時定数や読み取り専用の変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子を使って宣言できる。
<code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子は、非 <code class="docutils literal notranslate"><span class="pre">void</span></code> 透過基本データ型や、それらの構造体や配列で使用できる。宣言されていない <code class="docutils literal notranslate"><span class="pre">const</span></code> 変数に書き込むコードはコンパイルエラーとなるから、宣言時に初期化する必要がある。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">vec3</span> <span class="n">zAxis</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">ceiling</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// a and b not necessarily constants</span>
</pre></div>
</div>
<p>構造体のメンバーは <code class="docutils literal notranslate"><span class="pre">const</span></code> で修飾することはできない。構造体変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> として宣言し、構造体のコンストラクターまたは初期化子で初期化できる。</p>
<p>大域スコープでの <code class="docutils literal notranslate"><span class="pre">const</span></code> 宣言の初期化子は、次節で定義されるように、定数式でなければならない。</p>
</section>
<section id="constant-expressions">
<h2>4.3.3. Constant Expressions<a class="headerlink" href="#constant-expressions" title="Permalink to this headline">¶</a></h2>
<p>SPIR-V の特殊化定数は、”特殊化-定数修飾子 “で説明したように、GLSL では
<code class="docutils literal notranslate"><span class="pre">const</span></code> にレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">const_id</span></code> を付けて表現される。</p>
<p><strong>定数式</strong> (a constant expression) とは次のいずれかだ：</p>
<ul class="simple">
<li><p>リテラル値</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子と初期化子で宣言された変数で、初期化子が定数式であるもの。これは <code class="docutils literal notranslate"><span class="pre">layout(const_id</span> <span class="pre">=</span> <span class="pre">...)</span></code> のような特殊化定数レイアウト修飾子を付けて宣言された
<code class="docutils literal notranslate"><span class="pre">const</span></code> と、特殊化定数レイアウト修飾子を付けずに宣言された <code class="docutils literal notranslate"><span class="pre">const</span></code> の両方を含む。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> として修飾された組み込み変数。</p></li>
<li><p>定数配列の要素、定数構造体のメンバー、定数ベクトルの構成要素の取得など、すべて定数式であるオペランドに対して演算子で形成される式。</p></li>
<li><p>オブジェクト自体が定数であるかどうかに関わらず、明示的なサイズのオブジェクトに対する
<code class="docutils literal notranslate"><span class="pre">length()</span></code> メソッドの適切な使用（暗黙的なサイズの配列や実行時サイズの配列は定数式を返さない）。</p></li>
<li><p>引数がすべて定数式であるコンストラクター。</p></li>
<li><p>非特殊化定数の場合のみ：引数がすべて定数式である特定の組み込み関数の呼び出しの戻り値（少なくとも以下のリストを含む）。メモリーにアクセスしないその他の組み込み関数（テクスチャー探索関数、画像アクセス、原子カウンターなどを除く）であって、戻り値の型が非 <code class="docutils literal notranslate"><span class="pre">void</span></code> で <code class="docutils literal notranslate"><span class="pre">out</span></code> 引数がなく、ノイズ関数ではないものも定数とみなされる場合がある。関数が特殊化定数である引数で呼び出された場合、その結果は定数式ではない。</p>
<ul>
<li><p>角度および三角関数</p></li>
<li><p>指数関数</p></li>
<li><p>普通の関数</p></li>
<li><p>幾何関数</p></li>
</ul>
</li>
<li><p>ユーザー定義関数（非組み込み関数）の関数呼び出しは、定数式には使用できない。</p></li>
</ul>
<hr class="docutils" />
<p><strong>定整数式</strong> (a constant integral expression) とは定数式であって、スカラーの符号付きまたは符号なしの整数に評価されるものだ。</p>
<p>定数式は不変的な方法で評価されるため、複数のシェーダーに同じ定数式が現れた場合、同じ値が生成される。
<a class="reference internal" href="#the-invariant-qualifier"><span class="std std-ref">4.8.1. The Invariant Qualifier</span></a>, <a class="reference internal" href="#precision-qualifiers"><span class="std std-ref">4.7.2. Precision Qualifiers</span></a> を参照。</p>
<p>定数式は <code class="docutils literal notranslate"><span class="pre">precision</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">invariant</span></code> 修飾子を尊重するが、そのような修飾子の使用とは関係なく、常に不変的に評価されるため、複数のシェーダーに同じ定数式が現れた場合には、同じ値が生成される。</p>
<p>定数式はホストプラットフォームで評価される可能性がある。それゆえ同じ式がシェーダー実行対象で評価するような値と同じものを計算する必要はない。ただし、ホストは対象が使用するのと同じか、それ以上の精度を使用しなければならない。精度修飾子が決定できない場合、式は <code class="docutils literal notranslate"><span class="pre">highp</span></code> で評価される。
<a class="reference internal" href="#default-precision-qualifiers"><span class="std std-ref">4.7.3. Default Precision Qualifiers</span></a> 参照。</p>
<p>特殊化定数式は、コンパイラーのフロントエンドでは評価されないで、代わりに、後でホスト上で評価するために必要な式の操作を留めておく。</p>
</section>
<section id="input-variables">
<h2>4.3.4. Input Variables<a class="headerlink" href="#input-variables" title="Permalink to this headline">¶</a></h2>
<p>シェーダーの入力変数は <code class="docutils literal notranslate"><span class="pre">in</span></code> 格納修飾子で宣言される。この変数は、API パイプラインの前段階と宣言したシェーダーとの間の入力インターフェイスを形成する。入力変数は大域スコープで宣言しなければならない。前のパイプライン段階から来る値は、シェーダー実行開始時に入力変数にコピーされる。入力として宣言された変数に書き込むコードはコンパイルエラーとなる。</p>
<p>前の段階で書き込む必要があるのは、静的に読み込まれる入力変数だけであり、入力変数の宣言が余計に付いていても構わない。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>本文ではこのことをまとめた表がここに示されているが、割愛する。</p>
</div>
<p>消費エラーは静的な使用にしかよらない。未定義の値を消費する可能性のある動的な使用方法をコンパイラーが推論する場合、エラーではなく警告を発する。組み込み入力名の一覧は <a class="reference internal" href="note7.html#built-in-variables"><span class="std std-ref">7. Built-In Variables</span></a> を参照。</p>
<p>頂点シェーダーの入力変数（または属性）は、頂点ごとのデータを受け取る。頂点シェーダー入力に補助格納修飾子や補間修飾子を使用すると、コンパイルエラーとなる。コピーされた値は API またはレイアウト識別子 <code class="docutils literal notranslate"><span class="pre">location</span></code> の使用により設けられる。</p>
<p>以下の型で頂点シェーダー入力を宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
<li><p>構造体</p></li>
</ul>
<hr class="docutils" />
<p>頂点シェーダーにおける入力宣言の例を示す：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">vec4</span> <span class="n">position</span><span class="p">;</span>
<span class="k">in</span> <span class="kt">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">in</span> <span class="kt">vec2</span> <span class="n">texCoord</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</pre></div>
</div>
<hr class="docutils" />
<p>グラフィックスハードウェアでは、頂点入力を渡すための固定のベクトル場所が足りないことが予想される。そのため、OpenGL Shading Language では、行列以外の入力変数は、そのようなベクトル場所を一つ使用すると定義している。使用できる場所の数には実装依存の制限があり、これを超えるとリンクエラーが発生する（静的使用でないと宣言された入力変数は、この制限に含まれない）。スカラー入力は <code class="docutils literal notranslate"><span class="pre">vec4</span></code> と同じようにカウントされるので、アプリケーションでは、内在するハードウェアの性能をよりよく活用するために、関係のない 4 つの <code class="docutils literal notranslate"><span class="pre">float</span></code> 入力のグループをまとめてベクトルにすることを検討するとよいだろう。行列入力は、複数の場所を使用する。使用される場所の数は、行列の列数と同じだ。</p>
<p>多角形分割制御、多角形分割評価、幾何シェーダーの入力変数は、前のアクティブシェーダー段階で同じ名前の出力変数によって書き出された、頂点ごとの値を取得する。これらの入力では <code class="docutils literal notranslate"><span class="pre">centroid</span></code> や補間修飾子が使えるが、効果はない。多角形分割制御、多角形分割評価、幾何シェーダーは頂点集合を操作するので、各入力変数（または入力ブロック、下記のインターフェイスブロックを参照）は配列として宣言する必要がある。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">float</span> <span class="n">foo</span><span class="p">[];</span> <span class="c1">// geometry shader input for vertex &quot;out float foo&quot;</span>
</pre></div>
</div>
<p>このような配列の各要素は、処理される基本形状の一つの頂点に対応する。各配列はオプションでサイズを宣言することができる。幾何シェーダーの場合、配列のサイズは、<a class="reference internal" href="#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a> のように、入力基本形状の型を設定する入力 <code class="docutils literal notranslate"><span class="pre">layout</span></code> 宣言によって設定される。</p>
<hr class="docutils" />
<p>入力と出力は配列されているものもある。これは、シェーダー段階二つの間にあるインターフェイスでは、入力または出力の宣言を一致させるために、余分なレベルの配列インデックスが必要になることを意味する。例えば、頂点シェーダーと幾何シェーダーのインターフェイスでは、頂点シェーダーの出力変数と幾何シェーダーの入力変数の同名の変数は、型が一致していなければならない。ただし、幾何シェーダーは、頂点のインデックス付けを可能にするために、頂点シェーダーよりも 1 多い配列次元を持つことになる。このように配列されたインターフェイス変数が、必要である追加的入力・出力配列次元で宣言されていない場合、リンクエラーとなる。幾何シェーダー入力、多角形分割制御シェーダー入出力、多角形分割評価入力はすべて、他のシェーダー入出力に比べて追加的配列レベルを持っている。これらの入力と出力は、頂点ごとに配列された (per-vertex-arrayed) 入力と出力として知られている。配列されたインターフェイス (<code class="docutils literal notranslate"><span class="pre">gl_MaxTessControlInputComponents</span></code>, etc.)
の成分制限は、インターフェイス全体に対する制限ではなく、頂点ごとの制限だ。</p>
<p>非配列のインターフェイス（＝段階間配列の次元が変わらない）では、入力変数が一致する出力変数と配列の次元を含めて同じ型で宣言されていないと、リンクエラーとなる。</p>
<p>リンク時の型マッチング規則は、使用されているか否かに関わらず、宣言されたすべての入力変数と出力変数に適用される。</p>
<p>さらに、多角形分割評価シェーダーは <code class="docutils literal notranslate"><span class="pre">patch</span></code> および <code class="docutils literal notranslate"><span class="pre">in</span></code> 修飾子で宣言された
<code class="docutils literal notranslate"><span class="pre">patch</span></code> ごとの入力変数をサポートしている。パッチごとの入力変数には、多角形分割制御シェーダーによって書き込まれたパッチごとの出力変数の値が入る。パッチごとの入力は一次元配列として宣言できるが、頂点数によるインデックスは付けられない。入力への <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子の適用は、多角形分割評価シェーダでしか行えない。他の入力変数と同様に、パッチごとの入力は、前の（多角形分割・制御）シェーダー段階からのパッチごとの出力と同じ型と修飾子を使って宣言しなければならない。他の段階の入力で <code class="docutils literal notranslate"><span class="pre">patch</span></code> を使用することは、コンパイルエラーとなる。</p>
<p>多角形分割制御、多角形分割評価、幾何シェーダーの入力を、以下のいずれかの型で宣言することは、コンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<hr class="docutils" />
<p>フラグメントシェーダーの入力は、前の段階の出力から補間されたフラグメントごとの値をふつうは取得する。補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code> も、補間修飾子 <code class="docutils literal notranslate"><span class="pre">flat</span></code>, <code class="docutils literal notranslate"><span class="pre">noperspective</span></code>, <code class="docutils literal notranslate"><span class="pre">smooth</span></code> と同様に適用できる。</p>
<p>フラグメントシェーダーの入力を次のいずれかの型で宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<p>整数型または倍精度浮動小数点型であるか、またはそれを含むフラグメントシェーダー入力には補間修飾子 <code class="docutils literal notranslate"><span class="pre">flat</span></code> が必要だ。</p>
<p>フラグメント入力は以下の例のように宣言される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">centroid</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
<span class="k">invariant</span> <span class="k">centroid</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>
<span class="k">noperspective</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">temperature</span><span class="p">;</span>
<span class="k">flat</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">myColor</span><span class="p">;</span>
<span class="k">noperspective</span> <span class="k">centroid</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">myTexCoord</span><span class="p">;</span>
</pre></div>
</div>
<p>フラグメントシェーダーの入力は、頂点処理パイプラインにおける最終アクティブシェーダーとのインターフェイスを形成する。このインターフェイスでは、最終アクティブシェーダー段階出力変数とフラグメントシェーダーの入力変数の同名の変数は、いくつかの例外（格納修飾子の一方は <code class="docutils literal notranslate"><span class="pre">in</span></code> で他方は <code class="docutils literal notranslate"><span class="pre">out</span></code> でなければならない）を除いて、型と修飾子が一致していなければならない。また、補間修飾子や補助修飾子も異なる場合がある。これらのミスマッチは任意の段階対の間で許される。補間修飾子や補助修飾子が一致しない場合は、フラグメントシェーダーで提供される修飾子が前段階で提供される修飾子よりも優先される。フラグメントシェーダーにそのような修飾子が全くない場合は、前段階で宣言されていた修飾子ではなく、既定の修飾子が使用される。つまり、重要なのはフラグメントシェーダーで何が宣言されているかであり、前段階のシェーダーで何が宣言されているかではないということだ。</p>
<hr class="docutils" />
<p>シェーダー段階間のインターフェイスが別々のプログラムオブジェクトのシェーダーを使って形成されている場合、プログラムがリンクされたときに入力と出力の間のミスマッチを検出することはできない。このようなインターフェイスでは、入力と出力の間にミスマッチがあると、インターフェイスを介して渡される値は、部分的にまたは完全に未定義となる。</p>
<p>シェーダーで入出力レイアウト修飾子 (<a class="reference internal" href="#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a>,
<a class="reference internal" href="#output-layout-qualifiers"><span class="std std-ref">4.4.2. Output Layout Qualifiers</span></a>)
を使用するか、ブロックや変数の入力宣言と出力宣言を同一にすることで、このようなインターフェイス間のマッチングを担保することができる。インターフェイスのマッチングに関する完全な規則は、OpenGL 仕様書の 7.4.1項 Shader Interface Matching に記載されている。</p>
<hr class="docutils" />
<p>計算シェーダはユーザ定義の入力変数を許可せず、他のシェーダー段階との正式なインターフェイスを形成しない。組み込みの計算シェーダー入力変数については <a class="reference internal" href="note7.html#compute-shader-special-variables"><span class="std std-ref">7.1.6. Compute Shader Special Variables</span></a> を参照。計算シェーダーへの他のすべての入力は、画像ロード、テクスチャー取得、
uniforms または uniform buffers からのロード、または他のユーザーコードによって明示的に取得される。計算シェーダーの組み込み入力変数を再宣言することはできない。</p>
</section>
<section id="uniform-variables">
<h2>4.3.5. Uniform Variables<a class="headerlink" href="#uniform-variables" title="Permalink to this headline">¶</a></h2>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>英単語 uniform をどう訳したらしっくり来るだろうか。数学科専攻としては「一様」にしたい。中国語の仕様書を見たら「統一」に相当する単語をあてているようだ。</p>
</div>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">uniform</span></code> は、処理される基本形状全体で値が同じになる大域変数を宣言するために用いられる。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数はすべて読み取り専用で、リンク時または API を通じて外部から初期化される。リンク時の初期値は、変数の初期化子が存在する場合はその値で、存在しない場合は 0 だ。不透明型は初期化子を持つことができず、そうでない場合はコンパイルエラーが発生する。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span> <span class="kt">vec4</span> <span class="n">lightPosition</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">);</span> <span class="c1">// value assigned at link time</span>
</pre></div>
</div>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">uniform</span></code> は、基本的なデータ型のいずれか、または構造体を型とする変数を宣言するとき、あるいはこれらのいずれかの配列を宣言するときに使用できる。</p>
<p>シェーダーの種類ごとに使用できる <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 用変数の収容量には実装依存の制限がある。これを超えるとコンパイル時またはリンク時にエラーとなる。宣言されているが使用されていない <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数はこの制限に入らない。ユーザー定義の <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の個数と、シェーダー内で使用されている組み込みの <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の個数の和で、利用可能な収容量を超えているかどうかを判断する。</p>
<p>シェーダー内の <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数は、プログラムまたは分割可能なプログラムにリンクされている場合、すべて単一の大域名前空間を共有する。したがって、同じ名前で静的に使用される <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の型、初期化子、および任意の <code class="docutils literal notranslate"><span class="pre">location</span></code> 指定子は、単一プログラムにリンクされているすべてのシェーダーで一致しなければならない。ただし、リンクされたすべてのシェーダーで初期化子や <code class="docutils literal notranslate"><span class="pre">location</span></code> 指定子を繰り返す必要はない。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数名がある段階（例：頂点シェーダー）で宣言され、別の段階（例：フラグメントシェーダー）で宣言されていない場合、その名前は別の段階で別の用途に使用することが許される。</p>
</section>
<section id="output-variables">
<h2>4.3.6. Output Variables<a class="headerlink" href="#output-variables" title="Permalink to this headline">¶</a></h2>
<p>シェーダー出力変数は <code class="docutils literal notranslate"><span class="pre">out</span></code> 格納修飾子で宣言される。出力変数は、宣言したシェーダーと API パイプラインの後続段階との間の出力インターフェイスを形成する。出力変数は大域スコープで宣言しなければならない。シェーダーの実行中は、修飾のない通常の大域変数として振る舞う。シェーダーの終了時にその値は後続のパイプライン段階にコピーされる。後続のパイプライン段階で読まれる出力変数だけが書き込まれる必要があり、出力変数の余計な宣言があっても構わない。</p>
<p>単一の変数名をシェーダーの入力と出力の両方として宣言するための <code class="docutils literal notranslate"><span class="pre">inout</span></code> のような格納修飾子は存在しない。一つの変数に <code class="docutils literal notranslate"><span class="pre">in</span></code> と <code class="docutils literal notranslate"><span class="pre">out</span></code> の両方の修飾子をつけて宣言することもまたできない。コンパイル時またはリンク時にエラーとなる。出力変数は、入力変数とは異なる名前で宣言しなければならない。ただし、インスタンス名を持つインターフェイス・ブロックの中に入力または出力を入れ子にすると、ブロックのインスタンス名で参照されるものと同じ名前を使うことができる。</p>
<p>頂点、多角形分割評価、幾何の出力変数は、頂点ごとのデータを出力し、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子を用いて宣言される。出力への <code class="docutils literal notranslate"><span class="pre">patch</span></code> の適用は、多角形分割制御シェーダーでのみ可能だ。それ以外の段階での適用はコンパイルエラーとなる。</p>
<p>頂点、多角形分割評価、多角形分割制御、幾何それぞれのシェーダーの出力を、以下の型のいずれかで宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="kt">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">centroid</span> <span class="k">out</span> <span class="kt">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
<span class="k">invariant</span> <span class="k">centroid</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>
<span class="k">flat</span> <span class="k">out</span> <span class="kt">vec3</span> <span class="n">myColor</span><span class="p">;</span>
<span class="k">sample</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">perSampleColor</span><span class="p">;</span>
</pre></div>
</div>
<p>これらは <a class="reference internal" href="#interface-blocks"><span class="std std-ref">4.3.9. Interface Blocks</span></a> で述べられるように、インターフェイスブロックにも出現する。インターフェイスブロックでは、頂点シェーダーから幾何シェーダーへのインターフェイスに、より単純に配列を追加することができる。また、フラグメントシェーダーに、ある頂点シェーダーの幾何シェーダーと同じ入力インターフェイスを持たせることができる。</p>
<hr class="docutils" />
<p>多角形分割制御シェーダーの出力変数は、頂点ごとのデータと patch ごとのデータを出力するために用いられる。頂点ごとの出力変数は配列され (<a class="reference internal" href="#input-variables"><span class="std std-ref">4.3.4. Input Variables</span></a>)、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子なしに宣言される。パッチごとの出力変数は <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で宣言される。</p>
<p>多角形分割制御シェーダーは、複数の頂点からなる配列された基本形状を生成するため、各頂点ごとの出力変数（または出力ブロック）は、配列として宣言する必要がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="kt">float</span> <span class="n">foo</span><span class="p">[];</span> <span class="c1">// feeds next stage input &quot;in float foo[]&quot;</span>
</pre></div>
</div>
<p>このような配列の要素それぞれが、生成される基本形状一つの頂点に対応する。各配列はオプションでサイズを宣言することができる。配列のサイズは出力パッチの頂点の数を定める出力レイアウト宣言によって設定される
(<a class="reference internal" href="#tessellation-control-outputs"><span class="std std-ref">Tessellation Control Outputs</span></a>)（または、宣言されている場合は、それと一致しなければならない）。</p>
<p>各多角形分割制御シェーダー呼び出しは、対応する出力パッチの頂点を持ち、その対応する頂点に属しているときに限り、頂点ごとの出力に値を割り当てることができる。頂点ごとの出力変数を左辺値として使用する場合、頂点のインデックスを示す式が識別子 <code class="docutils literal notranslate"><span class="pre">gl_InvocationID</span></code> でないと、コンパイル時またはリンク時のエラーになる。</p>
<p>同じ入力パッチに対する他の呼び出しに対する多角形分割制御シェーダー呼び出しの相対的な実行順序は、組み込み関数 <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> が使用されない限り、未定義だ。これにより、相対的な実行順序の制御が可能になる。シェーダーの呼び出しが <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を呼び出すと、他のすべての呼び出しが同じ実行点に到達するまでその実行は一時停止する。
<code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を呼び出す前に実行された任意の呼び出しによって実行された出力変数の割り当ては、
<code class="docutils literal notranslate"><span class="pre">barrier()</span></code> の呼び出しが戻った後、他の任意の呼び出しから見えるようになる。</p>
<p>多角形分割制御シェーダーの呼び出しは、バリア間で未定義の順序で実行されるので、頂点ごと、あるいはパッチごとの出力変数の値は時々未定義になる。シェーダー実行の開始と終了、および <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> の各呼び出しを同期時点と考えるといい。出力変数の値が不定になるのは、以下の三つの場合のいずれかだ：</p>
<ol class="arabic simple">
<li><p>実行の開始時</p></li>
<li><p>以下の場合を除く各同期時点：</p>
<ul class="simple">
<li><p>前回の同期時点の後に値が定義され、その後どの呼び出しによっても書き込まれなかった場合、または</p></li>
<li><p>前回の同期時点以降、厳密に一つのシェーダー呼び出しによって値が書き込まれた場合、または</p></li>
<li><p>前回の同期時点以降に複数のシェーダー呼び出しによって値が書き込まれ、そのようなすべての呼び出しによって実行された最後の書き込みが同じ値を書き込んだ場合。</p></li>
</ul>
</li>
<li><p>シェーダーの呼び出しによって読み込まれたとき、もし</p>
<ul class="simple">
<li><p>その値が前回の同期時点で未定義であり、その後同じシェーダー呼び出しによって書き込まれていない場合、または</p></li>
<li><p>前回と次回の同期時点の間に他のシェーダー呼び出しによって出力変数が書き込まれた場合（その割り当てが読み取り後のコードで発生したときでさえ）</p></li>
</ul>
</li>
</ol>
<hr class="docutils" />
<p>フラグメント出力は、フラグメントごとのデータを出力し、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で宣言される。フラグメントシェーダー出力の宣言に補助格納修飾子や補間修飾子を使用するとコンパイルエラーとなる。フラグメントシェーダー出力を以下の型で宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>倍精度スカラーまたはベクトル (<code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec2</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec3</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec4</span></code>)</p></li>
<li><p>不透明型</p></li>
<li><p>行列型</p></li>
<li><p>構造体</p></li>
</ul>
<p>フラグメント出力宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="kt">vec4</span> <span class="n">FragmentColor</span><span class="p">;</span>
<span class="k">out</span> <span class="kt">uint</span> <span class="n">Luminosity</span><span class="p">;</span>
</pre></div>
</div>
<hr class="docutils" />
<p>計算シェーダーは組み込みの出力変数を持たず、ユーザー定義の出力変数もサポートせず、他のシェーダー段階との正式なインターフェイスを形成しない。計算シェーダーからの出力はすべて、画像格納や原子カウンターの演算などの副作用の形をとる。</p>
</section>
<section id="buffer-variables">
<h2>4.3.7. Buffer Variables<a class="headerlink" href="#buffer-variables" title="Permalink to this headline">¶</a></h2>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> はAPI を通じて束縛されたバッファーオブジェクトのデータ格納空間に値が格納される大域変数を宣言するために使用される。バッファー変数はすべてのアクティブなシェーダー呼び出しの間で内包される格納空間を共有して読み書きすることができる。単一のシェーダー呼び出し内でのバッファー変数のメモリーの読み取りと書き込みは順番に処理される。しかし、ある起動で実行される読み込みと書き込みの順序は、他の呼び出しで実行されるものと比較するとほとんど未定義だ。バッファー変数は内包されているメモリーへのアクセス方法に影響を与えるメモリー修飾子
(<a class="reference internal" href="#memory-qualifiers"><span class="std std-ref">4.10. Memory Qualifiers</span></a>) で修飾することができる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> は、インターフェイスブロック (<a class="reference internal" href="#interface-blocks"><span class="std std-ref">4.3.9. Interface Blocks</span></a>)
を宣言するために使用することができ、これらのブロックはシェーダー格納ブロックとして参照される。ブロックの外でバッファー変数を宣言するとコンパイルエラーとなる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// use buffer to create a buffer block (shader storage block)</span>
<span class="k">buffer</span> <span class="n">BufferName</span> <span class="p">{</span> <span class="c1">// externally visible name of buffer</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>      <span class="c1">// typed, shared memory...</span>
    <span class="p">...</span>             <span class="c1">// ...</span>
    <span class="kt">vec4</span> <span class="n">v</span><span class="p">[];</span>       <span class="c1">// last member may be an array that is not sized</span>
                    <span class="c1">// until after link time (dynamically sized)</span>
<span class="p">}</span> <span class="n">Name</span><span class="p">;</span>             <span class="c1">// name of block within the shader</span>
</pre></div>
</div>
<p>シェーダーの種類ごとに使用されるシェーダー格納ブロックの数、プログラムに使用されるシェーダー格納格納ブロックの合計数、個々のシェーダー格納ブロックが必要とする格納空間の量には、実装に依存した制限がある。これらの制限を超えた場合は、コンパイル時またはリンク時にエラーが発生する。</p>
<p>複数のシェーダーがリンクされている場合、それらのシェーダーは単一に大域バッファー変数の名前空間を共有することになる。したがって、同じ名前で宣言されたバッファー変数の型は、単一のプログラムにリンクされているすべてのシェーダーで一致しなければならない。</p>
</section>
<section id="shared-variables">
<h2>4.3.8. Shared Variables<a class="headerlink" href="#shared-variables" title="Permalink to this headline">¶</a></h2>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">shared</span></code> は、計算シェーダー作業グループ内のすべての作業項目間で共有される格納空間がある大域変数を宣言するために用いられる。
<code class="docutils literal notranslate"><span class="pre">shared</span></code> として宣言された変数は、計算シェーダーでしか使用されない
(<a class="reference internal" href="note2.html#compute-processor"><span class="std std-ref">2.6. Compute Processor</span></a>)。それ以外の共有変数の宣言は、コンパイルエラーとなる。共有変数は暗黙的に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> (<a class="reference internal" href="#memory-qualifiers"><span class="std std-ref">4.10. Memory Qualifiers</span></a>) だ。</p>
<p>共有変数として宣言された変数は初期化子を持たず、シェーダーの実行開始時にはその内容は未定義だ。共有変数に書き込まれたどんなデータも、同じ作業グループ内の他の作業項目（同じシェーダーを実行中）から見えるということになる。</p>
<p>同期が行われていない場合、シェーダーの異なる呼び出しによる同じ <code class="docutils literal notranslate"><span class="pre">shared</span></code> 変数への読み書きの順序は未定義とする。</p>
<p>共有変数への読み書きの順序を決めるためには、関数 <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を使って制御フローの障壁を設ける必要がある
(<a class="reference internal" href="note8.html#shader-invocation-control-functions"><span class="std std-ref">8.16. Shader Invocation Control Functions</span></a>)。</p>
<p>単一のプログラムで共有変数として宣言されたすべての変数の合計サイズには制限がある。
basic machine units 単位で表されるこの制限は、OpenGL API を使って
<code class="docutils literal notranslate"><span class="pre">MAX_COMPUTE_SHARED_MEMORY_SIZE</span></code> の値を照会することで決定できる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>最後のパラグラフ中の basic machine units なる用語がわからない。</p>
</div>
</section>
<section id="interface-blocks">
<h2>4.3.9. Interface Blocks<a class="headerlink" href="#interface-blocks" title="Permalink to this headline">¶</a></h2>
<p>入力、出力、一様、バッファー変数の宣言は、名前の付いたインターフェイスブロックにまとめることができ、個別の宣言では達せられない粗い粒度の backing が可能になる。これらはオプションでインスタンス名を持つことができ、シェーダー内でそのメンバーを参照するために用いられる。あるプログラム可能段階の出力ブロックは、後続のプログラム可能段階の対応する入力ブロックによって back される。一様ブロック (a uniform block) は、アプリケーションによってバッファーオブジェクトで back される。シェーダー格納ブロック (a shader storage block) と呼ばれるバッファー変数のブロックも、アプリケーションによってバッファーオブジェクトで back される。頂点シェーダーの入力ブロックやフラグメントシェーダーの出力ブロックを持つことは、コンパイルエラーとなり。これらの用途は将来のために予約されている。</p>
<p>インターフェイスブロックは、キーワード <code class="docutils literal notranslate"><span class="pre">in`,</span> <span class="pre">``out</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>
と、ブロック名、そして中括弧 <code class="docutils literal notranslate"><span class="pre">{</span></code> で始まる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>BNF による一覧を省略。</p>
</div>
<hr class="docutils" />
<p>次のコードは <code class="docutils literal notranslate"><span class="pre">Transform</span></code> という名前の一様ブロックを定義する。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数四つがグループ化される。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span> <span class="n">Transform</span> <span class="p">{</span>
    <span class="kt">mat4</span> <span class="n">ModelViewMatrix</span><span class="p">;</span>
    <span class="kt">mat4</span> <span class="n">ModelViewProjectionMatrix</span><span class="p">;</span>
    <span class="k">uniform</span> <span class="kt">mat3</span> <span class="n">NormalMatrix</span><span class="p">;</span>      <span class="c1">// allowed restatement of qualifier</span>
    <span class="kt">float</span> <span class="n">Deformation</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>型と宣言子は、ブロック外の他の入力、出力、一様、バッファー変数の宣言と同じだ、以下の例外がある：</p>
<ul class="simple">
<li><p>初期化子は許されない。</p></li>
<li><p>不透明型は許されない。</p></li>
<li><p>ブロック内での構造体定義の入れ子は許されない。</p></li>
</ul>
<p>これらはいずれもコンパイルエラーになる。</p>
<p>メンバー宣言にオプションの修飾子がない場合、メンバーの修飾には、
interface-qualifier で決定されるすべての <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">patch</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>,
<code class="docutils literal notranslate"><span class="pre">buffer</span></code> が含まれる。オプション修飾子を使用する場合、補間修飾子、補助格納修飾子、格納修飾子を含むことができ、ブロックのインターフェイス修飾子と一致する入力、出力、一様メンバーを宣言しなければならない。すなわち、入力変数、出力変数、一様変数、
<code class="docutils literal notranslate"><span class="pre">buffer</span></code> メンバーは、
<code class="docutils literal notranslate"><span class="pre">in</span></code> ブロック、
<code class="docutils literal notranslate"><span class="pre">out</span></code> ブロック、
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> ブロック、シェーダー格納ブロック内それぞれにしか存在しない。</p>
<p>メンバーの格納修飾子に <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">patch</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>
のいずれかのインターフェイス修飾子を繰り返すことはオプションだ。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="n">Material</span> <span class="p">{</span>
    <span class="k">smooth</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color1</span><span class="p">;</span> <span class="c1">// legal, input inside in block</span>
    <span class="k">smooth</span> <span class="kt">vec4</span> <span class="n">Color2</span><span class="p">;</span>    <span class="c1">// legal, &#39;in&#39; inherited from &#39;in Material&#39;</span>
    <span class="kt">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>         <span class="c1">// legal, TexCoord is an input</span>
    <span class="k">uniform</span> <span class="kt">float</span> <span class="n">Atten</span><span class="p">;</span>   <span class="c1">// illegal, mismatched storage qualifier</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p><strong>シェーダーインターフェイス</strong> (a shader interface) とは、次のうちの一つとする：</p>
<ul class="simple">
<li><p>プログラムの中で宣言されたすべての一様変数と一様ブロック。これは、一つのプログラム内でリンクされているすべてのコンパイル単位に及ぶ。</p></li>
<li><p>プログラム内で宣言された <code class="docutils literal notranslate"><span class="pre">buffer</span></code> ブロックすべて。</p></li>
<li><p>隣接するプログラム可能パイプライン段階間の境界。最初の段階のコンパイル単位すべてで宣言された出力すべてと、次の段階のコンパイル単位すべて宣言された入力すべてに及ぶ。なお、実際にはフラグメントシェーダーに渡された値すべては、まずラスタライザーと補間器を通過するが、この定義では、フラグメントシェーダーと先行するシェーダーは境界を共有すると考えられる。</p></li>
</ul>
<p>ブロック名 (block-name) は、シェーダーインターフェイス内での照合に用いられる。つまり、あるパイプライン段階の出力ブロックは、後続のパイプライン段階の同名の入力ブロックに合致する。一様ブロックやシェーダー格納ブロックの場合、アプリケーションはブロック名を使ってブロックを識別する。シェーダー内ではインターフェイスの照合以外にはブロック名を利用できない。大域スコープのブロック名をブロック名として以外に使用することはコンパイルエラーとなる（例えば、大域変数名や関数名にブロック名を使用することが現在予約されている）。ブロックの内容が同じであっても、一つのシェーダー内の同じシェーダーインターフェイスの複数のブロック宣言に同じブロック名を使用すると、コンパイルエラーとなる。</p>
<p>一つのシェーダインターフェイスの中で合致したブロック名は、同じ数の宣言と同じ型の並び、同じメンバー名の並び、そしてメンバーごとのレイアウト修飾が一致していなければならない。一致した一様ブロック名またはシェーダー格納ロック名（入力ブロック名または出力ブロック名ではない）は、すべてインスタンス名がないか、またはすべてインスタンス名があり、それらのメンバーが同じスコープレベルにあることも必要だ。合致したブロック名の上にインスタンス名がある場合、インスタンス名が違っていても構わない。さらに、合致ブロックが配列として宣言されている場合は、配列のサイズまでも一致していなければならない。（または、連続するシェーダー段階間のシェーダーインターフェイスの配列一致規則ルールに従う）。不一致の場合、リンクタイムエラーとなる。ブロック名は、同一シェーダー内の異なるシェーダーインターフェイスで異なる定義であることが許されており、例えば、入力ブロックと出力ブロックが同じ名前であることも可能である。</p>
<p>インスタンス名 (instance-name) を使用しない場合、ブロック内で宣言された名前は大域レベルでスコープされ、ブロックの外で宣言されたかのようにアクセスされる。インスタンス名を使用すると、スコープ内のすべてのメンバーが独自の名前空間内に置かれ、構造体と同様の、フィールドセレクター演算子 <code class="docutils literal notranslate"><span class="pre">.</span></code> でアクセスされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="n">Light</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">LightPos</span><span class="p">;</span>
    <span class="kt">vec3</span> <span class="n">LightColor</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">in</span> <span class="n">ColoredTexture</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>
    <span class="kt">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Material</span><span class="p">;</span>           <span class="c1">// instance name</span>
<span class="kt">vec3</span> <span class="n">Color</span><span class="p">;</span>           <span class="c1">// different Color than Material.Color</span>
<span class="kt">vec4</span> <span class="n">LightPos</span><span class="p">;</span>        <span class="c1">// illegal, already defined</span>
<span class="p">...</span>
<span class="p">...</span> <span class="o">=</span> <span class="n">LightPos</span><span class="p">;</span>       <span class="c1">// accessing LightPos</span>
<span class="p">...</span> <span class="o">=</span> <span class="n">Material</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span> <span class="c1">// accessing Color in ColoredTexture block</span>
</pre></div>
</div>
<p>シェーディング言語の外では、メンバーは同様に識別されるが、インスタンス名の代わりにブロック名が常に使用される。API のアクセスはシェーダーではなくシェーダーインターフェイスに対して行われるのだ。インスタンス名がない場合、API はメンバーにアクセスするためにブロック名を使用せず、メンバー名だけを使用する。</p>
<p>シェーダーインターフェイス内では、同じ大域名の宣言すべては同じオブジェクトに対するものでなければならず、型や、インスタンス名のないブロックの変数やメンバーを宣言しているかどうかが一致していなければならない。また、API はシェーダーインターフェイス内のオブジェクトを一意に識別するためにこの名前を必要とする。次のどちらかが成り立つならば、どのシェーダーインターフェイスもリンクエラーになる：</p>
<ul class="simple">
<li><p>インスタンス名を持たず、同じ名前のメンバーを持つ相異なるブロックが含まれている。</p></li>
<li><p>ブロック外の変数と、インスタンス名のないブロックで、その変数がブロック内のメンバーと同じ名前である。</p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="n">Vertex</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">Position</span><span class="p">;</span>  <span class="c1">// API transform/feedback will use &quot;Vertex.Position&quot;</span>
    <span class="kt">vec2</span> <span class="n">Texture</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Coords</span><span class="p">;</span>           <span class="c1">// shader will use &quot;Coords.Position&quot;</span>
<span class="k">out</span> <span class="n">Vertex2</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>     <span class="c1">// API will use &quot;Color&quot;</span>
    <span class="kt">float</span> <span class="n">Color2</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// in same program as Vertex2 above:</span>
<span class="k">out</span> <span class="n">Vertex3</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">Intensity</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>     <span class="c1">// ERROR, name collision with Color in Vertex2</span>
<span class="p">};</span>
<span class="kt">float</span> <span class="n">Color2</span><span class="p">;</span>       <span class="c1">// ERROR, collides with Color2 in Vertex2</span>
</pre></div>
</div>
<hr class="docutils" />
<p>配列として宣言されたブロックでは、メンバーにアクセスする際に配列のインデックスも含める必要がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span> <span class="n">Transform</span> <span class="p">{</span> <span class="c1">// API uses &quot;Transform[2]&quot; to refer to instance 2</span>
    <span class="kt">mat4</span> <span class="n">ModelViewMatrix</span><span class="p">;</span>
    <span class="kt">mat4</span> <span class="n">ModelViewProjectionMatrix</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">a</span><span class="p">[];</span> <span class="c1">// array will get implicitly sized</span>
    <span class="kt">float</span> <span class="n">Deformation</span><span class="p">;</span>
<span class="p">}</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">...</span>
<span class="p">...</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">ModelViewMatrix</span><span class="p">;</span> <span class="c1">// shader access of instance 2</span>
<span class="c1">// API uses &quot;Transform.ModelViewMatrix&quot; to query an offset or other query</span>
<span class="n">transforms</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="c1">// same length for &#39;a&#39; for all x</span>
<span class="n">Transform</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>             <span class="c1">// illegal, must use &#39;transforms&#39;</span>
<span class="n">Transform</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>     <span class="c1">// illegal, must use &#39;transforms&#39;</span>
<span class="p">...</span><span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]...</span>  <span class="c1">// if these are the only two dereferences of &#39;a&#39;,</span>
<span class="p">...</span><span class="n">transforms</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]...</span>  <span class="c1">// then &#39;a&#39; must be size 8, for all</span>
<span class="n">transforms</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>配列として宣言された一様ブロックやシェーダー格納ブロックでは、個々の配列要素が、ブロックのインスタンス一つを back する、個別のバッファーオブジェクトの結合範囲に対応する。配列のサイズは必要なバッファーオブジェクトの数を示すため、一様ブロックやシェーダー格納ブロックの配列宣言では、配列のサイズを指定する必要がある。一様ブロックやシェーダー格納ブロックの配列は、動的一様な整数式でしかインデックスを付けることができず、それ以外の場合は結果が未定義だ。</p>
<p>OpenGL API のエントリー点を使用してブロックの配列内の個々のブロックの名前を特定する場合、
<code class="docutils literal notranslate"><span class="pre">Transform[2]</span></code> のようにして、名前の文字列に配列のインデックスを含めることができる。
OpenGL API のエントリー点を使用してブロックメンバーのオフセットやその他の性質を参照する場合、
<code class="docutils literal notranslate"><span class="pre">Transform.ModelViewMatrix</span></code> のように、配列インデックスを抜かなければならない。</p>
<p>多角形分割制御、多角形分割評価、幾何シェーダー入力ブロックは、配列として宣言されなければならず、それぞれの段階のシェーダー入力すべては配列宣言とリンクルールに従わなければならない。その他のすべての入出力ブロックの配列は、配列サイズを指定しなければならない。</p>
<p>段階ごとに使用できる一様ブロックの個数とシェーダー格納ブロックの個数は、実装依存の制限がある。いずれかの制限を超えた場合、リンクエラーとなる。</p>
</section>
</section>
<section id="layout-qualifiers">
<h1>4.4. Layout Qualifiers<a class="headerlink" href="#layout-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>レイアウト修飾子は宣言形式がいくつかある。前節の文法で示したように、インターフェイスブロックの定義やブロックメンバーの一部として現れることがある。一つの <em>layout-qualifier</em> だけで、その修飾子を使った他の宣言のレイアウトを設定することもできる。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> <em>interface-qualifier</em> ;</div>
</div>
<p>また、インターフェース修飾子で宣言された個別の変数で出現することもある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> <em>interface-qualifier</em> <em>declaration</em> ;</div>
</div>
<p>レイアウトの宣言は、大域スコープまたはブロックメンバーでしか行えず、以下の節で示される場所でしか行えない。</p>
<p>レイアウト修飾子は次のように展開する：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">layout</span> <span class="pre">(</span></code> <em>layout-qualifier-id-list</em> <code class="docutils literal notranslate"><span class="pre">)</span></code></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-id-list</em> :</div>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em></div>
<div class="line"><em>layout-qualifier-id</em> , <em>layout-qualifier-id-list</em></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>layout-qualifier-name</em></div>
<div class="line"><em>layout-qualifier-name</em> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">shared</span></code></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>layout-qualifier-value</em> :</div>
<div class="line-block">
<div class="line"><em>integer-constant-expression</em></div>
</div>
</div>
<p><em>layout-qualifier-name</em> に使用されるトークンは、キーワードではなく識別子で、
<em>layout-qualifier-id</em> としてキーワード <strong>shared</strong> を使用することができる。一般的に、これらはどのような順序でも並べてよい。順序に依存する意味は、下で明示されている場合に限り存在する。同様に、これらの識別子は、明示的に別段の記載がない限り、大文字と小文字を区別しない。</p>
<p>単一の宣言にレイアウト修飾子を複数含めることができる。また、同じ <em>layout-qualifier-name</em> が、一つのレイアウト修飾子の中で複数回現れたり、同じ宣言の中で複数のレイアウト修飾子にまたがって現れたりすることがある。同じ <em>layout-qualifier-name</em> が単一の宣言の中で複数回出現する場合、最後に出現したものがそれ以前に出現したものよりも優先される。さらに、このような <em>layout-qualifier-name</em> が後続の宣言やその他の観察可能な挙動に影響する場合、影響を与えるのは最後に出現するものだけであり、以前に出現したものは存在しないかのように振る舞う。これは <em>layout-qualifier-name</em> を上書きする場合にも当てはまり、一方が他方を上書き場合 (e.g. <code class="docutils literal notranslate"><span class="pre">row_major</span></code> vs. <code class="docutils literal notranslate"><span class="pre">column_major</span></code>) には、最後に出現するものだけが影響を及ぼす。</p>
<p><em>integer-constant-expression</em> は <a class="reference internal" href="#constant-expressions"><span class="std std-ref">4.3.3. Constant Expressions</span></a> で
<em>constant integral expression</em> として定義されており、
<em>integer-constant-expression</em> が特殊化定数であることはコンパイルエラーになる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>仕様書本文ではレイアウト修飾子の使用法の概要が表になって掲載されている。巨大なデータなので引用は控える。</p>
</div>
<section id="input-layout-qualifiers">
<h2>4.4.1. Input Layout Qualifiers<a class="headerlink" href="#input-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>計算シェーダーを除くすべてのシェーダーでは、入力変数宣言、入力ブロック宣言、入力ブロックメンバー宣言に対してレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">location</span></code> を使うことができる。このうち、変数とブロックメンバー（ブロックは不可）には、さらにレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> が使用できる。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">component</span></code> = <em>layout-qualifier-value</em></div>
</div>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="kt">int</span> <span class="kt">vec4</span> <span class="n">v</span><span class="p">;</span>
</pre></div>
</div>
<p>これにより、シェーダー入力の <code class="docutils literal notranslate"><span class="pre">normal</span></code> はベクトル位置番号 3 に、
<code class="docutils literal notranslate"><span class="pre">v</span></code> は位置番号 8 に割り当てられる。頂点シェーダー入力の場合、位置を入力値を取得する頂点属性の番号で指定する。他のすべてのシェーダー型の入力では、そのシェーダーが別のプログラムオブジェクト内にあったとしても、位置を以前のシェーダー段階からの出力との照合に使用できるベクトル番号で指定する。</p>
<p>続く言語では、特定の型で消費される位置の数を記述する。ただし、幾何シェーダー入力、多角形分割制御シェーダー入出力、多角形分割評価入力はすべて、他のシェーダー入出力に対して追加の配列レベルを持っている。この外側の配列レベルは、型が消費する位置の数を考慮する前に、型から取り除かれます。</p>
<p>Vulkan を対象にしている場合を除き、頂点シェーダー入力が任意のスカラーまたはベクトル型である場合、位置を一つを消費する。非頂点シェーダーの入力や Vulkan を対象にしている場合の段階入力が
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 以外のスカラー型やベクトル型の場合は、位置を一つを消費するが、
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 型の場合は連続した二つの位置を消費する。
<code class="docutils literal notranslate"><span class="pre">double</span></code> 型や <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> 型の入力は、段階すべてで一つの位置しか消費しない。</p>
<p>上述のように外側の配列レベルを削除した後、宣言された入力がサイズ n の配列で、各要素が m 個の位置を取る場合、指定された位置から始まる m × n 個の連続した位置が割り当てられる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</pre></div>
</div>
<p>これにより、シェーダーの入力色がベクトルの位置番号 6, 7, 8 に割り当てられることが確定する。</p>
<p>宣言された入力が n × m 行列の場合は、指定された位置から始まる複数の位置が割り当てられる。各行列に割り当てられる位置の数は、m 成分のベクトルの n 要素の配列と同じになる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">9</span><span class="p">)</span> <span class="k">in</span> <span class="kt">mat4</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>これにより、シェーダー入力 <code class="docutils literal notranslate"><span class="pre">transforms</span></code> がベクトルの 9～16番に割り当てられる：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transforms[0]</span></code> が 9, 10, 11, 12 番に、</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">transforms[1]</span></code> が 13, 14, 15, 16 番に</p></li>
</ul>
<p>割り当てられる。</p>
<hr class="docutils" />
<p>宣言された入力が構造体やブロックの場合、そのメンバーには宣言順に連続した位置が割り当てられ、最初のメンバーにはレイアウト修飾子で指定された位置が割り当てられる。構造体の場合、この処理は構造体全体に適用される。
<code class="docutils literal notranslate"><span class="pre">layout</span></code> 修飾子を構造体のメンバーに使用するとコンパイルエラーとなる。ブロックの場合、この処理はブロック全体に適用される。つまり <code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子を持つ最初のメンバーに到達するまで適用される。</p>
<p>ブロックのメンバーが <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子付きで宣言されている場合、そのメンバーの位置はその修飾子に由来し、メンバーの <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子がブロックレベルの宣言よりも優先される。後続のメンバーには、次の <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子が宣言されたメンバーまで、最新の位置に基づいて連続した位置が再び割り当てられる。位置に使用される値は、昇順に宣言する必要はない。</p>
<p>ブロックレベルの <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子がないブロックでは、そのメンバーのすべてが <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子を持つか、またはそれを一つも持たないことが要求される。さもないとコンパイルエラーとなる。配列として宣言されたブロックには <code class="docutils literal notranslate"><span class="pre">location</span></code> がブロックレベルでしか適用できないものがある。ブロックが配列として宣言されていて、ブロックの配列要素ごとに各メンバーに追加の位置が必要な場合、ブロックのメンバーに位置を指定するとコンパイルエラーになる。つまり、ブロックメンバ上ーに位置を適用することで指定不足になる場合、それは認められない。配列されたインターフェイス（一般にインターフェイスの拡張により余計な配列を持つもの）では、この規則を適用する前に外側の配列が取り除かれる。</p>
<p>ブロックや構造体のメンバーが消費する位置は、構造体のメンバーが同じ型の入力変数として宣言されているかのように、上記の規則を再帰的に適用して決定される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">vec3</span> <span class="n">a</span><span class="p">;</span>                      <span class="c1">// gets location 3</span>
    <span class="kt">mat2</span> <span class="n">b</span><span class="p">;</span>                      <span class="c1">// gets locations 4 and 5</span>
    <span class="kt">vec4</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>                   <span class="c1">// gets locations 6 and 7</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="kt">vec2</span> <span class="n">A</span><span class="p">;</span> <span class="c1">// ERROR, can&#39;t use on struct member</span>
<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">in</span> <span class="n">block</span>
<span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">d</span><span class="p">;</span>                      <span class="c1">// gets location 4</span>
    <span class="kt">vec4</span> <span class="n">e</span><span class="p">;</span>                      <span class="c1">// gets location 5</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">7</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// gets location 7</span>
    <span class="kt">vec4</span> <span class="n">g</span><span class="p">;</span>                      <span class="c1">// gets location 8</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">h</span><span class="p">;</span> <span class="c1">// gets location 1</span>
    <span class="kt">vec4</span> <span class="n">i</span><span class="p">;</span>                      <span class="c1">// gets location 2</span>
    <span class="kt">vec4</span> <span class="n">j</span><span class="p">;</span>                      <span class="c1">// gets location 3</span>
    <span class="kt">vec4</span> <span class="n">k</span><span class="p">;</span>                      <span class="c1">// ERROR, location 4 already used</span>
<span class="p">};</span>
</pre></div>
</div>
<p>シェーダーが利用できる入力位置の数には制限がある。頂点シェーダーでは、その制限は公示された頂点属性の数だ。その他のシェーダーでは、制限は実装に依存し、公示された最大入力成分数の 1/4 以上でなければならない。</p>
<p>取り付けられたシェーダーがサポートされている個数を超える位置を使用している場合、デバイス依存最適化がプログラムに利用可能なハードウェア資源内に収まるようにさせない限り、プログラムはリンクに失敗する。</p>
<p>明示的な位置割り当てにより、リンカーが他の明示的割り当てのない変数のための空間を見つけられない場合、プログラムはリンクに失敗する。</p>
<p>非頂点入力が以前のシェーダー段階の出力と一致するかどうかを判断するためには、
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子がもしあれば一致していなければならない。</p>
<p>シェーダーテキストに位置が割り当てられていない頂点シェーダー入力変数に
OpenGL API で指定された位置がある場合は、その指定位置が使用される。そうでなければ、そのような変数はリンカーによって場所が割り当てられる。入力変数が同じ言語の複数のシェーダーで宣言されていて、位置が競合している場合、リンクエラー。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> を使用すると、スカラーやベクトルの位置をより細かく指定することができ、消費される位置内の個々の成分まで指定することができる修飾子 <code class="docutils literal notranslate"><span class="pre">location</span></code> を指定せずに <code class="docutils literal notranslate"><span class="pre">component</span></code> を使用すると、コンパイルエラーになる（順序は重要でない）。位置内の成分は 0, 1, 2, 3 だ。成分 N で始まる変数やブロックメンバーは、そのサイズまでの成分 N, N+1, N+2, …を消費する。この成分の並びが 3 より大きくなると、コンパイルエラーになる。スカラー <code class="docutils literal notranslate"><span class="pre">double</span></code> はこれらの成分のうち二つを消費し、
<code class="docutils literal notranslate"><span class="pre">dvec2</span></code> はある位置で利用可能な四つの成分全てを消費する。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> や <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> は成分指定なしでしか宣言できない。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> は一つ目の位置の四つの成分と、二つ目の位置の成分 0 と 1 をすべて消費する。これにより、成分 2 と 3 は他の成分修飾された宣言に使用できる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// a consumes components 2 and 3 of location 4</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">a</span><span class="p">;</span>

<span class="c1">// b consumes component 1 of location 4</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">// ERROR: c overflows component 3</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">c</span><span class="p">;</span>

<span class="c1">// d consumes components 2 and 3 of location 5</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>

<span class="c1">// ERROR: e overflows component 3 of location 6</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">dvec2</span> <span class="n">e</span><span class="p">;</span>

<span class="c1">// ERROR: f overlaps with g</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">double</span> <span class="n">f</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">float</span> <span class="n">g</span><span class="p">;</span>

<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="k">in</span> <span class="kt">dvec3</span> <span class="n">h</span><span class="p">;</span> <span class="c1">// components 0,1,2 and 3 of location 8</span>
                                 <span class="c1">// and components 0 and 1 of location 9</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// okay, compts 2 and 3</span>
</pre></div>
</div>
<p>but all at the same specified component within each location. For example:
変数が配列の場合、配列の各要素は順番に連続した位置に割り当てられるが、各位置の中ですべて同じ指定された成分になる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// component 3 in 6 locations are consumed</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">d</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</pre></div>
</div>
<p>この場合、位置 2 の成分 3 は <code class="docutils literal notranslate"><span class="pre">d[0]</span></code> を、位置 3 の成分 3 は <code class="docutils literal notranslate"><span class="pre">d[1]</span></code> を、…位置 7 の成分 3 に <code class="docutils literal notranslate"><span class="pre">d[5]</span></code> を格納する。</p>
<p>これにより二つの配列を同じ位置にまとめることができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// e consumes beginning (components 0, 1 and 2) of each of 6 slots</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">e</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

<span class="c1">// f consumes last component of the same 6 slots</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">,</span> <span class="n">component</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">f</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</pre></div>
</div>
<p>これを配列の配列に適用する場合は、すべてのレベルの配列性が取り除かれ、指定された成分に位置ごとに割り当てられた要素になる。これらの非配列要素は <a class="reference internal" href="note4.html#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> が指定する順序で配列の配列に対する位置を埋める。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">component</span></code> を行列、構造体、ブロック、またはこれらを含む配列に適用するとコンパイルエラーになる。
<code class="docutils literal notranslate"><span class="pre">component</span></code> 1 または 3 を <code class="docutils literal notranslate"><span class="pre">double</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> の先頭に使用するとコンパイルエラーになる。プログラム内で同じ変数に異なる成分を指定すると、リンクエラーになる。</p>
<hr class="docutils" />
<p><strong>位置エイリアシング</strong> (location aliasing) とは、二つの変数やブロックメンバーに同じ位置番号を持たせることだ。
<strong>成分エイリアシング</strong> (component aliasing) とは、二つの位置エイリアスに同じ（または重複する）成分番号を割り当てることだ（<code class="docutils literal notranslate"><span class="pre">component</span></code> を使用しない場合は 0 から始まる成分が割り当てられることを思い出せ）。一つの例外を除いて、位置エイリアシングは成分エイリアシングを起こさない場合に限り許される。さらに、位置エイリアシングを行う場合、その位置を共有するエイリアスは、内在する数値型とビット幅が同じでなければならず、補助格納修飾子と補間修飾子も同じでなければならない。成分エイリアシングが許可される例外とは、頂点シェーダーへの二つの入力変数（ブロックメンバーではない）に対して OpenGL を対象にする場合で、これらは成分エイリアシングが許されている。この頂点変数の成分エイリアシングは、各実行パスがエイリアシングされた各成分ごとに高々一つの入力にアクセスする頂点シェーダーをサポートすることしか目的としていない。頂点シェーダー実行形式を通るすべての実行パスが、任意の単一成分にエイリアスされた複数の入力にアクセスすることを検出した場合、実装はこれをリンクタイムエラーとすることが許されているが、必須ではない。</p>
<section id="tessellation-evaluation-inputs">
<h3>Tessellation Evaluation Inputs<a class="headerlink" href="#tessellation-evaluation-inputs" title="Permalink to this headline">¶</a></h3>
<p>多角形分割評価シェーダーで使える追加的な入力レイアウト修飾子の識別子は次の通り：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>primitive-mode</em></div>
<div class="line"><em>vertex-spacing</em></div>
<div class="line"><em>ordering</em></div>
<div class="line"><em>point-mode</em></div>
</div>
</div>
<p>識別子 <em>primitive-mode</em> は多角形分割基本形状生成器が使用する。</p>
<div class="line-block">
<div class="line"><em>primitive-mode</em>:</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">quads</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">isolines</span></code></div>
</div>
</div>
<p><em>primitive-mode</em> がもしあれば、多角形分割基本形状生成器は三角形をより小さな三角形に、四角形を三角形に、四角形を線の集合体にそれぞれ細分するべきだと指定する。</p>
<p>レイアウト識別子の二番目のグループである頂点間隔は、多角形分割基本形状生成器が辺を細分化する際の間隔を指定するために用いられる。</p>
<div class="line-block">
<div class="line"><em>vertex-spacing</em>:</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">equal_spacing</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">fractional_even_spacing</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">fractional_odd_spacing</span></code></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">equal_spacing</span></code> は辺を同じ大きさのセグメントの集まりに分割することを指定する。</p>
<p><code class="docutils literal notranslate"><span class="pre">fractional_even_spacing</span></code> は、辺を偶数個の同じ長さのセグメントとさらに二つのより短い「小数」のセグメントに分割することを指定する。</p>
<p><code class="docutils literal notranslate"><span class="pre">fractional_odd_spacing</span></code> は、辺を奇数個の同じ長さのセグメントとさらに二つの短い「小数」セグメントに分割することを指定する。</p>
<p>三番目のレイアウト識別子である <em>ordering</em> は、多角形分割基本形状生成器が、
OpenGL 仕様にある座標系に従い、時計回りまたは反時計回りのどちらの順序で三角形を生成するのかを指定する。</p>
<div class="line-block">
<div class="line"><em>ordering</em>:</div>
<div class="line-block">
<div class="line">cw</div>
<div class="line">ccw</div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">cw</span></code> と <code class="docutils literal notranslate"><span class="pre">ccw</span></code> は、それぞれ時計回りと反時計回りの三角形を示す。多角形分割基本形状生成器が三角形を生成しない場合、この順序は無視される。</p>
<p>最後の <em>point-mode</em> は、多角形分割基本形状生成器が、線や三角形を生成するのではなく、細分化された基本形状のそれぞれの紛れのない頂点に対して一点を生成するべきであることを示す。</p>
<div class="line-block">
<div class="line"><em>point-mode</em>:</div>
<div class="line-block">
<div class="line">point_mode</div>
</div>
</div>
<hr class="docutils" />
<p>これらの識別子は、単一の入力レイアウト宣言の中で、一回またはそれ以上指定することができる。プログラムの多角形分割評価シェーダーの中で、
<em>primitive-mode</em>, <em>vertex-spacing</em>, <em>ordering</em> が複数回宣言されている場合、そのような宣言はすべて同じ識別子を使用しなければならない。</p>
<p>プログラム内の少なくとも一つの多角形分割評価シェーダー（コンパイル単位）は、その入力レイアウトで <em>primitive-mode</em> を宣言しなければならない。
<em>vertex-spacing</em>, <em>ordering</em>, <em>point_mode</em> 識別子の宣言はオプションだ。プログラム内の多角形分割評価シェーダーすべてが <em>primitive_mode</em> を宣言するということは必須ではない。
<em>vertex-spacing</em> や <em>ordering</em> の宣言が省略された場合、多角形分割基本形状生成器は、それぞれ等間隔または反時計回りの頂点順序を採用する。
<em>point-mode</em> の宣言が省略された場合、多角形分割基本形状生成器は、
<em>primitive-mode</em> に従って線分または三角形を生成する。</p>
</section>
<section id="geometry-shader-inputs">
<h3>Geometry Shader Inputs<a class="headerlink" href="#geometry-shader-inputs" title="Permalink to this headline">¶</a></h3>
<p>幾何シェーダー入力に対する追加のレイアウト修飾子識別子には、基本形状 (primitive) 識別子と呼び出し回数 (invocation count) 識別子がある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">points</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">lines</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">invocations</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">points</span></code>, <code class="docutils literal notranslate"><span class="pre">lines</span></code>, <code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code>, <code class="docutils literal notranslate"><span class="pre">triangles</span></code>, <code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code>
は、幾何シェーダーが受け付ける入力基本形状の種類を指定するためのもので、これらのうちただ一つを受け付ける。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、この入力基本形状のレイアウトを宣言しなければならず、プログラム内の幾何シェーダーすべての入力レイアウト宣言は同じレイアウトを宣言しなければならない。プログラム内のすべての幾何シェーダーが入力基本形状レイアウトを宣言することは必須ではない。</p>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">invocations</span></code> は、受けとった入力基本形状それぞれに対して幾何シェーダー実行形式が呼び出される回数を指定するために用いられる。回数の宣言はオプションだ。プログラム内のどの幾何シェーダーでも回数が宣言されていない場合、幾何シェーダーは入力基本形状それぞれに対して一度実行される。宣言されている場合は、すべての宣言で同じ回数を指定しなければならない。シェーダーが実装依存の最大値を超える呼び出し回数を指定したり、ゼロ以下の呼び出し回数を指定したりすると、コンパイルエラーとなる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">invocations</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>例えば上の宣言では、幾何シェーダーへの入力はすべて三角形であり、幾何シェーダーの実行形式は、処理される三角形ごとに 6 回実行される。</p>
<p>幾何シェーダー入力サイズなし配列宣言のすべてで、以前の入力基本形状レイアウト修飾子がある場合、サイズが変更される：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">points</span></code>: 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lines</span></code>: 2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lines_adjacency</span></code>: 4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangles</span></code>: 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangles_adjacency</span></code>: 6</p></li>
</ul>
<p>内在的に宣言された入力配列 <code class="docutils literal notranslate"><span class="pre">gl_in[]</span></code> は、任意の入力基本形状レイアウト宣言によってもサイズが決定される。そのため、式 <code class="docutils literal notranslate"><span class="pre">gl_in.length()</span></code> 式は上にある値を返す。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_in</span></code> などの内在的に宣言された入力、配列サイズを持たずに宣言された入力については、メソッド <code class="docutils literal notranslate"><span class="pre">length()</span></code> を使用する前か、配列サイズを知る必要のあるその他の配列使用の前にレイアウトを宣言しなければならない。</p>
<p>レイアウト宣言の配列サイズが、同じシェーダー内の入力変数の宣言で指定されている明示的な配列サイズすべてと一致しない場合はコンパイルエラーとなります。コンパイルエラーの例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// code sequence within one shader...</span>
<span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color1</span><span class="p">[];</span>     <span class="c1">// legal, size still unknown</span>
<span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="c1">// legal, size is 2</span>
<span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>    <span class="c1">// illegal, input sizes are inconsistent</span>
<span class="k">layout</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>     <span class="c1">// legal for Color2, input size is 2, matching Color2</span>
<span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color4</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>    <span class="c1">// illegal, contradicts layout of lines</span>
<span class="k">layout</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>     <span class="c1">// legal, matches other layout() declaration</span>
<span class="k">layout</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span> <span class="c1">// illegal, does not match earlier layout() declaration</span>
</pre></div>
</div>
<p>プログラム内の幾何シェーダーすべてにおいて、提供されたサイズのすべて（サイズ付き入力配列とレイアウトサイズ）が一致しない場合は、リンクエラーとなる。</p>
</section>
<section id="fragment-shader-inputs">
<h3>Fragment Shader Inputs<a class="headerlink" href="#fragment-shader-inputs" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> には以下のような追加的フラグメントレイアウト修飾子がある：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code></div>
</div>
</div>
<p>OpenGL の <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> は既定ではウィンドウの座標は左下を原点とし、ピクセル中心は半ピクセルの座標にあるとしている。例えば、ウィンドウの左下端のピクセルに対しては
<code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> 座標 <code class="docutils literal notranslate"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></code> が返される。原点は <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> に <code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code> 修飾子を付けて再宣言することで変更することができ、
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の原点をウィンドウの左上に移動させ、
<code class="docutils literal notranslate"><span class="pre">y</span></code> はウィンドウの下に向かって値を大きくしていく。また、返される値は、<code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> によって、
<code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> の両方で半ピクセルずつずらすことができ、ピクセルが整数のオフセットで中心に置かれているように見える。これは <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> で返される <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> の値が既定値が <code class="docutils literal notranslate"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></code> であるのに対し、
<code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> で <code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.0)</span></code> に移動する。</p>
<p>Vulkan を対象にする場合、<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の原点は左上で、ピクセル中心は半ピクセル座標に配置されていると仮定し、要求される。この原点を明示的に設定するには <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を <code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code> 識別子で再宣言する。</p>
<p>再宣言は次のように行う：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FragCoord</span><span class="p">;</span> <span class="c1">// redeclaration that changes nothing is allowed</span>

<span class="c1">// All the following are allowed redeclaration that change behavior</span>
<span class="k">layout</span><span class="p">(</span><span class="n">origin_upper_left</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FragCoord</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">pixel_center_integer</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FragCoord</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">origin_upper_left</span><span class="p">,</span> <span class="n">pixel_center_integer</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FragCoord</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> がプログラム内のいずれかのフラグメントシェーダーで再宣言された場合、そのプログラム内で <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を静的に使用しているすべてのフラグメントシェーダーで再宣言されなければならない。単一のプログラム内にあるフラグメントシェーダーすべてにおける <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の再宣言はすべてが同じ修飾子の集合でなければならない。どのシェーダー内でも <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の最初の再宣言が
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> のどの使用の前にも現れなければならない。組み込み <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> はフラグメントシェーダーでしか事前に宣言されていないので、他のシェーダー言語で再宣言するとコンパイルエラーになる。</p>
<p><code class="docutils literal notranslate"><span class="pre">origin_upper_left</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">pixel_center_integer</span></code> 修飾子の両方とも、またはいずれか一方をつけて
<code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> を再宣言しても <code class="docutils literal notranslate"><span class="pre">gl_FragCoord.x</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_FragCoord.y</span></code> にしか影響しない。ラスタライズ、座標変換、その他の API パイプラインや言語機能には影響しない。</p>
<p>フラグメントシェーダーでは、OpenGL 仕様書の 15.2.4 “Early Fragment Tests” に記載されているように、フラグメントシェーダーの実行前にフラグメントテストを行うことを要求するために、
<code class="docutils literal notranslate"><span class="pre">in</span></code> のみで次のレイアウト修飾子を使用することが許される（変数宣言では不可）：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line">early_fragment_tests</div>
</div>
</div>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">early_fragment_tests</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>例えば上の宣言では、フラグメントシェーダーの実行前にフラグメントごとのテストが行われるようになる。これを宣言しない場合は、フラグメントシェーダーの実行後にフラグメントごとのテストが行われる。この宣言が必要となるのは、一つのフラグメントシェーダー（コンパイル単位）だけだが、複数のフラグメントシェーダーが宣言することもできる。少なくとも一つがこれを宣言していれば有効になる。</p>
</section>
<section id="compute-shader-inputs">
<h3>Compute Shader Inputs<a class="headerlink" href="#compute-shader-inputs" title="Permalink to this headline">¶</a></h3>
<p>計算シェーダー入力にはレイアウト位置修飾子がない。</p>
<p>計算シェーダー入力に対するレイアウト修飾子の識別子は、作業グループサイズ修飾子だ：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_x</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_y</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>If a shader does not specify a size for one of the dimensions, that dimension will have a size of 1.</p>
<p>For example, the following declaration in a compute shader
<code class="docutils literal notranslate"><span class="pre">local_size_x</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_y</span></code>, <code class="docutils literal notranslate"><span class="pre">local_size_z</span></code> 各修飾子は、それぞれ 1, 2, 3 次元の計算シェーダーによる固定作業グループのサイズを宣言するために用いられる。シェーダーが次元のサイズをここから指定していない場合、その次元は 1 となる。</p>
<p>例えば、計算シェーダーで次のように宣言した場合、</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>作業グループサイズが 32×32 要素の二次元計算シェーダーを宣言するために用いられる。これは、3次元目のサイズが 1 である三次元計算シェーダーに相当する。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>上の一文は何を言っているのか。</p>
</div>
<p>もう一つ別の例として、次の宣言は、一次元の計算シェーダーがコンパイルされており、そのサイズが実質的には 8 要素であることを指定している：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>いずれかの次元におけるシェーダーの固定作業グループサイズがゼロ以下、または実装でサポートされる最大サイズよりも大きい場合、コンパイルエラー。また、このようなレイアウト修飾子が同一シェーダー内で複数回宣言されている場合、それらの宣言はすべて同じ作業グループサイズの集合を設定し、同じ値を設定しなければならない。さもなければコンパイルエラー。単一のプログラムオブジェクトに取り付けられた複数の計算シェーダーが固定作業グループサイズを宣言する場合、その宣言は同一でなければならない。さもなければリンクエラー。</p>
<p>さらに、プログラムオブジェクトが計算シェーダーを何か含む場合、少なくとも一つはプログラムの固定作業グループサイズを指定する入力レイアウト修飾子を含まなければならない。さもなければリンクエラー。</p>
</section>
</section>
<section id="output-layout-qualifiers">
<h2>4.4.2. Output Layout Qualifiers<a class="headerlink" href="#output-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>出力レイアウト修飾子には、シェーダー段階すべてに適用されるものと、特定の段階にしか適用されないものがある。ここでは前者を議論する。</p>
<p>入力レイアウト修飾子と同様に、計算シェーダーを除くすべてのシェーダーでは、出力変数宣言、出力ブロック宣言、出力ブロックメンバー宣言に対して <code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子を許す。このうち、変数とブロックメンバー（ブロックは不可）には、さらに <code class="docutils literal notranslate"><span class="pre">component</span></code> レイアウト修飾子を許す。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">component</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>ブロックや構造体に <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子や <code class="docutils literal notranslate"><span class="pre">component</span></code> 修飾子を適用する際の使い方やルールは
<a class="reference internal" href="#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a> のとおりだ。また、フラグメントシェーダーの出力では、二つの変数が同じ位置に配置される場合、それらの変数の内容される型は同じでなければならない（浮動小数点・整数）。出力変数やメンバーの成分エイリアスは許されない。</p>
<p>Fragment shaders allow an additional index output layout qualifier:
フラグメントシェーダーでは <code class="docutils literal notranslate"><span class="pre">index</span></code> 出力レイアウト修飾子を追加的に付けられる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">index</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらの修飾子は、それぞれ高々一度現れる。
<code class="docutils literal notranslate"><span class="pre">index</span></code> が指定された場合 <code class="docutils literal notranslate"><span class="pre">location</span></code> も指定しなければならない。
<code class="docutils literal notranslate"><span class="pre">index</span></code> が指定されていない場合は値 0 が使用される。</p>
<p>例えば次のフラグメントシェーダーでは、フラグメントシェーダー出力色を混合方程式の最初（インデックス 0）の入力としてフラグメントカラー 3 に割り当てる設定をする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">color</span><span class="p">;</span>
</pre></div>
</div>
<p>次の例は、フラグメントシェーダーの出力係数が、混合方程式の 2 番目（インデックス 1）の入力としてフラグメント色 3 に割り当てる設定をする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">factor</span><span class="p">;</span>
</pre></div>
</div>
<p>フラグメントシェーダーの出力では、位置とインデックスは、出力の値を受け取る色出力番号とインデックスを指定する。他のすべてのシェーダー段階の出力では、位置は、後続のシェーダー段階の入力と照合するために使用できるベクトル番号を指定する（シェーダーが別のプログラムオブジェクトにある場合も同様）。</p>
<p>宣言された出力が <code class="docutils literal notranslate"><span class="pre">dvec3</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 以外のスカラーまたはベクトル型である場合は、単一の位置を消費する。
<code class="docutils literal notranslate"><span class="pre">dvec3</span></code> または <code class="docutils literal notranslate"><span class="pre">dvec4</span></code> 型の出力は連続した二つの場所を消費する。
<code class="docutils literal notranslate"><span class="pre">double</span></code> 型や <code class="docutils literal notranslate"><span class="pre">dvec2</span></code> 型の出力は全ての段階で一つの位置しか消費しない。</p>
<p>宣言された出力が配列の場合は、指定された場所から連続した場所が割り当てられる。例えば、次の宣言ではベクトルの位置番号 2, 3, 4 に <code class="docutils literal notranslate"><span class="pre">colors</span></code> が割り当てられる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</pre></div>
</div>
<p>宣言された出力が n×m の行列の場合、指定された位置から始まる複数の位置が割り当てられる。割り当てられる場所の数は m 成分ベクトルの n 要素の配列と同じだ。</p>
<p>宣言された出力が構造体の場合、そのメンバーには宣言された順に連続した場所が割り当てられ、構造体に指定された場所が最初のメンバーに割り当てられる。構造体のメンバーが消費する位置の個数は、その構造体のメンバーが同じ型の出力変数として宣言されているかのように、前述の規則が再帰的に適用される。</p>
<p><code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子は、構造体として宣言された出力変数に使用することができる。ただし、構造体メンバーに <code class="docutils literal notranslate"><span class="pre">location</span></code> 修飾子を使用するとコンパイルエラーとなる。
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子は出力ブロックと出力ブロックメンバーに使用できる。</p>
<p>シェーダーで使用できる出力位置の数は限界がある。フラグメントシェーダーでは、その限界は公表されたドローバッファー数だ。</p>
<p>その他のシェーダーの場合、制限は実装依存であり、公表されている最大出力成分数の 1/4 以上でなければならない（計算シェーダーには出力がない）。取り付けられたシェーダーがサポートされている個数以上の位置を使用している場合、デバイス依存最適化によってプログラムが利用可能なハードウェア資源内に収まるようにしない限り、プログラムはリンクに失敗する。</p>
<p>また、コンパイル時にリンクが失敗することがわかっている場合には、コンパイルエラーがあり得る。出力位置が負の場合は、コンパイルエラーになる。フラグメントシェーダーがレイアウトインデックスを 0 未満または 1 以上に設定した場合も、コンパイルエラーとなる。</p>
<p>次のいずれかが発生すると、コンパイルエラーまたはリンクエラー：</p>
<ul class="simple">
<li><p>フラグメントシェーダーの出力変数の二つが両者とも同じ位置とインデックスに割り当てられている。</p></li>
<li><p>同じ（頂点｜多角形分割｜幾何）シェーダー段階からの出力変数二つが同じ位置に割り当てられている。</p></li>
</ul>
<p>フラグメントシェーダー出力では <code class="docutils literal notranslate"><span class="pre">layout</span></code> 修飾子または OpenGL API を使用して位置を割り当てることができる。</p>
<p>すべてのシェーダー型において、明示的な位置の割り当てが明示的な割り当てのない他の変数のための空間をリンカーに見つけさせられなくなる場合、プログラムはリンクに失敗する。</p>
<p>シェーダーテキストで位置やインデックスが割り当てられていない出力変数が
OpenGL API を通じて位置を指定されている場合は API で指定された位置が採用される。それ以外の場合は、リンカーがそのような変数に場所を割り当てる。このような割り当てはすべて、色インデックスがゼロになる。詳細は、OpenGL 仕様書の 15.2 Shader Execution を参照。出力変数が同じ言語の複数のシェーダで宣言されており、位置やインデックスの値が衝突している場合、リンクエラーが発生する。</p>
<p>フラグメントではない出力が後続のあるシェーダー段階からの入力と一致するかどうかを判定するために、
<code class="docutils literal notranslate"><span class="pre">location</span></code> レイアウト修飾子が（もしあれば）一致しなければならない。</p>
<section id="transform-feedback-layout-qualifiers">
<h3>Transform Feedback Layout Qualifiers<a class="headerlink" href="#transform-feedback-layout-qualifiers" title="Permalink to this headline">¶</a></h3>
<p>頂点、多角形分割、幾何各段階では、シェーダーが変換反響を制御することができる。それをするときに、シェーダーはどの変換反響バッファーを使用するか、どの出力変数をどのバッファーに書き込むか、各バッファーをどのようにレイアウトするかを決定する。これを実現するために、シェーダでは出力宣言に次のレイアウト修飾子識別子を使用できる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらの <code class="docutils literal notranslate"><span class="pre">xfb_</span></code> 修飾子を（前処理後に）静的に使用するシェーダーは、変換反響捕捉モードとなり、変換反響の設定を記述する責任が生じる。このモードでは <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で選択された出力を、直接または間接的に、変換反響バッファーに取り込むことになる。</p>
<p>Shaders in the transform feedback capturing mode have an initial global default of
<code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で選択された出力をどの変換反響バッファーに取り込むかは
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子が指定する。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子、出力変数、出力ブロック、出力ブロックメンバーのどれにでも適用できる。変換反響捕捉モードのシェーダーには次の初期の大域既定がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>
</pre></div>
</div>
<p>この既定を変更するには、インターフェース修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> に <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> をつけて別のバッファーを宣言する。これが大域既定を変更する唯一の方法だ。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子を付けずに変数や出力ブロックを宣言した場合は、大域既定バッファーを継承する。
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> 修飾子をつけて変数や出力ブロックを宣言すると、その宣言されたバッファーを持る。あるブロックのメンバーすべてがそのブロックのバッファーを継承する。メンバーは <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> を宣言することができるが、そのバッファーはそのブロックから継承されたバッファーと一致しなければならない。そうでなければコンパイルエラー。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">xfb_offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="k">out</span> <span class="n">block</span> <span class="p">{</span> <span class="c1">// block&#39;s buffer is 2</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// okay, matches the inherited 2</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">u</span><span class="p">;</span> <span class="c1">// ERROR, mismatched buffer</span>
    <span class="kt">vec4</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// inherited</span>
<span class="p">};</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">t</span><span class="p">;</span>  <span class="c1">// initial default is buffer 0</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>          <span class="c1">// new global default of 1</span>
<span class="k">out</span> <span class="n">block</span> <span class="p">{</span>                        <span class="c1">// block has buffer 1</span>
    <span class="kt">vec4</span> <span class="n">x</span><span class="p">;</span>                        <span class="c1">// x has buffer 1 (not captured)</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// okay (not captured)</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// ERROR, mismatched buffer</span>
<span class="p">};</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">g</span><span class="p">;</span>   <span class="c1">// g has buffer 1</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">h</span><span class="p">;</span>   <span class="c1">// does not change global default</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">j</span><span class="p">;</span>  <span class="c1">// j has buffer 1</span>
</pre></div>
</div>
<p>これが意味するのは、ブロックのメンバーのうち、変換反響バッファーに行くものはすべて同じバッファーに行くということだ。</p>
<p>ブロックが配列として宣言されている場合、ブロックの配列要素 0 のメンバーすべては、前述のように、宣言または継承された <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> に取り込まれる。一般に、ブロックの大きさ N の配列は、N 個の連続したバッファに取り込まれ、ブロックの配列要素 E のメンバーすべては、バッファ B に取り込まれる。ここで、B は宣言または継承された <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> に E を加えたものに等しくなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> には、ブロックの配列を捕捉するために必要な追加のバッファーを含めて、
0 より小さいか、実装依存の定数 <code class="docutils literal notranslate"><span class="pre">gl_MaxTransformFeedbackBuffers</span></code> 以上の値を指定すると、コンパイルエラーかリンクエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> は、変換反響バッファー内のバイトオフセットを割り当てる。
<code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> をつけることができるのは、変数、ブロックメンバー、またはブロックしかない。ブロックが <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾されていれば、そのブロックのメンバーすべてに変換反響バッファー内のオフセットが割り当てられる。ブロックが <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾されていない場合、そのようなブロックのメンバーには変換反響バッファーのオフセットは割り当てられない。オフセットが割り当てられた変数やブロックメンバーだけが捕捉される（つまり、ブロックの適切な部分集合が捕捉される）。このような変数やブロックメンバーがシェーダー内で書き込まれるたびに、書き込まれた値は割り当てられたオフセットで捕捉される。シェーダーの呼び出し時の間にこのようなブロックメンバーや変数が書き込まれない場合、割り当てられたオフセットでのバッファーの内容は未定義となる。変換反響オフセットが割り当てられている変数やメンバーへの静的な書き込みがない場合でも、その空間はバッファーに割り当てられ、ストライドに影響を与える。</p>
<p><code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> で修飾された変数やブロックメンバーには、スカラー、ベクトル、行列、構造体、およびこれらの（サイズ付き）配列を指定できる。このオフセットは、最初に修飾された変数やブロックメンバーの第一成分のサイズの倍数でなければならない。そうでなければコンパイルエラー。さらに、 <code class="docutils literal notranslate"><span class="pre">double</span></code> を含む集合体に適用される場合、オフセットもバッファーに取られる空間も 8 の倍数でなければならない。与えられたオフセットは、修飾されたエンティティの最初のメンバーの最初の成分に適用される。その後、修飾された実体中で、後続の成分はそれぞれその成分のサイズの倍数に整列した、次に利用可能なオフセットに順に割り当てられる。集約型は成分レベルまで平坦化され、この成分の並びが得られる。サイズなし配列の宣言に <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を適用するとコンパイルエラー。</p>
<p>出力バッファーのエイリアシングは許されない。変換反響オフセットが重なり合っている変数を指定するとコンパイルエラーまたはリンクエラー。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> は、捕捉した各頂点が何バイト消費するかを指定する。その宣言の変換反響バッファーが継承されているか、明示的に宣言されているかに関わらず、これが適用される。この修飾子は、変数、ブロック、ブロックメンバー、あるいは単に修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> にも適用できる。バッファーが倍精度成分を持つ出力を捕捉する場合、バッファー幅は 8 の倍数であるか、そうでない場合は 4 の倍数でなければならず、そうでない場合はコンパイルエラーかリンクエラー。
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> をオーバーフローさせるような <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を持つことは、
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> の前後の宣言であろうと、異なるコンパイル単位であろうと、コンパイルエラーかリンクエラー。
<code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> は、同じバッファーに対して複数回宣言することができるが、異なる値のストライドを指定するとコンパイルエラーかリンクエラー。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// buffer 1 has 32-byte stride</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xfb_stride</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>

<span class="c1">// same as previous example; order within layout does not matter</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_stride</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>

<span class="c1">// everything in this block goes to buffer 0</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mo">0</span><span class="p">,</span> <span class="n">xfb_stride</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">out</span> <span class="n">block1</span> <span class="p">{</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// a goes to byte offset 0 of buffer 0</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// b goes to offset 16 of buffer 0</span>
<span class="p">};</span>

<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span> <span class="k">out</span> <span class="n">block2</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">v</span><span class="p">;</span>  <span class="c1">// v will be written to byte offsets 12 through 27 of buffer</span>
    <span class="kt">float</span> <span class="n">u</span><span class="p">;</span> <span class="c1">// u will be written to offset 28</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">40</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">w</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// x will be written to offset 56, the next available offset</span>
<span class="p">};</span>

<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">xfb_stride</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">out</span> <span class="n">block3</span> <span class="p">{</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span> <span class="kt">vec3</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">24</span><span class="p">)</span> <span class="kt">vec3</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// ERROR, requires stride of 36</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">vec3</span> <span class="n">g</span><span class="p">;</span>  <span class="c1">// okay, increasing order not required</span>
<span class="p">};</span>
</pre></div>
</div>
<p>バッファーに <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code> が指定されていない場合、バッファー幅は、最も高いオフセットに置かれた変数を保持するのに必要な最小値となり、必要な詰め物 (padding) も含まれる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// if there no other declarations for buffer 3, it has stride 32</span>
<span class="k">layout</span><span class="p">(</span><span class="n">xfb_buffer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">out</span> <span class="n">block4</span> <span class="p">{</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">e</span><span class="p">;</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">xfb_offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">f</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>結果のバッファー幅（暗黙的または明示的）を 4 で割って、実装依存の定数 <code class="docutils literal notranslate"><span class="pre">gl_MaxTransformFeedbackInterleavedComponents</span></code> 以下でなければならない。</p>
</section>
<section id="tessellation-control-outputs">
<h3>Tessellation Control Outputs<a class="headerlink" href="#tessellation-control-outputs" title="Permalink to this headline">¶</a></h3>
<p>変換反響レイアウト修飾子を除き、多角形分割制御シェーダーでは、出力ブロック、ブロックメンバー、または変数宣言ではなく、インターフェース修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> 上でのみ出力レイアウト修飾子を使用することができる。多角形分割制御シェーダーで使用できる出力レイアウト修飾子の識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">vertices</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">vertices</span></code> は多角形分割制御シェーダーが生成する出力パッチの頂点数を指定し、多角形分割制御シェーダーの呼び出し回数も指定します。出力頂点数がゼロ以下であったり、実装依存の最大パッチサイズより大きかったりすると、コンパイルエラーやリンクエラーとなる。</p>
<p>内在的に宣言された多角形分割制御出力配列 <code class="docutils literal notranslate"><span class="pre">gl_out[]</span></code> は、任意の出力レイアウト宣言によってもサイズが決定される。したがって、次の式は以前の出力レイアウト修飾子で指定された出力パッチの頂点数を返す：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="nb">gl_out</span><span class="p">.</span><span class="n">length</span><span class="p">()</span>
</pre></div>
</div>
<p>内在的に宣言された出力を含む、配列サイズなし宣言された出力については、メソッド <code class="docutils literal notranslate"><span class="pre">length()</span></code> の使用や、サイズを知る必要のある他の配列使用の前に、レイアウトを宣言しなければならない。</p>
<p>出力レイアウト修飾子で指定された出力パッチ頂点数が、同じシェーダー内の出力変数宣言で指定された配列サイズのどれとも一致しない場合は、コンパイルエラーとなる。</p>
<p>プログラム内のすべての多角形分割制御シェーダーのレイアウト宣言は、同じ出力パッチ頂点数を指定しなければならない。多角形分割制御シェーダーを含むプログラムには、出力パッチの頂点数を指定するレイアウト修飾子が少なくとも一つ必要だが、すべての多角形分割制御シェーダーでそのような宣言が必要ということではない。</p>
</section>
<section id="geometry-outputs">
<h3>Geometry Outputs<a class="headerlink" href="#geometry-outputs" title="Permalink to this headline">¶</a></h3>
<p>幾何シェーダーは、出力基本形状型、最大出力頂点数、出力ごとのストリーム番号の三種の出力レイアウト識別子を追加的に持てる。基本形状型と頂点数の識別子は、出力ブロック、ブロックメンバー、変数宣言ではなく、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code>
でしか許されない。ストリーム識別子は、インターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code>,
出力ブロック、変数宣言上で許される。</p>
<p>幾何シェーダー出力に対するレイアウト修飾子の識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">points</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">line_strip</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">triangle_strip</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">stream</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>基本形状型識別子の <code class="docutils literal notranslate"><span class="pre">points</span></code>, <code class="docutils literal notranslate"><span class="pre">line_strip</span></code>, <code class="docutils literal notranslate"><span class="pre">triangle_strip</span></code> は、幾何シェーダーが生成する出力基本形状の型を指定するために使用され、これらのうちただ一つが受け入れられる。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、出力基本形状型を宣言しなければならず、プログラム内のすべての幾何シェーダーの出力基本形状型宣言は、同じ基本形状型を宣言しなければならない。プログラム内のすべての幾何シェーダーが出力基本形状型宣言をすることは必須ではない。</p>
<p>頂点数識別子 <code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> は、シェーダーが単一の呼び出しで出力する最大の頂点数を指定するために使用される。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、最大出力頂点数を宣言しなければならず、プログラム内のすべての幾何シェーダーの出力頂点数宣言は、同じ回数を宣言しなければなりません。プログラム内のすべての幾何シェーダーが回数を宣言することは必須ではありません。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">60</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span> <span class="c1">// order does not matter</span>
<span class="k">layout</span><span class="p">(</span><span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">60</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>  <span class="c1">// redeclaration okay</span>
<span class="k">layout</span><span class="p">(</span><span class="n">triangle_strip</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>     <span class="c1">// redeclaration okay</span>
<span class="k">layout</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>             <span class="c1">// error, contradicts triangle_strip</span>
<span class="k">layout</span><span class="p">(</span><span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">30</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>  <span class="c1">// error, contradicts 60</span>
</pre></div>
</div>
<p>この例では、幾何シェーダーからの出力はすべて三角形であって、シェーダーから出力されるのは高々 60 個の頂点だ。最大の頂点数が <code class="docutils literal notranslate"><span class="pre">gl_MaxGeometryOutputVertices</span></code> よりも大きい場合はエラーとなる。</p>
<p>識別子 <code class="docutils literal notranslate"><span class="pre">stream</span></code> は、幾何シェーダーの出力変数またはブロックが、特定の頂点ストリーム（ゼロから始まる番号）に関連付けられていることを指定するために用いられる。ストリーム番号の既定値を、次の例のようにインターフェイス修飾子 <code class="docutils literal notranslate"><span class="pre">out</span></code> によって大域スコープで宣言することができる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">stream</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>
</pre></div>
</div>
<p>このような宣言で指定されたストリーム番号は、それまでの既定値を置き換え、新しい既定値が設定されるまで、後続のすべてのブロックおよび変数の宣言に適用される。初期設定のストリーム番号はゼロです。</p>
<p>各出力ブロックまたは非ブロック出力変数は、頂点ストリームに関連付けられる。ブロックまたは変数がストリーム識別子とともに宣言されている場合は、指定されたストリームに関連付けられ、そうでない場合は、現在の既定ストリームに関連付けられる。ブロックメンバーはストリーム識別子を付けて宣言することができるが、指定されたストリームは含まれるブロックに関連付けられたそれと一致しなければならない。例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>           <span class="c1">// default is now stream 1</span>
<span class="k">out</span> <span class="kt">vec4</span> <span class="n">var1</span><span class="p">;</span>                  <span class="c1">// var1 gets default stream (1)</span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">out</span> <span class="n">Block1</span> <span class="p">{</span>   <span class="c1">// &quot;Block1&quot; belongs to stream 2</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="kt">vec4</span> <span class="n">var2</span><span class="p">;</span> <span class="c1">// redundant block member stream decl</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="kt">vec2</span> <span class="n">var3</span><span class="p">;</span> <span class="c1">// ILLEGAL (must match block stream)</span>
    <span class="kt">vec3</span> <span class="n">var4</span><span class="p">;</span>                  <span class="c1">// belongs to stream 2</span>
<span class="p">};</span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>           <span class="c1">// default is now stream 0</span>
<span class="k">out</span> <span class="kt">vec4</span> <span class="n">var5</span><span class="p">;</span>                  <span class="c1">// var5 gets default stream (0)</span>
<span class="k">out</span> <span class="n">Block2</span> <span class="p">{</span>                    <span class="c1">// &quot;Block2&quot; gets default stream (0)</span>
    <span class="kt">vec4</span> <span class="n">var6</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">layout</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">var7</span><span class="p">;</span> <span class="c1">// var7 belongs to stream 3</span>
</pre></div>
</div>
<p>幾何シェーダーで出力された各頂点は、特定のストリームに割り当てられ、出力された頂点の属性は、対象となるストリームに割り当てられた出力ブロックと変数の集合から取得される。各頂点が放出された後、すべての出力変数の値は未定義となる。さらに、各頂点ストリームに関連する出力変数は、格納を共有してもよい。あるストリームに関連する出力変数に書き込むと、他のストリームに関連する出力変数が上書きされることがある。幾何シェーダーは、各頂点を放出する際に、その頂点が放出されるストリームに関連するすべての出力に書き込み、他のストリームに関連する出力には書き込まない。</p>
<p>幾何シェーダー出力ブロックや同変数が複数回宣言された場合、そのような宣言のすべてで、その変数は同じ頂点ストリームに関連付けられなければならない。存在しないストリーム番号を指定したストリーム宣言がある場合、シェーダーのコンパイルは失敗する。</p>
<p>組み込み幾何シェーダー出力は頂点ストリーム 0 に常に関連付けられる。</p>
<p>プログラム内のすべての幾何シェーダー出力レイアウト宣言は、同じレイアウトと同じ <code class="docutils literal notranslate"><span class="pre">max_vertices</span></code> 値を宣言しなければならない。幾何シェーダーがプログラムに含まれている場合、そのプログラムのどこかに少なくとも一つの幾何出力レイアウト宣言がなければならないが、すべての幾何シェーダー（コンパイル単位）がそれを宣言する必要はない。</p>
</section>
<section id="fragment-outputs">
<h3>Fragment Outputs<a class="headerlink" href="#fragment-outputs" title="Permalink to this headline">¶</a></h3>
<p>組み込みフラグメントシェーダ変数 <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> は、次のレイアウト修飾子のいずれかを使用して再宣言することができる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_any</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_greater</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_less</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">depth_unchanged</span></code></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> に対するレイアウト修飾子は、任意のシェーダー呼び出しによって書き込まれる
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値の意図を制約する。レイアウト修飾子に整合する <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のすべての値が失敗（合格）する場合には、与えられたフラグメントに対して奥行きテストが失敗（合格）すると仮定して最適化を行うことが GL 実装はできる。これには、フラグメントがさえぎられ、シェーダーに副作用がないために廃棄される場合に、シェーダーの実行を飛ばすことが含まれる可能性がある。
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値がそのレイアウト修飾子と整合しない場合、対応するフラグメントの奥行きテストの結果は未定義となる。しかし、この場合にはエラーとはならない。奥行きテストが合格し、奥行き書き込みが有効な場合、奥行きバッファーに書き込まれる値は、レイアウト修飾子と整合しているか否かに関わらず、常に <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の値となる。</p>
<p>既定では <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> は <code class="docutils literal notranslate"><span class="pre">depth_any</span></code> として修飾される。
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のレイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_any</span></code> の場合、シェーダーコンパイラーは <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> への割り当てが未知の方法で変更されていることに留意し、奥行きテストは常にシェーダーの実行後に行われる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_greater</span></code> の場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最終値が <code class="docutils literal notranslate"><span class="pre">gl_FragCoord</span></code> の <code class="docutils literal notranslate"><span class="pre">z</span></code> 成分で与えられるフラグメントの補間奥行き値以上であると仮定することができる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_less</span></code> の場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> を修正してもその値が減少するだけだと考えることができる。レイアウト修飾子が <code class="docutils literal notranslate"><span class="pre">depth_unchanged</span></code> の場合、シェーダーコンパイラーは
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> のいかなる修正も尊重するが、他の部分は <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code>
に新しい値が割り当てられていないと仮定することができる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の再宣言は以下のように行われる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// redeclaration that changes nothing is allowed +</span>
<span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>

<span class="c1">// assume it may be modified in any way</span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_any</span><span class="p">)</span> <span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>

<span class="c1">// assume it may be modified such that its value will only increase</span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_greater</span><span class="p">)</span> <span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>

<span class="c1">// assume it may be modified such that its value will only decrease</span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_less</span><span class="p">)</span> <span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>

<span class="c1">// assume it will not be modified</span>
<span class="k">layout</span><span class="p">(</span><span class="n">depth_unchanged</span><span class="p">)</span> <span class="k">out</span> <span class="kt">float</span> <span class="nb">gl_FragDepth</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> がプログラム内のいずれかのフラグメントシェーダーで再宣言された場合、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> への静的割り当てを持つそのプログラム内のフラグメントシェーダーすべてで再宣言されなければならない。単一プログラム内のフラグメントシェーダーすべてにおける
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の再宣言のすべてが同じ修飾子の集合を持たなければならない。どのシェーダー内でも、
<code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> の最初の再宣言がその使用よりも前に現れなければならない。組み込み <code class="docutils literal notranslate"><span class="pre">gl_FragDepth</span></code> はフラグメントシェーダーでのみ事前宣言されているので、他のシェーダー言語で再宣言するとコンパイルエラーになる。</p>
</section>
</section>
<section id="uniform-variable-layout-qualifiers">
<h2>4.4.3. Uniform Variable Layout Qualifiers<a class="headerlink" href="#uniform-variable-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>レイアウト修飾子は、一様変数とサブルーチン一様に使用できる。一様変数とサブルーチン一様（変数）に対するレイアウト修飾子識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">location</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>位置識別子は、既定ブロック一様変数とサブルーチン一様（変数）で使用できる。位置は、API が一様を参照し、その値を更新するための位置を指定する。一様配列の個々の要素には連続した位置が割り当てられ、最初の要素は位置 <code class="docutils literal notranslate"><span class="pre">location</span></code> だ。プログラム内でリンクされた同じ位置を共有する既定ブロック一様変数宣言は、名前、型、修飾子、配列性が一致しなければならない。配列の場合は、配列の次元と配列のサイズが一致していなければならない。構造体の場合、この規則がメンバーすべてに再帰的に適用される。サブルーチン一様変数二つが同じシェーダー段階内で同じ位置に存在することはできない。コンパイルエラーかリンクエラーとなる。既定ブロック変数の有効な位置は、0 から実装定義の一様位置の最大数から 1 を引いた範囲にある。サブルーチン一様（変数）の有効な位置は、0 から実装定義の段階ごとのサブルーチン一様（変数）の最大位置数から 1 を引いた値までの範囲にある。</p>
<p>位置は既定ブロック一様配列や構造体に割り当てることができる。最も内側にある最初のスカラー、ベクトル、行列のメンバーや要素は指定された <code class="docutils literal notranslate"><span class="pre">location</span></code> を取り、コンパイラーは次の最も内側にあるメンバーや要素に次の増分の位置値を割り当てる。それ以降の最内側のメンバーや要素は、構造体や配列全体の増分の位置を取得します。この規則は、入れ子になった構造体や配列にも適用され、最も内側にあるスカラー、ベクトル、行列の各メンバーに一意の位置を与える。明示的サイズのない配列の場合は、静的な使用量に基づいてサイズが計算される。リンカーが明示的位置のない一様（変数）の位置を生成する場合、明示的位置のある一様（変数）すべてについて、その配列要素や構造体のメンバーがすべて使用されていると仮定し、その要素やメンバーが使用されていないと判断された場合でも、リンカーは競合する位置を生成しない。</p>
<p>個々の（既定ブロック）透明一様変数を受け入れる API に対する SPIR-V を生成するとき、それらを宣言するときに位置を含めないとコンパイルエラー。</p>
<p>Vulkan を対象にしている場合、修飾子 <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> はブロック全体を宣言するために使用され、
Vulkan API で定義されているように、定数 <code class="docutils literal notranslate"><span class="pre">push</span></code> の集合を表す。これを一様ブロック宣言以外に適用したり、Vulkan を対象にしていない場合はコンパイルエラー。ブロック内の値は Vulkan API の仕様に基づいて初期化される。
<code class="docutils literal notranslate"><span class="pre">layout(push_constant)</span></code> で宣言されたブロックは、オプションで <em>instance-name</em> を含めることができる。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> ブロックは段階ごとに一つだけで、そうでない場合はコンパイルエラーやリンクエラー。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> 配列は、動的一様なインデックスでしかインデックスを付けられない。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> で宣言された一様ブロックは、宣言されていないブロックとは異なる資源を使用し、別々に計上される。</p>
</section>
<section id="subroutine-function-layout-qualifiers">
<h2>4.4.4. Subroutine Function Layout Qualifiers<a class="headerlink" href="#subroutine-function-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>レイアウト修飾子をサブルーチン関数に使用できる。サブルーチン関数のレイアウト修飾子識別子は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">index</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>シェーダー内でインデックス修飾子を持つ各サブルーチンには、一意のインデックスが与えられなければならない。そうでない場合はコンパイルエラーまたはリンクエラー。インデックスは 0 から実装定義のサブルーチン最大数から 1 を引いた範囲でなければならない。
OpenGL サブルーチン関数列挙 API がアクティブインデックスすべてに対して空ではない名前を返すように、シェーダーは 0 から始まる飛び飛びにならないインデックス値の範囲を割り当てることを推奨するが、必須ではない。</p>
</section>
<section id="uniform-and-shader-storage-block-layout-qualifiers">
<h2>4.4.5. Uniform and Shader Storage Block Layout Qualifiers<a class="headerlink" href="#uniform-and-shader-storage-block-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>レイアウト修飾子は一様およびシェーダー格納ブロックに使用できるが、非ブロック一様宣言には使用できない。一様およびシェーダー格納ブロックのレイアウト修飾子の識別子（および <code class="docutils literal notranslate"><span class="pre">shared</span></code> キーワード）は次のとおり：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">shared</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">packed</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">std140</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">std430</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">row_major</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">column_major</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">offset</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">align</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>これらはいずれも、宣言されている変数の使用法に意味的な影響を全く与えず、メモリー内でのデータの配置方法を示すに過ぎない。例えば、行列のセマンティクスは、どのようなレイアウト修飾子が使用されていても、この仕様の他の部分で述べられたように、常に列に基づく。</p>
<p>（一様｜シェーダー格納）ブロックレイアウト修飾子は、大域スコープ、単一の（一様｜シェーダー格納ブロック｜ブロックメンバー）宣言上で宣言することができる。</p>
<p>一様ブロックには大域スコープでの既定レイアウトが次のように設定されている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">layout</span><span class="o">-</span><span class="n">qualifier</span><span class="o">-</span><span class="n">id</span><span class="o">-</span><span class="n">list</span><span class="p">)</span> <span class="k">uniform</span><span class="p">;</span>
</pre></div>
</div>
<p>シェーダー格納ブロックの場合には：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">layout</span><span class="o">-</span><span class="n">qualifier</span><span class="o">-</span><span class="n">id</span><span class="o">-</span><span class="n">list</span><span class="p">)</span> <span class="k">buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>これが行われると、直前の既定修飾がまず継承され、それから宣言にある各修飾について、以下に述べる上書き規則に従って上書きされる。その結果、後続の（一様｜シェーダー格納）ブロックの定義に適用される新しい既定修飾となる。</p>
<p>SPIR-V を生成する際のコンパイルの初期状態は、次のように宣言されたかのようなものだ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span> <span class="k">uniform</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">std430</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span> <span class="k">buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>ところが <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> を宣言すると、バッファーの既定レイアウトは
<code class="docutils literal notranslate"><span class="pre">std430</span></code> になる。この既定を大域的に設定する方法はない。</p>
<p>The initial state of compilation when not generating SPIR-V is as if the following were declared:
SPIR-V を生成していないときのコンパイルの初期状態は、次のように宣言されたかのようなものだ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span> <span class="k">uniform</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span> <span class="k">buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>（一様｜シェーダー格納）ブロックは、オプションでレイアウト修飾子を付けて宣言することができ、その個々のメンバー宣言も同様だ。このようなブロックレイアウト修飾は、ブロックの内容にのみ適用される。大域レイアウト宣言と同様に、ブロックレイアウト修飾は、まず現在の既定の修飾を継承し、次にそれを上書きする。同様に、個々のメンバーのレイアウト修飾は、メンバー宣言だけに適用され、ブロックの修飾を継承して上書きする。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">shared</span></code> は <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>, および <code class="docutils literal notranslate"><span class="pre">packed</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。コンパイラーかリンカーは、すべての配列が明示的なサイズで宣言され、すべての行列が一致する <code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子と
<code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子の両方を、または一方を（ブロック定義外の宣言から得られる場合もある）持つ限り、この定義を含む複数のプログラムおよびプログラム可能段階が、このブロックのために同じメモリーレイアウトを共有することを保証する。これにより、異なるプログラム間で同じバッファーを使用して同じブロック定義を back することができる。
SPIR-Vを生成する際に <code class="docutils literal notranslate"><span class="pre">shared</span></code> を使用するとコンパイルエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">packed</span></code> は <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code> のみを上書きし、その他の修飾子は継承される。
<code class="docutils literal notranslate"><span class="pre">packed</span></code> を使用した場合、共有可能なレイアウトは保証されません。コンパイラーとリンカーは、どの変数が活発的に使用されるかや、その他の条件に基づいて、メモリー使用を最適化することができる。ブロック内のどこにどの変数があるかを保証する方法が他にないため、オフセットを問い合わせる必要がある。</p>
<p>プログラム内の複数の段階で同じ充満一様ブロックやシェーダー格納ブロックにアクセスするとリンクエラー。プログラム間で同じ充満一様ブロックやシェーダー格納ブロックにアクセスしようとすると、メンバーオフセットが衝突したり、未定義の値が読み込まれたりする可能性がある。しかし、実装では充満ブロックのための標準的なレイアウトを使用することで、充満ブロックのアプリケーション管理を支援することができる。
SPIR-V の生成時に <code class="docutils literal notranslate"><span class="pre">packed</span></code> 修飾子を使用するとコンパイルエラー。</p>
<p><code class="docutils literal notranslate"><span class="pre">std140</span></code> および <code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">packed</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">std140</span></code>,
<code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。
<code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子はシェーダー格納ブロックでのみサポートされている。一様ブロックに <code class="docutils literal notranslate"><span class="pre">std430</span></code> 修飾子を使用したシェーダーは、それが <code class="docutils literal notranslate"><span class="pre">push_constant</span></code> も修飾されていない限りコンパイルエラー。</p>
<p>OpenGL 仕様書の 7.6.2.2 項 “Standard Uniform Block Layout” に記載されているように、レイアウトはこれによって明示的に決定される。したがって、上記の <code class="docutils literal notranslate"><span class="pre">shared</span></code> と同様に、結果となるレイアウトはプログラムをまたがって共有可能だ。</p>
<p>メンバー宣言のレイアウト修飾子には <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">packed</span></code>, <code class="docutils literal notranslate"><span class="pre">std140</span></code>, <code class="docutils literal notranslate"><span class="pre">std430</span></code>
の各修飾子は使用できない。これらの修飾子は、（オブジェクトなし）大域スコープまたはブロック宣言でのみ使用でき、使用しない場合はコンパイルエラー。</p>
<p><code class="docutils literal notranslate"><span class="pre">row_major</span></code> および <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子は、構造体や配列に含まれるすべての行列を含むすべての入れ子の深さの行列のレイアウトにしか影響を与えない。これらの修飾子は他の型にも適用できるが、効果はない。</p>
<p><code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子のみを上書きし、その他の修飾子は継承される。行列の行内の要素は、メモリ内で連続している。</p>
<p><code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾子は <code class="docutils literal notranslate"><span class="pre">row_major</span></code> 修飾子よりも優先されるが、その他の修飾子は継承される。行列の列内の要素は、メモリ内で連続しています。</p>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子は（一様｜シェーダ格納）ブロックに対応する一様バッファー束縛点を指定し、ブロックのメンバ変数の値を取得するのに使用される。大域スコープやブロックメンバーの宣言に束縛修飾子を指定することはコンパイルエラーとなる。
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子を指定せずに宣言された（一様｜シェーダー格納）ブロックは、最初はブロック束縛点 0 に割り当てられる。プログラムがリンクされた後、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子の有無にかかわらず宣言された（一様｜シェーダー格納）ブロックに使用される束縛点は
API によって更新することができる。</p>
<p>OpenGL で使用する場合、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が配列としてインスタンス化された一様ブロックやシェーダー格納ブロックで使用されると、配列の最初の要素は指定されたブロック束縛を取り、それ以降の各要素は次の連続した束縛点を取る。配列の配列では、要素それぞれ（例えば <code class="docutils literal notranslate"><span class="pre">a[2][3]</span></code> の場合は 6 要素）が束縛点を得て、
<a class="reference internal" href="note4.html#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> で説明した配列の配列の順序に従って順序付けられる。</p>
<p>Vulkan を対象にした場合、配列としてインスタンス化された一様ブロックやバッファーブロックで <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が使用されると、配列全体が提供された束縛番号のみを受け取る。次の連続した束縛番号を別のオブジェクトで利用できる。配列の配列の場合、記述子集合アクセスに使用される記述子集合配列要素の番号は、
<a class="reference internal" href="note4.html#arrays"><span class="std std-ref">4.1.9. Arrays</span></a> で説明した配列の配列の順序に従って順序付けられる。</p>
<p>（一様｜シェーダー格納）ブロックインスタンスの束縛点がゼロより小さい場合、または対応する実装依存のバッファー束縛の最大数以上の場合は、コンパイルエラーとなる。（一様｜シェーダー格納）ブロックのインスタンスをサイズ N の配列として <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子を使用する場合、
<em>binding</em> から <em>binding</em> + N - 1 までの配列のすべての要素は、この範囲内に収まらなければならない。同じ束縛番号を複数の一様ブロックや複数のバッファーブロックに使用するとコンパイルエラーまたはリンクエラーとなる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">set</span></code> は Vulkan を対象にしている場合に限り使用できる。このオブジェクトが属する記述子集合を指定する。独立した修飾子、ブロックメンバー、または記述子集合をサポートする API を対象にしていない場合に <code class="docutils literal notranslate"><span class="pre">set</span></code> を適用するとコンパイルエラー。
<code class="docutils literal notranslate"><span class="pre">push_constant</span></code> 修飾されたブロックに <code class="docutils literal notranslate"><span class="pre">set</span></code> を適用するとコンパイルエラー。既定では <code class="docutils literal notranslate"><span class="pre">set</span></code> 識別子なしで宣言された非 <code class="docutils literal notranslate"><span class="pre">push-constant</span></code> （一様｜シェーダー格納）ブロックは、記述子集合 0に割り当てられる。同様に、
<code class="docutils literal notranslate"><span class="pre">set</span></code> 識別子なしで一様として宣言された採取器、テクスチャー、またはサブパス入力型も、記述子集合 0 に割り当てられる。</p>
<p>配列として宣言されたオブジェクトに適用された場合、その配列のすべての要素は、指定された <code class="docutils literal notranslate"><span class="pre">set</span></code> に属する。</p>
<p>SPIR-V を生成する際に <code class="docutils literal notranslate"><span class="pre">set</span></code> または <code class="docutils literal notranslate"><span class="pre">binding</span></code> の値がフロントエンド構成で指定された最大値を超えるとコンパイルエラーとなる。</p>
<p>一つのレイアウト宣言に複数の引数がリストされている場合、左から右の順に一つずる宣言されたのと同じ効果が得られる。それぞれが前の修飾の結果を引き継いで上書きする。例えば、次の例は <code class="docutils literal notranslate"><span class="pre">column_major</span></code> 修飾になる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">row_major</span><span class="p">,</span> <span class="n">column_major</span><span class="p">)</span>
</pre></div>
</div>
<p>さらなる例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="k">shared</span><span class="p">,</span> <span class="n">row_major</span><span class="p">)</span> <span class="k">uniform</span><span class="p">;</span> <span class="c1">// default is now shared and row_major</span>

<span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">Transform</span> <span class="p">{</span> <span class="c1">// layout of this block is std140</span>
    <span class="kt">mat4</span> <span class="n">M1</span><span class="p">;</span>                       <span class="c1">// row major</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">column_major</span><span class="p">)</span> <span class="kt">mat4</span> <span class="n">M2</span><span class="p">;</span>  <span class="c1">// column major</span>
    <span class="kt">mat3</span> <span class="n">N1</span><span class="p">;</span>                       <span class="c1">// row major</span>
<span class="p">};</span>

<span class="k">uniform</span> <span class="n">T2</span> <span class="p">{</span>                       <span class="c1">// layout of this block is shared</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">layout</span><span class="p">(</span><span class="n">column_major</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">T3</span> <span class="p">{</span>  <span class="c1">// shared and column major</span>
    <span class="kt">mat4</span> <span class="n">M3</span><span class="p">;</span>                       <span class="c1">// column major</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">row_major</span><span class="p">)</span> <span class="kt">mat4</span> <span class="n">m4</span><span class="p">;</span>     <span class="c1">// row major</span>
    <span class="kt">mat3</span> <span class="n">N2</span><span class="p">;</span>                       <span class="c1">// column major</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Vulkan を対象にしている場合、ブロックおよびブロックメンバーの
<code class="docutils literal notranslate"><span class="pre">offset</span></code> および <code class="docutils literal notranslate"><span class="pre">align</span></code> 修飾子は、一様ブロックおよびバッファーブロックに限り使用できる。
Vulkan を対象にしていない場合、これらの修飾子は <code class="docutils literal notranslate"><span class="pre">std140</span></code> または <code class="docutils literal notranslate"><span class="pre">std430</span></code>
レイアウトで宣言されたブロックに限り使用できる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">offset</span></code> はブロックメンバーに限り使用できる。修飾子 <code class="docutils literal notranslate"><span class="pre">offset</span></code> は、修飾されたメンバーを指定された <em>layout-qualifier-value</em>
（バッファーの先頭からのバイトオフセット）以降に強制的に開始させる。ブロックの他のメンバー内にあるオフセットを明示的または代入的に持たせるとコンパイルエラーとなる。
SPIR-V を生成しない場合、ブロック内の直前のメンバーのオフセットよりも小さいオフセットを指定するとコンパイルエラーとなる。同じプログラム内で同じブロック名でリンクされた二つのブロックは、
<code class="docutils literal notranslate"><span class="pre">offset</span></code> で修飾されたメンバーの集合が全く同じであり、それらの <em>layout-qualifier-value</em> の値が同じでなければならず、そうでなければリンクエラーとなる。指定されたオフセットは、それが修飾するブロックメンバーの型の
base alignment の倍数でなければならず、そうでなければコンパイルエラーになる。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">align</span></code> は、各ブロックメンバーの開始点を最小の byte alignment にする。各メンバー内の内部レイアウトには影響を与えず、
<code class="docutils literal notranslate"><span class="pre">std140</span></code> または <code class="docutils literal notranslate"><span class="pre">std430</span></code> の規則に従う。指定された alignment は 0 よりも大きく、かつ 2 のべき乗でなければならず、そうでない場合はコンパイルエラー。</p>
<p>メンバーの実際の alignment は、指定された <code class="docutils literal notranslate"><span class="pre">align</span></code> alignmentと、そのメンバーの型の標準（<code class="docutils literal notranslate"><span class="pre">std140</span></code> など）base alignment のうち大きい方になる。メンバーの実際のオフセットは次のように計算される：
<code class="docutils literal notranslate"><span class="pre">offset</span></code> が宣言されている場合は、そのオフセットから開始し、そうでない場合は、宣言順で先行メンバーの直後のオフセットから開始する。結果オフセットが実際の alignment の倍数でない場合は、実際の alignment の倍数である最初のオフセットまで増やす。これにより、メンバーの実際のオフセットが得られる。</p>
<p><code class="docutils literal notranslate"><span class="pre">align</span></code> が配列に適用された場合、配列の開始点のみに影響し、配列の内部幅には影響しない。宣言では <code class="docutils literal notranslate"><span class="pre">offset</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">align</span></code> 修飾子の両方を指定できる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">align</span></code> は、ブロックで使用された場合、ブロックで宣言されたのと同じ
<code class="docutils literal notranslate"><span class="pre">align</span></code> 値で各メンバーを修飾するのと同じ効果があり、これが行われた場合と同じコンパイル結果とコンパイルエラーが得られる。前述のように、個々のメンバーは独自の <code class="docutils literal notranslate"><span class="pre">align</span></code> を指定することができ、それはブロックレベルの <code class="docutils literal notranslate"><span class="pre">align</span></code> よりも優先されるが、そのメンバーに限られる。</p>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">std140</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">block</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">a</span><span class="p">;</span>                         <span class="c1">// a takes offsets 0-15</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="kt">vec3</span> <span class="n">b</span><span class="p">;</span>     <span class="c1">// b takes offsets 32-43</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">40</span><span class="p">)</span> <span class="kt">vec2</span> <span class="n">c</span><span class="p">;</span>     <span class="c1">// ERROR, lies within previous member</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">48</span><span class="p">)</span> <span class="kt">vec2</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// d takes offsets 48-55</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">align</span> <span class="o">=</span> <span class="mi">16</span><span class="p">)</span> <span class="kt">float</span> <span class="n">e</span><span class="p">;</span>     <span class="c1">// e takes offsets 64-67</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">align</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="kt">double</span> <span class="n">f</span><span class="p">;</span>     <span class="c1">// f takes offsets 72-79</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">align</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="kt">double</span> <span class="n">g</span><span class="p">;</span>     <span class="c1">// ERROR, 6 is not a power of 2</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">80</span><span class="p">)</span> <span class="kt">float</span> <span class="n">h</span><span class="p">;</span>    <span class="c1">// h takes offsets 80-83</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">align</span> <span class="o">=</span> <span class="mi">64</span><span class="p">)</span> <span class="kt">dvec3</span> <span class="n">i</span><span class="p">;</span>     <span class="c1">// i takes offsets 128-151</span>
    <span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">164</span><span class="p">,</span> <span class="n">align</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>
    <span class="kt">float</span> <span class="n">j</span><span class="p">;</span>                        <span class="c1">// j takes offsets 168-171</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="opaque-uniform-layout-qualifiers">
<h2>4.4.6. Opaque Uniform Layout Qualifiers<a class="headerlink" href="#opaque-uniform-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>Opaque uniform variables can take the uniform layout qualifier for binding:
不透明な一様変数は、結合のために一様レイアウト修飾子を取ることができます。</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子は、その変数が束縛される点を指定する。
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子なしで宣言された不透明変数は、既定束縛 0 になる。</p>
<p>OpenGL で使用する場合、
<code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が配列とともに使用されると、配列の最初の要素は指定された束縛点を取り、それ以降の各要素は連続した次の束縛点を取る。配列の配列の場合は先程の <code class="docutils literal notranslate"><span class="pre">a[2][3]</span></code> の例を述べた文と同じ。</p>
<p>Vulkan を対象にした場合、配列で <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子が使用されると、提供された束縛番号だけを配列全体が取る。次の連続した束縛番号は、別のオブジェクトに利用できる。</p>
<p><code class="docutils literal notranslate"><span class="pre">binding</span></code> が 0 より小さい場合、または実装依存のサポートされる束縛点の最大数以上の場合は、コンパイルエラーとなる。サイズ N の配列で <code class="docutils literal notranslate"><span class="pre">binding</span></code> 修飾子を使う場合、番号 <em>binding</em> から番号 <em>binding</em> + N - 1 までの配列のすべての要素は、この範囲内に収まる必要がある。同じ番号 <em>binding</em> を共有する原子カウンターのオフセットがすべて異なっていない限り、複数の原子カウンターに同じ束縛番号を使用すると、コンパイルエラーまたはリンクエラーとなる。</p>
<p>一つのプログラム内のシェーダー二つが同じ <em>opaque-uniform</em> 名に対して異なる
<em>layout-qualifier-value</em> 束縛を指定するとリンクエラーとなる。ただし、次の例のように、同じ名前の宣言の一部に <code class="docutils literal notranslate"><span class="pre">binding</span></code> を指定しても、すべての宣言に <code class="docutils literal notranslate"><span class="pre">binding</span></code> を指定してもエラーではない：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// in one shader...</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// s bound to point 3</span>

<span class="c1">// in another shader...</span>
<span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">s</span><span class="p">;</span>                   <span class="c1">// okay, s still bound at 3</span>

<span class="c1">// in another shader...</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// ERROR: contradictory bindings</span>
</pre></div>
</div>
</section>
<section id="atomic-counter-layout-qualifiers">
<h2>4.4.7. Atomic Counter Layout Qualifiers<a class="headerlink" href="#atomic-counter-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>Vulkan を対象にした場合、原子カウンターは使用できない。</p>
<p>原子カウンターのレイアウト修飾子は、その宣言で使用できる：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">offset</span></code> = <em>layout-qualifier-value</em></div>
</div>
</div>
<p>例えば下は、原子カウンター <code class="docutils literal notranslate"><span class="pre">a</span></code> の不透明ハンドルを、原子カウンターバッファーの束縛点 2 に、そのバッファーの 4 基本マシン単位のオフセットで束縛するように設定する。束縛点 2 の既定オフセットは 4（原子カウンターのサイズ）で後置インクリメントされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">a</span><span class="p">;</span>
</pre></div>
</div>
<p>後続の原子カウンター宣言は、直前の（インクリメントされた）オフセットを継承する。例えば次の宣言では、原子カウンター <code class="docutils literal notranslate"><span class="pre">bar</span></code> がバッファーの束縛点 2 に 8 基本マシン単位のオフセットで束縛されるように設定する。結合点 2 のオフセットは、再び 4 だけ後置インクリメントされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">bar</span><span class="p">;</span>
</pre></div>
</div>
<p>一つのレイアウト宣言に複数の変数がリストされている場合、左から右の順に一つずつ宣言したのと同じ効果が得られる。</p>
<p>束縛点は継承されず、オフセットのみが継承される。各束縛点では、同じ束縛を使用する後続の変数の継承のために、それ自身の現在の既定オフセットを追跡する。コンパイルの初期状態では、すべての束縛点のオフセットが 0 になる。オフセットは、大域スコープで（変数を宣言せずに）束縛点ごとに設定できる。例えば、以下のようになる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span><span class="p">;</span>
</pre></div>
</div>
<p>上記は結合点 2 に対する次の <code class="docutils literal notranslate"><span class="pre">atomic_uint</span></code> 宣言がオフセット 4 を継承するように設定する（ただし、既定束縛は設定しない）。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// offset is 4</span>
<span class="k">layout</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">bar</span><span class="p">;</span>  <span class="c1">// error, no default binding</span>
</pre></div>
</div>
<p>原子カウンターは同じ束縛点を共有することができるが、束縛が共有されている場合、それらのオフセットは、明示的または暗黙的に一意的であり、重なり合わないことが必要だ。</p>
<p>シェーダーの先頭を想定した、有効な一様宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// offset = 4</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">b</span><span class="p">;</span>           <span class="c1">// offset = 0</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">c</span><span class="p">;</span>           <span class="c1">// offset = 8</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">atomic_uint</span> <span class="n">d</span><span class="p">;</span>           <span class="c1">// offset = 4</span>
</pre></div>
</div>
<p>無効な一様宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="p">...</span>               <span class="c1">// error, must include binding</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="p">...</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// okay</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="p">...</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// okay</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mo">0</span><span class="p">)</span> <span class="p">...</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// error, offsets must not be shared</span>
                                   <span class="c1">// between a and c</span>
<span class="k">layout</span><span class="p">(</span><span class="n">binding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="p">...</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// error, overlaps offset 0 of a</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_MaxAtomicCounterBindings</span></code> 以上の束縛値で原子カウンターを束縛するとコンパイルエラーになる。サイズなし <code class="docutils literal notranslate"><span class="pre">atomic_uint</span></code> の配列を宣言するとコンパイルエラー。</p>
</section>
<section id="format-layout-qualifiers">
<h2>4.4.8. Format Layout Qualifiers<a class="headerlink" href="#format-layout-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>フォーマットレイアウト修飾子は、画像変数の宣言（キーワードに <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> を持つ基本型で宣言されたもの）に使用できる。画像変数宣言のためのフォーマットレイアウト修飾子の識別子は次のとおり（一部略）：</p>
<div class="line-block">
<div class="line"><em>layout-qualifier-id</em> :</div>
<div class="line-block">
<div class="line"><em>float-image-format-qualifier</em></div>
<div class="line"><em>int-image-format-qualifier</em></div>
<div class="line"><em>uint-image-format-qualifier</em></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">binding</span></code> = <em>layout-qualifier-value</em></div>
<div class="line"><br /></div>
</div>
<div class="line"><em>float-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32f</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba16f</span></code></div>
<div class="line">(etc.)</div>
<div class="line"><br /></div>
</div>
<div class="line"><em>int-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32i</span></code></div>
<div class="line">(etc.)</div>
<div class="line"><br /></div>
</div>
<div class="line"><em>uint-image-format-qualifier</em> :</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rgba32ui</span></code></div>
<div class="line">(etc.)</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">format</span></code> レイアウト修飾子は、宣言された画像変数に関連する画像フォーマットを指定する。画像変数宣言一個につき、フォーマット修飾子を一つだけ指定できる。浮動小数点成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> で始まるキーワード）、符号付き整数成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;iimage&quot;</span></code> で始まるキーワード）、または符号なし整数成分型（ <code class="docutils literal notranslate"><span class="pre">&quot;uimage&quot;</span></code> で始まるキーワード）の画像変数では、使用するフォーマット修飾子は、それぞれ
<em>float-image-format-qualifier</em>,
<em>int-image-format-qualifier</em>, <em>uint-image-format-qualifier</em>
文法規則に一致しなければならない。フォーマット修飾子が画像変数の型と一致しない画像変数を宣言するとコンパイルエラーとなる。</p>
<p>画像読み込みや原子操作に使用される画像変数は、フォーマットレイアウト修飾子を指定しなければならない。フォーマットレイアウト修飾子なしで宣言された画像一様変数や関数引数を画像読み込みや原子関数に渡すとコンパイルエラーとなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">writeonly</span></code> で修飾されていない一様（変数）はフォーマットレイアウト修飾子を持たなければならない。読み込みアクセスのために関数に渡された画像変数を <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> として宣言することはできないので、フォーマットレイアウト修飾子を付けて宣言しなければならないことに注意を要する。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">binding</span></code> については
<a class="reference internal" href="#opaque-uniform-layout-qualifiers"><span class="std std-ref">4.4.6. Opaque Uniform Layout Qualifiers</span></a> に記述がある。</p>
</section>
<section id="subpass-input-qualifier">
<h2>4.4.9. Subpass Input Qualifier<a class="headerlink" href="#subpass-input-qualifier" title="Permalink to this headline">¶</a></h2>
<p>サブパス入力は Vulkan を対象にしている場合に限り利用可能だ。</p>
<p>サブパス入力は、基本 <code class="docutils literal notranslate"><span class="pre">subpassInput</span></code> 型で宣言される。これらはレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> を付けて宣言しないとコンパイルエラー。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">input_attachment_index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">subpassInput</span> <span class="n">t</span><span class="p">;</span>
</pre></div>
</div>
<p>これはどのサブパスから入力が読み込まれるかを選択する。
<code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> に割り当てられた値、たとえば i とする
(<code class="docutils literal notranslate"><span class="pre">input_attachment_index</span> <span class="pre">=</span> <span class="pre">i</span></code>) と、パスの入力リストの中のその i 番目のエントリーを選択する。</p>
<p>サイズ N の配列が宣言されている場合は、提供されたものから始まる N 個の連続した <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> 値を消費する。</p>
<p>同じ <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> を異なる変数に宣言すると、コンパイルエラーまたはリンクエラーとなる。これには、配列宣言で消費される暗黙の <code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> の重複も含まれる。</p>
<p><code class="docutils literal notranslate"><span class="pre">input_attachment_index</span></code> に割り当てられた値が <code class="docutils literal notranslate"><span class="pre">gl_MaxInputAttachments</span></code>
以上の場合、コンパイルエラーとなる。</p>
</section>
</section>
<section id="interpolation-qualifiers">
<h1>4.5. Interpolation Qualifiers<a class="headerlink" href="#interpolation-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>補間される可能性のある入力および出力は、以下の補間修飾子のうち高々一つによってさらに修飾される：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">smooth</span></code></p></td>
<td><p>透視図法的補正補間</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">flat</span></code></p></td>
<td><p>補間なし</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">noperspective</span></code></p></td>
<td><p>線形補間</p></td>
</tr>
</tbody>
</table>
<p>補間の有無と型は上記の補間修飾子と補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code> によって制御される。補間修飾子がない場合は <code class="docutils literal notranslate"><span class="pre">smooth</span></code> 補間が行われる。複数の補間修飾子を使用するとコンパイルエラーとなる。補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">patch</span></code> は補間には使用されない。補間修飾子を <code class="docutils literal notranslate"><span class="pre">patch</span></code> と共に使用するとコンパイルエラーとなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">flat</span></code> と指定された変数は補間されない。代わりに、基本形状内のフラグメントみんなに対して同じ値を持つ。この値は、API で説明されているように、単一の provoking vertex から得られる。
<code class="docutils literal notranslate"><span class="pre">flat</span></code> と修飾された変数は <code class="docutils literal notranslate"><span class="pre">centroid</span></code> や <code class="docutils literal notranslate"><span class="pre">sample</span></code> と修飾されることもあり、これは <code class="docutils literal notranslate"><span class="pre">flat</span></code> としか修飾されていないのと同じ意味になる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>この provoking vertex とは？</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">smooth</span></code> と修飾された変数は、レンダリングされている基本形状の上に、透視図法的な補正による方法で補間される。遠近法的に正しい方法での補間は、
OpenGL 仕様の式 14.7 および 14.5 節 “Line Segments” で規定されている。</p>
<p><code class="docutils literal notranslate"><span class="pre">nonperspective</span></code> と修飾された変数は、OpenGL 仕様書の 3.5 節 “Line Segments” の式 3.7 で述べられているに、スクリーン空間内で線形に補間しなければならない。</p>
<p>多重採取ラスタライズが無効の場合、または <code class="docutils literal notranslate"><span class="pre">centroid</span></code> 修飾も <code class="docutils literal notranslate"><span class="pre">sample</span></code> 修飾もないフラグメントシェーダー入力変数の場合、割り当てられた変数の値は、
OpenGL 仕様で許可されている範囲内で、ピクセル内の任意の場所に補間することができ、ピクセル内の各標本に単一の値を割り当てることができる。</p>
<p>多重採取ラスタライズが有効な場合、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code> を使用して、修飾されたフラグメントシェーダー入力の採取位置と頻度を制御することができる。フラグメントシェーダー入力が
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> で修飾されている場合、その変数にはピクセル内のすべての標本に対して単一の値を割り当てることができるが、その値は、基本形状で網羅されているピクセルの標本を含めて、ピクセルとレンダリングされている基本形状の両方に位置する場所で補間されなければならない。変数が補間される位置は隣接するピクセルで異なる可能性があり、微係数は隣接するピクセル間の差を計算することで算出されるため、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> 採取された入力の微係数は、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> 以外で補間された変数のそれよりも精度が低い可能性がある。フラグメントシェーダーの入力が <code class="docutils literal notranslate"><span class="pre">sample</span></code> で修飾されている場合、その変数には、ピクセル内の網羅された標本ごとに個別の値が割り当てられなければならず、その値は個々の標本の位置で採取されなければならない。</p>
<p>同一段階内で同じ名前の変数の補間修飾子が一致しないとリンクエラーになる。</p>
<section id="redeclaring-built-in-interpolation-variables-in-the-compatibility-profile">
<h2>4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile<a class="headerlink" href="#redeclaring-built-in-interpolation-variables-in-the-compatibility-profile" title="Permalink to this headline">¶</a></h2>
<p>互換性プロファイルを使用する場合、次の宣言済み変数を補間修飾子付きで再宣言できる。</p>
<ul class="simple">
<li><p>頂点、多角形分割制御、多角形分割評価、幾何の各言語</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_FrontColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_BackColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_FrontSecondaryColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_BackSecondaryColor</span></code></p></li>
</ul>
</li>
<li><p>フラグメント言語</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_Color</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_SecondaryColor</span></code></p></li>
</ul>
</li>
</ul>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_Color</span><span class="p">;</span>            <span class="c1">// predeclared by the fragment language</span>
<span class="k">flat</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_Color</span><span class="p">;</span>       <span class="c1">// redeclared by user to be flat</span>
<span class="k">flat</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FrontColor</span><span class="p">;</span>  <span class="c1">// input to geometry shader, no &quot;gl_in[]&quot;</span>
<span class="k">flat</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="nb">gl_FrontColor</span><span class="p">;</span> <span class="c1">// output from geometry shader</span>
</pre></div>
</div>
<p>理想的には、Compatibility Profile Built-In Language Variables で記述されるように、インターフェイスブロックの再宣言の一部としてこれらを再宣言する。しかし、上記の目的のために、インターフェイスブロックの外部で、大域スコープの個々の変数として再宣言することもできる。このような再宣言をすると、出力変数に変換反響修飾子である
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code>, <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を付けることもできる。</p>
<ul class="simple">
<li><p>変数上の <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> は大域既定バッファーを変化させない。</p></li>
</ul>
<p>シェーダーが、インタフェイスブロックの再宣言と、そのインタフェイスブロックのメンバーの再宣言を、このインタフェースブロックの再宣言の外側で別々に行うと、コンパイル時にエラーになる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_Color</span></code> が補間修飾子で再宣言された場合、
<code class="docutils literal notranslate"><span class="pre">gl_FrontColor</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_BackColor</span></code> も同じ補間修飾子で再宣言されなければならず、その逆もまた然り。
<code class="docutils literal notranslate"><span class="pre">gl_SecondaryColor</span></code> が補間修飾子付きで再宣言されたならば、
<code class="docutils literal notranslate"><span class="pre">gl_FrontSecondaryColor</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_BackSecondaryColor</span></code> も同じ補間修飾子付きで再宣言されなければならず、その逆もまた然り。このような、宣言済みの変数に対する修飾子の符合判定は、プログラム中のシェーダー内で静的に使用される変数に対してのみ必要だ。</p>
</section>
</section>
<section id="parameter-qualifiers">
<h1>4.6. Parameter Qualifiers<a class="headerlink" href="#parameter-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>精度修飾子とメモリー修飾子に加えて、次のパラメータ修飾子を引数に付けることができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>なし（既定）</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span></code> と同じ</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">const</span></code></p></td>
<td><p>書き込めない引数</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">in</span></code></p></td>
<td><p>関数に渡される引数</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">out</span></code></p></td>
<td><p>関数に渡される引数のうち、初期化されていないもの</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">inout</span></code></p></td>
<td><p>関数の中と外の両方に渡される引数</p></td>
</tr>
</tbody>
</table>
<p>引数修飾子については <a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> に記述がある。</p>
</section>
<section id="precision-and-precision-qualifiers">
<h1>4.7. Precision and Precision Qualifiers<a class="headerlink" href="#precision-and-precision-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>Vulkan を対象にしていない場合：精度修飾子は OpenGL ES とのコードの可搬性のために追加されたものであって、機能的なものではない。精度修飾子は OpenGL ES と同じ構文を持ちますが、セマンティックな意味はなく、変数の格納や演算に使用される精度にも影響しない。拡張機能が OpenGL ES 2.0 仕様の精度修飾子と同じセマンティクスと機能を追加する場合は、その目的のために本節で記述されるキーワードを再利用することができる。</p>
<p>Vulkan を対象とする場合：インターフェイスの照合処理では、一様変数、一様ブロック、バッファーブロックメンバーは、同じ精度修飾を持たなければならない。同じシェーダー段階にリンクされていて異なるコンパイル単位で宣言された大域変数は、同じ精度修飾子で宣言されなければならない。</p>
<p>あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判断する目的では、精度修飾子が一致する必要はない。</p>
<section id="range-and-precision">
<h2>4.7.1. Range and Precision<a class="headerlink" href="#range-and-precision" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">highp</span></code> 単精度および倍精度浮動小数点変数の精度は 32 ビットおよび 64 ビット浮動小数点数の IEEE 754 規格により定義される。</p>
<p>これには、NaN と Inf、および正と負のゼロのサポートが含まれる。</p>
<p>以下の規則は、単精度と倍精度の演算の両方で <code class="docutils literal notranslate"><span class="pre">highp</span></code> に適用される。符号付きの無限大とゼロは、IEEE の規定に従って生成されるが、次の表（省略）で許可されている精度が適用される。シェーダーに入力された非正規化値、またはシェーダー内の任意の演算で潜在的に生成される値は、
0 に flush することができる。丸めモードは設定することができず、未定義だが、結果に 1ULP 以上の影響を与えてはならない。
NaN を生成する必要はない。
NaN の signaling のサポートは必須ではなく、例外は決して発生しない。
NaN を操作する組み込み関数を含む操作は、結果として NaN を返す必要はない。しかし、NaN が生成された場合 <code class="docutils literal notranslate"><span class="pre">isnan()</span></code> は正しい値を返さなければならない。</p>
<p>特に断りのない限り、精度は ULP 単位で最大相対誤差で表される。</p>
<p>単精度演算の場合、精度は以下のように（略）求められる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>ちょっとした表が入るが、省略。</p>
</div>
<p>上記の操作から作られた式を持つ、仕様書で定義された組み込み関数は、上記の誤差を継承する。</p>
<p>これらには、例えば、幾何関数、共通関数、および多くの行列関数が含まれる。上記に記載されておらず、上記の方程式で定義されていない組み込み関数は、精度が未定義だ。例えば、三角関数や行列式などが該当する。</p>
<p>倍精度演算の精度は、少なくとも単精度のそれはある。</p>
</section>
<section id="precision-qualifiers">
<h2>4.7.2. Precision Qualifiers<a class="headerlink" href="#precision-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>単精度浮動小数点型、整数型、不透明型宣言では、これらの精度修飾子の一つを型の前に付けることができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">highp</span></code></p></td>
<td><p>整数に対しては 32 ビット長 2の補数、浮動小数点数に対しては 32 ビット長 IEEE 754 浮動小数点</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mediump</span></code></p></td>
<td><p>Vulkan を対象にしている場合は SPIR-V RelaxedPrecision,それ以外の場合はなし。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lowp</span></code></p></td>
<td><p>同上</p></td>
</tr>
</tbody>
</table>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">lowp</span> <span class="kt">float</span> <span class="n">color</span><span class="p">;</span>
<span class="k">out</span> <span class="k">mediump</span> <span class="kt">vec2</span> <span class="n">P</span><span class="p">;</span>
<span class="k">lowp</span> <span class="kt">ivec2</span> <span class="n">foo</span><span class="p">(</span><span class="k">lowp</span> <span class="kt">mat3</span><span class="p">);</span>
<span class="k">highp</span> <span class="kt">mat4</span> <span class="n">m</span><span class="p">;</span>
</pre></div>
</div>
<p>リテラル定数には精度修飾子がない。真偽変数にもない。コンストラクターにもない。</p>
<p>この段落で言う「操作」には演算子、組み込み関数、コンストラクターを含み、「オペランド」には関数実引数とコンストラクター実引数を含むことにする。演算を内部的に評価するために使用される精度と、その後に生じる中間値に関連する精度修飾子は、演算によって消費されるオペランドの最高精度修飾子と少なくとも同じでなければならない。</p>
<p>オペランドが精度修飾子を持たない場合には、精度修飾子は他のオペランドから得られる。精度修飾子のあるオペランドがない場合は、式の中で次に消費される演算のオペランドの精度修飾子が使用される。この規則は、精度修飾されたオペランドが見つかるまで再帰的に適用することができる。必要に応じて、代入のための左辺値の精度修飾、初期化子のための被宣言変数の精度修飾、関数呼び出し実引数に対する仮引数の精度修飾、関数戻り値のための関数戻り型の精度修飾も含まれる。この方法で精度が決定できない場合、例えば、式全体が精度修飾子のないオペランドだけで構成されていて、その結果が代入されたり実引数として渡されたりしない場合は、その型の既定精度あるいはそれ以上で評価される。フラグメントシェーダーでこのような事態が発生した場合、既定の精度を定義する必要がある。</p>
<p>例えば、次の文を考える：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span> <span class="k">highp</span> <span class="kt">float</span> <span class="n">h1</span><span class="p">;</span>
<span class="k">highp</span> <span class="kt">float</span> <span class="n">h2</span> <span class="o">=</span> <span class="mf">2.3</span> <span class="o">*</span> <span class="mf">4.7</span><span class="p">;</span> <span class="c1">// operation and result are highp precision</span>
<span class="k">mediump</span> <span class="kt">float</span> <span class="n">m</span><span class="p">;</span>
<span class="n">m</span> <span class="o">=</span> <span class="mf">3.7</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">*</span> <span class="n">h2</span><span class="p">;</span> <span class="c1">// all operations are highp precision</span>
<span class="n">h2</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">h1</span><span class="p">;</span> <span class="c1">// operation is highp precision</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">h2</span> <span class="o">-</span> <span class="n">h1</span><span class="p">;</span> <span class="c1">// operation is highp precision</span>
<span class="n">h2</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// addition and result at mediump precision</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">highp</span> <span class="kt">float</span> <span class="n">p</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mf">3.3</span><span class="p">);</span> <span class="c1">// 3.3 will be passed in at highp precision</span>
</pre></div>
</div>
<p>精度修飾子は、他の修飾子と同様に、変数の基本型には影響しない。特に、精度変換のためのコンストラクターはない。コンストラクターは型を変換するだけだ。同様に、精度修飾子は、他の修飾子と同様に、引数型に基づく関数のオーバーロードには関与しない。
<a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> で述べられているように、関数入出力はコピーによって行われるので、修飾子は一致しなくても構わない。</p>
<p>変数の精度はその変数が宣言された時点で決定され、その後変化することはあり得ない。</p>
<p>This rule does not affect the precision qualification of the expression.
定整数式または定浮動小数点式の精度が指定されていない場合、評価は <code class="docutils literal notranslate"><span class="pre">highp</span></code> で行われる。この規則は式の精度修飾には影響しない。</p>
<p>定数式の評価は不変でなければならず、通常はコンパイル時に実行される。</p>
</section>
<section id="default-precision-qualifiers">
<h2>4.7.3. Default Precision Qualifiers<a class="headerlink" href="#default-precision-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>精度文</p>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">precision</span></code> <em>precision-qualifier</em> <em>type</em>;</div>
</div>
<p>を既定精度修飾子を設定するために使用することができる。
<em>type</em> 欄は <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, 不透明型のいずれかであり、
<em>precision-qualifier</em> には <code class="docutils literal notranslate"><span class="pre">lowp</span></code>, <code class="docutils literal notranslate"><span class="pre">mediump</span></code>, <code class="docutils literal notranslate"><span class="pre">highp</span></code> が宣言される。</p>
<p>これ以外の型や修飾子を指定するとコンパイルエラーになる。
<code class="docutils literal notranslate"><span class="pre">type</span></code> が <code class="docutils literal notranslate"><span class="pre">float</span></code> の場合、この指令は精度修飾のない単精度浮動小数点型（スカラー、ベクトル、行列）の宣言に適用される。
<code class="docutils literal notranslate"><span class="pre">type</span></code> が <code class="docutils literal notranslate"><span class="pre">int</span></code> の場合は、精度修飾のない整数型（スカラー、ベクトルー、符号あり、符号なし）の宣言に適用される。これには、大域変数宣言、関数戻り値宣言、関数引数タ宣言、局所変数宣言が含まれる。</p>
<p>精度修飾のない宣言は、スコープ内にある直近の精度文で指定された精度修飾子を使用する。
<code class="docutils literal notranslate"><span class="pre">precision</span></code> 文には変数宣言と同じスコープ規則がある。複文の中で宣言された場合、その効果は宣言された最も内側の文の終わりで停止する。入れ子になったスコープ内の精度文は、外側のスコープ内の精度文を上書きする。同じ基本型に対する複数の精度文が同じスコープ内に現れることができ、そのスコープ内で遅れて現れる文が早く現れる文を上書きする。</p>
<p>精度修飾子を受け付ける型に対する既定精度修飾子は <code class="docutils literal notranslate"><span class="pre">highp</span></code> だ。精度修飾子を必要とする全ての型には既定精度があるので、精度修飾子の省略によるエラーはない。</p>
</section>
<section id="available-precision-qualifiers">
<h2>4.7.4. Available Precision Qualifiers<a class="headerlink" href="#available-precision-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>組み込みマクロ <code class="docutils literal notranslate"><span class="pre">GL_FRAGMENT_PRECISION_HIGH</span></code> は 1 に定義されている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GL_FRAGMENT_PRECISION_HIGH 1</span>
</pre></div>
</div>
<p>このマクロは計算以外の言語すべてで使用できる。</p>
</section>
</section>
<section id="variance-and-the-invariant-qualifier">
<h1>4.8. Variance and the Invariant Qualifier<a class="headerlink" href="#variance-and-the-invariant-qualifier" title="Permalink to this headline">¶</a></h1>
<p>この節でいうばらつき (variance) とは、異なるプログラムにある同じ式から異なる値が得られる可能性を意味する。例えば、異なるプログラムにある二つの頂点シェーダーがそれぞれ
<code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> を同じ式で設定し、その式への入力値が両方のシェーダーの実行時に同じであるとする。シェーダー二つが独立してコンパイルされているため、これらの実行時に
<code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> に代入される値が完全に同じではないことがあり得る。この例では、多重パスアルゴリズムにおける幾何の alignment に問題が生じ得る。</p>
<p>一般的には、シェーダー間のこのようなばらつきは許容される。特定の出力変数にそのようなばらつきがない場合、その変数は不変である (invariant) と言われる。</p>
<section id="the-invariant-qualifier">
<h2>4.8.1. The Invariant Qualifier<a class="headerlink" href="#the-invariant-qualifier" title="Permalink to this headline">¶</a></h2>
<p>特定の出力変数が不変であることを保証するには、修飾子 <code class="docutils literal notranslate"><span class="pre">invariant</span></code> を使用する。この修飾子を以前に宣言された変数が不変であることを修飾するのに使用することもできる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span> <span class="nb">gl_Position</span><span class="p">;</span> <span class="c1">// make existing gl_Position be invariant</span>
<span class="k">out</span> <span class="kt">vec3</span> <span class="n">Color</span><span class="p">;</span>
<span class="k">invariant</span> <span class="n">Color</span><span class="p">;</span>       <span class="c1">// make existing Color be invariant</span>
</pre></div>
</div>
<p>または、変数が宣言されたときにその宣言の一部とする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span> <span class="k">centroid</span> <span class="k">out</span> <span class="kt">vec3</span> <span class="n">Color</span><span class="p">;</span>
</pre></div>
</div>
<p>不変性の候補はシェーダーの出力変数しかない。ユーザー定義の出力変数と組み込み出力変数を含む。不変宣言できるのは出力のみなので、あるシェーダー段階の出力は、入力が不変宣言されていなくても後続段階の入力と一致します。</p>
<p>ブロック上の入力または出力インスタンス名は、組み込み変数を再宣言する際には使用されない。</p>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">invariant</span></code> の後には、以前に宣言された識別子をカンマで区切って列挙することができる。
<code class="docutils literal notranslate"><span class="pre">invariant</span></code> の使用はすべて、大域スコープまたはブロックメンバー上で、かつ <code class="docutils literal notranslate"><span class="pre">invariant</span></code> として宣言された変数が使用される前でなければならない。</p>
<p>特定の出力変数の不変性を二つのプログラムを横断して保証するには、次も成り立っていなければならない：</p>
<ul class="simple">
<li><p>出力変数が両方のプログラムで不変であると宣言されている。</p></li>
<li><p>出力変数に割り当てられた値に関与する式や制御フローで消費されるシェーダー入力変数すべてに同じ値を入力する必要がある。</p></li>
<li><p>テクスチャーフォーマット、テクセル値、およびテクスチャーフィルタリングは、出力変数の値に関与するすべてのテクスチャー関数呼び出しに対して同じ方法に設定される。</p></li>
<li><p>入力値すべてが同じ方法ですべて操作される。消費される式と中間式の操作すべてが、評価の順序が同じになるように、オペランドの順序と結合性（左結合とか右結合とかのこと）を同じにしなければならない。中間変数と関数は、同じ明示的または暗黙的精度修飾子を持つ同じ型として宣言されなければならない。出力値に影響を与えるすべての制御フローは同じでなければならず、この制御フローを決定するために消費されるどんな式も、これらの不変性規則に従わなければならない。</p></li>
<li><p>不変出力変数を設定するためのデータフローと制御フローすべては、単一のコンパイル単位に宿る。</p></li>
</ul>
<p>原則的に、不変出力に至るデータフローと制御フローのすべてで一致しなければならない。</p>
<p>To force all output variables to be invariant, use the pragma
初期状態では、既定で、すべての出力変数に <code class="docutils literal notranslate"><span class="pre">variant</span></code> が許されている。すべての出力変数を強制的に <code class="docutils literal notranslate"><span class="pre">invariant</span></code> にするには、プラグマ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma STDGL invariant(all)</span>
</pre></div>
</div>
<p>をシェーダー内のすべての宣言の前に使用する。このプラグマがいずれかの変数や関数の宣言の後に使用された場合、不変の動作をする出力集合は未定義となる。</p>
<p>一般に、不変性は最適化の柔軟性を犠牲にして確保されるため、不変性を使用することでパフォーマンスが低下する可能性がある。したがって、このプラグマの使用は、出力変数すべてを一つ一つ <code class="docutils literal notranslate"><span class="pre">invariant</span></code> と宣言するのを避けるためのデバッグ支援を目的としている。</p>
</section>
<section id="invariance-of-constant-expressions">
<h2>4.8.2. Invariance of Constant Expressions<a class="headerlink" href="#invariance-of-constant-expressions" title="Permalink to this headline">¶</a></h2>
<p>定数式には不変性が保証されなければならない。特定の定数式は、それが同じシェーダーに現れようが異なるシェーダーに現れようが、同じ結果になるように評価しなければならない。これには、同じ式が同じ言語の二つのシェーダーに現れる場合と、二つの異なる言語のシェーダーに現れる場合が含まれる。</p>
<p>定数式は、前述の不変変数と同様に操作しても、同じ結果に評価しなければならない。</p>
</section>
</section>
<section id="the-precise-qualifier">
<h1>4.9. The Precise Qualifier<a class="headerlink" href="#the-precise-qualifier" title="Permalink to this headline">¶</a></h1>
<p>アルゴリズムの中には、ほぼ同等の結果をより高いパフォーマンスで得られる最適化をサポートしている実装であっても、ソースコードで指定された演算順序に正確に従い、すべての演算を着実に処理することを浮動小数点計算に要求するものがある。例えば、多くの実装は、次のような浮動小数点式を計算する multiply-add 命令をサポートしている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>これは三度の演算の代わりに二度で、すなわち、二度の乗算と一度の加算の代わりに、一度の乗算と一度の multiply-add 演算を行う。</p>
<p>浮動小数点の multiply-add 結果は、最初に浮動小数点の結果が得られる乗算を行ってから浮動小数点の加算を行った場合と同じになるとは限らない。したがって、この例では、二つの乗算はつじつまが合うようには扱われず、二つの乗算は事実上、異なる精度であるように見える可能性がある。</p>
<p>一貫性を持たせる必要がある重要な計算は、多角形分割の際に現れる。下図（注：本書には巨大な図式が掲載されている）のように、細分化のための中間点が異なる方向に合成されるが、同じ結果を得る必要がある。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>ここにあるイラストは、多角形分割を実装するようなプログラマーでないと理解できないものだと思う。</p>
</div>
<p>最適化されたコードが最適化されていないコードと比較してわずかに異なる結果をもたらすかもしれなくても、実装は修飾子なしで、式の評価に使用される演算の順序または数を効果的に変更する最適化を実行することが許可される。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は変数の値に与する演算が、指定された順序で、演算子の一貫性を持って行われることを保証する。演算子の順序は、
<a class="reference internal" href="note5.html#operators"><span class="std std-ref">5.1. Operators</span></a> で記述されているように、演算子の優先順位と括弧によって決定される。演算子の一貫性とは、例えば乗算演算子 <code class="docutils literal notranslate"><span class="pre">*</span></code> のような特定の演算子について、その演算が常に同じ精度で計算されることを意味する。具体的には、コンパイラーで生成されたコードで計算された値は、以下の恒等式に従わなければならない：</p>
<div class="line-block">
<div class="line">a + b = b + a</div>
<div class="line">a * b = b * a</div>
<div class="line">a * b + c * d = b * a + c* d = d * c + b * a = &lt;any other mathematically valid combination&gt;</div>
</div>
<p>次を防ぐことができる一方：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c)</span></code> が <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">+</span> <span class="pre">c</span></code> になることは許されない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">(b</span> <span class="pre">*</span> <span class="pre">c)</span></code> が <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">*</span> <span class="pre">b)</span> <span class="pre">*</span> <span class="pre">c</span></code> になることは許されません。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span></code> が単一の演算 <code class="docutils literal notranslate"><span class="pre">fma(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> になることは許されない 。</p></li>
</ul>
<p>ここで <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> ,``c`` ,``d`` は行列ではなく、スカラーまたはベクトルとする（行列は一般には可換でない）。これらの規則に基づいて計算を表現するのはシェーダー作成者の責任であり、これらの規則に従うのはコンパイラーの責任だ。多角形分割段階が従うべき規則については <code class="docutils literal notranslate"><span class="pre">gl_TessCoord</span></code> の説明を参照。これらの規則は、上記と合わせて、細分化する際のひび割れを避けることができる。</p>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">precise</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">position</span><span class="p">;</span>
</pre></div>
</div>
<p>は <code class="docutils literal notranslate"><span class="pre">position</span></code> の値を生成するために使用される演算が、ソースコードで指定された順序で正確に実行されなければならず、すべての演算子が着実に扱われなければならないことを宣言している。修飾子 <code class="docutils literal notranslate"><span class="pre">invariant</span></code> と同様に、修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は組み込み変数や事前に宣言されたユーザー定義変数が正確であることを修飾するために使用できる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="kt">vec3</span> <span class="n">Color</span><span class="p">;</span>
<span class="k">precise</span> <span class="n">Color</span><span class="p">;</span> <span class="c1">// make existing Color be precise</span>
</pre></div>
</div>
<p>ブロック、構造体型、または構造体型の変数に <code class="docutils literal notranslate"><span class="pre">precise</span></code> を適用すると、変数のメンバーそれぞれに再帰的に <code class="docutils literal notranslate"><span class="pre">precise</span></code> を適用することになる。</p>
<p>Unaffected expressions also include the controlling expressions in selection and iteration statements and the condition in ternary operators (?:).
この修飾子は、特定の関数内の右辺値の評価に影響を与えるが、それは、その結果が最終的に同じ関数内で <code class="docutils literal notranslate"><span class="pre">precise</span></code> と修飾された左辺値によって消費される場合にかつその場合に限られる。関数内の他の式は影響を受けない。これには、
<code class="docutils literal notranslate"><span class="pre">precise</span></code> 宣言されていないが、関数の外で <code class="docutils literal notranslate"><span class="pre">precise</span></code> 修飾された変数によって最終的に消費される戻り値や出力引数も含まれる。影響を受けない式には、選択文と反復文と条件演算子の条件式とにある式を制御するものも含まれる。</p>
<p><code class="docutils literal notranslate"><span class="pre">precise</span></code> の使用例（略）。</p>
<p>あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判定する目的では、修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は入力と出力の間で一致する必要はない。</p>
<p>すべての定数式は <code class="docutils literal notranslate"><span class="pre">precise</span></code> が存在するかどうかにかかわらず、それが存在するかのように評価される。ただし、コンパイル時の定数式が対応する非定数式と同じ値に評価されるという要件はない
(<a class="reference internal" href="#constant-expressions"><span class="std std-ref">4.3.3. Constant Expressions</span></a>)。</p>
</section>
<section id="memory-qualifiers">
<h1>4.10. Memory Qualifiers<a class="headerlink" href="#memory-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>シェーダー格納ブロックとその内側で宣言された変数と画像型（キーワードに <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> を含む基本不透明型）として宣言された変数は、以下（略）の記憶修飾子の一つまたは複数を追加的に修飾することができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">coherent</span></code></p></td>
<td><p>（面倒なので本文参照）</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">volatile</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">restrict</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">readonly</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">writeonly</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">coherent</span></code> を使って宣言された画像変数へのメモリーアクセスは、他のシェーダー呼び出しからの同じ場所へのアクセスとともに密着的に実行される。特に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> 宣言された変数を読み出す場合、戻り値には、他のシェーダー呼び出しで実行された以前に完了した書き込みの結果が反映される。また、<code class="docutils literal notranslate"><span class="pre">coherent</span></code> 宣言された変数を書き込む場合、書き込まれた値は、他のシェーダー呼び出しで実行された後の密着的読み込みに反映される。</p>
<p>OpenGL 仕様書の 7.12 “Shader Memory Access” にあるように、シェーダーメモリーの読み取りと書き込みは、ほとんど定義されていない順序で行われる。必要であれば、組み込み関数 <code class="docutils literal notranslate"><span class="pre">memoryBarrier()</span></code> を使って、単一のシェーダー呼び出しで実行されるメモリーアクセスの完了と相対的な順序を保証できる。</p>
<p><code class="docutils literal notranslate"><span class="pre">coherent</span></code> と宣言されていない変数を使ってメモリーにアクセスする場合、シェーダーがアクセスするそのメモリーは、同じアドレスへの将来のアクセスのために、実装がキャッシュすることがある。メモリー格納は、書き込まれた値が同じメモリーにアクセスする他のシェーダー呼び出しから見えないような方法でキャッシュされることがある。実装は、メモリー読みによって持ってきた値をキャッシュし、内在するメモリーが最初のメモリー読み以降に変更された場合でも、同じメモリーにアクセスするシェーダー呼び出しに同じ値を返すことができる。
<code class="docutils literal notranslate"><span class="pre">coherent</span></code> と宣言されていない変数は、シェーダー呼び出し間の通信には役立たないかもしれないが、非密着式のアクセスを使用することで、より高いパフォーマンスが得られる可能性がある。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">volatile</span></code> を使用して宣言された画像変数へのメモリーアクセスは、シェーダー実行中の任意の時点で、実行中のシェーダー呼び出し以外のソースによって読み書きされる可能性があるかのように、内在するメモリーを扱わなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数が読み取られた場合、その値は、読み取りを実行するシェーダー呼び出しが以前に同じメモリーからその値を持ってきていたとしても、内在するメモリーから再取得されなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数が書き込まれた場合、その値が後続の書き込みによって上書きされることをコンパイラーが明確に判断したとしても、その値は内在するメモリーに書き込まれなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数を読み書きする外部ソースは別のシェーダー呼び出しである可能性があるため、
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 宣言された変数は自動的に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> として扱われる。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> を使って宣言された画像変数へのメモリーアクセスは、メモリーアクセスを行うために使用される変数が、当該シェーダー段階を使って内在するメモリーにアクセスする唯一の方法であると仮定してコンパイルすることができる。これにより、コンパイラーは他のコードが内在する画像を読み書きしないと仮定できるので、非 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> 画像変数では許可されない方法で、
<code class="docutils literal notranslate"><span class="pre">restrict</span></code> 画像変数を使用してロードや格納をまとめたり、並べ替えたりすることができます。アプリケーションは <code class="docutils literal notranslate"><span class="pre">restrict</span></code> 変数が参照する画像メモリーが同じスコープの他の変数から参照されないようにする責任がある。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> を使用して宣言された画像変数へのメモリーアクセスは内在するメモリに対する読み取りのみ可能で、読み取り専用のメモリーとして扱われ、書き込みはできない。
<code class="docutils literal notranslate"><span class="pre">readonly</span></code> 画像変数を <code class="docutils literal notranslate"><span class="pre">imageStore()</span></code> やその他画像メモリーを変更する組み込み関数に渡すとコンパイルエラー。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> を使用して宣言された画像変数へのメモリーアクセスは内在するメモリーに対する書き込みのみ可能で、内在するメモリーを読み取ることはできない。
<code class="docutils literal notranslate"><span class="pre">writeonly</span></code> 画像変数を <a href="#id1"><span class="problematic" id="id2">``</span></a>imageLoad() `` やその他画像メモリーを読み込む組み込み関数に渡すとコンパイルエラー。</p>
<hr class="docutils" />
<p>変数を <code class="docutils literal notranslate"><span class="pre">readonly</span></code> と <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> の両方で修飾して、読み込みと書き込みの両方を禁止することもできる。このような変数でも、
<code class="docutils literal notranslate"><span class="pre">imageSize()</span></code> や <code class="docutils literal notranslate"><span class="pre">.length()</span></code> など、いくつかの問い合わせで使用することができる。</p>
<p>記憶修飾子 <code class="docutils literal notranslate"><span class="pre">coherent</span></code>, <code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">restrict</span></code>, <code class="docutils literal notranslate"><span class="pre">readonly</span></code>, <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> は、バッファー変数（つまりシェーダー格納ブロックのメンバー）の宣言に使用できる。バッファー変数が記憶修飾子付きで宣言されている場合、上述の画像変数を含むメモリーアクセスに指定された動作は、そのバッファー変数を含むメモリーアクセスにも同じように適用される。
<code class="docutils literal notranslate"><span class="pre">readonly</span></code> バッファー変数への代入や <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> バッファー変数からの読み出しはコンパイルエラー。
<code class="docutils literal notranslate"><span class="pre">readonly</span> <span class="pre">writeonly</span></code> の組み合わせは可能。</p>
<p>さらに、シェーダー格納ブロックのブロックレベルの宣言では、
<code class="docutils literal notranslate"><span class="pre">readonly</span> <span class="pre">writeonly</span></code> の組み合わせを含む記憶修飾子を使用することができる。ブロック宣言が記憶修飾子で修飾されている場合、そのブロックのすべてのメンバーが同じ記憶修飾子で宣言されているかのようになる。例えば、</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">coherent</span> <span class="k">buffer</span> <span class="n">Block</span> <span class="p">{</span>
    <span class="k">readonly</span> <span class="kt">vec4</span> <span class="n">member1</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">member2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>このブロック宣言は次のものに等価だ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">buffer</span> <span class="n">Block</span> <span class="p">{</span>
    <span class="k">coherent</span> <span class="k">readonly</span> <span class="kt">vec4</span> <span class="n">member1</span><span class="p">;</span>
    <span class="k">coherent</span> <span class="kt">vec4</span> <span class="n">member2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>記憶修飾子は画像変数、バッファー変数、シェーダー格納ブロックの宣言でしかサポートされていない。その他の宣言でこれらの修飾子を使用するとエラーとなる。</p>
<p>ユーザー定義関数を呼び出す際、
<code class="docutils literal notranslate"><span class="pre">coherent</span></code>, <code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">readonly</span></code>, <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> で修飾された変数を、そのような修飾語がない仮引数を持つ関数に渡すことはできない。仮引数に記憶修飾子を追加することは合法だが、修飾子 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> を持たない仮引数が呼び出し引数から取り去ることができるのは <code class="docutils literal notranslate"><span class="pre">restrict</span></code> だけだ。</p>
<p>組み込み関数が呼び出されたとき、生成されるコードは実引数の実際の修飾子に基づくものであり、プロトタイプの仮引数に指定された記憶修飾子のリストに基づくのではない。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span> <span class="n">funcA</span><span class="p">(</span><span class="k">restrict</span> <span class="kt">image2D</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="kt">vec4</span> <span class="n">funcB</span><span class="p">(</span><span class="kt">image2D</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">image2D</span> <span class="n">img1</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">)</span> <span class="k">coherent</span> <span class="k">uniform</span> <span class="kt">image2D</span> <span class="n">img2</span><span class="p">;</span>

<span class="n">funcA</span><span class="p">(</span><span class="n">img1</span><span class="p">);</span>        <span class="c1">// OK, adding &quot;restrict&quot; is allowed</span>
<span class="n">funcB</span><span class="p">(</span><span class="n">img2</span><span class="p">);</span>        <span class="c1">// illegal, stripping &quot;coherent&quot; is not</span>
</pre></div>
</div>
<p>レイアウト修飾子は仮引数には使用できず、引数照合処理に含まれない。</p>
<p>画像変数の宣言で <code class="docutils literal notranslate"><span class="pre">const</span></code> を使用すると、参照する画像ではなく、宣言されている変数の <code class="docutils literal notranslate"><span class="pre">const</span></code> 性を修飾することに注意してください。修飾子 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> は（その変数を介してアクセスされる）画像メモリーを修飾し、修飾子 <code class="docutils literal notranslate"><span class="pre">const</span></code> は変数自体を修飾する。</p>
</section>
<section id="specialization-constant-qualifier">
<h1>4.11. Specialization-Constant Qualifier<a class="headerlink" href="#specialization-constant-qualifier" title="Permalink to this headline">¶</a></h1>
<p>特殊化定数は SPIR-V でのみ使用され、レイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> を使用して宣言される。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span> <span class="o">=</span> <span class="mi">17</span><span class="p">)</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">arraySize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</pre></div>
</div>
<p>If it is never changed before final lowering
これは既定値が 12 である特殊化定数を作る。
17 という数字は、API や他のツールが後でこの独特な特殊化定数を参照するために、著者が選んだ例示的な ID だ。それが final lowering 前に決して変更されなければ 12 の値を維持する。スカラー <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code> の SPIR-V 生成以外で修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> を使用するとコンパイルエラー。</p>
<p>組み込み定数を特殊化定数として宣言することができる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span> <span class="o">=</span> <span class="mi">31</span><span class="p">)</span> <span class="nb">gl_MaxClipDistances</span><span class="p">;</span> <span class="c1">// add specialization_id</span>
</pre></div>
</div>
<p>この宣言では、先に宣言された組み込み変数の名前だけを使用し、レイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> 宣言をしている。定数が使用された後にこれを行うとコンパイルエラーとなる。定数は厳密に非特殊化定数か特殊化定数のどちらか一方であり、両方ではない。</p>
<p>The built-in constant vector gl_WorkGroupSize can be specialized using the local_size_{xyz}_id qualifiers, to individually give the components an id. For example:
組み込み定数ベクトル <code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> は、修飾子 <code class="docutils literal notranslate"><span class="pre">local_size_{xyz}_id</span></code> を使って、成分に個別に ID を与えることで特殊化できる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x_id</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span> <span class="n">local_size_z_id</span> <span class="o">=</span> <span class="mi">19</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p>These ids are declared independently from declaring the workgroup size:
<code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize.y</span></code> は非特殊化定数として残され、
<code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> は部分的に特殊化されたベクトルとなる。その <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> 成分は、SPIR-V を生成した後に
ID 18 および 19 を使用して、後で特殊化することができる。これらの ID は作業グループサイズの宣言とは別に宣言される。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>   <span class="c1">// size is (32,32,1)</span>
<span class="k">layout</span><span class="p">(</span><span class="n">local_size_x_id</span> <span class="o">=</span> <span class="mi">18</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>                   <span class="c1">// constant_id for x</span>
<span class="k">layout</span><span class="p">(</span><span class="n">local_size_z_id</span> <span class="o">=</span> <span class="mi">19</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>                   <span class="c1">// constant_id for z</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">local_size_{xyz}</span></code> の宣言に関する既存の規則は変化しない。
<code class="docutils literal notranslate"><span class="pre">local_size_{xz}_id</span></code> については、同じ ID に異なる ID 値を与えたり、使用後に ID 値を与えたりするとコンパイルエラーとなる。それ以外では、順序、配置、文の個数、および複製はエラーにならない。</p>
<p>特殊化定数でサイズ調整された二つの配列は、同じ記号でサイズ調整され、かつ演算を伴わない場合に限り、同じ型となる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span> <span class="o">=</span> <span class="mi">51</span><span class="p">)</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">aSize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">aSize</span> <span class="o">+</span> <span class="n">pad</span><span class="p">;</span> <span class="c1">// specialization constant</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">total</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">total</span><span class="p">];</span>        <span class="c1">// a and b have the same type</span>
<span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>                     <span class="c1">// different type than a or b</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">aSize</span> <span class="o">+</span> <span class="n">pad</span><span class="p">];</span>            <span class="c1">// different type than a, b, or c</span>
<span class="kt">int</span> <span class="n">e</span><span class="p">[</span><span class="n">aSize</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>              <span class="c1">// different type than a, b, c, or d</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>なぜこのようになるのか説明できるか？</p>
</div>
<p>特殊化定数でサイズ調整された配列を含む型を比較すること、集約として代入すること、初期化を使って宣言すること、初期化として使用することができない。ただし、同じ型の仮引数を持つ関数の実引数として渡すことはできる。配列の配列として宣言された変数の最も外側の次元しか特殊化定数とはならず、そうでなければコンパイルエラーとなる。</p>
<p>ブロック内の配列のサイズを特殊化定数で指定することはできるものの、ブロックは静的レイアウトを有するようになる。特殊化サイズを変化させても、ブロックは再配置されません。明示的なオフセットがない場合は、そのレイアウトは配列の既定サイズに基づいたものになる。</p>
</section>
<section id="order-and-repetition-of-qualification">
<h1>4.12. Order and Repetition of Qualification<a class="headerlink" href="#order-and-repetition-of-qualification" title="Permalink to this headline">¶</a></h1>
<p>一つの宣言に修飾子が複数ある場合、それらの順序は何でもよいが、型の前にすべて置かなければならない。修飾子 <code class="docutils literal notranslate"><span class="pre">layout</span></code> は、一度を超えて現れることができる唯一の修飾子だ。さらに、一つの宣言は、格納修飾子、補助格納修飾子、補間修飾子を高々一つ持てる。
<code class="docutils literal notranslate"><span class="pre">inout</span></code> が使用された場合、<code class="docutils literal notranslate"><span class="pre">in</span></code> も <code class="docutils literal notranslate"><span class="pre">out</span></code> も使用できまない。記憶修飾子を複数使用することができる。これらの規則に違反すると、コンパイルエラーとなる。</p>
</section>
<section id="empty-declarations">
<h1>4.13. Empty Declarations<a class="headerlink" href="#empty-declarations" title="Permalink to this headline">¶</a></h1>
<p><strong>空宣言</strong> (empty declarations) とは、変数名のない宣言のことであって、その宣言によってインスタンス化されるオブジェクトがないことを意味する。一般的に、空宣言は許されている。構造体を宣言するときに便利なものもあれば、何の効果もないものもある。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">;</span>               <span class="c1">// No effect</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span><span class="kt">int</span> <span class="n">x</span><span class="p">;};</span> <span class="c1">// Defines a struct S</span>
</pre></div>
</div>
<p>コンパイルエラーやリンクエラーが発生する修飾子の組み合わせは、例えば、宣言が空であってもなくても同じだ。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// Error. An input cannot be invariant.</span>
<span class="k">invariant</span> <span class="k">in</span> <span class="kt">float</span><span class="p">;</span>   <span class="c1">// Error even though no variable is declared.</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="note5.html" title="GLSL 4.60 仕様書 読書ノート 5 of ?"
             >next</a></li>
        <li class="right" >
          <a href="note4.html" title="GLSL 4.60 仕様書 読書ノート 4 of ?"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >GLSL 4.60 仕様書 読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">4.3. Storage Qualifiers</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2021, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>