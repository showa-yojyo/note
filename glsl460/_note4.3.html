
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4.3. Storage Qualifiers &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/prefab.css" />
    
    <script src="../_static/mathjax-v3.js"></script>
     
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">4.3. Storage Qualifiers</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="storage-qualifiers">
<h1>4.3. Storage Qualifiers<a class="headerlink" href="#storage-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>変数宣言では、型の前に高々一つの格納修飾子を指定することができる。詳しくは本書の表を参照。名前だけ列挙すると：
<code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">attribute</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">varying</span></code>,
<code class="docutils literal notranslate"><span class="pre">buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, 以上。</p>
<p>入出力修飾変数の中には、高々一つの補助格納修飾子を追加できるものがある。詳しくは本書の表を参照。名前だけ列挙すると：
<code class="docutils literal notranslate"><span class="pre">centroid</span></code>, <code class="docutils literal notranslate"><span class="pre">sample</span></code>, <code class="docutils literal notranslate"><span class="pre">patch</span></code>, 以上。</p>
<p>すべての修飾子の組み合わせが許されるわけではない。補助格納修飾子は <code class="docutils literal notranslate"><span class="pre">in</span></code> または <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子と一緒にしか使用できない。その他の修飾子の規則については、以降の節で説明。</p>
<p>局所変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子のみ使用できる（または格納修飾子を使用しない）。</p>
<p>関数の引数には <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code> を使用できるが、引数修飾子としては使用できないことに注意。引数修飾子については
<a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> を参照。</p>
<p>関数の戻り値の型や構造体のメンバーには格納修飾子を使用しない。</p>
<p>大域宣言の初期化子は、格納修飾子がないか、
<code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子があるか、または <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 修飾子がある大域変数の宣言でしか使用できない。</p>
<p>格納修飾子のない大域変数は、その宣言またはアプリケーションで初期化されないと、初期化されずに未定義の値で <code class="docutils literal notranslate"><span class="pre">main()</span></code> に入る。</p>
<p>あるシェーダー段階の出力と後続のシェーダー段階の入力を比較するとき、補助修飾子（またはその欠落）が同じでない場合、入力と出力は一致しない。</p>
<section id="default-storage-qualifier">
<h2>4.3.1. Default Storage Qualifier<a class="headerlink" href="#default-storage-qualifier" title="Permalink to this headline">¶</a></h2>
<p>大域変数に修飾子がない場合、その変数はアプリケーションや他のパイプライン段階で実行されるシェーダーとはリンクしていない。大域変数でも局所変数でも、修飾されていない変数では、宣言は対象となる処理器に関連するメモリーが割り当てられているように見える。この変数は、この割り当てられたメモリーへの読み取り・書き込みアクセスを提供する。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>意味不明。</p>
</div>
</section>
<section id="constant-qualifier">
<h2>4.3.2. Constant Qualifier<a class="headerlink" href="#constant-qualifier" title="Permalink to this headline">¶</a></h2>
<p>名前付きのコンパイル時定数や読み取り専用の変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子を使って宣言できる。
<code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子は、非 <code class="docutils literal notranslate"><span class="pre">void</span></code> 透過基本データ型や、それらの構造体や配列で使用できる。宣言されていない <code class="docutils literal notranslate"><span class="pre">const</span></code> 変数に書き込むコードはコンパイルエラーとなるから、宣言時に初期化する必要がある。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">vec3</span> <span class="n">zAxis</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">ceiling</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// a and b not necessarily constants</span>
</pre></div>
</div>
<p>構造体のメンバーは <code class="docutils literal notranslate"><span class="pre">const</span></code> で修飾することはできない。構造体変数は <code class="docutils literal notranslate"><span class="pre">const</span></code> として宣言し、構造体のコンストラクターまたは初期化子で初期化できる。</p>
<p>大域スコープでの <code class="docutils literal notranslate"><span class="pre">const</span></code> 宣言の初期化子は、次節で定義されるように、定数式でなければならない。</p>
</section>
<section id="constant-expressions">
<h2>4.3.3. Constant Expressions<a class="headerlink" href="#constant-expressions" title="Permalink to this headline">¶</a></h2>
<p>SPIR-V の特殊化定数は、
<a class="reference internal" href="note4.html#specialization-constant-qualifier"><span class="std std-ref">4.11. Specialization-Constant Qualifier</span></a> で記述されるように、
GLSL では <code class="docutils literal notranslate"><span class="pre">const</span></code> にレイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">const_id</span></code> を付けて表現される。</p>
<p><strong>定数式</strong> (a constant expression) とは次のいずれかだ：</p>
<ul class="simple">
<li><p>リテラル値</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> 修飾子と初期化子で宣言された変数で、初期化子が定数式であるもの。これは <code class="docutils literal notranslate"><span class="pre">layout(const_id</span> <span class="pre">=</span> <span class="pre">...)</span></code> のような特殊化定数レイアウト修飾子を付けて宣言された
<code class="docutils literal notranslate"><span class="pre">const</span></code> と、特殊化定数レイアウト修飾子を付けずに宣言された <code class="docutils literal notranslate"><span class="pre">const</span></code> の両方を含む。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> として修飾された組み込み変数。</p></li>
<li><p>定数配列の要素、定数構造体のメンバー、定数ベクトルの構成要素の取得など、すべて定数式であるオペランドに対して演算子で形成される式。</p></li>
<li><p>オブジェクト自体が定数であるかどうかに関わらず、明示的なサイズのオブジェクトに対する
<code class="docutils literal notranslate"><span class="pre">length()</span></code> メソッドの適切な使用（暗黙的なサイズの配列や実行時サイズの配列は定数式を返さない）。</p></li>
<li><p>引数がすべて定数式であるコンストラクター。</p></li>
<li><p>非特殊化定数の場合のみ：引数がすべて定数式である特定の組み込み関数の呼び出しの戻り値（少なくとも以下のリストを含む）。メモリーにアクセスしないその他の組み込み関数（テクスチャー探索関数、画像アクセス、不可分カウンターなどを除く）であって、戻り値の型が非 <code class="docutils literal notranslate"><span class="pre">void</span></code> で <code class="docutils literal notranslate"><span class="pre">out</span></code> 引数がなく、ノイズ関数ではないものも定数とみなされる場合がある。関数が特殊化定数である引数で呼び出された場合、その結果は定数式ではない。</p>
<ul>
<li><p>角度および三角関数</p></li>
<li><p>指数関数</p></li>
<li><p>普通の関数</p></li>
<li><p>幾何関数</p></li>
</ul>
</li>
<li><p>ユーザー定義関数（非組み込み関数）の関数呼び出しは、定数式には使用できない。</p></li>
</ul>
<hr class="docutils" />
<p><strong>定整数式</strong> (a constant integral expression) とは定数式であって、スカラーの符号付きまたは符号なしの整数に評価されるものだ。</p>
<p>定数式は不変的な方法で評価されるため、複数のシェーダーに同じ定数式が現れた場合、同じ値が生成される。
<a class="reference internal" href="note4.html#the-invariant-qualifier"><span class="std std-ref">4.8.1. The Invariant Qualifier</span></a>, <a class="reference internal" href="note4.html#precision-qualifiers"><span class="std std-ref">4.7.2. Precision Qualifiers</span></a> を参照。</p>
<p>定数式は <code class="docutils literal notranslate"><span class="pre">precision</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">invariant</span></code> 修飾子を尊重するが、そのような修飾子の使用とは関係なく、常に不変的に評価されるため、複数のシェーダーに同じ定数式が現れた場合には、同じ値が生成される。</p>
<p>定数式はホストプラットフォームで評価される可能性がある。それゆえ同じ式がシェーダー実行対象で評価するような値と同じものを計算する必要はない。ただし、ホストは対象が使用するのと同じか、それ以上の精度を使用しなければならない。精度修飾子が決定できない場合、式は <code class="docutils literal notranslate"><span class="pre">highp</span></code> で評価される。
<a class="reference internal" href="note4.html#default-precision-qualifiers"><span class="std std-ref">4.7.3. Default Precision Qualifiers</span></a> 参照。</p>
<p>特殊化定数式は、コンパイラーのフロントエンドでは評価されないで、代わりに、後でホスト上で評価するために必要な式の操作を留めておく。</p>
</section>
<section id="input-variables">
<h2>4.3.4. Input Variables<a class="headerlink" href="#input-variables" title="Permalink to this headline">¶</a></h2>
<p>シェーダーの入力変数は <code class="docutils literal notranslate"><span class="pre">in</span></code> 格納修飾子で宣言される。この変数は、API パイプラインの前段階と宣言したシェーダーとの間の入力インターフェイスを形成する。入力変数は大域スコープで宣言しなければならない。前のパイプライン段階から来る値は、シェーダー実行開始時に入力変数にコピーされる。入力として宣言された変数に書き込むコードはコンパイルエラーとなる。</p>
<p>前の段階で書き込む必要があるのは、静的に読み込まれる入力変数だけであり、入力変数の宣言が余計に付いていても構わない。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>本文ではこのことをまとめた表がここに示されているが、割愛する。</p>
</div>
<p>消費エラーは静的な使用にしかよらない。未定義の値を消費する可能性のある動的な使用方法をコンパイラーが推論する場合、エラーではなく警告を発する。組み込み入力名の一覧は <a class="reference internal" href="note7.html#built-in-variables"><span class="std std-ref">7. Built-In Variables</span></a> を参照。</p>
<p>頂点シェーダーの入力変数（または属性）は、頂点ごとのデータを受け取る。頂点シェーダー入力に補助格納修飾子や補間修飾子を使用すると、コンパイルエラーとなる。コピーされた値は API またはレイアウト識別子 <code class="docutils literal notranslate"><span class="pre">location</span></code> の使用により設けられる。</p>
<p>以下の型で頂点シェーダー入力を宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
<li><p>構造体</p></li>
</ul>
<hr class="docutils" />
<p>頂点シェーダーにおける入力宣言の例を示す：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">vec4</span> <span class="n">position</span><span class="p">;</span>
<span class="k">in</span> <span class="kt">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">in</span> <span class="kt">vec2</span> <span class="n">texCoord</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</pre></div>
</div>
<hr class="docutils" />
<p>グラフィックスハードウェアでは、頂点入力を渡すための固定のベクトル場所が足りないことが予想される。そのため、OpenGL Shading Language では、行列以外の入力変数は、そのようなベクトル位置を一つ使用すると定義している。使用できる場所の数には実装依存の制限があり、これを超えるとリンクエラーが発生する（静的使用でないと宣言された入力変数は、この制限に含まれない）。スカラー入力は <code class="docutils literal notranslate"><span class="pre">vec4</span></code> と同じようにカウントされるので、アプリケーションでは、内在するハードウェアの性能をよりよく活用するために、関係のない 4 つの <code class="docutils literal notranslate"><span class="pre">float</span></code> 入力のグループをまとめてベクトルにすることを検討するとよいだろう。行列入力は、複数の場所を使用する。使用される場所の数は、行列の列数と同じだ。</p>
<p>多角形分割制御、多角形分割評価、幾何シェーダーの入力変数は、前のアクティブシェーダー段階で同じ名前の出力変数によって書き出された、頂点ごとの値を取得する。これらの入力では <code class="docutils literal notranslate"><span class="pre">centroid</span></code> や補間修飾子が使えるが、効果はない。多角形分割制御、多角形分割評価、幾何シェーダーは頂点集合を操作するので、各入力変数（または入力ブロック、下記のインターフェイスブロックを参照）は配列として宣言する必要がある。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">float</span> <span class="n">foo</span><span class="p">[];</span> <span class="c1">// geometry shader input for vertex &quot;out float foo&quot;</span>
</pre></div>
</div>
<p>このような配列の各要素は、処理される基本形状の一つの頂点に対応する。各配列はオプションでサイズを宣言することができる。幾何シェーダーの場合、配列のサイズは、<a class="reference internal" href="note4.html#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a> のように、入力基本形状の型を設定する入力 <code class="docutils literal notranslate"><span class="pre">layout</span></code> 宣言によって設定される。</p>
<hr class="docutils" />
<p>入力と出力は配列されているものもある。これは、シェーダー段階二つの間にあるインターフェイスでは、入力または出力の宣言を一致させるために、余分なレベルの配列インデックスが必要になることを意味する。例えば、頂点シェーダーと幾何シェーダーのインターフェイスでは、頂点シェーダーの出力変数と幾何シェーダーの入力変数の同名の変数は、型が一致していなければならない。ただし、幾何シェーダーは、頂点のインデックス付けを可能にするために、頂点シェーダーよりも 1 多い配列次元を持つことになる。このように配列されたインターフェイス変数が、必要である追加的入力・出力配列次元で宣言されていない場合、リンクエラーとなる。幾何シェーダー入力、多角形分割制御シェーダー入出力、多角形分割評価入力はすべて、他のシェーダー入出力に比べて追加的配列レベルを持っている。これらの入力と出力は、頂点ごとに配列された (per-vertex-arrayed) 入力と出力として知られている。配列されたインターフェイス (<code class="docutils literal notranslate"><span class="pre">gl_MaxTessControlInputComponents</span></code>, etc.)
の成分制限は、インターフェイス全体に対する制限ではなく、頂点ごとの制限だ。</p>
<p>非配列のインターフェイス（＝段階間配列の次元が変わらない）では、入力変数が一致する出力変数と配列の次元を含めて同じ型で宣言されていないと、リンクエラーとなる。</p>
<p>リンク時の型マッチング規則は、使用されているか否かに関わらず、宣言されたすべての入力変数と出力変数に適用される。</p>
<p>さらに、多角形分割評価シェーダーは <code class="docutils literal notranslate"><span class="pre">patch</span></code> および <code class="docutils literal notranslate"><span class="pre">in</span></code> 修飾子で宣言された
<code class="docutils literal notranslate"><span class="pre">patch</span></code> ごとの入力変数をサポートしている。パッチごとの入力変数には、多角形分割制御シェーダーによって書き込まれたパッチごとの出力変数の値が入る。パッチごとの入力は一次元配列として宣言できるが、頂点数によるインデックスは付けられない。入力への <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子の適用は、多角形分割評価シェーダでしか行えない。他の入力変数と同様に、パッチごとの入力は、前の（多角形分割制御）シェーダー段階からのパッチごとの出力と同じ型と修飾子を使って宣言しなければならない。他の段階の入力で <code class="docutils literal notranslate"><span class="pre">patch</span></code> を使用することは、コンパイルエラーとなる。</p>
<p>多角形分割制御、多角形分割評価、幾何シェーダーの入力を、以下のいずれかの型で宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<hr class="docutils" />
<p>フラグメントシェーダーの入力は、前の段階の出力から補間されたフラグメントごとの値をふつうは取得する。補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code> も、補間修飾子 <code class="docutils literal notranslate"><span class="pre">flat</span></code>, <code class="docutils literal notranslate"><span class="pre">noperspective</span></code>,
<cite>smooth`</cite> と同様に適用できる。</p>
<p>フラグメントシェーダーの入力を次のいずれかの型で宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<p>整数型または倍精度浮動小数点型であるか、またはそれを含むフラグメントシェーダー入力には補間修飾子 <code class="docutils literal notranslate"><span class="pre">flat</span></code> が必要だ。</p>
<p>フラグメント入力は以下の例のように宣言される：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">centroid</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
<span class="k">invariant</span> <span class="k">centroid</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>
<span class="k">noperspective</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">temperature</span><span class="p">;</span>
<span class="k">flat</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">myColor</span><span class="p">;</span>
<span class="k">noperspective</span> <span class="k">centroid</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">myTexCoord</span><span class="p">;</span>
</pre></div>
</div>
<p>フラグメントシェーダーの入力は、頂点処理パイプラインにおける最終アクティブシェーダーとのインターフェイスを形成する。このインターフェイスでは、最終アクティブシェーダー段階出力変数とフラグメントシェーダーの入力変数の同名の変数は、いくつかの例外（格納修飾子の一方は <code class="docutils literal notranslate"><span class="pre">in</span></code> で他方は <code class="docutils literal notranslate"><span class="pre">out</span></code> でなければならない）を除いて、型と修飾子が一致していなければならない。また、補間修飾子や補助修飾子も異なる場合がある。これらのミスマッチは任意の段階対の間で許される。補間修飾子や補助修飾子が一致しない場合は、フラグメントシェーダーで提供される修飾子が前段階で提供される修飾子よりも優先される。フラグメントシェーダーにそのような修飾子が全くない場合は、前段階で宣言されていた修飾子ではなく、既定の修飾子が使用される。つまり、重要なのはフラグメントシェーダーで何が宣言されているかであり、前段階のシェーダーで何が宣言されているかではないということだ。</p>
<hr class="docutils" />
<p>シェーダー段階間のインターフェイスが別々のプログラムオブジェクトのシェーダーを使って形成されている場合、プログラムがリンクされたときに入力と出力の間の不一致を検出することはできない。このようなインターフェイスでは、入力と出力の間に不一致があると、インターフェイスを介して渡される値は、部分的にまたは完全に未定義となる。</p>
<p>シェーダーで入出力レイアウト修飾子 (<a class="reference internal" href="note4.html#input-layout-qualifiers"><span class="std std-ref">4.4.1. Input Layout Qualifiers</span></a>,
<a class="reference internal" href="note4.html#output-layout-qualifiers"><span class="std std-ref">4.4.2. Output Layout Qualifiers</span></a>)
を使用するか、ブロックや変数の入力宣言と出力宣言を同一にすることで、このようなインターフェイス間のマッチングを担保することができる。インターフェイスのマッチングに関する完全な規則は、
OpenGL 仕様書の 7.4.1 “Shader Interface Matching” に記載されている。</p>
<hr class="docutils" />
<p>計算シェーダはユーザ定義の入力変数を許可せず、他のシェーダー段階との正式なインターフェイスを形成しない。組み込みの計算シェーダー入力変数については
<a class="reference internal" href="note7.html#compute-shader-special-variables"><span class="std std-ref">7.1.6. Compute Shader Special Variables</span></a> を参照。計算シェーダーへの他のすべての入力は、画像ロード、テクスチャー取得、
uniforms または uniform buffers からのロード、または他のユーザーコードによって明示的に取得される。計算シェーダーの組み込み入力変数を再宣言することはできない。</p>
</section>
<section id="uniform-variables">
<h2>4.3.5. Uniform Variables<a class="headerlink" href="#uniform-variables" title="Permalink to this headline">¶</a></h2>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>英単語 uniform をどう訳したらしっくり来るだろうか。数学科専攻としては「一様」にしたい。中国語の仕様書を見たら「統一」に相当する単語をあてているようだ。</p>
</div>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">uniform</span></code> は、処理される基本形状全体で値が同じになる大域変数を宣言するために用いられる。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数はすべて読み取り専用で、リンク時または API を通じて外部から初期化される。リンク時の初期値は、変数の初期化子が存在する場合はその値で、存在しない場合は 0 だ。不透明型は初期化子を持つことができず、そうでない場合はコンパイルエラーが発生する。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span> <span class="kt">vec4</span> <span class="n">lightPosition</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">);</span> <span class="c1">// value assigned at link time</span>
</pre></div>
</div>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">uniform</span></code> は、基本的なデータ型のいずれか、または構造体を型とする変数を宣言するとき、あるいはこれらのいずれかの配列を宣言するときに使用できる。</p>
<p>シェーダーの種類ごとに使用できる <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 用変数の収容量には実装依存の制限がある。これを超えるとコンパイル時またはリンク時にエラーとなる。宣言されているが使用されていない <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数はこの制限に入らない。ユーザー定義の <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の個数と、シェーダー内で使用されている組み込みの <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の個数の和で、利用可能な収容量を超えているかどうかを判断する。</p>
<p>シェーダー内の <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数は、プログラムまたは分割可能なプログラムにリンクされている場合、すべて単一の大域名前空間を共有する。したがって、同じ名前で静的に使用される <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数の型、初期化子、および任意の <code class="docutils literal notranslate"><span class="pre">location</span></code> 指定子は、単一プログラムにリンクされているすべてのシェーダーで一致しなければならない。ただし、リンクされたすべてのシェーダーで初期化子や
<cite>location`</cite> 指定子を繰り返す必要はない。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数名がある段階（例：頂点シェーダー）で宣言され、別の段階（例：フラグメントシェーダー）で宣言されていない場合、その名前は別の段階で別の用途に使用することが許される。</p>
</section>
<section id="output-variables">
<h2>4.3.6. Output Variables<a class="headerlink" href="#output-variables" title="Permalink to this headline">¶</a></h2>
<p>シェーダー出力変数は <code class="docutils literal notranslate"><span class="pre">out</span></code> 格納修飾子で宣言される。出力変数は、宣言したシェーダーと API パイプラインの後続段階との間の出力インターフェイスを形成する。出力変数は大域スコープで宣言しなければならない。シェーダーの実行中は、修飾のない通常の大域変数として振る舞う。シェーダーの終了時にその値は後続のパイプライン段階にコピーされる。後続のパイプライン段階で読まれる出力変数だけが書き込まれる必要があり、出力変数の余計な宣言があっても構わない。</p>
<p>単一の変数名をシェーダーの入力と出力の両方として宣言するための
<code class="docutils literal notranslate"><span class="pre">inout</span></code> のような格納修飾子は存在しない。一つの変数に <code class="docutils literal notranslate"><span class="pre">in</span></code> と <code class="docutils literal notranslate"><span class="pre">out</span></code> の両方の修飾子をつけて宣言することもまたできない。コンパイル時またはリンク時にエラーとなる。出力変数は、入力変数とは異なる名前で宣言しなければならない。ただし、インスタンス名を持つインターフェイスブロックの中に入力または出力を入れ子にすると、ブロックのインスタンス名で参照されるものと同じ名前を使うことができる。</p>
<p>頂点、多角形分割評価、幾何の出力変数は、頂点ごとのデータを出力し、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子を用いて宣言される。出力への <code class="docutils literal notranslate"><span class="pre">patch</span></code> の適用は、多角形分割制御シェーダーでのみ可能だ。それ以外の段階での適用はコンパイルエラーとなる。</p>
<p>頂点、多角形分割評価、多角形分割制御、幾何それぞれのシェーダーの出力を、以下の型のいずれかで宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>不透明型</p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="kt">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">centroid</span> <span class="k">out</span> <span class="kt">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
<span class="k">invariant</span> <span class="k">centroid</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>
<span class="k">flat</span> <span class="k">out</span> <span class="kt">vec3</span> <span class="n">myColor</span><span class="p">;</span>
<span class="k">sample</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">perSampleColor</span><span class="p">;</span>
</pre></div>
</div>
<p>これらは <a class="reference internal" href="note4.html#interface-blocks"><span class="std std-ref">4.3.9. Interface Blocks</span></a> で述べられるように、インターフェイスブロックにも出現する。インターフェイスブロックでは、頂点シェーダーから幾何シェーダーへのインターフェイスに、より単純に配列を追加することができる。また、フラグメントシェーダーに、ある頂点シェーダーの幾何シェーダーと同じ入力インターフェイスを持たせることができる。</p>
<hr class="docutils" />
<p>多角形分割制御シェーダーの出力変数は、頂点ごとのデータとパッチごとのデータを出力するために用いられる。頂点ごとの出力変数は配列され (<a class="reference internal" href="note4.html#input-variables"><span class="std std-ref">4.3.4. Input Variables</span></a>)、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子なしに宣言される。パッチごとの出力変数は <code class="docutils literal notranslate"><span class="pre">patch</span></code> 修飾子と <code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で宣言される。</p>
<p>多角形分割制御シェーダーは、複数の頂点からなる配列された基本形状を生成するため、各頂点ごとの出力変数（または出力ブロック）は、配列として宣言する必要がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="kt">float</span> <span class="n">foo</span><span class="p">[];</span> <span class="c1">// feeds next stage input &quot;in float foo[]&quot;</span>
</pre></div>
</div>
<p>このような配列の要素それぞれが、生成される基本形状一つの頂点に対応する。各配列はオプションでサイズを宣言することができる。配列のサイズは出力パッチの頂点の数を定める出力レイアウト宣言によって設定される
(<a class="reference internal" href="note4.html#tessellation-control-outputs"><span class="std std-ref">Tessellation Control Outputs</span></a>)（または、宣言されている場合は、それと一致しなければならない）。</p>
<p>各多角形分割制御シェーダー呼び出しは、対応する出力パッチの頂点を持ち、その対応する頂点に属しているときに限り、頂点ごとの出力に値を割り当てることができる。頂点ごとの出力変数を左辺値として使用する場合、頂点のインデックスを示す式が識別子 <code class="docutils literal notranslate"><span class="pre">gl_InvocationID</span></code> でないと、コンパイル時またはリンク時のエラーになる。</p>
<p>同じ入力パッチに対する他の呼び出しに対する多角形分割制御シェーダー呼び出しの相対的な実行順序は、組み込み関数 <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> が使用されない限り、未定義だ。これにより、相対的な実行順序の制御が可能になる。シェーダーの呼び出しが <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を呼び出すと、他のすべての呼び出しが同じ実行箇所に到達するまでその実行は一時停止する。
<code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を呼び出す前に実行された任意の呼び出しによって実行された出力変数の割り当ては、
<code class="docutils literal notranslate"><span class="pre">barrier()</span></code> の呼び出しが戻った後、他の任意の呼び出しから見えるようになる。</p>
<p>多角形分割制御シェーダーの呼び出しは、障壁間で未定義の順序で実行されるので、頂点ごと、あるいはパッチごとの出力変数の値は時々未定義になる。シェーダー実行の開始と終了、および <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> の各呼び出しを同期時点と考えるといい。出力変数の値が不定になるのは、以下の三つの場合のいずれかだ：</p>
<ol class="arabic simple">
<li><p>実行の開始時</p></li>
<li><p>以下の場合を除く各同期時点：</p>
<ul class="simple">
<li><p>前回の同期時点の後に値が定義され、その後どの呼び出しによっても書き込まれなかった場合、または</p></li>
<li><p>前回の同期時点以降、厳密に一つのシェーダー呼び出しによって値が書き込まれた場合、または</p></li>
<li><p>前回の同期時点以降に複数のシェーダー呼び出しによって値が書き込まれ、そのようなすべての呼び出しによって実行された最後の書き込みが同じ値を書き込んだ場合。</p></li>
</ul>
</li>
<li><p>シェーダーの呼び出しによって読み込まれたとき、もし</p>
<ul class="simple">
<li><p>その値が前回の同期時点で未定義であり、その後同じシェーダー呼び出しによって書き込まれていない場合、または</p></li>
<li><p>前回と次回の同期時点の間に他のシェーダー呼び出しによって出力変数が書き込まれた場合（その割り当てが読み取り後のコードで発生したときでさえ）</p></li>
</ul>
</li>
</ol>
<hr class="docutils" />
<p>フラグメント出力は、フラグメントごとのデータを出力し、
<code class="docutils literal notranslate"><span class="pre">out</span></code> 修飾子で宣言される。フラグメントシェーダー出力の宣言に補助格納修飾子や補間修飾子を使用するとコンパイルエラーとなる。フラグメントシェーダー出力を以下の型で宣言するとコンパイルエラーとなる：</p>
<ul class="simple">
<li><p>真偽型</p></li>
<li><p>倍精度スカラーまたはベクトル (<code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec2</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec3</span></code>, <code class="docutils literal notranslate"><span class="pre">dvec4</span></code>)</p></li>
<li><p>不透明型</p></li>
<li><p>行列型</p></li>
<li><p>構造体</p></li>
</ul>
<p>フラグメント出力宣言の例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="kt">vec4</span> <span class="n">FragmentColor</span><span class="p">;</span>
<span class="k">out</span> <span class="kt">uint</span> <span class="n">Luminosity</span><span class="p">;</span>
</pre></div>
</div>
<hr class="docutils" />
<p>計算シェーダーは組み込みの出力変数を持たず、ユーザー定義の出力変数も対処せず、他のシェーダー段階との正式なインターフェイスを形成しない。計算シェーダーからの出力はすべて、画像格納や不可分カウンターの演算などの副作用の形をとる。</p>
</section>
<section id="buffer-variables">
<h2>4.3.7. Buffer Variables<a class="headerlink" href="#buffer-variables" title="Permalink to this headline">¶</a></h2>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> はAPI を通じて束縛されたバッファーオブジェクトのデータ格納空間に値が格納される大域変数を宣言するために使用される。バッファー変数はすべてのアクティブなシェーダー呼び出しの間で内包される格納空間を共有して読み書きすることができる。単一のシェーダー呼び出し内でのバッファー変数のメモリーの読み取りと書き込みは順番に処理される。しかし、ある起動で実行される読み込みと書き込みの順序は、他の呼び出しで実行されるものと比較するとほとんど未定義だ。バッファー変数は内包されているメモリーへのアクセス方法に影響を与えるメモリー修飾子
(<a class="reference internal" href="note4.html#memory-qualifiers"><span class="std std-ref">4.10. Memory Qualifiers</span></a>) で修飾することができる。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> は、インターフェイスブロック (<a class="reference internal" href="note4.html#interface-blocks"><span class="std std-ref">4.3.9. Interface Blocks</span></a>)
を宣言するために使用することができ、これらのブロックはシェーダー格納ブロックとして参照される。ブロックの外でバッファー変数を宣言するとコンパイルエラーとなる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// use buffer to create a buffer block (shader storage block)</span>
<span class="k">buffer</span> <span class="n">BufferName</span> <span class="p">{</span> <span class="c1">// externally visible name of buffer</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>      <span class="c1">// typed, shared memory...</span>
    <span class="p">...</span>             <span class="c1">// ...</span>
    <span class="kt">vec4</span> <span class="n">v</span><span class="p">[];</span>       <span class="c1">// last member may be an array that is not sized</span>
                    <span class="c1">// until after link time (dynamically sized)</span>
<span class="p">}</span> <span class="n">Name</span><span class="p">;</span>             <span class="c1">// name of block within the shader</span>
</pre></div>
</div>
<p>シェーダーの種類ごとに使用されるシェーダー格納ブロックの数、プログラムに使用されるシェーダー格納格納ブロックの合計数、個々のシェーダー格納ブロックが必要とする格納空間の量には、実装に依存した制限がある。これらの制限を超えた場合は、コンパイル時またはリンク時にエラーが発生する。</p>
<p>複数のシェーダーがリンクされている場合、それらのシェーダーは単に大域バッファー変数の名前空間を共有することになる。したがって、同じ名前で宣言されたバッファー変数の型は、単一のプログラムにリンクされているすべてのシェーダーで一致しなければならない。</p>
</section>
<section id="shared-variables">
<h2>4.3.8. Shared Variables<a class="headerlink" href="#shared-variables" title="Permalink to this headline">¶</a></h2>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">shared</span></code> は、計算シェーダー作業グループ内のすべての作業項目間で共有される格納空間がある大域変数を宣言するために用いられる。
<code class="docutils literal notranslate"><span class="pre">shared</span></code> として宣言された変数は、計算シェーダーでしか使用されない
(<a class="reference internal" href="note2.html#compute-processor"><span class="std std-ref">2.6. Compute Processor</span></a>)。それ以外の共有変数の宣言は、コンパイルエラーとなる。共有変数は暗黙的に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> (<a class="reference internal" href="note4.html#memory-qualifiers"><span class="std std-ref">4.10. Memory Qualifiers</span></a>) だ。</p>
<p>共有変数として宣言された変数は初期化子を持たず、シェーダーの実行開始時にはその内容は未定義だ。共有変数に書き込まれたどんなデータも、同じ作業グループ内の他の作業項目（同じシェーダーを実行中）から見えるということになる。</p>
<p>同期が行われていない場合、シェーダーの異なる呼び出しによる同じ <code class="docutils literal notranslate"><span class="pre">shared</span></code> 変数への読み書きの順序は未定義とする。</p>
<p>共有変数への読み書きの順序を決めるためには、関数 <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> を使って制御フローの障壁を設ける必要がある
(<span class="xref std std-ref">8.16. Shader Invocation Control Functions</span>)。</p>
<p>単一のプログラムで共有変数として宣言されたすべての変数の合計サイズには制限がある。
basic machine units 単位で表されるこの制限は、OpenGL API を使って
<code class="docutils literal notranslate"><span class="pre">MAX_COMPUTE_SHARED_MEMORY_SIZE</span></code> の値を照会することで決定できる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>最後のパラグラフ中の basic machine units なる用語がわからない。</p>
</div>
</section>
<section id="interface-blocks">
<h2>4.3.9. Interface Blocks<a class="headerlink" href="#interface-blocks" title="Permalink to this headline">¶</a></h2>
<p>入力、出力、一様、バッファー変数の宣言は、名前の付いたインターフェイスブロックにまとめることができ、個別の宣言では達せられない粗い粒度の backing が可能になる。これらはオプションでインスタンス名を持つことができ、シェーダー内でそのメンバーを参照するために用いられる。あるプログラム可能段階の出力ブロックは、後続のプログラム可能段階の対応する入力ブロックによって back される。一様ブロック (a uniform block) は、アプリケーションによってバッファーオブジェクトで back される。シェーダー格納ブロック (a shader storage block) と呼ばれるバッファー変数のブロックも、アプリケーションによってバッファーオブジェクトで back される。頂点シェーダーの入力ブロックやフラグメントシェーダーの出力ブロックを持つことは、コンパイルエラーとなり。これらの用途は将来のために予約されている。</p>
<p>インターフェイスブロックは、キーワード <code class="docutils literal notranslate"><span class="pre">in`,</span> <span class="pre">``out</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>
と、ブロック名、そして中括弧 <code class="docutils literal notranslate"><span class="pre">{</span></code> で始まる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>BNF による一覧を省略。</p>
</div>
<hr class="docutils" />
<p>次のコードは <code class="docutils literal notranslate"><span class="pre">Transform</span></code> という名前の一様ブロックを定義する。
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> 変数四つがグループ化される。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span> <span class="n">Transform</span> <span class="p">{</span>
    <span class="kt">mat4</span> <span class="n">ModelViewMatrix</span><span class="p">;</span>
    <span class="kt">mat4</span> <span class="n">ModelViewProjectionMatrix</span><span class="p">;</span>
    <span class="k">uniform</span> <span class="kt">mat3</span> <span class="n">NormalMatrix</span><span class="p">;</span>      <span class="c1">// allowed restatement of qualifier</span>
    <span class="kt">float</span> <span class="n">Deformation</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>型と宣言子は、ブロック外の他の入力、出力、一様、バッファー変数の宣言と同じだ、以下の例外がある：</p>
<ul class="simple">
<li><p>初期化子は許されない。</p></li>
<li><p>不透明型は許されない。</p></li>
<li><p>ブロック内での構造体定義の入れ子は許されない。</p></li>
</ul>
<p>これらはいずれもコンパイルエラーになる。</p>
<p>メンバー宣言にオプションの修飾子がない場合、メンバーの修飾には、
interface-qualifier で決定されるすべての <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">patch</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>,
<code class="docutils literal notranslate"><span class="pre">buffer</span></code> が含まれる。オプション修飾子を使用する場合、補間修飾子、補助格納修飾子、格納修飾子を含むことができ、ブロックのインターフェイス修飾子と一致する入力、出力、一様メンバーを宣言しなければならない。すなわち、入力変数、出力変数、一様変数、
<code class="docutils literal notranslate"><span class="pre">buffer</span></code> メンバーは、
<code class="docutils literal notranslate"><span class="pre">in</span></code> ブロック、
<code class="docutils literal notranslate"><span class="pre">out</span></code> ブロック、
<code class="docutils literal notranslate"><span class="pre">uniform</span></code> ブロック、シェーダー格納ブロック内それぞれにしか存在しない。</p>
<p>メンバーの格納修飾子に <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">patch</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>
のいずれかのインターフェイス修飾子を繰り返すことはオプションだ。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="n">Material</span> <span class="p">{</span>
    <span class="k">smooth</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">Color1</span><span class="p">;</span> <span class="c1">// legal, input inside in block</span>
    <span class="k">smooth</span> <span class="kt">vec4</span> <span class="n">Color2</span><span class="p">;</span>    <span class="c1">// legal, &#39;in&#39; inherited from &#39;in Material&#39;</span>
    <span class="kt">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>         <span class="c1">// legal, TexCoord is an input</span>
    <span class="k">uniform</span> <span class="kt">float</span> <span class="n">Atten</span><span class="p">;</span>   <span class="c1">// illegal, mismatched storage qualifier</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p><strong>シェーダーインターフェイス</strong> (a shader interface) とは、次のうちの一つとする：</p>
<ul class="simple">
<li><p>プログラムの中で宣言されたすべての一様変数と一様ブロック。これは、一つのプログラム内でリンクされているすべてのコンパイル単位に及ぶ。</p></li>
<li><p>プログラム内で宣言された <code class="docutils literal notranslate"><span class="pre">buffer</span></code> ブロックすべて。</p></li>
<li><p>隣接するプログラム可能パイプライン段階間の境界。最初の段階のコンパイル単位すべてで宣言された出力すべてと、次の段階のコンパイル単位すべて宣言された入力すべてに及ぶ。なお、実際にはフラグメントシェーダーに渡された値すべては、まずラスタライザーと補間器を通過するが、この定義では、フラグメントシェーダーと先行するシェーダーは境界を共有すると考えられる。</p></li>
</ul>
<p>ブロック名 (<em>block-name</em>) は、シェーダーインターフェイス内での照合に用いられる。つまり、あるパイプライン段階の出力ブロックは、後続のパイプライン段階の同名の入力ブロックに合致する。一様ブロックやシェーダー格納ブロックの場合、アプリケーションはブロック名を使ってブロックを識別する。シェーダー内ではインターフェイスの照合以外にはブロック名を利用できない。大域スコープのブロック名をブロック名として以外に使用することはコンパイルエラーとなる（例えば、大域変数名や関数名にブロック名を使用することが現在予約されている）。ブロックの内容が同じであっても、一つのシェーダー内の同じシェーダーインターフェイスの複数のブロック宣言に同じブロック名を使用すると、コンパイルエラーとなる。</p>
<p>一つのシェーダインターフェイスの中で合致したブロック名は、同じ数の宣言と同じ型の並び、同じメンバー名の並び、そしてメンバーごとのレイアウト修飾が一致していなければならない。一致した一様ブロック名またはシェーダー格納ロック名（入力ブロック名または出力ブロック名ではない）は、すべてインスタンス名がないか、またはすべてインスタンス名があり、それらのメンバーが同じスコープレベルにあることも必要だ。合致したブロック名の上にインスタンス名がある場合、インスタンス名が違っていても構わない。さらに、合致ブロックが配列として宣言されている場合は、配列のサイズまでも一致していなければならない。（または、連続するシェーダー段階間のシェーダーインターフェイスの配列一致規則に従う）。不一致の場合、リンクタイムエラーとなる。ブロック名は、同一シェーダー内の異なるシェーダーインターフェイスで異なる定義であることが許されており、例えば、入力ブロックと出力ブロックが同じ名前であることも可能である。</p>
<p>インスタンス名 (<em>instance-name</em>) を使用しない場合、ブロック内で宣言された名前は大域レベルでスコープされ、ブロックの外で宣言されたかのようにアクセスされる。インスタンス名を使用すると、スコープ内のすべてのメンバーが独自の名前空間内に置かれ、構造体と同様の、フィールドセレクター演算子 <code class="docutils literal notranslate"><span class="pre">.</span></code> でアクセスされる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="n">Light</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">LightPos</span><span class="p">;</span>
    <span class="kt">vec3</span> <span class="n">LightColor</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">in</span> <span class="n">ColoredTexture</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>
    <span class="kt">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Material</span><span class="p">;</span>           <span class="c1">// instance name</span>
<span class="kt">vec3</span> <span class="n">Color</span><span class="p">;</span>           <span class="c1">// different Color than Material.Color</span>
<span class="kt">vec4</span> <span class="n">LightPos</span><span class="p">;</span>        <span class="c1">// illegal, already defined</span>
<span class="p">...</span>
<span class="p">...</span> <span class="o">=</span> <span class="n">LightPos</span><span class="p">;</span>       <span class="c1">// accessing LightPos</span>
<span class="p">...</span> <span class="o">=</span> <span class="n">Material</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span> <span class="c1">// accessing Color in ColoredTexture block</span>
</pre></div>
</div>
<p>シェーディング言語の外では、メンバーは同様に識別されるが、インスタンス名の代わりにブロック名が常に使用される。API のアクセスはシェーダーではなくシェーダーインターフェイスに対して行われるのだ。インスタンス名がない場合、API はメンバーにアクセスするためにブロック名を使用せず、メンバー名だけを使用する。</p>
<p>シェーダーインターフェイス内では、同じ大域名の宣言すべては同じオブジェクトに対するものでなければならず、型や、インスタンス名のないブロックの変数やメンバーを宣言しているかどうかが一致していなければならない。また、API はシェーダーインターフェイス内のオブジェクトを一意に識別するためにこの名前を必要とする。次のどちらかが成り立つならば、どのシェーダーインターフェイスもリンクエラーになる：</p>
<ul class="simple">
<li><p>インスタンス名を持たず、同じ名前のメンバーを持つ相異なるブロックが含まれている。</p></li>
<li><p>ブロック外の変数と、インスタンス名のないブロックで、その変数がブロック内のメンバーと同じ名前である。</p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="n">Vertex</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">Position</span><span class="p">;</span>  <span class="c1">// API transform/feedback will use &quot;Vertex.Position&quot;</span>
    <span class="kt">vec2</span> <span class="n">Texture</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Coords</span><span class="p">;</span>           <span class="c1">// shader will use &quot;Coords.Position&quot;</span>
<span class="k">out</span> <span class="n">Vertex2</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>     <span class="c1">// API will use &quot;Color&quot;</span>
    <span class="kt">float</span> <span class="n">Color2</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// in same program as Vertex2 above:</span>
<span class="k">out</span> <span class="n">Vertex3</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">Intensity</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">Color</span><span class="p">;</span>     <span class="c1">// ERROR, name collision with Color in Vertex2</span>
<span class="p">};</span>
<span class="kt">float</span> <span class="n">Color2</span><span class="p">;</span>       <span class="c1">// ERROR, collides with Color2 in Vertex2</span>
</pre></div>
</div>
<hr class="docutils" />
<p>配列として宣言されたブロックでは、メンバーにアクセスする際に配列のインデックスも含める必要がある：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span> <span class="n">Transform</span> <span class="p">{</span> <span class="c1">// API uses &quot;Transform[2]&quot; to refer to instance 2</span>
    <span class="kt">mat4</span> <span class="n">ModelViewMatrix</span><span class="p">;</span>
    <span class="kt">mat4</span> <span class="n">ModelViewProjectionMatrix</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">a</span><span class="p">[];</span> <span class="c1">// array will get implicitly sized</span>
    <span class="kt">float</span> <span class="n">Deformation</span><span class="p">;</span>
<span class="p">}</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">...</span>
<span class="p">...</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">ModelViewMatrix</span><span class="p">;</span> <span class="c1">// shader access of instance 2</span>
<span class="c1">// API uses &quot;Transform.ModelViewMatrix&quot; to query an offset or other query</span>
<span class="n">transforms</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="c1">// same length for &#39;a&#39; for all x</span>
<span class="n">Transform</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>             <span class="c1">// illegal, must use &#39;transforms&#39;</span>
<span class="n">Transform</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>     <span class="c1">// illegal, must use &#39;transforms&#39;</span>
<span class="p">...</span><span class="n">transforms</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]...</span>  <span class="c1">// if these are the only two dereferences of &#39;a&#39;,</span>
<span class="p">...</span><span class="n">transforms</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]...</span>  <span class="c1">// then &#39;a&#39; must be size 8, for all</span>
<span class="n">transforms</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>配列として宣言された一様ブロックやシェーダー格納ブロックでは、個々の配列要素が、ブロックのインスタンス一つを back する、個別のバッファーオブジェクトの結合範囲に対応する。配列のサイズは必要なバッファーオブジェクトの数を示すため、一様ブロックやシェーダー格納ブロックの配列宣言では、配列のサイズを指定する必要がある。一様ブロックやシェーダー格納ブロックの配列は、動的一様な整数式でしかインデックスを付けることができず、それ以外の場合は結果が未定義だ。</p>
<p>OpenGL API のエントリー点を使用してブロックの配列内の個々のブロックの名前を特定する場合、
<code class="docutils literal notranslate"><span class="pre">Transform[2]</span></code> のようにして、名前の文字列に配列のインデックスを含めることができる。
OpenGL API のエントリー点を使用してブロックメンバーのオフセットやその他の性質を参照する場合、
<code class="docutils literal notranslate"><span class="pre">Transform.ModelViewMatrix</span></code> のように、配列インデックスを抜かなければならない。</p>
<p>多角形分割制御、多角形分割評価、幾何シェーダー入力ブロックは、配列として宣言されなければならず、それぞれの段階のシェーダー入力すべては配列宣言とリンク規則に従わなければならない。その他のすべての入出力ブロックの配列は、配列サイズを指定しなければならない。</p>
<p>段階ごとに使用できる一様ブロックの個数とシェーダー格納ブロックの個数は、実装依存の制限がある。いずれかの制限を超えた場合、リンクエラーとなる。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">4.3. Storage Qualifiers</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2021, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>