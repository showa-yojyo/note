
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4.5. Interpolation Qualifiers &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/prefab.css" />
    
    <script src="../_static/mathjax-v3.js"></script>
     
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">4.5. Interpolation Qualifiers</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="interpolation-qualifiers">
<h1>4.5. Interpolation Qualifiers<a class="headerlink" href="#interpolation-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>補間される可能性のある入力および出力は、以下の補間修飾子のうち高々一つによってさらに修飾される：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">smooth</span></code></p></td>
<td><p>透視図法的補正補間</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">flat</span></code></p></td>
<td><p>補間なし</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">noperspective</span></code></p></td>
<td><p>線形補間</p></td>
</tr>
</tbody>
</table>
<p>補間の有無と型は上記の補間修飾子と補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code>
によって制御される。補間修飾子がない場合は <code class="docutils literal notranslate"><span class="pre">smooth</span></code> 補間が行われる。複数の補間修飾子を使用するとコンパイルエラーとなる。補助格納修飾子 <code class="docutils literal notranslate"><span class="pre">patch</span></code> は補間には使用されない。補間修飾子を <code class="docutils literal notranslate"><span class="pre">patch</span></code> と共に使用するとコンパイルエラーとなる。</p>
<p><code class="docutils literal notranslate"><span class="pre">flat</span></code> と指定された変数は補間されない。代わりに、基本形状内のフラグメントみんなに対して同じ値を持つ。この値は、API で説明されているように、単一の provoking vertex から得られる。
<code class="docutils literal notranslate"><span class="pre">flat</span></code> と修飾された変数は <code class="docutils literal notranslate"><span class="pre">centroid</span></code> や <code class="docutils literal notranslate"><span class="pre">sample</span></code> と修飾されることもあり、これは <code class="docutils literal notranslate"><span class="pre">flat</span></code> としか修飾されていないのと同じ意味になる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>この provoking vertex とは？</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">smooth</span></code> と修飾された変数は、レンダリングされている基本形状の上に、透視図法的な補正による方法で補間される。遠近法的に正しい方法での補間は、
OpenGL 仕様の式 14.7 および 14.5 “Line Segments” で規定されている。</p>
<p><code class="docutils literal notranslate"><span class="pre">nonperspective</span></code> と修飾された変数は、OpenGL 仕様書 3.5 “Line Segments” の式 3.7 で述べられているに、スクリーン空間内で線形に補間しなければならない。</p>
<p>多重採取ラスタライズが無効の場合、または <code class="docutils literal notranslate"><span class="pre">centroid</span></code> 修飾も <code class="docutils literal notranslate"><span class="pre">sample</span></code> 修飾もないフラグメントシェーダー入力変数の場合、割り当てられた変数の値は、
OpenGL 仕様で許可されている範囲内で、画素内の任意の場所に補間することができ、画素内の各標本に単一の値を割り当てることができる。</p>
<p>多重採取ラスタライズが有効な場合、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> と <code class="docutils literal notranslate"><span class="pre">sample</span></code> を使用して、修飾されたフラグメントシェーダー入力の採取位置と頻度を制御することができる。フラグメントシェーダー入力が
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> で修飾されている場合、その変数には画素内のすべての標本に対して単一の値を割り当てることができるが、その値は、基本形状で網羅されている画素の標本を含めて、画素とレンダリングされている基本形状の両方に位置する場所で補間されなければならない。変数が補間される位置は隣接する画素で異なる可能性があり、微係数は隣接する画素間の差を計算することで算出されるため、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> 採取された入力の微係数は、
<code class="docutils literal notranslate"><span class="pre">centroid</span></code> 以外で補間された変数のそれよりも精度が低い可能性がある。フラグメントシェーダーの入力が <code class="docutils literal notranslate"><span class="pre">sample</span></code> で修飾されている場合、その変数には、画素内の網羅された標本ごとに個別の値が割り当てられなければならず、その値は個々の標本の位置で採取されなければならない。</p>
<p>同一段階内で同じ名前の変数の補間修飾子が一致しないとリンクエラーになる。</p>
<section id="redeclaring-built-in-interpolation-variables-in-the-compatibility-profile">
<h2>4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile<a class="headerlink" href="#redeclaring-built-in-interpolation-variables-in-the-compatibility-profile" title="Permalink to this headline">¶</a></h2>
<p>互換性プロファイルを使用する場合、次の宣言済み変数を補間修飾子付きで再宣言できる。</p>
<ul class="simple">
<li><p>頂点、多角形分割制御、多角形分割評価、幾何の各言語</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_FrontColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_BackColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_FrontSecondaryColor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_BackSecondaryColor</span></code></p></li>
</ul>
</li>
<li><p>フラグメント言語</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_Color</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_SecondaryColor</span></code></p></li>
</ul>
</li>
</ul>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_Color</span><span class="p">;</span>            <span class="c1">// predeclared by the fragment language</span>
<span class="k">flat</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_Color</span><span class="p">;</span>       <span class="c1">// redeclared by user to be flat</span>
<span class="k">flat</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="nb">gl_FrontColor</span><span class="p">;</span>  <span class="c1">// input to geometry shader, no &quot;gl_in[]&quot;</span>
<span class="k">flat</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="nb">gl_FrontColor</span><span class="p">;</span> <span class="c1">// output from geometry shader</span>
</pre></div>
</div>
<p>理想的には、<a class="reference internal" href="note7.html#compatibility-profile-built-in-language-variables"><span class="std std-ref">7.1.7. Compatibility Profile Built-In Language Variables</span></a>
で記述されるように、インターフェイスブロックの再宣言の一部としてこれらを再宣言する。しかし、上記の目的のために、インターフェイスブロックの外部で、大域スコープの個々の変数として再宣言することもできる。このような再宣言をすると、出力変数に変換反響修飾子である
<code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">xfb_stride</span></code>, <code class="docutils literal notranslate"><span class="pre">xfb_offset</span></code> を付けることもできる。</p>
<ul class="simple">
<li><p>変数上の <code class="docutils literal notranslate"><span class="pre">xfb_buffer</span></code> は大域既定バッファーを変化させない。</p></li>
</ul>
<p>シェーダーが、インタフェイスブロックの再宣言と、そのインタフェイスブロックのメンバーの再宣言を、このインタフェースブロックの再宣言の外側で別々に行うと、コンパイルエラーになる。</p>
<p><code class="docutils literal notranslate"><span class="pre">gl_Color</span></code> が補間修飾子で再宣言された場合、
<code class="docutils literal notranslate"><span class="pre">gl_FrontColor</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_BackColor</span></code> も同じ補間修飾子で再宣言されなければならず、その逆もまた然り。
<code class="docutils literal notranslate"><span class="pre">gl_SecondaryColor</span></code> が補間修飾子付きで再宣言されたならば、
<code class="docutils literal notranslate"><span class="pre">gl_FrontSecondaryColor</span></code> と <code class="docutils literal notranslate"><span class="pre">gl_BackSecondaryColor</span></code> も同じ補間修飾子付きで再宣言されなければならず、その逆もまた然り。このような、宣言済みの変数に対する修飾子の符合判定は、プログラム中のシェーダー内で静的に使用される変数に対してのみ必要だ。</p>
</section>
</section>
<section id="parameter-qualifiers">
<h1>4.6. Parameter Qualifiers<a class="headerlink" href="#parameter-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>精度修飾子とメモリー修飾子に加えて、次のパラメータ修飾子を引数に付けることができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>なし（既定）</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span></code> と同じ</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">const</span></code></p></td>
<td><p>書き込めない引数</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">in</span></code></p></td>
<td><p>関数に渡される引数</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">out</span></code></p></td>
<td><p>関数に渡される引数のうち、初期化されていないもの</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">inout</span></code></p></td>
<td><p>関数の中と外の両方に渡される引数</p></td>
</tr>
</tbody>
</table>
<p>引数修飾子については <a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> に記述がある。</p>
</section>
<section id="precision-and-precision-qualifiers">
<h1>4.7. Precision and Precision Qualifiers<a class="headerlink" href="#precision-and-precision-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>Vulkan を対象にしていない場合：精度修飾子は OpenGL ES とのコードの可搬性のために追加されたものであって、機能的なものではない。精度修飾子は OpenGL ES と同じ構文を持ちますが、セマンティックな意味はなく、変数の格納や演算に使用される精度にも影響しない。拡張機能が OpenGL ES 2.0 仕様の精度修飾子と同じセマンティクスと機能を追加する場合は、その目的のために本節で記述されるキーワードを再利用することができる。</p>
<p>Vulkan を対象とする場合：インターフェイスの照合処理では、一様変数、一様ブロック、バッファーブロックメンバーは、同じ精度修飾を持たなければならない。同じシェーダー段階にリンクされていて異なるコンパイル単位で宣言された大域変数は、同じ精度修飾子で宣言されなければならない。</p>
<p>あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判断する目的では、精度修飾子が一致する必要はない。</p>
<section id="range-and-precision">
<h2>4.7.1. Range and Precision<a class="headerlink" href="#range-and-precision" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">highp</span></code> 単精度および倍精度浮動小数点変数の精度は 32 ビットおよび 64 ビット浮動小数点数の IEEE 754 規格により定義される。</p>
<p>これには、NaN と Inf、および正と負のゼロのサポートが含まれる。</p>
<p>以下の規則は、単精度と倍精度の演算の両方で <code class="docutils literal notranslate"><span class="pre">highp</span></code> に適用される。符号付きの無限大とゼロは、IEEE の規定に従って生成されるが、次の表（省略）で許可されている精度が適用される。シェーダーに入力された非正規化値、またはシェーダー内の任意の演算で潜在的に生成される値は、
0 に flush することができる。丸めモードは設定することができず、未定義だが、結果に 1ULP 以上の影響を与えてはならない。
NaN を生成する必要はない。
NaN の signaling のサポートは必須ではなく、例外は決して発生しない。
NaN を操作する組み込み関数を含む操作は、結果として NaN を返す必要はない。しかし、NaN が生成された場合 <code class="docutils literal notranslate"><span class="pre">isnan()</span></code> は正しい値を返さなければならない。</p>
<p>特に断りのない限り、精度は ULP 単位で最大相対誤差で表される。</p>
<p>単精度演算の場合、精度は以下のように（略）求められる。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>ちょっとした表が入るが、省略。</p>
</div>
<p>上記の操作から作られた式を持つ、仕様書で定義された組み込み関数は、上記の誤差を継承する。</p>
<p>これらには、例えば、幾何関数、共通関数、および多くの行列関数が含まれる。上記に記載されておらず、上記の方程式で定義されていない組み込み関数は、精度が未定義だ。例えば、三角関数や行列式などが該当する。</p>
<p>倍精度演算の精度は、少なくとも単精度のそれはある。</p>
</section>
<section id="precision-qualifiers">
<h2>4.7.2. Precision Qualifiers<a class="headerlink" href="#precision-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>単精度浮動小数点型、整数型、不透明型宣言では、これらの精度修飾子の一つを型の前に付けることができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">highp</span></code></p></td>
<td><p>整数に対しては 32 ビット長 2の補数、浮動小数点数に対しては 32 ビット長 IEEE 754 浮動小数点</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mediump</span></code></p></td>
<td><p>Vulkan を対象にしている場合は SPIR-V RelaxedPrecision, それ以外の場合はなし。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lowp</span></code></p></td>
<td><p>同上</p></td>
</tr>
</tbody>
</table>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">lowp</span> <span class="kt">float</span> <span class="n">color</span><span class="p">;</span>
<span class="k">out</span> <span class="k">mediump</span> <span class="kt">vec2</span> <span class="n">P</span><span class="p">;</span>
<span class="k">lowp</span> <span class="kt">ivec2</span> <span class="n">foo</span><span class="p">(</span><span class="k">lowp</span> <span class="kt">mat3</span><span class="p">);</span>
<span class="k">highp</span> <span class="kt">mat4</span> <span class="n">m</span><span class="p">;</span>
</pre></div>
</div>
<p>リテラル定数には精度修飾子がない。真偽変数にもない。コンストラクターにもない。</p>
<p>この段落で言う「操作」には演算子、組み込み関数、コンストラクターを含み、「オペランド」には関数実引数とコンストラクター実引数を含むことにする。演算を内部的に評価するために使用される精度と、その後に生じる中間値に関連する精度修飾子は、演算によって消費されるオペランドの最高精度修飾子と少なくとも同じでなければならない。</p>
<p>オペランドが精度修飾子を持たない場合には、精度修飾子は他のオペランドから得られる。精度修飾子のあるオペランドがない場合は、式の中で次に消費される演算のオペランドの精度修飾子が使用される。この規則は、精度修飾されたオペランドが見つかるまで再帰的に適用することができる。必要に応じて、代入のための左辺値の精度修飾、初期化子のための被宣言変数の精度修飾、関数呼び出し実引数に対する仮引数の精度修飾、関数戻り値のための関数戻り型の精度修飾も含まれる。この方法で精度が決定できない場合、例えば、式全体が精度修飾子のないオペランドだけで構成されていて、その結果が代入されたり実引数として渡されたりしない場合は、その型の既定精度あるいはそれ以上で評価される。フラグメントシェーダーでこのような事態が発生した場合、既定の精度を定義する必要がある。</p>
<p>例えば、次の文を考える：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span> <span class="k">highp</span> <span class="kt">float</span> <span class="n">h1</span><span class="p">;</span>
<span class="k">highp</span> <span class="kt">float</span> <span class="n">h2</span> <span class="o">=</span> <span class="mf">2.3</span> <span class="o">*</span> <span class="mf">4.7</span><span class="p">;</span> <span class="c1">// operation and result are highp precision</span>
<span class="k">mediump</span> <span class="kt">float</span> <span class="n">m</span><span class="p">;</span>
<span class="n">m</span> <span class="o">=</span> <span class="mf">3.7</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">*</span> <span class="n">h2</span><span class="p">;</span> <span class="c1">// all operations are highp precision</span>
<span class="n">h2</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">h1</span><span class="p">;</span> <span class="c1">// operation is highp precision</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">h2</span> <span class="o">-</span> <span class="n">h1</span><span class="p">;</span> <span class="c1">// operation is highp precision</span>
<span class="n">h2</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// addition and result at mediump precision</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">highp</span> <span class="kt">float</span> <span class="n">p</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mf">3.3</span><span class="p">);</span> <span class="c1">// 3.3 will be passed in at highp precision</span>
</pre></div>
</div>
<p>精度修飾子は、他の修飾子と同様に、変数の基本型には影響しない。特に、精度変換のためのコンストラクターはない。コンストラクターは型を変換するだけだ。同様に、精度修飾子は、他の修飾子と同様に、引数型に基づく関数のオーバーロードには関与しない。
<a class="reference internal" href="note6.html#function-calling-conventions"><span class="std std-ref">6.1.1. Function Calling Conventions</span></a> で述べられているように、関数入出力はコピーによって行われるので、修飾子は一致しなくても構わない。</p>
<p>変数の精度はその変数が宣言された時点で決定され、その後変化することはあり得ない。</p>
<p>This rule does not affect the precision qualification of the expression.
定整数式または定浮動小数点式の精度が指定されていない場合、評価は <code class="docutils literal notranslate"><span class="pre">highp</span></code> で行われる。この規則は式の精度修飾には影響しない。</p>
<p>定数式の評価は不変でなければならず、通常はコンパイル時に実行される。</p>
</section>
<section id="default-precision-qualifiers">
<h2>4.7.3. Default Precision Qualifiers<a class="headerlink" href="#default-precision-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>精度文</p>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">precision</span></code> <em>precision-qualifier</em> <em>type</em>;</div>
</div>
<p>を既定精度修飾子を設定するために使用することができる。
<em>type</em> 欄は <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, 不透明型のいずれかであり、
<em>precision-qualifier</em> には <code class="docutils literal notranslate"><span class="pre">lowp</span></code>, <code class="docutils literal notranslate"><span class="pre">mediump</span></code>, <code class="docutils literal notranslate"><span class="pre">highp</span></code> が宣言される。</p>
<p>これ以外の型や修飾子を指定するとコンパイルエラーになる。
<code class="docutils literal notranslate"><span class="pre">type</span></code> が <code class="docutils literal notranslate"><span class="pre">float</span></code> の場合、この指令は精度修飾のない単精度浮動小数点型（スカラー、ベクトル、行列）の宣言に適用される。
<code class="docutils literal notranslate"><span class="pre">type</span></code> が <code class="docutils literal notranslate"><span class="pre">int</span></code> の場合は、精度修飾のない整数型（スカラー、ベクトルー、符号あり、符号なし）の宣言に適用される。これには、大域変数宣言、関数戻り値宣言、関数引数タ宣言、局所変数宣言が含まれる。</p>
<p>精度修飾のない宣言は、スコープ内にある直近の精度文で指定された精度修飾子を使用する。
<code class="docutils literal notranslate"><span class="pre">precision</span></code> 文には変数宣言と同じスコープ規則がある。複文の中で宣言された場合、その効果は宣言された最も内側の文の終わりで停止する。入れ子になったスコープ内の精度文は、外側のスコープ内の精度文を上書きする。同じ基本型に対する複数の精度文が同じスコープ内に現れることができ、そのスコープ内で遅れて現れる文が早く現れる文を上書きする。</p>
<p>精度修飾子を受け付ける型に対する既定精度修飾子は <code class="docutils literal notranslate"><span class="pre">highp</span></code> だ。精度修飾子を必要とする全ての型には既定精度があるので、精度修飾子の省略によるエラーはない。</p>
</section>
<section id="available-precision-qualifiers">
<h2>4.7.4. Available Precision Qualifiers<a class="headerlink" href="#available-precision-qualifiers" title="Permalink to this headline">¶</a></h2>
<p>組み込みマクロ <code class="docutils literal notranslate"><span class="pre">GL_FRAGMENT_PRECISION_HIGH</span></code> は 1 に定義されている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GL_FRAGMENT_PRECISION_HIGH 1</span>
</pre></div>
</div>
<p>このマクロは計算以外の言語すべてで使用できる。</p>
</section>
</section>
<section id="variance-and-the-invariant-qualifier">
<h1>4.8. Variance and the Invariant Qualifier<a class="headerlink" href="#variance-and-the-invariant-qualifier" title="Permalink to this headline">¶</a></h1>
<p>この節でいうばらつき (variance) とは、異なるプログラムにある同じ式から異なる値が得られる可能性を意味する。例えば、異なるプログラムにある二つの頂点シェーダーがそれぞれ
<code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> を同じ式で設定し、その式への入力値が両方のシェーダーの実行時に同じであるとする。シェーダー二つが独立してコンパイルされているため、これらの実行時に
<code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> に代入される値が完全に同じではないことがあり得る。この例では、多重パスアルゴリズムにおける幾何の alignment に問題が生じ得る。</p>
<p>一般的には、シェーダー間のこのようなばらつきは許容される。特定の出力変数にそのようなばらつきがない場合、その変数は不変である (invariant)
と言われる。</p>
<section id="the-invariant-qualifier">
<h2>4.8.1. The Invariant Qualifier<a class="headerlink" href="#the-invariant-qualifier" title="Permalink to this headline">¶</a></h2>
<p>特定の出力変数が不変であることを保証するには、修飾子 <code class="docutils literal notranslate"><span class="pre">invariant</span></code> を使用する。この修飾子を以前に宣言された変数が不変であることを修飾するのに使用することもできる：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span> <span class="nb">gl_Position</span><span class="p">;</span> <span class="c1">// make existing gl_Position be invariant</span>
<span class="k">out</span> <span class="kt">vec3</span> <span class="n">Color</span><span class="p">;</span>
<span class="k">invariant</span> <span class="n">Color</span><span class="p">;</span>       <span class="c1">// make existing Color be invariant</span>
</pre></div>
</div>
<p>または、変数が宣言されたときにその宣言の一部とする：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span> <span class="k">centroid</span> <span class="k">out</span> <span class="kt">vec3</span> <span class="n">Color</span><span class="p">;</span>
</pre></div>
</div>
<p>不変性の候補はシェーダーの出力変数しかない。ユーザー定義の出力変数と組み込み出力変数を含む。不変宣言できるのは出力のみなので、あるシェーダー段階の出力は、入力が不変宣言されていなくても後続段階の入力と一致します。</p>
<p>ブロック上の入力または出力インスタンス名は、組み込み変数を再宣言する際には使用されない。</p>
<p>キーワード <code class="docutils literal notranslate"><span class="pre">invariant</span></code> の後には、以前に宣言された識別子をカンマで区切って列挙することができる。
<code class="docutils literal notranslate"><span class="pre">invariant</span></code> の使用はすべて、大域スコープまたはブロックメンバー上で、かつ <code class="docutils literal notranslate"><span class="pre">invariant</span></code> として宣言された変数が使用される前でなければならない。</p>
<p>特定の出力変数の不変性を二つのプログラムを横断して保証するには、次も成り立っていなければならない：</p>
<ul class="simple">
<li><p>出力変数が両方のプログラムで不変であると宣言されている。</p></li>
<li><p>出力変数に割り当てられた値に関与する式や制御フローで消費されるシェーダー入力変数すべてに同じ値を入力する必要がある。</p></li>
<li><p>テクスチャーフォーマット、テクセル値、およびテクスチャーフィルタリングは、出力変数の値に関与するすべてのテクスチャー関数呼び出しに対して同じ方法に設定される。</p></li>
<li><p>入力値すべてが同じ方法ですべて操作される。消費される式と中間式の操作すべてが、評価の順序が同じになるように、オペランドの順序と結合性（左結合とか右結合とかのこと）を同じにしなければならない。中間変数と関数は、同じ明示的または暗黙的精度修飾子を持つ同じ型として宣言されなければならない。出力値に影響を与えるすべての制御フローは同じでなければならず、この制御フローを決定するために消費されるどんな式も、これらの不変性規則に従わなければならない。</p></li>
<li><p>不変出力変数を設定するためのデータフローと制御フローすべては、単一のコンパイル単位に宿る。</p></li>
</ul>
<p>原則的に、不変出力に至るデータフローと制御フローのすべてで一致しなければならない。</p>
<p>初期状態では、既定で、すべての出力変数に <code class="docutils literal notranslate"><span class="pre">variant</span></code> が許されている。すべての出力変数を強制的に <code class="docutils literal notranslate"><span class="pre">invariant</span></code> にするには、プラグマ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma STDGL invariant(all)</span>
</pre></div>
</div>
<p>をシェーダー内のすべての宣言の前に使用する。このプラグマがいずれかの変数や関数の宣言の後に使用された場合、不変の動作をする出力集合は未定義となる。</p>
<p>一般に、不変性は最適化の柔軟性を犠牲にして確保されるため、不変性を使用することでパフォーマンスが低下する可能性がある。したがって、このプラグマの使用は、出力変数すべてを一つ一つ <code class="docutils literal notranslate"><span class="pre">invariant</span></code> と宣言するのを避けるためのデバッグ支援を目的としている。</p>
</section>
<section id="invariance-of-constant-expressions">
<h2>4.8.2. Invariance of Constant Expressions<a class="headerlink" href="#invariance-of-constant-expressions" title="Permalink to this headline">¶</a></h2>
<p>定数式には不変性が保証されなければならない。特定の定数式は、それが同じシェーダーに現れようが異なるシェーダーに現れようが、同じ結果になるように評価しなければならない。これには、同じ式が同じ言語の二つのシェーダーに現れる場合と、二つの異なる言語のシェーダーに現れる場合が含まれる。</p>
<p>定数式は、前述の不変変数と同様に操作しても、同じ結果に評価しなければならない。</p>
</section>
</section>
<section id="the-precise-qualifier">
<h1>4.9. The Precise Qualifier<a class="headerlink" href="#the-precise-qualifier" title="Permalink to this headline">¶</a></h1>
<p>アルゴリズムの中には、ほぼ同等の結果をより高いパフォーマンスで得られる最適化をサポートしている実装であっても、ソースコードで指定された演算順序に正確に従い、すべての演算を着実に処理することを浮動小数点計算に要求するものがある。例えば、多くの実装は、次のような浮動小数点式を計算する multiply-add 命令をサポートしている：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>これは三度の演算の代わりに二度で、すなわち、二度の乗算と一度の加算の代わりに、一度の乗算と一度の multiply-add 演算を行う。</p>
<p>浮動小数点の multiply-add 結果は、最初に浮動小数点の結果が得られる乗算を行ってから浮動小数点の加算を行った場合と同じになるとは限らない。したがって、この例では、二つの乗算はつじつまが合うようには扱われず、二つの乗算は事実上、異なる精度であるように見える可能性がある。</p>
<p>一貫性を持たせる必要がある重要な計算は、多角形分割の際に現れる。下図（注：本書には巨大な図式が掲載されている）のように、細分化のための中間点が異なる方向に合成されるが、同じ結果を得る必要がある。</p>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>ここにあるイラストは、多角形分割を実装するようなプログラマーでないと理解できないものだと思う。</p>
</div>
<p>最適化されたコードが最適化されていないコードと比較してわずかに異なる結果をもたらすかもしれなくても、実装は修飾子なしで、式の評価に使用される演算の順序または数を効果的に変更する最適化を実行することが許可される。</p>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は変数の値に与する演算が、指定された順序で、演算子の一貫性を持って行われることを保証する。演算子の順序は、
<a class="reference internal" href="note5.html#operators"><span class="std std-ref">5.1. Operators</span></a> で記述されているように、演算子の優先順位と括弧によって決定される。演算子の一貫性とは、例えば乗算演算子 <code class="docutils literal notranslate"><span class="pre">*</span></code> のような特定の演算子について、その演算が常に同じ精度で計算されることを意味する。具体的には、コンパイラーで生成されたコードで計算された値は、以下の恒等式に従わなければならない：</p>
<div class="line-block">
<div class="line">a + b = b + a</div>
<div class="line">a * b = b * a</div>
<div class="line">a * b + c * d = b * a + c* d = d * c + b * a = &lt;any other mathematically valid combination&gt;</div>
</div>
<p>次を防ぐことができる一方：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c)</span></code> が <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">+</span> <span class="pre">c</span></code> になることは許されない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">(b</span> <span class="pre">*</span> <span class="pre">c)</span></code> が <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">*</span> <span class="pre">b)</span> <span class="pre">*</span> <span class="pre">c</span></code> になることは許されません。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span></code> が単一の演算 <code class="docutils literal notranslate"><span class="pre">fma(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> になることは許されない 。</p></li>
</ul>
<p>ここで <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> ,``c`` ,``d`` は行列ではなく、スカラーまたはベクトルとする（行列は一般には可換でない）。これらの規則に基づいて計算を表現するのはシェーダー作成者の責任であり、これらの規則に従うのはコンパイラーの責任だ。多角形分割段階が従うべき規則については <code class="docutils literal notranslate"><span class="pre">gl_TessCoord</span></code> の説明を参照。これらの規則は、上記と合わせて、細分化する際のひび割れを避けることができる。</p>
<p>例：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">precise</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">position</span><span class="p">;</span>
</pre></div>
</div>
<p>は <code class="docutils literal notranslate"><span class="pre">position</span></code> の値を生成するために使用される演算が、ソースコードで指定された順序で正確に実行されなければならず、すべての演算子が着実に扱われなければならないことを宣言している。修飾子 <code class="docutils literal notranslate"><span class="pre">invariant</span></code> と同様に、修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は組み込み変数や事前に宣言されたユーザー定義変数が正確であることを修飾するために使用できる。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">out</span> <span class="kt">vec3</span> <span class="n">Color</span><span class="p">;</span>
<span class="k">precise</span> <span class="n">Color</span><span class="p">;</span> <span class="c1">// make existing Color be precise</span>
</pre></div>
</div>
<p>ブロック、構造体型、または構造体型の変数に <code class="docutils literal notranslate"><span class="pre">precise</span></code> を適用すると、変数のメンバーそれぞれに再帰的に <code class="docutils literal notranslate"><span class="pre">precise</span></code> を適用することになる。</p>
<p>この修飾子は、特定の関数内の右辺値の評価に影響を与えるが、それは、その結果が最終的に同じ関数内で <code class="docutils literal notranslate"><span class="pre">precise</span></code> と修飾された左辺値によって消費される場合に、かつその場合に限られる。関数内の他の式は影響を受けない。これには、
<code class="docutils literal notranslate"><span class="pre">precise</span></code> 宣言されていないが、関数の外で <code class="docutils literal notranslate"><span class="pre">precise</span></code> 修飾された変数によって最終的に消費される戻り値や出力引数も含まれる。影響を受けない式には、選択文と反復文と条件演算子の条件式とにある式を制御するものも含まれる。</p>
<p><code class="docutils literal notranslate"><span class="pre">precise</span></code> の使用例（略）。</p>
<p>あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判定する目的では、修飾子 <code class="docutils literal notranslate"><span class="pre">precise</span></code> は入力と出力の間で一致する必要はない。</p>
<p>すべての定数式は <code class="docutils literal notranslate"><span class="pre">precise</span></code> が存在するかどうかにかかわらず、それが存在するかのように評価される。ただし、コンパイル時の定数式が対応する非定数式と同じ値に評価されるという要件はない
(<a class="reference internal" href="note4.html#constant-expressions"><span class="std std-ref">4.3.3. Constant Expressions</span></a>)。</p>
</section>
<section id="memory-qualifiers">
<h1>4.10. Memory Qualifiers<a class="headerlink" href="#memory-qualifiers" title="Permalink to this headline">¶</a></h1>
<p>シェーダー格納ブロックとその内側で宣言された変数と画像型（キーワードに <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code> を含む基本不透明型）として宣言された変数は、以下（略）の記憶修飾子の一つまたは複数を追加的に修飾することができる：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>修飾子</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">coherent</span></code></p></td>
<td><p>（面倒なので本文参照）</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">volatile</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">restrict</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">readonly</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">writeonly</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">coherent</span></code> を使って宣言された画像変数へのメモリーアクセスは、他のシェーダー呼び出しからの同じ場所へのアクセスとともに密着的に実行される。特に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> 宣言された変数を読み出す場合、戻り値には、他のシェーダー呼び出しで実行された以前に完了した書き込みの結果が反映される。また、
<code class="docutils literal notranslate"><span class="pre">coherent</span></code> 宣言された変数を書き込む場合、書き込まれた値は、他のシェーダー呼び出しで実行された後の密着的読み込みに反映される。</p>
<p>OpenGL 仕様書の 7.12 “Shader Memory Access” にあるように、シェーダーメモリーの読み取りと書き込みは、ほとんど定義されていない順序で行われる。必要であれば、組み込み関数 <code class="docutils literal notranslate"><span class="pre">memoryBarrier()</span></code> を使って、単一のシェーダー呼び出しで実行されるメモリーアクセスの完了と相対的な順序を保証できる。</p>
<p><code class="docutils literal notranslate"><span class="pre">coherent</span></code> と宣言されていない変数を使ってメモリーにアクセスする場合、シェーダーがアクセスするそのメモリーは、同じアドレスへの将来のアクセスのために、実装がキャッシュすることがある。メモリー格納は、書き込まれた値が同じメモリーにアクセスする他のシェーダー呼び出しから見えないような方法でキャッシュされることがある。実装は、メモリー読みによって持ってきた値をキャッシュし、内在するメモリーが最初のメモリー読み以降に変更された場合でも、同じメモリーにアクセスするシェーダー呼び出しに同じ値を返すことができる。
<code class="docutils literal notranslate"><span class="pre">coherent</span></code> と宣言されていない変数は、シェーダー呼び出し間の通信には役立たないかもしれないが、非密着式のアクセスを使用することで、より高いパフォーマンスが得られる可能性がある。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">volatile</span></code> を使用して宣言された画像変数へのメモリーアクセスは、シェーダー実行中の任意の時点で、実行中のシェーダー呼び出し以外のソースによって読み書きされる可能性があるかのように、内在するメモリーを扱わなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数が読み取られた場合、その値は、読み取りを実行するシェーダー呼び出しが以前に同じメモリーからその値を持ってきていたとしても、内在するメモリーから再取得されなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数が書き込まれた場合、その値が後続の書き込みによって上書きされることをコンパイラーが明確に判断したとしても、その値は内在するメモリーに書き込まれなければならない。
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 変数を読み書きする外部ソースは別のシェーダー呼び出しである可能性があるため、
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> 宣言された変数は自動的に <code class="docutils literal notranslate"><span class="pre">coherent</span></code> として扱われる。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> を使って宣言された画像変数へのメモリーアクセスは、メモリーアクセスを行うために使用される変数が、当該シェーダー段階を使って内在するメモリーにアクセスする唯一の方法であると仮定してコンパイルすることができる。これにより、コンパイラーは他のコードが内在する画像を読み書きしないと仮定できるので、非 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> 画像変数では許可されない方法で、
<code class="docutils literal notranslate"><span class="pre">restrict</span></code> 画像変数を使用してロードや格納をまとめたり、並べ替えたりすることができます。アプリケーションは <code class="docutils literal notranslate"><span class="pre">restrict</span></code> 変数が参照する画像メモリーが同じスコープの他の変数から参照されないようにする責任がある。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> を使用して宣言された画像変数へのメモリーアクセスは内在するメモリに対する読み取りのみ可能で、読み取り専用のメモリーとして扱われ、書き込みはできない。
<code class="docutils literal notranslate"><span class="pre">readonly</span></code> 画像変数を <code class="docutils literal notranslate"><span class="pre">imageStore()</span></code> やその他画像メモリーを変更する組み込み関数に渡すとコンパイルエラー。</p>
<hr class="docutils" />
<p>修飾子 <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> を使用して宣言された画像変数へのメモリーアクセスは内在するメモリーに対する書き込みのみ可能で、内在するメモリーを読み取ることはできない。
<code class="docutils literal notranslate"><span class="pre">writeonly</span></code> 画像変数を <code class="docutils literal notranslate"><span class="pre">imageLoad()</span></code> やその他画像メモリーを読み込む組み込み関数に渡すとコンパイルエラー。</p>
<hr class="docutils" />
<p>変数を <code class="docutils literal notranslate"><span class="pre">readonly</span></code> と <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> の両方で修飾して、読み込みと書き込みの両方を禁止することもできる。このような変数でも、
<code class="docutils literal notranslate"><span class="pre">imageSize()</span></code> や <code class="docutils literal notranslate"><span class="pre">.length()</span></code> など、いくつかの問い合わせで使用することができる。</p>
<p>記憶修飾子 <code class="docutils literal notranslate"><span class="pre">coherent</span></code>, <code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">restrict</span></code>, <code class="docutils literal notranslate"><span class="pre">readonly</span></code>, <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> は、バッファー変数（つまりシェーダー格納ブロックのメンバー）の宣言に使用できる。バッファー変数が記憶修飾子付きで宣言されている場合、上述の画像変数を含むメモリーアクセスに指定された動作は、そのバッファー変数を含むメモリーアクセスにも同じように適用される。
<code class="docutils literal notranslate"><span class="pre">readonly</span></code> バッファー変数への代入や <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> バッファー変数からの読み出しはコンパイルエラー。
<code class="docutils literal notranslate"><span class="pre">readonly</span> <span class="pre">writeonly</span></code> の組み合わせは可能。</p>
<p>さらに、シェーダー格納ブロックのブロックレベルの宣言では、
<code class="docutils literal notranslate"><span class="pre">readonly</span> <span class="pre">writeonly</span></code> の組み合わせを含む記憶修飾子を使用することができる。ブロック宣言が記憶修飾子で修飾されている場合、そのブロックのすべてのメンバーが同じ記憶修飾子で宣言されているかのようになる。例えば、</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">coherent</span> <span class="k">buffer</span> <span class="n">Block</span> <span class="p">{</span>
    <span class="k">readonly</span> <span class="kt">vec4</span> <span class="n">member1</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">member2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>このブロック宣言は次のものに等価だ：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">buffer</span> <span class="n">Block</span> <span class="p">{</span>
    <span class="k">coherent</span> <span class="k">readonly</span> <span class="kt">vec4</span> <span class="n">member1</span><span class="p">;</span>
    <span class="k">coherent</span> <span class="kt">vec4</span> <span class="n">member2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>記憶修飾子は画像変数、バッファー変数、シェーダー格納ブロックの宣言でしかサポートされていない。その他の宣言でこれらの修飾子を使用するとエラーとなる。</p>
<p>ユーザー定義関数を呼び出す際、
<code class="docutils literal notranslate"><span class="pre">coherent</span></code>, <code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">readonly</span></code>, <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> で修飾された変数を、そのような修飾語がない仮引数を持つ関数に渡すことはできない。仮引数に記憶修飾子を追加することは合法だが、修飾子 <code class="docutils literal notranslate"><span class="pre">restrict</span></code> を持たない仮引数が呼び出し引数から取り去ることができるのは <code class="docutils literal notranslate"><span class="pre">restrict</span></code> だけだ。</p>
<p>組み込み関数が呼び出されたとき、生成されるコードは実引数の実際の修飾子に基づくものであり、プロトタイプの仮引数に指定された記憶修飾子のリストに基づくのではない。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span> <span class="n">funcA</span><span class="p">(</span><span class="k">restrict</span> <span class="kt">image2D</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="kt">vec4</span> <span class="n">funcB</span><span class="p">(</span><span class="kt">image2D</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">image2D</span> <span class="n">img1</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">)</span> <span class="k">coherent</span> <span class="k">uniform</span> <span class="kt">image2D</span> <span class="n">img2</span><span class="p">;</span>

<span class="n">funcA</span><span class="p">(</span><span class="n">img1</span><span class="p">);</span>        <span class="c1">// OK, adding &quot;restrict&quot; is allowed</span>
<span class="n">funcB</span><span class="p">(</span><span class="n">img2</span><span class="p">);</span>        <span class="c1">// illegal, stripping &quot;coherent&quot; is not</span>
</pre></div>
</div>
<p>レイアウト修飾子は仮引数には使用できず、引数照合処理に含まれない。</p>
<p>画像変数の宣言で <code class="docutils literal notranslate"><span class="pre">const</span></code> を使用すると、参照する画像ではなく、宣言されている変数の <code class="docutils literal notranslate"><span class="pre">const</span></code> 性を修飾することに注意してください。修飾子 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> は（その変数を介してアクセスされる）画像メモリーを修飾し、修飾子 <code class="docutils literal notranslate"><span class="pre">const</span></code> は変数自体を修飾する。</p>
</section>
<section id="specialization-constant-qualifier">
<h1>4.11. Specialization-Constant Qualifier<a class="headerlink" href="#specialization-constant-qualifier" title="Permalink to this headline">¶</a></h1>
<p>特殊化定数は SPIR-V でのみ使用され、レイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> を使用して宣言される。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span> <span class="o">=</span> <span class="mi">17</span><span class="p">)</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">arraySize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</pre></div>
</div>
<p>If it is never changed before final lowering
これは既定値が 12 である特殊化定数を作る。
17 という数字は、API や他のツールが後でこの独特な特殊化定数を参照するために、著者が選んだ例示的な ID だ。それが final lowering 前に決して変更されなければ 12 の値を維持する。スカラー <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code> の SPIR-V 生成以外で修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> を使用するとコンパイルエラー。</p>
<p>組み込み定数を特殊化定数として宣言することができる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span> <span class="o">=</span> <span class="mi">31</span><span class="p">)</span> <span class="nb">gl_MaxClipDistances</span><span class="p">;</span> <span class="c1">// add specialization_id</span>
</pre></div>
</div>
<p>この宣言では、先に宣言された組み込み変数の名前だけを使用し、レイアウト修飾子 <code class="docutils literal notranslate"><span class="pre">constant_id</span></code> 宣言をしている。定数が使用された後にこれを行うとコンパイルエラーとなる。定数は厳密に非特殊化定数か特殊化定数のどちらか一方であり、両方ではない。</p>
<p>組み込み定数ベクトル <code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> は、修飾子 <code class="docutils literal notranslate"><span class="pre">local_size_{xyz}_id</span></code> を使って、成分に個別に ID を与えることで特殊化できる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x_id</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span> <span class="n">local_size_z_id</span> <span class="o">=</span> <span class="mi">19</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize.y</span></code> は非特殊化定数として残され、
<code class="docutils literal notranslate"><span class="pre">gl_WorkGroupSize</span></code> は部分的に特殊化されたベクトルとなる。その <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> 成分は、SPIR-V を生成した後に
ID 18 および 19 を使用して、後で特殊化することができる。これらの ID は作業グループサイズの宣言とは別に宣言される。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>   <span class="c1">// size is (32,32,1)</span>
<span class="k">layout</span><span class="p">(</span><span class="n">local_size_x_id</span> <span class="o">=</span> <span class="mi">18</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>                   <span class="c1">// constant_id for x</span>
<span class="k">layout</span><span class="p">(</span><span class="n">local_size_z_id</span> <span class="o">=</span> <span class="mi">19</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>                   <span class="c1">// constant_id for z</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">local_size_{xyz}</span></code> の宣言に関する既存の規則は変化しない。
<code class="docutils literal notranslate"><span class="pre">local_size_{xz}_id</span></code> については、同じ ID に異なる ID 値を与えたり、使用後に ID 値を与えたりするとコンパイルエラーとなる。それ以外では、順序、配置、文の個数、および複製はエラーにならない。</p>
<p>特殊化定数でサイズ調整された二つの配列は、同じ記号でサイズ調整され、かつ演算を伴わない場合に限り、同じ型となる。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">constant_id</span> <span class="o">=</span> <span class="mi">51</span><span class="p">)</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">aSize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">aSize</span> <span class="o">+</span> <span class="n">pad</span><span class="p">;</span> <span class="c1">// specialization constant</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">total</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">total</span><span class="p">];</span>        <span class="c1">// a and b have the same type</span>
<span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>                     <span class="c1">// different type than a or b</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">aSize</span> <span class="o">+</span> <span class="n">pad</span><span class="p">];</span>            <span class="c1">// different type than a, b, or c</span>
<span class="kt">int</span> <span class="n">e</span><span class="p">[</span><span class="n">aSize</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>              <span class="c1">// different type than a, b, c, or d</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">コメント</p>
<p>なぜこのようになるのか説明できるか？</p>
</div>
<p>特殊化定数でサイズ調整された配列を含む型を比較すること、集約として代入すること、初期化を使って宣言すること、初期化として使用することができない。ただし、同じ型の仮引数を持つ関数の実引数として渡すことはできる。配列の配列として宣言された変数の最も外側の次元しか特殊化定数とはならず、そうでなければコンパイルエラーとなる。</p>
<p>ブロック内の配列のサイズを特殊化定数で指定することはできるものの、ブロックは静的レイアウトを有するようになる。特殊化サイズを変化させても、ブロックは再配置されません。明示的なオフセットがない場合は、そのレイアウトは配列の既定サイズに基づいたものになる。</p>
</section>
<section id="order-and-repetition-of-qualification">
<h1>4.12. Order and Repetition of Qualification<a class="headerlink" href="#order-and-repetition-of-qualification" title="Permalink to this headline">¶</a></h1>
<p>一つの宣言に修飾子が複数ある場合、それらの順序は何でもよいが、型の前にすべて置かなければならない。修飾子 <code class="docutils literal notranslate"><span class="pre">layout</span></code> は、一度を超えて現れることができる唯一の修飾子だ。さらに、一つの宣言は、格納修飾子、補助格納修飾子、補間修飾子を高々一つ持てる。
<code class="docutils literal notranslate"><span class="pre">inout</span></code> が使用された場合、
<code class="docutils literal notranslate"><span class="pre">in</span></code> も <code class="docutils literal notranslate"><span class="pre">out</span></code> も使用できまない。記憶修飾子を複数使用することができる。これらの規則に違反すると、コンパイルエラーとなる。</p>
</section>
<section id="empty-declarations">
<h1>4.13. Empty Declarations<a class="headerlink" href="#empty-declarations" title="Permalink to this headline">¶</a></h1>
<p><strong>空宣言</strong> (empty declarations) とは、変数名のない宣言のことであって、その宣言によってインスタンス化されるオブジェクトがないことを意味する。一般的に、空宣言は許されている。構造体を宣言するときに便利なものもあれば、何の効果もないものもある。例えば：</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">;</span>               <span class="c1">// No effect</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span><span class="kt">int</span> <span class="n">x</span><span class="p">;};</span> <span class="c1">// Defines a struct S</span>
</pre></div>
</div>
<p>コンパイルエラーやリンクエラーが発生する修飾子の組み合わせは、例えば、宣言が空であってもなくても同じだ。</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">invariant</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// Error. An input cannot be invariant.</span>
<span class="k">invariant</span> <span class="k">in</span> <span class="kt">float</span><span class="p">;</span>   <span class="c1">// Error even though no variable is declared.</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">4.5. Interpolation Qualifiers</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2021, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>