<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modern C++ Design 読書ノート 2/3 &mdash; 読書ノート v1.2.1</title>
    
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/twitter-button.js"></script>
    <link rel="top" title="読書ノート v1.2.1" href="index.html" />
    <link rel="up" title="Modern C++ Design 読書ノート" href="alexandrescu01.html" />
    <link rel="next" title="Modern C++ Design 読書ノート 3/3" href="alexandrescu01-note3.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート 1/3" href="alexandrescu01-note1.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート v1.2.1</a> &raquo;</li>
          <li><a href="alexandrescu01.html" accesskey="U">Modern C++ Design 読書ノート</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="modern-c-design-2-3">
<h1><a class="toc-backref" href="#id5">Modern C++ Design 読書ノート 2/3</a><a class="headerlink" href="#modern-c-design-2-3" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="alexandrescu01-note1.html"><em>Modern C++ Design 読書ノート 1/3</em></a> からの続き。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Andrey Alexandrescu</td>
</tr>
<tr class="field-even field"><th class="field-name">訳者:</th><td class="field-body">村上雅章</td>
</tr>
<tr class="field-odd field"><th class="field-name">出版社:</th><td class="field-body">ピアソン・エデュケーション</td>
</tr>
<tr class="field-even field"><th class="field-name">ISBN:</th><td class="field-body">4-89471-435-3</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#modern-c-design-2-3" id="id5">Modern C++ Design 読書ノート 2/3</a><ul>
<li><a class="reference internal" href="#id2" id="id6">第 5 章 汎用のファンクタ</a></li>
<li><a class="reference internal" href="#singleton" id="id7">第 6 章 Singleton の実装</a></li>
<li><a class="reference internal" href="#id3" id="id8">第 7 章 スマート・ポインタ</a></li>
<li><a class="reference internal" href="#id4" id="id9">第 8 章 オブジェクト・ファクトリ</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id6">第 5 章 汎用のファンクタ</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>「値のセマンティックスを伴ったオブジェクト」という言い回しが頻出する。
これはオブジェクトがコピー、代入、値による引渡しが完全にサポートされていることを意味する。</li>
<li>&lt;関数へのポインタをかなり現代風にアレンジしたもの&gt; (p. 105)</li>
<li>&lt;状態を保存でき、メンバ関数を起動できる&gt; (p. 105) ので、単なる関数ポインタより有利。</li>
</ul>
<hr class="docutils" />
<p>Command デザインパターンの解説セクション。</p>
<ul>
<li><p class="first">&lt;作業がどのようにして行われるのかを起動側は気にしなくても良い&gt; (p. 106)</p>
</li>
<li><p class="first">&lt;呼び出しを無期限に延期できる&gt; (p. 107)</p>
</li>
<li><p class="first">&lt;Command パターンでは、処理を実行するために必要な環境を整えるタイミングが、
処理を実行するタイミングと異なっています&gt; (p. 107)</p>
</li>
<li><p class="first">&lt;Command パターンの実装を手作業で行う場合、スケーラビリティに劣ることがあります。
つまり、小さな機能を持った具体的な Command クラスを数多く記述しなければならず
（それぞれが、 <tt class="docutils literal"><span class="pre">CmdAddUser</span></tt>, <tt class="docutils literal"><span class="pre">CmdDeleteUser</span></tt>, <tt class="docutils literal"><span class="pre">CmdModifyUser</span></tt> といった
アプリケーション中の単一動作を表します）、
それぞれに特定オブジェクトに対する特定のメンバ関数を単に呼び出すだけの
<tt class="docutils literal"><span class="pre">Execute</span></tt> メンバ関数を保持させなければならないのです&gt; (p. 108)</p>
<p>→心当たりありまくり。</p>
</li>
</ul>
<hr class="docutils" />
<ul>
<li><p class="first">&lt;Command パターンにおける <tt class="docutils literal"><span class="pre">Command::Execute</span></tt> は、C++ におけるユーザ定義演算子
<tt class="docutils literal"><span class="pre">operator()</span></tt> となるべきです&gt; (p. 111)</p>
<p>→呼び出しシンタックスを <tt class="docutils literal"><span class="pre">operator()</span></tt> に統一することで、
<tt class="docutils literal"><span class="pre">Functor</span></tt> が他の <tt class="docutils literal"><span class="pre">Functor</span></tt> を保持できるようになるから。</p>
</li>
<li><p class="first">クラステンプレート <tt class="docutils literal"><span class="pre">Functor</span></tt> を、
戻り値の型が <tt class="docutils literal"><span class="pre">ResultType</span></tt> で、パラメータリストをタイプリスト <tt class="docutils literal"><span class="pre">TList</span></tt> で表現する。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Functor</span></tt> の定義は一回。Pimpl パターンにより実装を別のクラステンプレート
<tt class="docutils literal"><span class="pre">FunctorImpl</span></tt> で行う。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">FunctorImpl</span></tt> を部分特殊化をしまくって、
引数リストのパラメータ数が十分大きくても対応できるようにしておく。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 114 より引用</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">class</span> <span class="nc">TList</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FunctorImpl</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FunctorImpl</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span> <span class="n">NullType</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">R</span> <span class="k">operator</span><span class="p">()()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">FunctorImpl</span><span class="o">*</span> <span class="n">Clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FunctorImpl</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">P1</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FunctorImpl</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span> <span class="n">TYPELIST_1</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">R</span> <span class="k">operator</span><span class="p">()(</span><span class="n">P1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">FunctorImpl</span><span class="o">*</span> <span class="n">Clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FunctorImpl</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="p">...</span>
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<p><tt class="docutils literal"><span class="pre">Functor::operator()</span></tt> は <tt class="docutils literal"><span class="pre">FunctorImpl::operator()</span></tt> へ転送を行う必要がある。</p>
<ul>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">Functor</span></tt> の定義内に任意のパラメータ数で全ての <tt class="docutils literal"><span class="pre">operator()</span></tt> を定義することができる&gt; (p. 115)</p>
<ul>
<li><p class="first">第 3 章で紹介した <tt class="docutils literal"><span class="pre">TypeAtNonStrict&lt;...&gt;::Result</span></tt> を十分な個数だけ <tt class="docutils literal"><span class="pre">typedef</span></tt> する。</p>
<p><tt class="docutils literal"><span class="pre">TypeAtNonStrict</span></tt> は <tt class="docutils literal"><span class="pre">TypeAt</span></tt> のゆるゆるバージョン。</p>
</li>
<li><p class="first">力作業で <tt class="docutils literal"><span class="pre">operator()</span></tt> のオーバーロードをその個数分だけ実装する。</p>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p><tt class="docutils literal"><span class="pre">Functor</span></tt> オブジェクトの構築に関する考察。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">FunctorImpl</span></tt> のサブクラス <tt class="docutils literal"><span class="pre">FunctorHandler</span></tt> を定義して、</li>
<li><tt class="docutils literal"><span class="pre">Functor</span></tt> のコンストラクターで Pimpl メンバーデータにセットする。</li>
</ul>
<hr class="docutils" />
<p>「メンバ関数へのポインタ」に関する考察。</p>
<ul class="simple">
<li>C++ では全てのオブジェクトには型があるが、
<tt class="docutils literal"><span class="pre">operator.*</span></tt> と <tt class="docutils literal"><span class="pre">operator-&gt;*</span></tt> の結果は何か違うものだ。</li>
</ul>
<hr class="docutils" />
<p>バインダーに関する考察。ちょっと読みにくいのと、
<tt class="docutils literal"><span class="pre">BinderFirst</span></tt> しか議論していないのが惜しい。
任意の位置のパラメータにバインドするバインダーの話を振らないと。</p>
<hr class="docutils" />
<p>この章の残りの話題は、</p>
<ul>
<li><p class="first">Command パターンの話をしていたので、マクロやらアンドゥ・リドゥの話。</p>
</li>
<li><p class="first">「参照の参照」問題回避のため、traits を <tt class="docutils literal"><span class="pre">Functor::operator()</span></tt> にクッションする。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 例えば型 Parm1 が組み込み型でない場合、</span>
<span class="c1">// p1 の型は Parm1&amp; となる。</span>
<span class="c1">// const が付いていたら const Parm1&amp; となる。</span>
<span class="n">R</span> <span class="nf">operator</span><span class="p">()(</span>
    <span class="k">typename</span> <span class="n">TypeTraits</span><span class="o">&lt;</span><span class="n">Parm1</span><span class="o">&gt;::</span><span class="n">ParameterType</span> <span class="n">p1</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TypeTraits</span><span class="o">&lt;</span><span class="n">Parm2</span><span class="o">&gt;::</span><span class="n">ParameterType</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">spImpl_</span><span class="p">)(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;典型的な 32 ビットのシステムの場合、（略）
メンバ関数へのポインタは 16 バイト&gt; (p. 132) となる。</p>
</li>
</ul>
<p>など。</p>
</div>
<div class="section" id="singleton">
<h2><a class="toc-backref" href="#id7">第 6 章 Singleton の実装</a><a class="headerlink" href="#singleton" title="Permalink to this headline">¶</a></h2>
<p>&lt;Singleton デザイン・パターンの実装で「正解」というものは存在しません。
（略）扱っている問題次第で最適なものとなるのです&gt; (p. 137)</p>
<hr class="docutils" />
<ul class="simple">
<li>&lt;static データ + static 関数 != Singleton&gt; (p. 138)</li>
<li>&lt;static な関数は virtual にできない&gt; (p. 138)</li>
<li>&lt;Singleton の実装では、2 番目のインスタンスを生成しないようにしながら、
オブジェクトの生成と唯一性の管理に集中することになる&gt; (p. 139)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>デフォルト・コンストラクター、コピー・コンストラクター、代入演算子は
private に宣言することは承知しているが、これを読むまでデストラクターも
private にするのを忘れていた。</li>
</ul>
<hr class="docutils" />
<p>基本を説明してすぐに Singleton オブジェクトの破棄に関する議論が始まる。
これ以降の議論は、デザインパターンの本ではまずお目にかかったことのないものだ。</p>
<ul>
<li><p class="first">&lt;リソース・リークを避ける唯一の正しい手段とは、
アプリケーションの終了時に Singleton オブジェクトを削除することです。
問題は、その破棄後に、該当 Singleton に対するアクセスが発生しないようなタイミングを注意深く設定しなければならない点です&gt; (p. 142)</p>
</li>
<li><p class="first">次のタイプの実装を Meyers の Singleton と呼ぶことにする。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Singleton</span> <span class="n">obj</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>&lt;Meyers の Singleton は、アプリケーションの終了処理における最も簡単な
Singleton の破棄手段を提供しています&gt; (p. 143)</p>
</li>
</ul>
<hr class="docutils" />
<p>死んだ参照の議論。
<tt class="docutils literal"><span class="pre">Keyboard</span></tt>, <tt class="docutils literal"><span class="pre">Display</span></tt>, <tt class="docutils literal"><span class="pre">Log</span></tt> という 3 クラスがそれぞれ Singleton な場合で、
<tt class="docutils literal"><span class="pre">Keyboard</span></tt> と <tt class="docutils literal"><span class="pre">Display</span></tt> のエラーが <tt class="docutils literal"><span class="pre">Log</span></tt> に報告するような状況を考察する。
この問題を KDL 問題と呼ぶことにする。</p>
<ul>
<li><p class="first">&lt;この 3 つの Singleton を Meyers の Singleton で実装した場合、
プログラムは正しく動作しないのです&gt; (p. 144)</p>
</li>
<li><p class="first">&lt;妥当な方法は、Singleton に死んだ参照の検出をさせることです&gt; (p. 144)</p>
<p><tt class="docutils literal"><span class="pre">Singleton::Instance</span></tt> で検出させることで、何らかのエラーハンドリングをする。</p>
</li>
</ul>
<hr class="docutils" />
<p>Phoenix Singleton なる概念を導入する。
デストラクトされたオブジェクトのあったメモリに、
再度オブジェクトをコンストラクトするというものだ。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Singleton::OnDeadReference</span></tt> で placement new の機能を利用し、
<tt class="docutils literal"><span class="pre">pInstance_</span></tt> に <tt class="docutils literal"><span class="pre">Singleton</span></tt> オブジェクトを構築する。</li>
<li><tt class="docutils literal"><span class="pre">atexit</span></tt> に破棄関数 <tt class="docutils literal"><span class="pre">KillPhoenixSingleton</span></tt> を登録する。
<tt class="docutils literal"><span class="pre">KillPhoenixSingleton</span></tt> では <tt class="docutils literal"><span class="pre">pInstance_</span></tt> に対して明示的にデストラクターを呼び出す。
&lt;<tt class="docutils literal"><span class="pre">new</span></tt> を使用すると（略）コンパイラによる自動破棄が行われなくなるためです&gt; (p. 147)</li>
<li>ちなみに <tt class="docutils literal"><span class="pre">atexit</span></tt> にはキズがある。
&lt;規格では、 <tt class="docutils literal"><span class="pre">atexit</span></tt> を用いた関数の登録中に他の
<tt class="docutils literal"><span class="pre">atexit</span></tt> による登録が発生した場合の定義が行われていない&gt; (p. 147)</li>
</ul>
<hr class="docutils" />
<p>次の議論は、「Singleton に寿命レベルを導入する」というもの。</p>
<ul class="simple">
<li>前節の戦略だと、状態を保持するような Singleton では復活し切れないことは明白。</li>
<li>KDL 問題は「K, D よりも L のほうが長生きである」ことが表現できれば問題解決だ。</li>
</ul>
<p>&lt;ここで出てくる寿命の制御というコンセプトは、
Singleton のコンセプトとは独立したものです。
オブジェクトの寿命が長いほど、破棄が後にまわされるのです&gt; (p. 149)</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SetLongevity</span></tt> 関数の「仕様」は p. 151 のリスト参照。
<tt class="docutils literal"><span class="pre">atexit</span></tt> の呼び出しを含むのがポイント。</li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">寿命を指定する Singleton の実装法について数ページにわたる説明があるが、
読むのが面倒になったのでスキップ。</p>
</div>
<hr class="docutils" />
<p>マルチスレッド対応。</p>
<p>&lt;共有されるグローバル・リソースというものは全て、競合条件とスレッドに関連する問題の元凶となり得るのです&gt; (p. 155)</p>
<ul>
<li><p class="first">今では有名になった手法だが、Doug Schdmit と Tim Harrison が発案した (1996)
Double-Checked Locking パターンを紹介している。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 157 より引用</span>
<span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pInstance_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Guard</span> <span class="n">myGuard</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pInstance_</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pInstance_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">pInstance_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">ただし、ある種のマルチプロセッサではこのパターンが使えない。
使えるか否かを決定するには &lt;コンパイラのドキュメントを熟読しなければならない&gt; (p. 157)</p>
</li>
<li><p class="first">&lt;少なくとも、 <tt class="docutils literal"><span class="pre">pInstance_</span></tt> の次に <tt class="docutils literal"><span class="pre">volatile</span></tt> 修飾子を置くことです&gt; (p. 157)</p>
</li>
</ul>
<hr class="docutils" />
<p>これまでの分析を総合する。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">SingletonHolder</span></tt> を 3 つのポリシーに分解する。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Creator</span></tt>: <tt class="docutils literal"><span class="pre">pInstance_</span></tt> の初期化ポリシー。</li>
<li><tt class="docutils literal"><span class="pre">Lifetime</span></tt>: 「通常」「復活アリ」「寿命制御」「無限」の 4 パターンを提供している。</li>
<li><tt class="docutils literal"><span class="pre">Threading</span></tt>: シングルスレッド or マルチスレッド。</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 160 より引用</span>
<span class="k">template</span> <span class="o">&lt;</span>
   <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CreationPolicy</span> <span class="o">=</span> <span class="n">CreateUsingNew</span><span class="p">,</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">LifetimePolicy</span> <span class="o">=</span> <span class="n">DefaultLifetime</span><span class="p">,</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">ThreadingModel</span> <span class="o">=</span> <span class="n">SingleThreaded</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SingletonHolder</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;インスタンスの型は <tt class="docutils literal"><span class="pre">T*</span></tt> ではなく <tt class="docutils literal"><span class="pre">ThreadingModel&lt;T&gt;::VolatileType*</span></tt> です&gt; (p. 160)</p>
<p>→マルチスレッド環境では仇になる、コンパイラによるある種の最適化処理を抑止するため。</p>
</li>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">SingletonHolder</span></tt> が <tt class="docutils literal"><span class="pre">DestroySingleton</span></tt> を呼び出すことはありません&gt; (p. 161)</p>
</li>
<li><p class="first">KDL 問題の解として、仮コードを p. 164 に掲載している。</p>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id8">第 7 章 スマート・ポインタ</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>&lt;スマート・ポインタとは、 <tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> と単項演算子 <tt class="docutils literal"><span class="pre">operator*</span></tt>
を実装することによって単純なポインタとして使えるようにした C++ のオブジェクトです。
スマート・ポインタは、れっきとしたポインタのシンタックスとセマンティックスに加えて、
メモリ管理やロックといった処理を内部で実行することによって、
指しているオブジェクトの寿命を注意深く管理するという面倒な作業からアプリケーションを解放します&gt;
(p. 167) と、スマートポインタの定義を簡潔に与えている。</p>
<hr class="docutils" />
<ul>
<li><p class="first">&lt;スマート・ポインタとは、シンタックスとある種のセマンティックスに関して、
通常のポインタを模倣するような C++ のクラスです&gt; (p. 167)</p>
</li>
<li><p class="first">&lt;既存の高品質なスマート・ポインタでは、たいていの場合、
以下のコードのようにポインタの型によってテンプレート化されています&gt; (p. 168)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SmartPtr</span>
<span class="p">{</span>
    <span class="p">...</span>

<span class="nl">private:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">pointee_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;値のセマンティックスが存在するオブジェクトとは、
コピーや代入が可能なオブジェクトのことです&gt; (p. 169)</li>
<li>ほとんどのスマートポインタには &lt;所有権管理機能&gt; (p. 169) が提供されている。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">pointee_</span></tt> の型は必ず <tt class="docutils literal"><span class="pre">T*</span></tt> なのでしょうか&gt; (p. 170)</li>
<li><tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> のメカニズムを応用した &lt;事前および事後の関数呼び出し&gt; (p. 170)</li>
<li>ハンドルとポインタの類似性。
&lt;セマンティックスと管理方法を見た場合、ハンドルはポインタと良く似たものなのです&gt; (p. 171)</li>
</ul>
<hr class="docutils" />
<ul>
<li><p class="first">&lt;メンバ関数というものはスマート・ポインタに適したものではないのです&gt; (p. 172)</p>
<p>なぜかというと、 <tt class="docutils literal"><span class="pre">T</span></tt> の解放のためのメンバ関数呼び出しと、
<tt class="docutils literal"><span class="pre">SmartPtr&lt;T&gt;</span></tt> のそれが似ていて紛らわしいから。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SmartPtr</span><span class="o">&lt;</span><span class="n">Printer</span><span class="o">&gt;</span> <span class="n">spRes</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">spRes</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
<span class="n">spRes</span><span class="p">.</span><span class="n">Release</span><span class="p">();</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;スマート・ポインタは、メンバ関数を使ってはいけないのです。
つまり、 <tt class="docutils literal"><span class="pre">SmartPtr</span></tt> は非メンバ関数のみを使用するわけです&gt; (p. 172)</p>
</li>
</ul>
<hr class="docutils" />
<p>所有権に関する考察。</p>
<ul class="simple">
<li>ディープ・コピー方式<ul>
<li>ポリモフィズムをサポートするため、コピーには <tt class="docutils literal"><span class="pre">T</span></tt> のコピーコンストラクタは利用できない。
別途コピー用のポリシーを設けて、 <tt class="docutils literal"><span class="pre">SmartPtr</span></tt> のテンプレート引数とする。</li>
</ul>
</li>
<li>COW 方式<ul>
<li>COW 方式とは、「指しているオブジェクトが最初に更新されるタイミングでコピーする」というもの。</li>
<li>スマート・ポインタではその「タイミング」が把握できそうにないので、不採用とする。</li>
</ul>
</li>
<li>参照カウント方式<ul>
<li>&lt;同じオブジェクトを指しているスマート・ポインタの総数を追跡する&gt; (p. 176) 方式。</li>
<li>その総数カウンターを被参照オブジェクトにくっつける方式を侵入型参照カウント方式 (p. 177) と呼ぶ。</li>
</ul>
</li>
<li>参照リンク方式<ul>
<li>同じオブジェクトを指す <tt class="docutils literal"><span class="pre">SmartPtr</span></tt> が双方向リンクリスト構造をなす。
リストが空になるタイミングが、被参照オブジェクトの破棄タイミングとなる。</li>
</ul>
</li>
<li>破壊型コピー方式<ul>
<li><tt class="docutils literal"><span class="pre">SmartPtr</span></tt> のコピーを行った場合、コピー元のオブジェクトが破壊される方式。
<tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt> はまさにこれ。</li>
<li>&lt;破壊型コピー方式を用いたスマート・ポインタは、
値のセマンティックスをサポートしていないため、
コンテナに格納することができず、たいていの場合、
生のポインタを扱うのと同じくらい細心の注意を払って扱わなければならないのです&gt; (p. 180)</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>&lt;単項演算子 <tt class="docutils literal"><span class="pre">opearator&amp;</span></tt> のオーバーロードはお勧めできない&gt; (p. 181)</p>
<hr class="docutils" />
<p>生のポインタ型への暗黙の変換はサポートしない。
かわりに明示的な変換のための関数を提供する。</p>
<hr class="docutils" />
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SmartPtr&lt;T&gt;</span></tt> と <tt class="docutils literal"><span class="pre">T*</span></tt> の等価性テストのため、考え得る全ての組み合わせの
<tt class="docutils literal"><span class="pre">operator==</span></tt> および <tt class="docutils literal"><span class="pre">operator!=</span></tt> を提供する。</li>
<li>なおかつ、 <tt class="docutils literal"><span class="pre">SmartPtr&lt;T&gt;</span></tt> と <tt class="docutils literal"><span class="pre">U*</span></tt> のテストのために、
テンプレート版 (p. 187) も追加する。</li>
<li>算術型への変換は <tt class="docutils literal"><span class="pre">operator</span> <span class="pre">bool</span></tt> と同じ理由で推奨できない (p. 188)</li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">順序比較のセクションは、読むのが面倒になったのでスキップ。</p>
</div>
<hr class="docutils" />
<p>&lt;スマート・ポインタにおけるチェックの問題は、
初期化時と参照外し時という 2 つのカテゴリに分類できます&gt; (p. 192)</p>
<ul class="simple">
<li>&lt;経験則としては、ポインタのチェックを厳格に行うことから始めて、
プロファイラ結果に応じて、チェックの除去が可能なスマート・ポインタを選ぶというのが良いでしょう&gt; (p. 193)</li>
<li>&lt;エラーを報告するための最も優れた方法は、例外をスローすることです&gt; (p. 193)</li>
</ul>
<hr class="docutils" />
<p>マルチスレッド問題は付録 A まで取っておくか。</p>
<ul class="simple">
<li>ここ (p. 196) で紹介されている <tt class="docutils literal"><span class="pre">LockingProxy</span></tt> での <tt class="docutils literal"><span class="pre">operator-&gt;</span></tt> トリックはおさえること。</li>
<li>マルチスレッド参照カウント方式と、マルチスレッド参照リンク方式。</li>
<li>クラスレベルのロックと、オブジェクトレベルのロック。</li>
</ul>
<hr class="docutils" />
<p>これまでの分析を総合する。</p>
<ul>
<li><p class="first">&lt;私たちは問題をポリシーと呼ぶ小さなクラスへと分割するのです。
そして、各ポリシー・クラスでは、たった 1 つの問題を取り扱います&gt; (p. 200)</p>
</li>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">SmartPtr</span></tt> の宣言中に現れるポリシーの順序は、
最も良くカスタマイズされるものが先頭に来るようになっています&gt; (p. 201)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span>
<span class="o">&lt;</span>
   <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">OwnershipPolicy</span> <span class="o">=</span> <span class="n">RefCounted</span><span class="p">,</span>
   <span class="k">class</span> <span class="nc">ConversionPolicy</span> <span class="o">=</span> <span class="n">DisallowConversion</span><span class="p">,</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CheckingPolicy</span> <span class="o">=</span> <span class="n">AssertCheck</span><span class="p">,</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">StoragePolicy</span> <span class="o">=</span> <span class="n">DefaultSPStorage</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SmartPtr</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id9">第 8 章 オブジェクト・ファクトリ</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>この章のテーマは Factory Method デザインパターン。
個人的には C++ では最もコードが書きにくいパターンだと思っているので、
楽しく読めた。</p>
<ul class="simple">
<li>&lt;ここで問題になるのは、実際に導出を行う <tt class="docutils literal"><span class="pre">Derived</span></tt> という型名を
<tt class="docutils literal"><span class="pre">new</span></tt> 演算子の起動時に記述しなければならない点です。（略）ある意味では、
使用してはいけないとされているコード中の数値定数と良く似ています&gt; (p. 209)</li>
<li>&lt;型は必ずコンパイル時点で既知のものでなければならないのです&gt; (p. 209)</li>
<li>&lt;C++ におけるオブジェクトの生成では、
呼び出し側と導出された具体的なクラスを束縛することになるのです&gt; (p. 210)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>例えば、ライブラリーがユーザー定義クラスのオブジェクト生成を行う必要がある場合、
これはオブジェクト・ファクトリが必要とされるケースのひとつだ。</li>
<li>説明コードの <tt class="docutils literal"><span class="pre">DocumentManager::NewDocument</span></tt> では <tt class="docutils literal"><span class="pre">new</span></tt> 演算子ではなく、
<tt class="docutils literal"><span class="pre">CreateDocument</span></tt> 仮想メソッド呼び出しで（ユーザー定義型の）オブジェクトを生成する。<ul>
<li>この <tt class="docutils literal"><span class="pre">CreateDocument</span></tt> のような役割を持つメソッドを Factory Method と呼ぶ。</li>
</ul>
</li>
<li>保存ファイルからオブジェクトを再現する際にも、オブジェクト・ファクトリが必要だ。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;何故言語自身にオブジェクトを生成するための柔軟な手段が備わっていないのでしょうか？&gt; (p. 212)</li>
<li>&lt;C++ でオブジェクト・ファクトリを作り出すのは難しい問題になる&gt; (p. 213)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Drawing::Load</span></tt> コード (pp. 214-215) は現場でよく見かけるパターン。
いい題材だ。</li>
<li>&lt;唯一の問題は、オブジェクト指向にける最も重要な規則に反している点です&gt; (p. 215)<ul>
<li>型の「タグ」に基づいて <tt class="docutils literal"><span class="pre">switch</span></tt> 文を書いている点。</li>
<li><tt class="docutils literal"><span class="pre">Shape</span></tt> の派生クラスへの言及が、単独のソースファイルに集積される点。</li>
<li>拡張することが難しい。</li>
</ul>
</li>
<li>クラス <tt class="docutils literal"><span class="pre">ShapeFactory</span></tt> で <tt class="docutils literal"><span class="pre">Shape</span></tt> 派生オブジェクトを生成する関数のポインタのマップを管理する。<ul>
<li>各 <tt class="docutils literal"><span class="pre">Shape</span></tt> 派生クラスの実装ファイルで、p. 217 のコードを機械的に記述すればよい。</li>
<li>&lt;このコードは、 <tt class="docutils literal"><span class="pre">std::map</span></tt> クラス・テンプレートに馴染みのない方にとっては、
若干説明が必要かもしれません&gt; (p. 218) とあるが、
そんな方はこの本の読者なんかやってないと思う。</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>マップのキーを整数型ではなく、もっとそれらしいものにしようではないかという議論。</p>
<p>&lt;こういったことから帰結できる唯一の結論は、
型識別子の管理はオブジェクト・ファクトリ自身の管轄ではないということです。
C++ という言語が、ユニークで永続的な型 ID を保証していない以上、
型 ID の管理はプログラマが対処しなければならない問題なのです&gt; (p. 219)</p>
<hr class="docutils" />
<p>ここからオブジェクト・ファクトリの一般化について議論する。</p>
<ul class="simple">
<li>&lt;ファクトリは具体的な成果物を知る必要がない&gt; (p. 220) ので、
「具体的な成果物」は <tt class="docutils literal"><span class="pre">Factory</span></tt> のテンプレートパラメータにならない。</li>
<li>&lt;エラー時の取り扱いコードを <tt class="docutils literal"><span class="pre">CreateObject</span></tt> メンバ関数から無くし、
<tt class="docutils literal"><span class="pre">FactoryError</span></tt> ポリシーに分離しなければなりません&gt; (p. 221)</li>
</ul>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span>
<span class="o">&lt;</span>
   <span class="k">class</span> <span class="nc">AbstractProduct</span><span class="p">,</span>
   <span class="k">class</span> <span class="nc">IdentifierType</span><span class="p">,</span>
   <span class="k">class</span> <span class="nc">ProductCreator</span> <span class="o">=</span> <span class="n">AbstractProduct</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="p">)(),</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span> <span class="n">class</span><span class="o">&gt;</span>
      <span class="k">class</span> <span class="nc">FactoryErrorPolicy</span> <span class="o">=</span> <span class="n">DefaultFactoryError</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Factory</span><span class="p">;</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">クローン・ファクトリは読みとばす。
「共変の戻り型」の用語解説はおさえておくこと。</p>
</div>
<hr class="docutils" />
<p>オブジェクト・ファクトリは通常 Singleton であることが自然。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 228 より引用</span>
<span class="k">typedef</span> <span class="n">SingletonHolder</span><span class="o">&lt;</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">Shape</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ShapeFactory</span><span class="p">;</span>
</pre></div>
</div>
<p>以前の <tt class="docutils literal"><span class="pre">Functor</span></tt> を <tt class="docutils literal"><span class="pre">ProductCreator</span></tt> とすることも可能。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 228 より引用</span>
<span class="k">typedef</span> <span class="n">SingletonHolder</span>
<span class="o">&lt;</span>
   <span class="n">Factory</span><span class="o">&lt;</span><span class="n">Shape</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">*&gt;</span> <span class="o">&gt;</span>
<span class="o">&gt;</span>
<span class="n">ShapeFactory</span><span class="p">;</span>
</pre></div>
</div>
<hr class="docutils" />
<p><a class="reference internal" href="alexandrescu01-note3.html"><em>Modern C++ Design 読書ノート 3/3</em></a> へ。</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート v1.2.1</a> &raquo;</li>
          <li><a href="alexandrescu01.html" >Modern C++ Design 読書ノート</a> &raquo;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_share">
        <a href="https://twitter.com/share" class="twitter-share-button" data-size="large">Tweet</a>
        <script type="text/javascript">render_twitter_button(document, 'script', 'twitter-wjs')</script>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2014, プレハブ小屋 All rights reserved.
      </div>
      <div id="footer_spacer">
        <p>
          Last updated at 2014/11/07 (Fri) 22:31:11.
        </p>
      </div>
    </div>
  </body>
</html>