
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>ネットワークフロー &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/prefab.css" />
    
    <script src="../_static/mathjax-v3.js"></script>
    
    <link rel="next" title="グラフを描画する" href="drawing.html" />
    <link rel="prev" title="連結度" href="connectivity.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="drawing.html" title="グラフを描画する"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="connectivity.html" title="連結度"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">NetworkX 利用ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ネットワークフロー</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="id1">
<h1><a class="toc-backref" href="#id8">ネットワークフロー</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>本稿では <a class="reference external" href="https://networkx.github.io/">NetworkX</a> の提供する機能を利用して、各種ネットワークフロー問題を解決する方法について記す。</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id8">ネットワークフロー</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id9">最大フロー</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id10">お手軽な手法</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id11">残余ネットワーク計算アルゴリズムを指定する手法</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id5" id="id12">最大フロー最小カット</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id13">最小コストフロー</a></p>
<ul>
<li><p><a class="reference internal" href="#id7" id="id14">最大フロー最小コスト</a></p></li>
<li><p><a class="reference internal" href="#nx-network-simplex" id="id15">関数 <code class="docutils literal notranslate"><span class="pre">nx.network_simplex</span></code></a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="id2">
<h2><a class="toc-backref" href="#id9">最大フロー</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>上下水道路、ガス管網、電線網、通信網、等々、ある種の「流れ」を表現するグラフが与えられているときに、その源流始点から終点までに流すことのできる水量なり電流なりの最大値、ここでは最大フローと呼ぶことにするが、この値を求める問題を解くための機能について記す。</p>
<p>各種ネットワークの水道管なり電線なりをグラフの辺として解釈するわけだが、その各辺に付随する容量を属性として定義するのが肝要だ。</p>
<section id="id3">
<h3><a class="toc-backref" href="#id10">お手軽な手法</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://networkx.github.io/">NetworkX</a> では最大フローを求める関数はズバリ <code class="code docutils literal notranslate"><span class="pre">nx.maximum_flow</span></code> だ。まずはキーワード引数を全く指定せずに利用する例を示す。すなわち、グラフと始点と終点だけを指定するだけで最大フローを求める。</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Maximum_flow_problem">Wikipedia</a> の説明文の図を拝借して、実行してみる。図の各辺のキャプションの <code class="docutils literal notranslate"><span class="pre">/</span></code> の右側の値が容量だから、グラフの構築コードは次のようになる。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;maxflow.py: demonstrate NetworkX (maximum_flow).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;The main function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This graph is borrowed from:</span>
    <span class="c1"># http://en.wikipedia.org/wiki/Maximum_flow_problem</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(((</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span>
                      <span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span>
                      <span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="mi">2</span><span class="p">)),</span>
                      <span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span>
                      <span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="mi">4</span><span class="p">)),</span>
                      <span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="mi">2</span><span class="p">)),</span>
                      <span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="mi">2</span><span class="p">)),</span>
                      <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="mi">3</span><span class="p">)),))</span>

    <span class="n">flow_value</span><span class="p">,</span> <span class="n">flows</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">maximum_flow</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;maximum flow: </span><span class="si">{</span><span class="n">flow_value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">caps</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;capacity&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">flow</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">flows</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">): </span><span class="si">{</span><span class="n">flow</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">caps</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>実行結果は次のようになる。最大フローが得られており、各辺の流量が <a class="reference external" href="http://en.wikipedia.org/wiki/Maximum_flow_problem">Wikipedia</a> の図の各辺のキャプションの <code class="docutils literal notranslate"><span class="pre">/</span></code> の左側の値と一致した。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python maxflow.py
maximum flow: <span class="m">5</span>
<span class="o">(</span>s, o<span class="o">)</span>: <span class="m">3</span>/3
<span class="o">(</span>s, p<span class="o">)</span>: <span class="m">2</span>/3
<span class="o">(</span>o, p<span class="o">)</span>: <span class="m">0</span>/2
<span class="o">(</span>o, q<span class="o">)</span>: <span class="m">3</span>/3
<span class="o">(</span>q, r<span class="o">)</span>: <span class="m">1</span>/4
<span class="o">(</span>q, t<span class="o">)</span>: <span class="m">2</span>/2
<span class="o">(</span>p, r<span class="o">)</span>: <span class="m">2</span>/2
<span class="o">(</span>r, t<span class="o">)</span>: <span class="m">3</span>/3
</pre></div>
</div>
</section>
<section id="id4">
<h3><a class="toc-backref" href="#id11">残余ネットワーク計算アルゴリズムを指定する手法</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>ここでは関数 <code class="code docutils literal notranslate"><span class="pre">nx.maximum_flow</span></code> のキーワード引数
<code class="docutils literal notranslate"><span class="pre">flow_func</span></code> を明示的に指示する方法を記す。出来合いのアルゴリズムでは、以下の表に示すものが利用できる。グラフや容量の特性に合わせてアルゴリズムを選択するのだ？</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 24%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>関数</p></th>
<th class="head"><p>計算量</p></th>
<th class="head"><p>コメント</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">preflow_push</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(O(n^2 \sqrt{m})\)</span></p></td>
<td><p>デフォルトのアルゴリズム。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">ford_fulkerson</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(O(nm^2)\)</span></p></td>
<td><p>レガシーな実装とのこと。</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">edmonds_karp</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(O(n m^2)\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ford_fulkerson</span></code> の「特殊版」の実装。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">shortest_augmenting_path</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(O(\min(n^{2/3}, m^{1/2}) m)\)</span></p></td>
<td><p>最短増大路。</p></td>
</tr>
</tbody>
</table>
<p>関数 <code class="code docutils literal notranslate"><span class="pre">nx.maximum_flow</span></code> の実装を調べると、どうもこれらの関数のラッパーなのではないかという気がする。</p>
<p>インポートについては、例えば <code class="code docutils literal notranslate"><span class="pre">shortest_augmenting_path</span></code> ならば次のように書けばよい。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">networkx.algorithms.flow</span> <span class="kn">import</span> <span class="n">shortest_augmenting_path</span>
</pre></div>
</div>
</section>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id12">最大フロー最小カット</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>先程の例と同じグラフを用いて、最小カットを求める手順を以下に示す。関数 <code class="code docutils literal notranslate"><span class="pre">nx.minimum_cut</span></code> を利用するだけでよいのだが、最小カットが複数存在する場合でも、そのうちの一つを求めるようだ。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># partition here is a tuple with the two sets of nodes that</span>
    <span class="c1"># define the minimum cut (S, T).</span>
    <span class="n">cut_value</span><span class="p">,</span> <span class="n">partition</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">partition</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cut value: </span><span class="si">{</span><span class="n">cut_value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;(S, T): (</span><span class="si">{</span><span class="n">S</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">T</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the cut set of edges that induce the minimum cut</span>
    <span class="c1"># as follows:</span>
    <span class="n">cutset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">G</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">S</span><span class="p">):</span>
        <span class="n">cutset</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nbrs</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cut set: </span><span class="si">{</span><span class="n">cutset</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>実行結果を次に示す。カットセットの構成本数が点 s, t に関する辺連結度 2 と一致している。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cut value: 5
(S, T): ({&#39;o&#39;, &#39;r&#39;, &#39;p&#39;, &#39;s&#39;, &#39;q&#39;}, {&#39;t&#39;})
cut set: {(&#39;r&#39;, &#39;t&#39;), (&#39;q&#39;, &#39;t&#39;)}
</pre></div>
</div>
<figure class="align-center">
<a class="reference external image-reference" href="http://commons.wikimedia.org/wiki/File:Max_flow.svg"><img alt="Licensed under CC-BY-SA 3.0" src="../_images/networkx-mincut.png" style="width: 400.0px; height: 240.0px;" /></a>
</figure>
<p>当然ながら関数 <code class="code docutils literal notranslate"><span class="pre">nx.minimum_cut</span></code> もキーワード引数
<code class="docutils literal notranslate"><span class="pre">flow_func</span></code> をサポートしているので、グラフの特性に適したアルゴリズムを指示するとよいだろう。</p>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id13">最小コストフロー</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>今まで見てきたのは、グラフの辺に容量という属性が付いた条件下の最大フロー算出問題だったが、ここではコストという概念を取り扱う。具体的には、フローを成立させるコストが最小になるようなものを求める。</p>
<p>輸送コストは辺に属性として指定する。属性値名はデフォルトでは <code class="docutils literal notranslate"><span class="pre">weight</span></code> だ。例によって各関数のキーワード引数 <code class="docutils literal notranslate"><span class="pre">weight</span></code> で明示的に指示できる。本稿では特に書き換えない。辺の容量の属性は引き続き <code class="docutils literal notranslate"><span class="pre">capacity</span></code> として指定する。なお、容量が未指定の辺も許される。グラフの構造によっては一部負の値の容量を持つものも許される。</p>
<p>例題はドキュメントを参照して欲しい。探すのが難しい。</p>
<section id="id7">
<h3><a class="toc-backref" href="#id14">最大フロー最小コスト</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>最大フロー最小コスト問題を考える。これは、各辺の容量とコストが与えられているときに、ある始点からある終点までの、可能な限り安くつく最大フローを求める問題だ。これを解くには、各属性を持つ辺の集合から有向グラフを適宜構築し、関数 <code class="code docutils literal notranslate"><span class="pre">nx.max_flow_min_cost</span></code> と <code class="code docutils literal notranslate"><span class="pre">nx.cost_of_flow</span></code>
を用いて最大フローを得るという手順を踏むのがよさそうだ。</p>
</section>
<section id="nx-network-simplex">
<h3><a class="toc-backref" href="#id15">関数 <code class="docutils literal notranslate"><span class="pre">nx.network_simplex</span></code></a><a class="headerlink" href="#nx-network-simplex" title="Permalink to this headline">¶</a></h3>
<p>さらに、グラフの辺に輸送コストも付けたり、グラフの点に需要供給量を指定した状況でのフロー問題を解く機能について記す。</p>
<p>これには関数 <code class="code docutils literal notranslate"><span class="pre">nx.network_simplex</span></code> を利用する。ただし必要に応じて、グラフの点に属性 <code class="docutils literal notranslate"><span class="pre">demand</span></code> を付加する。「流れ」が発生する点には負の値を、消費する点には正の値を指定する。</p>
<p>なお、最小コスト系の関数はすべて関数 <code class="code docutils literal notranslate"><span class="pre">nx.network_simplex</span></code> で実装されている。</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="drawing.html" title="グラフを描画する"
             >next</a></li>
        <li class="right" >
          <a href="connectivity.html" title="連結度"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >NetworkX 利用ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ネットワークフロー</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2021, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>