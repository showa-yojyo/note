<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Modern C++ Design 読書ノート 1/3 &#8212; 読書ノート 1.6dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=c9b0a06a" />
    <script src="../_static/documentation_options.js?v=4354bf25"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="../_static/mathjax-v3.js?v=bf1ec211"></script>
    <script src="../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="Modern C++ Design 読書ノート 2/3" href="note2.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
    <div class="related top">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="index.html" title="Previous">Modern C++ Design 読書ノート</a>
        </li>
      
        <li>
          <a href="note2.html" title="Next">Modern C++ Design 読書ノート 2/3</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>


          <div class="body" role="main">
            
  <section id="modern-c-design-1-3">
<h1><a class="toc-backref" href="#id7" role="doc-backlink">Modern C++ Design 読書ノート 1/3</a><a class="headerlink" href="#modern-c-design-1-3" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">著者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Andrey Alexandrescu</p>
</dd>
<dt class="field-even">訳者<span class="colon">:</span></dt>
<dd class="field-even"><p>村上雅章</p>
</dd>
<dt class="field-odd">出版社<span class="colon">:</span></dt>
<dd class="field-odd"><p>ピアソン・エデュケーション</p>
</dd>
<dt class="field-even">発行年<span class="colon">:</span></dt>
<dd class="field-even"><p>2001 年</p>
</dd>
<dt class="field-odd">ISBN<span class="colon">:</span></dt>
<dd class="field-odd"><p>978-4-89471-435-9</p>
</dd>
</dl>
<nav class="contents" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#modern-c-design-1-3" id="id7">Modern C++ Design 読書ノート 1/3</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id8">ローマ数字ページ各種</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id9">第 1 章 ポリシーを基にしたクラス・デザイン</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id10">第 2 章 テクニック</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id11">第 3 章 タイプリスト</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id12">第 4 章 小規模オブジェクトの割り当て</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="id2">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">ローマ数字ページ各種</a><a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>本書推薦その 1 は Scott Meyers が寄せている。言うまでもなく Effective C++ シリーズの著者だ。</p>
<ul>
<li><p>&lt;パターン自身をコード化するのではなく、パターンの実装を自動的に生成させる&gt;
(p. x)</p></li>
</ul>
</li>
<li><p>推薦その 2 は John Vlissides が寄せている。GoF の一人。</p>
<ul>
<li><p>&lt;テンプレート・パラメータによって、実行時のオーバーヘッドをまったく発生させずに、実装上のトレード・オフを変えることもできるのです&gt; (p. xiii)</p></li>
</ul>
</li>
<li><p>著者によるまえがきで、本書の目的を明瞭に示している。</p>
<ul>
<li><p>対象読者タイプ 1: &lt;C++ プログラマ経験者で最新のライブラリ作成テクニックをマスターしたいと考えている方々&gt;</p></li>
<li><p>対象読者タイプ 2: &lt;忙しいプログラマで手っ取り早く作業を済ませてしまう必要がある方々&gt; (p. xviii)</p></li>
<li><p>&lt;Loki という実在する C++ ライブラリ&gt; (p. xviii) を解説する本である。</p></li>
<li><p>本書中のコード例では、Herb Sutter 式コーディング規則を採用。もしかして
Exceptional C++ Style が関係ある？</p></li>
</ul>
</li>
<li><p>訳者まえがき</p>
<ul>
<li><p>&lt;ある種の意思決定は実装段階でなければ行えない&gt; (p. xxiii)</p></li>
<li><p>&lt;センス・オブ・ワンダーの渦巻く C++ の新世界をお楽しみ下さい&gt;</p></li>
</ul>
</li>
</ul>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">第 1 章 ポリシーを基にしたクラス・デザイン</a><a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>ポリシーとポリシー・クラスとは、重要なクラス設計技術のひとつらしい。</p></li>
<li><p><em class="dfn">ポリシー</em> とは、&lt;特定の動作や構造上の側面を専門的に受け持った小さなクラス群&gt; (p. 3) のこと。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;プログラミングの天才が若年層に分布しているのに対して、ソフトウェア設計の天才がより高年齢層に分布する傾向にある&gt; (p. 4)</p></li>
<li><p>&lt;システム・アーキテクチャには、「設計によってある種の公理を強制する」という重要な目標があります&gt; (p. 4)</p></li>
<li><p>&lt;理想的には、設計によって課された制約のほとんどが、コンパイル時点で強制されるべきなのです&gt; (p. 4)</p></li>
<li><p>&lt;組み合わせ爆発と真っ向勝負を挑んではいけない&gt; (p. 5)</p></li>
<li><p>&lt;設計指向のライブラリ&gt; (p. 5)</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;いくつかの吟味された基底クラスを用意しておき、多重継承によって設計の選択における組み合わせの爆発を取り扱うというアイディアが考えられます。（略）しかし、少しでもクラス設計の経験があれば、こういった単純な設計がうまく機能しないことは理解できるでしょう&gt; (p. 6)</p></li>
<li><p>&lt;クラス・テンプレートは、通常のクラスではサポートされていないような方法でカスタマイズすることが可能です。もし特殊なケースを実装したいのであれば、特定のクラス・テンプレートを生成する際に、そのテンプレートにおける任意のメンバ関数を特殊化することができるのです。例えば、<code class="docutils literal notranslate"><span class="pre">SmartPtr&lt;T&gt;</span></code> というテンプレートがある場合、<code class="docutils literal notranslate"><span class="pre">Smart&lt;Widget&gt;</span></code> における任意のメンバ関数を特殊化することができるわけです&gt; (p. 6)</p></li>
<li><p>&lt;さらに、多重パラメータのクラス・テンプレートを用いた場合、部分的にテンプレートの特殊化を行うこともできます&gt; (p. 6)</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// こういう定義がある場合、</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">SmartPtr</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// この定義は部分特殊化となる。</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">SmartPtr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;多重継承とテンプレートには相補的なトレード・オフが存在しています&gt; (p. 7)</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>ポリシーは traits と通じるものがあるが、型ではなく動作を強調する点が異なる。</p></li>
<li><p>ポリシーは「コンパイル時 Strategy パターン」と見ることもできる。</p></li>
<li><p>&lt;ポリシーは、シグネチャ指向ではなく、シンタックス指向なのです&gt; (p. 8) &lt;例えば、<code class="docutils literal notranslate"><span class="pre">Creator</span></code> ポリシーでは <code class="docutils literal notranslate"><span class="pre">Create</span></code> が <code class="docutils literal notranslate"><span class="pre">static</span></code> であるか <code class="docutils literal notranslate"><span class="pre">virtual</span></code> であるかを規定しません&gt; (p. 8)</p></li>
<li><p><strong>ホスト</strong> または <strong>ホスト・クラス</strong> とは、1 つ以上のポリシーを利用するクラスのことを指す。</p></li>
</ul>
<hr class="docutils" />
<p>テンプレート・パラメータに <code class="docutils literal notranslate"><span class="pre">template</span></code> を用いる技法が紹介されている。自分ではこういうクラスを定義することはないが、利用する可能性があるので覚えておくこと。</p>
<ul class="simple">
<li><p>ポリシーを使用することで得られる柔軟性</p>
<ul>
<li><p>実体化する際のテンプレート引数を変更するだけで、簡単に外部からポリシーを変更できる。</p></li>
<li><p>アプリケーションに特化した自作ポリシーを提供できる。</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>ポリシー・クラスのデストラクタについて言及あり。</p>
<ul class="simple">
<li><p>ポリシーに対してデストラクタを <code class="docutils literal notranslate"><span class="pre">virtual</span></code> にすると、ポリシーの性質が静的ではなくなる。効率のよい解決策としては、デストラクタを非 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> かつ
<code class="docutils literal notranslate"><span class="pre">protected</span></code> とする。</p></li>
</ul>
<hr class="docutils" />
<p>「不完全実体化」の技法について解説あり。</p>
<p>「あるクラス・テンプレートのメンバ関数が使用されない場合、それは実体化されることがない」すなわちコンパイルエラーが起こらない。</p>
<hr class="docutils" />
<ul>
<li><p>&lt;ポリシーに基づいたクラス設計を行う上で最も難しいのは、クラスの機能を正しくポリシーへと分解することです&gt; (p. 20)</p></li>
<li><p>&lt;極端に言えば、ホスト・クラスから固有のポリシーを完全に無くしてしまうのです&gt;
(p. 20)</p></li>
<li><p>&lt;過度に一般化されたホスト・クラスの欠点は、テンプレート・パラメータが氾濫するということです&gt; (p. 20)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">typedef</span></code> の使用によって、秩序だった使用と容易な保守性が保証される。</p></li>
<li><p>&lt;クラスをポリシーに分解する際、 <strong>直交性のある</strong> (orthogonal) 切り口を見つけ出すことが大変重要になります&gt; (p. 21)</p>
<p>&lt;お互いが完全に独立した&gt; (p. 21) 役割になるように、ポリシー分割するのがよいということだな。あるポリシーが別のポリシーに干渉するようではまずい。</p>
</li>
</ul>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">第 2 章 テクニック</a><a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>静的チェックの必要性。すなわち、コンパイル時版 <code class="docutils literal notranslate"><span class="pre">assert</span></code> だ。 &lt;評価される式がコンパイル時の定数になるのであれば、実行時ではなく、コンパイル時にチェックを行うことができるはずです&gt; (p. 26)</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">CompileTimeError</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">CompileTimeError</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">{};</span>

<span class="cp">#define STATIC_CHECK(expr) \</span>
<span class="cp">   (CompileTimeError&lt;(expr) != 0&gt;())</span>
</pre></div>
</div>
<ul class="simple">
<li><p>上記のマクロからスタートし、エラーメッセージをなるべく読み易くするように工夫を重ねていく。</p></li>
<li><p>省略記号 <code class="docutils literal notranslate"><span class="pre">(...)</span></code> を用いた関数宣言を利用する。</p></li>
</ul>
<hr class="docutils" />
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Window</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Controller</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Widget</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// テンプレート全体を明示的に特殊化する場合の例。</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Widget</span><span class="o">&lt;</span><span class="n">ModalDialog</span><span class="p">,</span><span class="w"> </span><span class="n">MyController</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// 任意の Window や MyController に対して特殊化する場合（部分特殊化）。</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Window</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Widget</span><span class="o">&lt;</span><span class="n">Window</span><span class="p">,</span><span class="w"> </span><span class="n">MyController</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;クラス・テンプレートの部分的な特殊化では、テンプレート引数の一部だけを記述し、その他の引数を元のままにしておく&gt; (p. 29)</p></li>
<li><p>&lt;テンプレートの部分的な特殊化は、メンバ関数、非メンバ関数を問わず、関数には適用されません&gt; (p. 30) が、こういう場合は関数のオーバーロードを併用する。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>ローカルクラスの話題だが、他のプログラミング言語を知っている人間なら驚かないかも。</p></li>
<li><p>ローカルクラスの特徴</p>
<ul>
<li><p>ローカルクラスでは <code class="docutils literal notranslate"><span class="pre">static</span></code> メンバを定義できない。</p></li>
<li><p>ローカルクラスから（それを含む関数定義内にある）非 <code class="docutils literal notranslate"><span class="pre">static</span></code> のローカル変数にアクセスできない。</p></li>
<li><p>関数テンプレート内でローカルクラスを定義することができ、それを囲んでいる関数のテンプレート・パラメータを用いることもできる。</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Int2Type</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>例えば &lt;<code class="docutils literal notranslate"><span class="pre">Int2Type&lt;0&gt;</span></code> と <code class="docutils literal notranslate"><span class="pre">Int2Type&lt;1&gt;</span></code> は異なった型&gt; (p. 31) となる。このようなクラスの応用例として、p. 33 の <code class="docutils literal notranslate"><span class="pre">NiftyContainer::DoSomething</span></code> を覚えておくこと。</p></li>
</ul>
<hr class="docutils" />
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Type2Type</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">OriginalType</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type2Type</span></code> もオーバーロード関数の仮引数の型としてだけ利用する。p. 35 の関数テンプレート <code class="docutils literal notranslate"><span class="pre">Create</span></code> のオーバーロードに注目。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;ブーリアン定数によって様々な型から特定の型を選択しなければならない場合&gt;
(p. 35)</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Select</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">Result</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Select</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">Result</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPolymorphic</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NiftyContainer</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ここでコンテナの収容型を typedef するのに</span>
<span class="w">    </span><span class="c1">// Select を利用できる。</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;何も情報が与えられていない 2 つの型 <code class="docutils literal notranslate"><span class="pre">T</span></code> と <code class="docutils literal notranslate"><span class="pre">U</span></code> がある場合、<code class="docutils literal notranslate"><span class="pre">U</span></code> が
<code class="docutils literal notranslate"><span class="pre">T</span></code> を継承しているかどうか、そのようにすれば判るのでしょうか&gt; (p. 37)</p></li>
<li><p>&lt;任意の型 <code class="docutils literal notranslate"><span class="pre">T</span></code> が任意の型 <code class="docutils literal notranslate"><span class="pre">U</span></code> への自動変換をサポートしているかどうかは、どのように検出すればよいのでしょうか&gt; (p. 37)</p></li>
<li><p>脚注にいいことが書いてある。&lt;<code class="docutils literal notranslate"><span class="pre">sizeof</span></code> はいずれにしても型を検出しなければならないため、<code class="docutils literal notranslate"><span class="pre">typeof</span></code> と <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> は明らかに同じバックエンドを共有しているのです&gt; (p. 37)</p></li>
<li><p>解決策は、まず p.38 のアイディアをコードに落として、それから p. 39 のクラステンプレート <code class="docutils literal notranslate"><span class="pre">Conversion</span></code> の中にすべて閉じ込めるというもの。省略記号をとる関数オーバーロード、定義なし関数宣言と <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> のペアをうまく組み合わせている。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">typeid</span></code> 演算子とは、<code class="docutils literal notranslate"><span class="pre">type_info</span></code> オブジェクトへの参照を返すものです&gt;
(p. 40) 個人的にはこれまでの C++ 経験で <code class="docutils literal notranslate"><span class="pre">typeid</span></code> を利用した記憶がない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_info</span></code> の特徴 (p. 41)</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> というメンバ関数があるが、クラス名を文字列に対応づける方法は標準化されていない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">before</span></code> メンバ関数が <code class="docutils literal notranslate"><span class="pre">type_info</span></code> 型の順序関係を定義する。</p></li>
<li><p>コピーコンストラクタと代入演算子が無効化されている。何が言いたいかというと、「値」を何か変数に格納できないということ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">typeid</span></code> が返すオブジェクトは静的記憶域内に存在する。</p></li>
</ul>
</li>
<li><p>使いにくいので、ラッパークラスを定義する。</p></li>
</ul>
<hr class="docutils" />
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">NullType</span><span class="p">{};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">EmptyType</span><span class="p">{};</span><span class="w"> </span><span class="c1">// 継承を許す。</span>
</pre></div>
</div>
<hr class="docutils" />
<ul>
<li><p>&lt;特性 (traits) とは、値に基づく決定が実行時に行えるのと同様に、型に基づく決定をコンパイル時に行えるようにするジェネリックなプログラミング・テクニックです
(Alexandrescu 2000a)&gt; (p. 43)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::copy</span></code> の実装にこの技法が採用されていることが多いようだ。</p></li>
<li><p>&lt;ある型 <code class="docutils literal notranslate"><span class="pre">T</span></code> のオブジェクトを引数として関数間で授受する場合、（略）一般的に最も効率の良い方法とは、複雑な型を参照で、スカラ型は値で引き渡すことです&gt;
(p. 46)</p></li>
<li><p>&lt;ここで注意が必要なのは、C++ では参照への参照が許されないという点です&gt; (p. 47)</p>
<p><code class="docutils literal notranslate"><span class="pre">std::bind2nd</span></code> と <code class="docutils literal notranslate"><span class="pre">std::mem_fun</span></code> を組み合わせた場合に、このエラーが発生することも言及している。</p>
</li>
<li><p>&lt;型が <code class="docutils literal notranslate"><span class="pre">enum</span></code> かどうかを判断する方法は存在しない&gt; (p. 47)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span></code> と言えば、p. 49 のコードを見て知ったが、関数定義の中で <code class="docutils literal notranslate"><span class="pre">enum</span></code> を定義できるようだ。</p></li>
</ul>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">第 3 章 タイプリスト</a><a class="headerlink" href="#id5" title="Link to this heading">¶</a></h2>
<p>この章を真面目に読めば読むほど疲れる。理解できなくて構わないから、気になるところだけ書き留めておく。</p>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;Abstract Factory では、設計時点で確定している型毎に、1 つずつ仮想関数を定義します&gt; (p. 53) 「設計時点で確定している型毎」というのがミソ。Abstract Factory
をライブラリー化しづらいことを示唆している。</p></li>
<li><p>&lt;根幹となるコンセプトを一般化することができなければ、そのコンセプトの具体的な実体も一般化することができません&gt; (p. 54)</p></li>
<li><p>&lt;テンプレート・パラメータの数を可変にすることはできない&gt; (p. 55)</p></li>
<li><p>&lt;仮想関数はテンプレートにできない&gt; (p. 55) 言われてみればそうだった。</p></li>
</ul>
<hr class="docutils" />
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Typelist</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">Head</span><span class="p">;</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">Tail</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;テンプレート・パラメータには、同じテンプレートの別な実体化を含む任意の型を指定できる&gt; (p. 56) ので、<code class="docutils literal notranslate"><span class="pre">U</span></code> をガンガン入れ子にすることで <code class="docutils literal notranslate"><span class="pre">Typelist</span></code> を伸ばす。</p></li>
</ul>
<hr class="docutils" />
<p>&lt;タイプリストは Lisp 的&gt; (p. 57) なので、色々補助的なマクロを用意する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">Typelist</span><span class="o">&lt;</span><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span>
<span class="w">      </span><span class="n">Typelist</span><span class="o">&lt;</span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span>
<span class="w">         </span><span class="n">Typelist</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Typelist</span><span class="o">&lt;</span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span>
<span class="w">   </span><span class="n">SignedIntegrals</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define TYPELIST_1(T1) Typelist&lt;T1, NullType&gt;</span>
<span class="cp">#define TYPELIST_2(T1, T2) Typelist&lt;T1, Typelist_1(T2) &gt;</span>
<span class="p">...</span>

<span class="k">typedef</span><span class="w"> </span><span class="n">TYPELIST_4</span><span class="p">(</span><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span>
<span class="w">   </span><span class="n">SignedIntegrals</span><span class="p">;</span>
</pre></div>
</div>
<hr class="docutils" />
<p>以下、延々と「コンパイル時に <code class="docutils literal notranslate"><span class="pre">Typelist</span></code> の情報を得る機能」の実装が続く。</p>
<ul class="simple">
<li><p>&lt;C++ でコンパイル時プログラミングに用いることができる道具は、テンプレート、コンパイル時の整数計算、型定義 (<code class="docutils literal notranslate"><span class="pre">typedef</span></code>) です&gt; (p. 59)</p></li>
<li><p>&lt;C++ 自体は命令型言語に限りなく近い位置づけなのですが、コンパイル時に行われる全ての計算処理は、値の変更を行うことができない関数型言語を思い出させるようなテクニックに頼らなければならないわけです&gt; (p. 59)</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;単純に線形化されたものとしてタイプリストにアクセスすることができれば、タイプリスト操作が用意になるはずです&gt; (p. 60)</p></li>
<li><p>&lt;しかし、タイプリストの場合、こういった時間はコンパイル中に発生するものであり、コンパイル時間というものはある意味「無料」なのです&gt; (p. 61) とあるが、脚注で言い訳しているように、現場でコンパイル時間をタダとみなせるようなことはない。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;再帰を用いて古典的な線形探索を実装する&gt; (p. 61) ことで、タイプリストから型を検索する機能を記述できる。</p></li>
</ul>
<hr class="docutils" />
<p>残りはザッと読み流してよいが、次のトピックは後で読み返すことになる。</p>
<ul class="simple">
<li><p>タイプリストを部分的に並び替える。特に、型を継承階層の下層から順に並び替えたりする機能(<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">DerivedToFront</span></code>, <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">MostDerived</span></code>)</p></li>
<li><p>タイプリストを利用して、クラス階層を一気に構築する機能
(<code class="docutils literal notranslate"><span class="pre">GenScatterHierarchy</span></code>, <code class="docutils literal notranslate"><span class="pre">Tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">GenLinearHierarchy</span></code>)</p></li>
</ul>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">第 4 章 小規模オブジェクトの割り当て</a><a class="headerlink" href="#id6" title="Link to this heading">¶</a></h2>
<p>以下のノートでは <code class="docutils literal notranslate"><span class="pre">std::size_t</span></code> を単に <code class="docutils literal notranslate"><span class="pre">size_t</span></code> と書く。</p>
<ul class="simple">
<li><p>この章で言う小規模オブジェクトとは、数バイト程度のメモリーを消費するものらしい。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code> と <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code> は &lt;汎用目的の演算子であり、小規模オブジェクトの割り当てには向いていない&gt; (p. 83): 本章で紹介するアロケータは、それらよりも処理速度は数段優れ、メモリー消費も半分以下だと豪語している。</p></li>
</ul>
<hr class="docutils" />
<p>デフォルトのアロケータについて。</p>
<ul class="simple">
<li><p>&lt;通常の場合、デフォルトのアロケータというものが、C のヒープアロケータを薄いラッパで包み込んだ形で実装されているため&gt; (p. 84) 恐ろしく遅い。</p></li>
<li><p>遅いだけでなく、&lt;小規模オブジェクトに対するスペース効率も非常に悪い&gt; (p. 84):
管理用のメモリを余分に食うためとのこと。</p></li>
</ul>
<hr class="docutils" />
<p>「メモリ・アロケータの作業」に書かれているメモリレイアウトの理解が面倒。パス。</p>
<hr class="docutils" />
<ul class="simple">
<li><p>本章で解説している小規模オブジェクト・アロケータは 4 層構造。下位層から上位層へ向かって <code class="docutils literal notranslate"><span class="pre">Chunk</span></code>, <code class="docutils literal notranslate"><span class="pre">FixedAllocator</span></code>, <code class="docutils literal notranslate"><span class="pre">SmallObjAllocator</span></code>,
<code class="docutils literal notranslate"><span class="pre">SmallObject</span></code> となっている。</p></li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">Chunk</span></code> は「固定長ブロックを保持するメモリのチャンク」を保持・管理する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 87 より引用。細部省略。</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Chunk</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Init</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">blockSize</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">blocks</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">Allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">blockSize</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">blockSize</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Release</span><span class="p">();</span>

<span class="w">    </span><span class="n">unsinged</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pData_</span><span class="p">;</span>
<span class="w">    </span><span class="n">unsinged</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">firstAvailableBlock_</span><span class="p">;</span>
<span class="w">    </span><span class="n">unsinged</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">blocksAvailable_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>関数の引数にやたらサイズがあるのは、&lt;上位層がブロック・サイズを管理するべき&gt;
(p. 88) だから。</p></li>
<li><p>&lt;効率性を考慮し、<code class="docutils literal notranslate"><span class="pre">Chunk</span></code> にはコンストラクタ、デストラクタ、代入演算子を定義しません&gt; (p. 88)</p></li>
<li><p>255 (<code class="docutils literal notranslate"><span class="pre">UCHAR_MAX</span></code>) ブロック以上のチャンクを保持できないことに注意。</p></li>
<li><p>&lt;未使用ブロックの最初のバイトには、次の未使用ブロックのインデックスを保持します&gt; (p. 88): 例えば <code class="docutils literal notranslate"><span class="pre">Chunk::Init</span></code> の実装で
<code class="code docutils literal notranslate"><span class="pre">pData_[i</span> <span class="pre">*</span> <span class="pre">blockSize]</span> <span class="pre">==</span> <span class="pre">(i</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">blockSize</span></code> となるように配列の中身を埋める。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Chunk::Allocate</span></code> の実装を見ると、処理時間は <span class="math notranslate nohighlight">\(O(1)\)</span> になっているようだ。必然的に <code class="docutils literal notranslate"><span class="pre">Chunk::Deallocate</span></code> も <span class="math notranslate nohighlight">\(O(1)\)</span> になる。</p></li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">FixedAllocator</span></code> は <code class="docutils literal notranslate"><span class="pre">Chunk</span></code> の <code class="docutils literal notranslate"><span class="pre">vector</span></code> として実装する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 91 より引用。</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FixedAllocator</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">blockSize_</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">numBlocks_</span><span class="p">;</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Chunk</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Chunks</span><span class="p">;</span>
<span class="w">    </span><span class="n">Chunks</span><span class="w"> </span><span class="n">chunks_</span><span class="p">;</span>
<span class="w">    </span><span class="n">Chunk</span><span class="o">*</span><span class="w"> </span><span class="n">allocChunk_</span><span class="p">;</span>
<span class="w">    </span><span class="n">Chunk</span><span class="o">*</span><span class="w"> </span><span class="n">deallocChunk_</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">allocChunk_</span></code> は「前回の割り当てに使用したチャンク」とする。これに余裕がまだあれば、次の割り当てでもここを使用することで効率化できる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deallocChunk_</span></code> 「直前に開放されたチャンク」だが、扱いがちょっと難しい。</p></li>
</ul>
<hr class="docutils" />
<p>&lt;<code class="docutils literal notranslate"><span class="pre">SmallObjAllocator</span></code> は、いくつかの <code class="docutils literal notranslate"><span class="pre">FixedAllocator</span></code> オブジェクトを集約することによって実現されています&gt; (p. 94)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// pp. 94-95 参照。</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SmallObjAllocator</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FixedAllocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pool_</span><span class="p">;</span>
<span class="w">    </span><span class="n">FixedAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">pLastAlloc_</span><span class="p">;</span>
<span class="w">    </span><span class="n">FixedAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">pLastDealloc_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">SmallObjAllocator</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">chunkSize</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">maxObjectSize</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">Allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">numBytes</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>

<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Deallocate</span></code> の引数のサイズが、ここでは「解放するサイズ」を意味する。高速に解放するため。</p></li>
<li><p>&lt;「効率的な」やり方は、常に「効率的な」やり方とは限らない&gt; (p. 95)</p></li>
<li><p>&lt;メモリ保持のために若干探索速度を犠牲にする&gt; (p. 95) ことにした。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pool_</span></code> をブロックサイズに従ってソートしておくと、バイナリ・サーチが適用できる。</p></li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">SmallObject</span></code> はほぼ教科書通りのインターフェイスになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 96</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SmallObject</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">SmallObject</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>デストラクタは仮想でなければならない。理由は <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code> に引き渡されるサイズを正しくさせるため。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code> の実装で <code class="docutils literal notranslate"><span class="pre">SmallObjAllocator::Allocate</span></code> を利用する。また
<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code> で <code class="docutils literal notranslate"><span class="pre">SmallObjAllocator::Deallocate</span></code> を利用する。</p></li>
<li><p>ということは、<code class="docutils literal notranslate"><span class="pre">SmallObjAllocator</span></code> は Singleton でなければならない。</p></li>
</ul>
<hr class="docutils" />
<p>各種ポリシーをくっつけて <code class="docutils literal notranslate"><span class="pre">SmallObject</span></code> をクラステンプレートにして仕上がる。本章ではここまでテンプレートがなかなか出てこなかった感があるが、ここでようやく登場。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 100 より引用。</span>
<span class="k">template</span>
<span class="o">&lt;</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">        </span><span class="k">class</span><span class="w"> </span><span class="nc">ThreadingModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_THREADING</span><span class="p">,</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">chunkSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_CHUNK_SIZE</span><span class="p">,</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">maxSmallObjectSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_SMALL_OBJECT_SIZE</span>
<span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SmallObject</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;保守的ということは最適ではないということを意味しているのです&gt; (p. 101)</p></li>
</ul>
</section>
</section>


          </div>
    <div class="related bottom">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="index.html" title="Previous">Modern C++ Design 読書ノート</a>
        </li>
      
        <li>
          <a href="note2.html" title="Next">Modern C++ Design 読書ノート 2/3</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>

      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="../index.html" title="読書ノート Home"><img src="../_images/logo.svg"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2024, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>