
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Modern C++ Design 読書ノート 2/3 &#8212; 読書ノート v1.4</title>
    <link rel="stylesheet" href="../_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/mathjaxconf.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="next" title="Modern C++ Design 読書ノート 3/3" href="note3.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート 1/3" href="note1.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="note3.html" title="Modern C++ Design 読書ノート 3/3"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="note1.html" title="Modern C++ Design 読書ノート 1/3"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Modern C++ Design 読書ノート</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="modern-c-design-2-3">
<h1><a class="toc-backref" href="#id5">Modern C++ Design 読書ノート 2/3</a><a class="headerlink" href="#modern-c-design-2-3" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Andrey Alexandrescu</td>
</tr>
<tr class="field-even field"><th class="field-name">訳者:</th><td class="field-body">村上雅章</td>
</tr>
<tr class="field-odd field"><th class="field-name">出版社:</th><td class="field-body">ピアソン・エデュケーション</td>
</tr>
<tr class="field-even field"><th class="field-name">発行年:</th><td class="field-body">2001 年</td>
</tr>
<tr class="field-odd field"><th class="field-name">ISBN:</th><td class="field-body">978-4-89471-435-9</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#modern-c-design-2-3" id="id5">Modern C++ Design 読書ノート 2/3</a><ul>
<li><a class="reference internal" href="#id2" id="id6">第 5 章 汎用のファンクタ</a></li>
<li><a class="reference internal" href="#singleton" id="id7">第 6 章 Singleton の実装</a></li>
<li><a class="reference internal" href="#id3" id="id8">第 7 章 スマート・ポインタ</a></li>
<li><a class="reference internal" href="#id4" id="id9">第 8 章 オブジェクト・ファクトリ</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id6">第 5 章 汎用のファンクタ</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>「値のセマンティックスを伴ったオブジェクト」という言い回しが頻出する。これはオブジェクトがコピー、代入、値による引渡しが完全にサポートされていることを意味する。</li>
<li>&lt;関数へのポインタをかなり現代風にアレンジしたもの&gt; (p. 105)</li>
<li>&lt;状態を保存でき、メンバ関数を起動できる&gt; (p. 105) ので、単なる関数ポインタより有利。</li>
</ul>
<hr class="docutils" />
<p>Command デザインパターンの解説セクション。</p>
<ul>
<li><p class="first">&lt;作業がどのようにして行われるのかを起動側は気にしなくても良い&gt; (p. 106)</p>
</li>
<li><p class="first">&lt;呼び出しを無期限に延期できる&gt; (p. 107)</p>
</li>
<li><p class="first">&lt;Command パターンでは、処理を実行するために必要な環境を整えるタイミングが、処理を実行するタイミングと異なっています&gt; (p. 107)</p>
</li>
<li><p class="first">&lt;Command パターンの実装を手作業で行う場合、スケーラビリティに劣ることがあります。つまり、小さな機能を持った具体的な Command クラスを数多く記述しなければならず（それぞれが、<code class="docutils literal notranslate"><span class="pre">CmdAddUser</span></code>, <code class="docutils literal notranslate"><span class="pre">CmdDeleteUser</span></code>, <code class="docutils literal notranslate"><span class="pre">CmdModifyUser</span></code> といったアプリケーション中の単一動作を表します）、それぞれに特定オブジェクトに対する特定のメンバ関数を単に呼び出すだけの
<code class="docutils literal notranslate"><span class="pre">Execute</span></code> メンバ関数を保持させなければならないのです&gt; (p. 108)</p>
<p>→心当たりありまくり。</p>
</li>
</ul>
<hr class="docutils" />
<ul>
<li><p class="first">&lt;Command パターンにおける <code class="docutils literal notranslate"><span class="pre">Command::Execute</span></code> は、C++ におけるユーザ定義演算子
<code class="docutils literal notranslate"><span class="pre">operator()</span></code> となるべきです&gt; (p. 111)</p>
<p>→呼び出しシンタックスを <code class="docutils literal notranslate"><span class="pre">operator()</span></code> に統一することで、
<code class="docutils literal notranslate"><span class="pre">Functor</span></code> が他の <code class="docutils literal notranslate"><span class="pre">Functor</span></code> を保持できるようになるから。</p>
</li>
<li><p class="first">クラステンプレート <code class="docutils literal notranslate"><span class="pre">Functor</span></code> を、戻り値の型が <code class="docutils literal notranslate"><span class="pre">ResultType</span></code> で、パラメータリストをタイプリスト <code class="docutils literal notranslate"><span class="pre">TList</span></code> で表現する。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Functor</span></code> の定義は一回。Pimpl パターンにより実装を別のクラステンプレート
<code class="docutils literal notranslate"><span class="pre">FunctorImpl</span></code> で行う。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">FunctorImpl</span></code> を部分特殊化をしまくって、引数リストのパラメータ数が十分大きくても対応できるようにしておく。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span><span class="o">.</span> <span class="mi">114</span> <span class="n">より引用</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">class</span> <span class="nc">TList</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FunctorImpl</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FunctorImpl</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span> <span class="n">NullType</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="n">R</span> <span class="n">operator</span><span class="p">()()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">virtual</span> <span class="n">FunctorImpl</span><span class="o">*</span> <span class="n">Clone</span><span class="p">()</span> <span class="n">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">virtual</span> <span class="o">~</span><span class="n">FunctorImpl</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">R</span><span class="p">,</span> <span class="n">typename</span> <span class="n">P1</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FunctorImpl</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span> <span class="n">TYPELIST_1</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="n">R</span> <span class="n">operator</span><span class="p">()(</span><span class="n">P1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">virtual</span> <span class="n">FunctorImpl</span><span class="o">*</span> <span class="n">Clone</span><span class="p">()</span> <span class="n">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">virtual</span> <span class="o">~</span><span class="n">FunctorImpl</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">Functor::operator()</span></code> は <code class="docutils literal notranslate"><span class="pre">FunctorImpl::operator()</span></code> へ転送を行う必要がある。</p>
<ul>
<li><p class="first">&lt;<code class="docutils literal notranslate"><span class="pre">Functor</span></code> の定義内に任意のパラメータ数で全ての <code class="docutils literal notranslate"><span class="pre">operator()</span></code> を定義することができる&gt; (p. 115)</p>
<ul>
<li><p class="first">第 3 章で紹介した <code class="docutils literal notranslate"><span class="pre">TypeAtNonStrict&lt;...&gt;::Result</span></code> を十分な個数だけ <code class="docutils literal notranslate"><span class="pre">typedef</span></code> する。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeAtNonStrict</span></code> は <code class="docutils literal notranslate"><span class="pre">TypeAt</span></code> のゆるゆるバージョン。</p>
</li>
<li><p class="first">力作業で <code class="docutils literal notranslate"><span class="pre">operator()</span></code> のオーバーロードをその個数分だけ実装する。</p>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">Functor</span></code> オブジェクトの構築に関する考察。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">FunctorImpl</span></code> のサブクラス <code class="docutils literal notranslate"><span class="pre">FunctorHandler</span></code> を定義して、</li>
<li><code class="docutils literal notranslate"><span class="pre">Functor</span></code> のコンストラクターで Pimpl メンバーデータにセットする。</li>
</ul>
<hr class="docutils" />
<p>「メンバ関数へのポインタ」に関する考察。</p>
<ul class="simple">
<li>C++ では全てのオブジェクトには型があるが、
<code class="docutils literal notranslate"><span class="pre">operator.*</span></code> と <code class="docutils literal notranslate"><span class="pre">operator-&gt;*</span></code> の結果は何か違うものだ。</li>
</ul>
<hr class="docutils" />
<p>バインダーに関する考察。ちょっと読みにくいのと、<code class="docutils literal notranslate"><span class="pre">BinderFirst</span></code> しか議論していないのが惜しい。任意の位置のパラメータにバインドするバインダーの話を振らないと。</p>
<hr class="docutils" />
<p>この章の残りの話題は、</p>
<ul>
<li><p class="first">Command パターンの話をしていたので、マクロやらアンドゥ・リドゥの話。</p>
</li>
<li><p class="first">「参照の参照」問題回避のため、traits を <code class="docutils literal notranslate"><span class="pre">Functor::operator()</span></code> にクッションする。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// 例えば型 Parm1 が組み込み型でない場合、
// p1 の型は Parm1&amp; となる。
// const が付いていたら const Parm1&amp; となる。
R operator()(
    typename TypeTraits&lt;Parm1&gt;::ParameterType p1,
    typename TypeTraits&lt;Parm2&gt;::ParameterType p2)
{
    return (*spImpl_)(p1, p2);
}
</pre></div>
</div>
</li>
<li><p class="first">&lt;典型的な 32 ビットのシステムの場合、（略）メンバ関数へのポインタは 16 バイト&gt; (p. 132) となる。</p>
</li>
</ul>
<p>など。</p>
</div>
<div class="section" id="singleton">
<h2><a class="toc-backref" href="#id7">第 6 章 Singleton の実装</a><a class="headerlink" href="#singleton" title="Permalink to this headline">¶</a></h2>
<p>&lt;Singleton デザイン・パターンの実装で「正解」というものは存在しません。（略）扱っている問題次第で最適なものとなるのです&gt; (p. 137)</p>
<hr class="docutils" />
<ul class="simple">
<li>&lt;static データ + static 関数 != Singleton&gt; (p. 138)</li>
<li>&lt;static な関数は virtual にできない&gt; (p. 138)</li>
<li>&lt;Singleton の実装では、2 番目のインスタンスを生成しないようにしながら、オブジェクトの生成と唯一性の管理に集中することになる&gt; (p. 139)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>デフォルト・コンストラクター、コピー・コンストラクター、代入演算子は
private に宣言することは承知しているが、これを読むまでデストラクターも
private にするのを忘れていた。</li>
</ul>
<hr class="docutils" />
<p>基本を説明してすぐに Singleton オブジェクトの破棄に関する議論が始まる。これ以降の議論は、デザインパターンの本ではまずお目にかかったことのないものだ。</p>
<ul>
<li><p class="first">&lt;リソース・リークを避ける唯一の正しい手段とは、アプリケーションの終了時に Singleton オブジェクトを削除することです。問題は、その破棄後に、該当 Singleton に対するアクセスが発生しないようなタイミングを注意深く設定しなければならない点です&gt; (p. 142)</p>
</li>
<li><p class="first">次のタイプの実装を Meyers の Singleton と呼ぶことにする。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">Singleton</span><span class="p">::</span><span class="n">Instance</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">Singleton</span> <span class="n">obj</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>&lt;Meyers の Singleton は、アプリケーションの終了処理における最も簡単な
Singleton の破棄手段を提供しています&gt; (p. 143)</p>
</li>
</ul>
<hr class="docutils" />
<p>死んだ参照の議論。<code class="docutils literal notranslate"><span class="pre">Keyboard</span></code>, <code class="docutils literal notranslate"><span class="pre">Display</span></code>, <code class="docutils literal notranslate"><span class="pre">Log</span></code>
という 3 クラスがそれぞれ Singleton な場合で、<code class="docutils literal notranslate"><span class="pre">Keyboard</span></code> と <code class="docutils literal notranslate"><span class="pre">Display</span></code> のエラーが
<code class="docutils literal notranslate"><span class="pre">Log</span></code> に報告するような状況を考察する。この問題を KDL 問題と呼ぶことにする。</p>
<ul>
<li><p class="first">&lt;この 3 つの Singleton を Meyers の Singleton で実装した場合、プログラムは正しく動作しないのです&gt; (p. 144)</p>
</li>
<li><p class="first">&lt;妥当な方法は、Singleton に死んだ参照の検出をさせることです&gt; (p. 144)</p>
<p><code class="docutils literal notranslate"><span class="pre">Singleton::Instance</span></code> で検出させることで、何らかのエラーハンドリングをする。</p>
</li>
</ul>
<hr class="docutils" />
<p>Phoenix Singleton なる概念を導入する。デストラクトされたオブジェクトのあったメモリに、再度オブジェクトをコンストラクトするというものだ。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Singleton::OnDeadReference</span></code> で placement new の機能を利用し、
<code class="docutils literal notranslate"><span class="pre">pInstance_</span></code> に <code class="docutils literal notranslate"><span class="pre">Singleton</span></code> オブジェクトを構築する。</li>
<li><code class="docutils literal notranslate"><span class="pre">atexit</span></code> に破棄関数 <code class="docutils literal notranslate"><span class="pre">KillPhoenixSingleton</span></code> を登録する。
<code class="docutils literal notranslate"><span class="pre">KillPhoenixSingleton</span></code> では <code class="docutils literal notranslate"><span class="pre">pInstance_</span></code> に対して明示的にデストラクターを呼び出す。
&lt;<code class="docutils literal notranslate"><span class="pre">new</span></code> を使用すると（略）コンパイラによる自動破棄が行われなくなるためです&gt; (p. 147)</li>
<li>ちなみに <code class="docutils literal notranslate"><span class="pre">atexit</span></code> にはキズがある。
&lt;規格では、<code class="docutils literal notranslate"><span class="pre">atexit</span></code> を用いた関数の登録中に他の
<code class="docutils literal notranslate"><span class="pre">atexit</span></code> による登録が発生した場合の定義が行われていない&gt; (p. 147)</li>
</ul>
<hr class="docutils" />
<p>次の議論は、「Singleton に寿命レベルを導入する」というもの。</p>
<ul class="simple">
<li>前節の戦略だと、状態を保持するような Singleton では復活し切れないことは明白。</li>
<li>KDL 問題は「K, D よりも L のほうが長生きである」ことが表現できれば問題解決だ。</li>
</ul>
<p>&lt;ここで出てくる寿命の制御というコンセプトは、
Singleton のコンセプトとは独立したものです。オブジェクトの寿命が長いほど、破棄が後にまわされるのです&gt; (p. 149)</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">SetLongevity</span></code> 関数の「仕様」は p. 151 のリスト参照。
<code class="docutils literal notranslate"><span class="pre">atexit</span></code> の呼び出しを含むのがポイント。</li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">寿命を指定する Singleton の実装法について数ページにわたる説明があるが、読むのが面倒になったのでスキップ。</p>
</div>
<hr class="docutils" />
<p>マルチスレッド対応。</p>
<p>&lt;共有されるグローバル・リソースというものは全て、競合条件とスレッドに関連する問題の元凶となり得るのです&gt; (p. 155)</p>
<ul>
<li><p class="first">今では有名になった手法だが、Doug Schdmit と Tim Harrison が発案した (1996)
Double-Checked Locking パターンを紹介している。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// p. 157 より引用
Singleton&amp; Singleton::Instance()
{
    if(!pInstance_)
    {
        Guard myGuard(lock_);
        if(!pInstance_)
        {
            pInstance_ = new Singleton;
        }
    }
    return *pInstance_;
}
</pre></div>
</div>
</li>
<li><p class="first">ただし、ある種のマルチプロセッサではこのパターンが使えない。使えるか否かを決定するには &lt;コンパイラのドキュメントを熟読しなければならない&gt; (p. 157)</p>
</li>
<li><p class="first">&lt;少なくとも、<code class="docutils literal notranslate"><span class="pre">pInstance_</span></code> の次に <code class="docutils literal notranslate"><span class="pre">volatile</span></code> 修飾子を置くことです&gt; (p. 157)</p>
</li>
</ul>
<hr class="docutils" />
<p>これまでの分析を総合する。</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">SingletonHolder</span></code> を 3 つのポリシーに分解する。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Creator</span></code>: <code class="docutils literal notranslate"><span class="pre">pInstance_</span></code> の初期化ポリシー。</li>
<li><code class="docutils literal notranslate"><span class="pre">Lifetime</span></code>: 「通常」「復活アリ」「寿命制御」「無限」の 4 パターンを提供している。</li>
<li><code class="docutils literal notranslate"><span class="pre">Threading</span></code>: シングルスレッド or マルチスレッド。</li>
</ul>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span><span class="o">.</span> <span class="mi">160</span> <span class="n">より引用</span>
<span class="n">template</span> <span class="o">&lt;</span>
   <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
   <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CreationPolicy</span> <span class="o">=</span> <span class="n">CreateUsingNew</span><span class="p">,</span>
   <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">LifetimePolicy</span> <span class="o">=</span> <span class="n">DefaultLifetime</span><span class="p">,</span>
   <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">ThreadingModel</span> <span class="o">=</span> <span class="n">SingleThreaded</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SingletonHolder</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;インスタンスの型は <code class="docutils literal notranslate"><span class="pre">T*</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">ThreadingModel&lt;T&gt;::VolatileType*</span></code> です&gt; (p. 160)</p>
<p>→マルチスレッド環境では仇になる、コンパイラによるある種の最適化処理を抑止するため。</p>
</li>
<li><p class="first">&lt;<code class="docutils literal notranslate"><span class="pre">SingletonHolder</span></code> が <code class="docutils literal notranslate"><span class="pre">DestroySingleton</span></code> を呼び出すことはありません&gt; (p. 161)</p>
</li>
<li><p class="first">KDL 問題の解として、仮コードを p. 164 に掲載している。</p>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id8">第 7 章 スマート・ポインタ</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>&lt;スマート・ポインタとは、<code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> と単項演算子 <code class="docutils literal notranslate"><span class="pre">operator*</span></code>
を実装することによって単純なポインタとして使えるようにした C++ のオブジェクトです。スマート・ポインタは、れっきとしたポインタのシンタックスとセマンティックスに加えて、メモリ管理やロックといった処理を内部で実行することによって、指しているオブジェクトの寿命を注意深く管理するという面倒な作業からアプリケーションを解放します&gt;
(p. 167) と、スマートポインタの定義を簡潔に与えている。</p>
<hr class="docutils" />
<ul>
<li><p class="first">&lt;スマート・ポインタとは、シンタックスとある種のセマンティックスに関して、通常のポインタを模倣するような C++ のクラスです&gt; (p. 167)</p>
</li>
<li><p class="first">&lt;既存の高品質なスマート・ポインタでは、たいていの場合、以下のコードのようにポインタの型によってテンプレート化されています&gt; (p. 168)</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SmartPtr</span>
<span class="p">{</span>
    <span class="o">...</span>

<span class="n">private</span><span class="p">:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">pointee_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;値のセマンティックスが存在するオブジェクトとは、コピーや代入が可能なオブジェクトのことです&gt; (p. 169)</li>
<li>ほとんどのスマートポインタには &lt;所有権管理機能&gt; (p. 169) が提供されている。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;<code class="docutils literal notranslate"><span class="pre">pointee_</span></code> の型は必ず <code class="docutils literal notranslate"><span class="pre">T*</span></code> なのでしょうか&gt; (p. 170)</li>
<li><code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> のメカニズムを応用した &lt;事前および事後の関数呼び出し&gt; (p. 170)</li>
<li>ハンドルとポインタの類似性。
&lt;セマンティックスと管理方法を見た場合、ハンドルはポインタと良く似たものなのです&gt; (p. 171)</li>
</ul>
<hr class="docutils" />
<ul>
<li><p class="first">&lt;メンバ関数というものはスマート・ポインタに適したものではないのです&gt; (p. 172)</p>
<p>なぜかというと、<code class="docutils literal notranslate"><span class="pre">T</span></code> の解放のためのメンバ関数呼び出しと、
<code class="docutils literal notranslate"><span class="pre">SmartPtr&lt;T&gt;</span></code> のそれが似ていて紛らわしいから。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SmartPtr</span><span class="o">&lt;</span><span class="n">Printer</span><span class="o">&gt;</span> <span class="n">spRes</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">...</span>
<span class="n">spRes</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
<span class="n">spRes</span><span class="o">.</span><span class="n">Release</span><span class="p">();</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;スマート・ポインタは、メンバ関数を使ってはいけないのです。つまり、<code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> は非メンバ関数のみを使用するわけです&gt; (p. 172)</p>
</li>
</ul>
<hr class="docutils" />
<p>所有権に関する考察。</p>
<ul class="simple">
<li>ディープ・コピー方式<ul>
<li>ポリモフィズムをサポートするため、コピーには <code class="docutils literal notranslate"><span class="pre">T</span></code> のコピーコンストラクタは利用できない。別途コピー用のポリシーを設けて、<code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> のテンプレート引数とする。</li>
</ul>
</li>
<li>COW 方式<ul>
<li>COW 方式とは、「指しているオブジェクトが最初に更新されるタイミングでコピーする」というもの。</li>
<li>スマート・ポインタではその「タイミング」が把握できそうにないので、不採用とする。</li>
</ul>
</li>
<li>参照カウント方式<ul>
<li>&lt;同じオブジェクトを指しているスマート・ポインタの総数を追跡する&gt; (p. 176) 方式。</li>
<li>その総数カウンターを被参照オブジェクトにくっつける方式を侵入型参照カウント方式 (p. 177) と呼ぶ。</li>
</ul>
</li>
<li>参照リンク方式<ul>
<li>同じオブジェクトを指す <code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> が双方向リンクリスト構造をなす。リストが空になるタイミングが、被参照オブジェクトの破棄タイミングとなる。</li>
</ul>
</li>
<li>破壊型コピー方式<ul>
<li><code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> のコピーを行った場合、コピー元のオブジェクトが破壊される方式。
<code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> はまさにこれ。</li>
<li>&lt;破壊型コピー方式を用いたスマート・ポインタは、値のセマンティックスをサポートしていないため、コンテナに格納することができず、たいていの場合、生のポインタを扱うのと同じくらい細心の注意を払って扱わなければならないのです&gt; (p. 180)</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>&lt;単項演算子 <code class="docutils literal notranslate"><span class="pre">opearator&amp;</span></code> のオーバーロードはお勧めできない&gt; (p. 181)</p>
<hr class="docutils" />
<p>生のポインタ型への暗黙の変換はサポートしない。かわりに明示的な変換のための関数を提供する。</p>
<hr class="docutils" />
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">SmartPtr&lt;T&gt;</span></code> と <code class="docutils literal notranslate"><span class="pre">T*</span></code> の等価性テストのため、考え得る全ての組み合わせの
<code class="docutils literal notranslate"><span class="pre">operator==</span></code> および <code class="docutils literal notranslate"><span class="pre">operator!=</span></code> を提供する。</li>
<li>なおかつ、<code class="docutils literal notranslate"><span class="pre">SmartPtr&lt;T&gt;</span></code> と <code class="docutils literal notranslate"><span class="pre">U*</span></code> のテストのために、テンプレート版 (p. 187) も追加する。</li>
<li>算術型への変換は <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">bool</span></code> と同じ理由で推奨できない (p. 188)</li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">順序比較のセクションは、読むのが面倒になったのでスキップ。</p>
</div>
<hr class="docutils" />
<p>&lt;スマート・ポインタにおけるチェックの問題は、初期化時と参照外し時という 2 つのカテゴリに分類できます&gt; (p. 192)</p>
<ul class="simple">
<li>&lt;経験則としては、ポインタのチェックを厳格に行うことから始めて、プロファイラ結果に応じて、チェックの除去が可能なスマート・ポインタを選ぶというのが良いでしょう&gt; (p. 193)</li>
<li>&lt;エラーを報告するための最も優れた方法は、例外をスローすることです&gt; (p. 193)</li>
</ul>
<hr class="docutils" />
<p>マルチスレッド問題は付録 A まで取っておくか。</p>
<ul class="simple">
<li>ここ (p. 196) で紹介されている <code class="docutils literal notranslate"><span class="pre">LockingProxy</span></code> での <code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> トリックはおさえること。</li>
<li>マルチスレッド参照カウント方式と、マルチスレッド参照リンク方式。</li>
<li>クラスレベルのロックと、オブジェクトレベルのロック。</li>
</ul>
<hr class="docutils" />
<p>これまでの分析を総合する。</p>
<ul>
<li><p class="first">&lt;私たちは問題をポリシーと呼ぶ小さなクラスへと分割するのです。そして、各ポリシー・クラスでは、たった 1 つの問題を取り扱います&gt; (p. 200)</p>
</li>
<li><p class="first">&lt;<code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> の宣言中に現れるポリシーの順序は、最も良くカスタマイズされるものが先頭に来るようになっています&gt; (p. 201)</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span>
<span class="o">&lt;</span>
   <span class="n">typename</span> <span class="n">T</span><span class="p">,</span>
   <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">OwnershipPolicy</span> <span class="o">=</span> <span class="n">RefCounted</span><span class="p">,</span>
   <span class="k">class</span> <span class="nc">ConversionPolicy</span> <span class="o">=</span> <span class="n">DisallowConversion</span><span class="p">,</span>
   <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CheckingPolicy</span> <span class="o">=</span> <span class="n">AssertCheck</span><span class="p">,</span>
   <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">StoragePolicy</span> <span class="o">=</span> <span class="n">DefaultSPStorage</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SmartPtr</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id9">第 8 章 オブジェクト・ファクトリ</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>この章のテーマは Factory Method デザインパターン。個人的には C++ では最もコードが書きにくいパターンだと思っているので、楽しく読めた。</p>
<ul class="simple">
<li>&lt;ここで問題になるのは、実際に導出を行う <code class="docutils literal notranslate"><span class="pre">Derived</span></code> という型名を
<code class="docutils literal notranslate"><span class="pre">new</span></code> 演算子の起動時に記述しなければならない点です。（略）ある意味では、使用してはいけないとされているコード中の数値定数と良く似ています&gt; (p. 209)</li>
<li>&lt;型は必ずコンパイル時点で既知のものでなければならないのです&gt; (p. 209)</li>
<li>&lt;C++ におけるオブジェクトの生成では、呼び出し側と導出された具体的なクラスを束縛することになるのです&gt; (p. 210)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>例えば、ライブラリーがユーザー定義クラスのオブジェクト生成を行う必要がある場合、これはオブジェクト・ファクトリが必要とされるケースのひとつだ。</li>
<li>説明コードの <code class="docutils literal notranslate"><span class="pre">DocumentManager::NewDocument</span></code> では <code class="docutils literal notranslate"><span class="pre">new</span></code> 演算子ではなく、
<code class="docutils literal notranslate"><span class="pre">CreateDocument</span></code> 仮想メソッド呼び出しで（ユーザー定義型の）オブジェクトを生成する。<ul>
<li>この <code class="docutils literal notranslate"><span class="pre">CreateDocument</span></code> のような役割を持つメソッドを Factory Method と呼ぶ。</li>
</ul>
</li>
<li>保存ファイルからオブジェクトを再現する際にも、オブジェクト・ファクトリが必要だ。</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;何故言語自身にオブジェクトを生成するための柔軟な手段が備わっていないのでしょうか？&gt; (p. 212)</li>
<li>&lt;C++ でオブジェクト・ファクトリを作り出すのは難しい問題になる&gt; (p. 213)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Drawing::Load</span></code> コード (pp. 214-215) は現場でよく見かけるパターン。いい題材だ。</li>
<li>&lt;唯一の問題は、オブジェクト指向にける最も重要な規則に反している点です&gt; (p. 215)<ul>
<li>型の「タグ」に基づいて <code class="docutils literal notranslate"><span class="pre">switch</span></code> 文を書いている点。</li>
<li><code class="docutils literal notranslate"><span class="pre">Shape</span></code> の派生クラスへの言及が、単独のソースファイルに集積される点。</li>
<li>拡張することが難しい。</li>
</ul>
</li>
<li>クラス <code class="docutils literal notranslate"><span class="pre">ShapeFactory</span></code> で <code class="docutils literal notranslate"><span class="pre">Shape</span></code> 派生オブジェクトを生成する関数のポインタのマップを管理する。<ul>
<li>各 <code class="docutils literal notranslate"><span class="pre">Shape</span></code> 派生クラスの実装ファイルで、p. 217 のコードを機械的に記述すればよい。</li>
<li>&lt;このコードは、<code class="docutils literal notranslate"><span class="pre">std::map</span></code> クラス・テンプレートに馴染みのない方にとっては、若干説明が必要かもしれません&gt; (p. 218) とあるが、そんな方はこの本の読者なんかやってないと思う。</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>マップのキーを整数型ではなく、もっとそれらしいものにしようではないかという議論。</p>
<p>&lt;こういったことから帰結できる唯一の結論は、型識別子の管理はオブジェクト・ファクトリ自身の管轄ではないということです。
C++ という言語が、ユニークで永続的な型 ID を保証していない以上、型 ID の管理はプログラマが対処しなければならない問題なのです&gt; (p. 219)</p>
<hr class="docutils" />
<p>ここからオブジェクト・ファクトリの一般化について議論する。</p>
<ul class="simple">
<li>&lt;ファクトリは具体的な成果物を知る必要がない&gt; (p. 220) ので、「具体的な成果物」は <code class="docutils literal notranslate"><span class="pre">Factory</span></code> のテンプレートパラメータにならない。</li>
<li>&lt;エラー時の取り扱いコードを <code class="docutils literal notranslate"><span class="pre">CreateObject</span></code> メンバ関数から無くし、
<code class="docutils literal notranslate"><span class="pre">FactoryError</span></code> ポリシーに分離しなければなりません&gt; (p. 221)</li>
</ul>
<hr class="docutils" />
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span>
<span class="o">&lt;</span>
   <span class="k">class</span> <span class="nc">AbstractProduct</span><span class="p">,</span>
   <span class="k">class</span> <span class="nc">IdentifierType</span><span class="p">,</span>
   <span class="k">class</span> <span class="nc">ProductCreator</span> <span class="o">=</span> <span class="n">AbstractProduct</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="p">)(),</span>
   <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span><span class="p">,</span> <span class="n">class</span><span class="o">&gt;</span>
      <span class="k">class</span> <span class="nc">FactoryErrorPolicy</span> <span class="o">=</span> <span class="n">DefaultFactoryError</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Factory</span><span class="p">;</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">クローン・ファクトリは読みとばす。「共変の戻り型」の用語解説はおさえておくこと。</p>
</div>
<hr class="docutils" />
<p>オブジェクト・ファクトリは通常 Singleton であることが自然。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span><span class="o">.</span> <span class="mi">228</span> <span class="n">より引用</span>
<span class="n">typedef</span> <span class="n">SingletonHolder</span><span class="o">&lt;</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">Shape</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ShapeFactory</span><span class="p">;</span>
</pre></div>
</div>
<p>以前の <code class="docutils literal notranslate"><span class="pre">Functor</span></code> を <code class="docutils literal notranslate"><span class="pre">ProductCreator</span></code> とすることも可能。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span><span class="o">.</span> <span class="mi">228</span> <span class="n">より引用</span>
<span class="n">typedef</span> <span class="n">SingletonHolder</span>
<span class="o">&lt;</span>
   <span class="n">Factory</span><span class="o">&lt;</span><span class="n">Shape</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">*&gt;</span> <span class="o">&gt;</span>
<span class="o">&gt;</span>
<span class="n">ShapeFactory</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="note3.html" title="Modern C++ Design 読書ノート 3/3"
             >next</a></li>
        <li class="right" >
          <a href="note1.html" title="Modern C++ Design 読書ノート 1/3"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Modern C++ Design 読書ノート</a> &#187;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2018, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>