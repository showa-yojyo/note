
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Modern C++ Design 読書ノート 2/3 &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="Modern C++ Design 読書ノート 3/3" href="note3.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート 1/3" href="note1.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note1.html" title="Previous document">Modern C++ Design 読書ノート 1/3</a>
        </li>
        <li>
          <a href="note3.html" title="Next document">Modern C++ Design 読書ノート 3/3</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="modern-c-design-2-3">
<h1><a class="toc-backref" href="#id6" role="doc-backlink">Modern C++ Design 読書ノート 2/3</a><a class="headerlink" href="#modern-c-design-2-3" title="Permalink to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">著者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Andrey Alexandrescu</p>
</dd>
<dt class="field-even">訳者<span class="colon">:</span></dt>
<dd class="field-even"><p>村上雅章</p>
</dd>
<dt class="field-odd">出版社<span class="colon">:</span></dt>
<dd class="field-odd"><p>ピアソン・エデュケーション</p>
</dd>
<dt class="field-even">発行年<span class="colon">:</span></dt>
<dd class="field-even"><p>2001 年</p>
</dd>
<dt class="field-odd">ISBN<span class="colon">:</span></dt>
<dd class="field-odd"><p>978-4-89471-435-9</p>
</dd>
</dl>
<nav class="contents" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#modern-c-design-2-3" id="id6">Modern C++ Design 読書ノート 2/3</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id7">第 5 章 汎用のファンクタ</a></p></li>
<li><p><a class="reference internal" href="#singleton" id="id8">第 6 章 Singleton の実装</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id9">第 7 章 スマート・ポインタ</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id10">第 8 章 オブジェクト・ファクトリ</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="id2">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">第 5 章 汎用のファンクタ</a><a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>「値のセマンティックスを伴ったオブジェクト」という言い回しが頻出する。これはオブジェクトがコピー、代入、値による引渡しが完全にサポートされていることを意味する。</p></li>
<li><p>&lt;関数へのポインタをかなり現代風にアレンジしたもの&gt; (p. 105)</p></li>
<li><p>&lt;状態を保存でき、メンバ関数を起動できる&gt; (p. 105) ので、単なる関数ポインタより有利。</p></li>
</ul>
<hr class="docutils" />
<p>Command デザインパターンの解説セクション。</p>
<ul class="simple">
<li><p>&lt;作業がどのようにして行われるのかを起動側は気にしなくても良い&gt; (p. 106)</p></li>
<li><p>&lt;呼び出しを無期限に延期できる&gt; (p. 107)</p></li>
<li><p>&lt;Command パターンでは、処理を実行するために必要な環境を整えるタイミングが、処理を実行するタイミングと異なっています&gt; (p. 107)</p></li>
<li><p>&lt;Command パターンの実装を手作業で行う場合、スケーラビリティに劣ることがあります。つまり、小さな機能を持った具体的な Command クラスを数多く記述しなければならず（それぞれが、<code class="docutils literal notranslate"><span class="pre">CmdAddUser</span></code>, <code class="docutils literal notranslate"><span class="pre">CmdDeleteUser</span></code>, <code class="docutils literal notranslate"><span class="pre">CmdModifyUser</span></code> といったアプリケーション中の単一動作を表します）、それぞれに特定オブジェクトに対する特定のメンバ関数を単に呼び出すだけの <code class="docutils literal notranslate"><span class="pre">Execute</span></code> メンバ関数を保持させなければならないのです&gt; (p. 108): 心当たりありまくり。</p></li>
</ul>
<hr class="docutils" />
<ul>
<li><p>&lt;Command パターンにおける <code class="docutils literal notranslate"><span class="pre">Command::Execute</span></code> は、C++ におけるユーザ定義演算子 <code class="docutils literal notranslate"><span class="pre">operator()</span></code> となるべきです&gt; (p. 111): 呼び出しシンタックスを
<code class="docutils literal notranslate"><span class="pre">operator()</span></code> に統一することで、 <code class="docutils literal notranslate"><span class="pre">Functor</span></code> が他の <code class="docutils literal notranslate"><span class="pre">Functor</span></code> を保持できるようになるから。</p></li>
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">Functor</span></code> を、戻り値の型が <code class="docutils literal notranslate"><span class="pre">ResultType</span></code> で、パラメータリストをタイプリスト <code class="docutils literal notranslate"><span class="pre">TList</span></code> で表現する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Functor</span></code> の定義は一回。Pimpl パターンにより実装を別のクラステンプレート
<code class="docutils literal notranslate"><span class="pre">FunctorImpl</span></code> で行う。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FunctorImpl</span></code> を部分特殊化をしまくって、引数リストのパラメータ数が十分大きくても対応できるようにしておく。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 114 より引用</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TList</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">FunctorImpl</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">FunctorImpl</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">operator</span><span class="p">()()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">FunctorImpl</span><span class="o">*</span><span class="w"> </span><span class="nf">Clone</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">FunctorImpl</span><span class="p">(){}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">P1</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">FunctorImpl</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">TYPELIST_1</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">P1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">FunctorImpl</span><span class="o">*</span><span class="w"> </span><span class="nf">Clone</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">FunctorImpl</span><span class="p">(){}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">Functor::operator()</span></code> は <code class="docutils literal notranslate"><span class="pre">FunctorImpl::operator()</span></code> へ転送を行う必要がある。</p>
<ul>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Functor</span></code> の定義内に任意のパラメータ数で全ての <code class="docutils literal notranslate"><span class="pre">operator()</span></code> を定義することができる&gt; (p. 115)</p>
<ul>
<li><p>第 3 章で紹介した <code class="docutils literal notranslate"><span class="pre">TypeAtNonStrict&lt;...&gt;::Result</span></code> を十分な個数だけ
<code class="docutils literal notranslate"><span class="pre">typedef</span></code> する。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeAtNonStrict</span></code> は <code class="docutils literal notranslate"><span class="pre">TypeAt</span></code> のゆるゆるバージョン。</p>
</li>
<li><p>力作業で <code class="docutils literal notranslate"><span class="pre">operator()</span></code> のオーバーロードをその個数分だけ実装する。</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">Functor</span></code> オブジェクトの構築に関する考察。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FunctorImpl</span></code> のサブクラス <code class="docutils literal notranslate"><span class="pre">FunctorHandler</span></code> を定義して、</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Functor</span></code> のコンストラクターで Pimpl メンバーデータにセットする。</p></li>
</ul>
<hr class="docutils" />
<p>「メンバ関数へのポインタ」に関する考察。</p>
<ul class="simple">
<li><p>C++ では全てのオブジェクトには型があるが、<code class="docutils literal notranslate"><span class="pre">operator.*</span></code> と <code class="docutils literal notranslate"><span class="pre">operator-&gt;*</span></code>
の結果は何か違うものだ。</p></li>
</ul>
<hr class="docutils" />
<p>バインダーに関する考察。ちょっと読みにくいのと、<code class="docutils literal notranslate"><span class="pre">BinderFirst</span></code> しか議論していないのが惜しい。任意の位置のパラメータにバインドするバインダーの話を振らないと。</p>
<hr class="docutils" />
<p>この章の残りの話題は、</p>
<ul>
<li><p>Command パターンの話をしていたので、マクロやらアンドゥ・リドゥの話。</p></li>
<li><p>「参照の参照」問題回避のため、traits を <code class="docutils literal notranslate"><span class="pre">Functor::operator()</span></code> にクッションする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 例えば型 Parm1 が組み込み型でない場合、</span>
<span class="c1">// p1 の型は Parm1&amp; となる。</span>
<span class="c1">// const が付いていたら const Parm1&amp; となる。</span>
<span class="n">R</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">TypeTraits</span><span class="o">&lt;</span><span class="n">Parm1</span><span class="o">&gt;::</span><span class="n">ParameterType</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">TypeTraits</span><span class="o">&lt;</span><span class="n">Parm2</span><span class="o">&gt;::</span><span class="n">ParameterType</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">spImpl_</span><span class="p">)(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>&lt;典型的な 32 ビットのシステムの場合、（略）メンバ関数へのポインタは 16 バイト&gt;
(p. 132) となる。</p></li>
</ul>
<p>など。</p>
</section>
<section id="singleton">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">第 6 章 Singleton の実装</a><a class="headerlink" href="#singleton" title="Permalink to this heading">¶</a></h2>
<p>&lt;Singleton デザイン・パターンの実装で「正解」というものは存在しません。（略）扱っている問題次第で最適なものとなるのです&gt; (p. 137)</p>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">static</span></code> データ + <code class="docutils literal notranslate"><span class="pre">static</span></code> 関数 != Singleton&gt; (p. 138)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">static</span></code> な関数は <code class="docutils literal notranslate"><span class="pre">virtual</span></code> にできない&gt; (p. 138)</p></li>
<li><p>&lt;Singleton の実装では、2 番目のインスタンスを生成しないようにしながら、オブジェクトの生成と唯一性の管理に集中することになる&gt; (p. 139)</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>デフォルト・コンストラクター、コピー・コンストラクター、代入演算子は
<code class="docutils literal notranslate"><span class="pre">private</span></code> に宣言することは承知しているが、これを読むまでデストラクターも
<code class="docutils literal notranslate"><span class="pre">private</span></code> にするのを忘れていた。</p></li>
</ul>
<hr class="docutils" />
<p>基本を説明してすぐに Singleton オブジェクトの破棄に関する議論が始まる。これ以降の議論は、デザインパターンの本ではまずお目にかかったことのないものだ。</p>
<ul>
<li><p>&lt;リソース・リークを避ける唯一の正しい手段とは、アプリケーションの終了時に
Singleton オブジェクトを削除することです。問題は、その破棄後に、該当 Singleton
に対するアクセスが発生しないようなタイミングを注意深く設定しなければならない点です&gt; (p. 142)</p></li>
<li><p>次のタイプの実装を Meyers の Singleton と呼ぶことにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Singleton</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">Singleton::Instance</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>&lt;Meyers の Singleton は、アプリケーションの終了処理における最も簡単な
Singleton の破棄手段を提供しています&gt; (p. 143)</p>
</li>
</ul>
<hr class="docutils" />
<p>死んだ参照の議論。<code class="docutils literal notranslate"><span class="pre">Keyboard</span></code>, <code class="docutils literal notranslate"><span class="pre">Display</span></code>, <code class="docutils literal notranslate"><span class="pre">Log</span></code> という 3 クラスがそれぞれ
Singleton な場合で、<code class="docutils literal notranslate"><span class="pre">Keyboard</span></code> と <code class="docutils literal notranslate"><span class="pre">Display</span></code> のエラーが <code class="docutils literal notranslate"><span class="pre">Log</span></code> に報告するような状況を考察する。この問題を KDL 問題と呼ぶことにする。</p>
<ul class="simple">
<li><p>&lt;この 3 つの Singleton を Meyers の Singleton で実装した場合、プログラムは正しく動作しないのです&gt; (p. 144)</p></li>
<li><p>&lt;妥当な方法は、Singleton に死んだ参照の検出をさせることです&gt; (p. 144):
<code class="docutils literal notranslate"><span class="pre">Singleton::Instance</span></code> で検出させることで、何らかのエラーハンドリングをする。</p></li>
</ul>
<hr class="docutils" />
<p>Phoenix Singleton なる概念を導入する。デストラクトされたオブジェクトのあったメモリに、再度オブジェクトをコンストラクトするというものだ。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Singleton::OnDeadReference</span></code> で placement new の機能を利用し、
<code class="docutils literal notranslate"><span class="pre">pInstance_</span></code> に <code class="docutils literal notranslate"><span class="pre">Singleton</span></code> オブジェクトを構築する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atexit</span></code> に破棄関数 <code class="docutils literal notranslate"><span class="pre">KillPhoenixSingleton</span></code> を登録する。
<code class="docutils literal notranslate"><span class="pre">KillPhoenixSingleton</span></code> では <code class="docutils literal notranslate"><span class="pre">pInstance_</span></code> に対して明示的にデストラクターを呼び出す。&lt;<code class="docutils literal notranslate"><span class="pre">new</span></code> を使用すると（略）コンパイラによる自動破棄が行われなくなるためです&gt; (p. 147)</p></li>
<li><p>ちなみに <code class="docutils literal notranslate"><span class="pre">atexit</span></code> にはキズがある。&lt;規格では、<code class="docutils literal notranslate"><span class="pre">atexit</span></code> を用いた関数の登録中に他の <code class="docutils literal notranslate"><span class="pre">atexit</span></code> による登録が発生した場合の定義が行われていない&gt; (p. 147)</p></li>
</ul>
<hr class="docutils" />
<p>次の議論は、「Singleton に寿命レベルを導入する」というもの。</p>
<ul class="simple">
<li><p>前節の戦略だと、状態を保持するような Singleton では復活し切れないことは明白。</p></li>
<li><p>KDL 問題は「K, D よりも L のほうが長生きである」ことが表現できれば問題解決だ。</p></li>
</ul>
<p>&lt;ここで出てくる寿命の制御というコンセプトは、Singleton のコンセプトとは独立したものです。オブジェクトの寿命が長いほど、破棄が後にまわされるのです&gt; (p. 149)</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SetLongevity</span></code> 関数の「仕様」は p. 151 のリスト参照。<code class="docutils literal notranslate"><span class="pre">atexit</span></code> の呼び出しを含むのがポイント。</p></li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>寿命を指定する Singleton の実装法について数ページにわたる説明があるが、読むのが面倒になったのでスキップ。</p>
</div>
<hr class="docutils" />
<p>マルチスレッド対応。</p>
<p>&lt;共有されるグローバル・リソースというものは全て、競合条件とスレッドに関連する問題の元凶となり得るのです&gt; (p. 155)</p>
<ul>
<li><p>今では有名になった手法だが、Doug Schdmit と Tim Harrison が発案した (1996)
Double-Checked Locking パターンを紹介している。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 157 より引用</span>
<span class="n">Singleton</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">Singleton::Instance</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pInstance_</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Guard</span><span class="w"> </span><span class="n">myGuard</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pInstance_</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">pInstance_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">pInstance_</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>ただし、ある種のマルチプロセッサではこのパターンが使えない。使えるか否かを決定するには &lt;コンパイラのドキュメントを熟読しなければならない&gt; (p. 157)</p></li>
<li><p>&lt;少なくとも、<code class="docutils literal notranslate"><span class="pre">pInstance_</span></code> の次に <code class="docutils literal notranslate"><span class="pre">volatile</span></code> 修飾子を置くことです&gt; (p. 157)</p></li>
</ul>
<hr class="docutils" />
<p>これまでの分析を総合する。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">SingletonHolder</span></code> を 3 つのポリシーに分解する。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Creator</span></code>: <code class="docutils literal notranslate"><span class="pre">pInstance_</span></code> の初期化ポリシー。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Lifetime</span></code>: 「通常」「復活アリ」「寿命制御」「無限」の 4 パターンを提供している。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Threading</span></code>: シングルスレッド or マルチスレッド。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 160 より引用</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="w"></span>
<span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">CreationPolicy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateUsingNew</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">LifetimePolicy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultLifetime</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ThreadingModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SingleThreaded</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">SingletonHolder</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>&lt;インスタンスの型は <code class="docutils literal notranslate"><span class="pre">T*</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">ThreadingModel&lt;T&gt;::VolatileType*</span></code> です&gt;
(p. 160): マルチスレッド環境では仇になる、コンパイラによるある種の最適化処理を抑止するため。</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">SingletonHolder</span></code> が <code class="docutils literal notranslate"><span class="pre">DestroySingleton</span></code> を呼び出すことはありません&gt;
(p. 161)</p></li>
<li><p>KDL 問題の解として、仮コードを p. 164 に掲載している。</p></li>
</ul>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">第 7 章 スマート・ポインタ</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>&lt;スマート・ポインタとは、<code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> と単項演算子 <code class="docutils literal notranslate"><span class="pre">operator*</span></code> を実装することによって単純なポインタとして使えるようにした C++ のオブジェクトです。スマート・ポインタは、れっきとしたポインタのシンタックスとセマンティックスに加えて、メモリ管理やロックといった処理を内部で実行することによって、指しているオブジェクトの寿命を注意深く管理するという面倒な作業からアプリケーションを解放します&gt;
(p. 167) と、スマートポインタの定義を簡潔に与えている。</p>
<hr class="docutils" />
<ul>
<li><p>&lt;スマート・ポインタとは、シンタックスとある種のセマンティックスに関して、通常のポインタを模倣するような C++ のクラスです&gt; (p. 167)</p></li>
<li><p>&lt;既存の高品質なスマート・ポインタでは、たいていの場合、以下のコードのようにポインタの型によってテンプレート化されています&gt; (p. 168)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">SmartPtr</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">pointee_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;値のセマンティックスが存在するオブジェクトとは、コピーや代入が可能なオブジェクトのことです&gt; (p. 169)</p></li>
<li><p>ほとんどのスマートポインタには &lt;所有権管理機能&gt; (p. 169) が提供されている。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">pointee_</span></code> の型は必ず <code class="docutils literal notranslate"><span class="pre">T*</span></code> なのでしょうか&gt; (p. 170)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> のメカニズムを応用した &lt;事前および事後の関数呼び出し&gt; (p. 170)</p></li>
<li><p>ハンドルとポインタの類似性。 &lt;セマンティックスと管理方法を見た場合、ハンドルはポインタと良く似たものなのです&gt; (p. 171)</p></li>
</ul>
<hr class="docutils" />
<ul>
<li><p>&lt;メンバ関数というものはスマート・ポインタに適したものではないのです&gt; (p. 172)</p>
<p>なぜかというと、<code class="docutils literal notranslate"><span class="pre">T</span></code> の解放のためのメンバ関数呼び出しと、<code class="docutils literal notranslate"><span class="pre">SmartPtr&lt;T&gt;</span></code> のそれが似ていて紛らわしいから。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SmartPtr</span><span class="o">&lt;</span><span class="n">Printer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spRes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">spRes</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
<span class="n">spRes</span><span class="p">.</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>&lt;スマート・ポインタは、メンバ関数を使ってはいけないのです。つまり、
<code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> は非メンバ関数のみを使用するわけです&gt; (p. 172)</p></li>
</ul>
<hr class="docutils" />
<p>所有権に関する考察。</p>
<ul class="simple">
<li><p>ディープ・コピー方式</p>
<ul>
<li><p>ポリモフィズムをサポートするため、コピーには <code class="docutils literal notranslate"><span class="pre">T</span></code> のコピーコンストラクタは利用できない。別途コピー用のポリシーを設けて、<code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> のテンプレート引数とする。</p></li>
</ul>
</li>
<li><p>COW 方式</p>
<ul>
<li><p>COW 方式とは、「指しているオブジェクトが最初に更新されるタイミングでコピーする」というもの。</p></li>
<li><p>スマート・ポインタではその「タイミング」が把握できそうにないので、不採用とする。</p></li>
</ul>
</li>
<li><p>参照カウント方式</p>
<ul>
<li><p>&lt;同じオブジェクトを指しているスマート・ポインタの総数を追跡する&gt; (p. 176) 方式。</p></li>
<li><p>その総数カウンターを被参照オブジェクトにくっつける方式を侵入型参照カウント方式 (p. 177) と呼ぶ。</p></li>
</ul>
</li>
<li><p>参照リンク方式</p>
<ul>
<li><p>同じオブジェクトを指す <code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> が双方向リンクリスト構造をなす。リストが空になるタイミングが、被参照オブジェクトの破棄タイミングとなる。</p></li>
</ul>
</li>
<li><p>破壊型コピー方式</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> のコピーを行った場合、コピー元のオブジェクトが破壊される方式。
<code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> はまさにこれ。</p></li>
<li><p>&lt;破壊型コピー方式を用いたスマート・ポインタは、値のセマンティックスをサポートしていないため、コンテナに格納することができず、たいていの場合、生のポインタを扱うのと同じくらい細心の注意を払って扱わなければならないのです&gt; (p. 180)</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>&lt;単項演算子 <code class="docutils literal notranslate"><span class="pre">opearator&amp;</span></code> のオーバーロードはお勧めできない&gt; (p. 181)</p>
<hr class="docutils" />
<p>生のポインタ型への暗黙の変換はサポートしない。かわりに明示的な変換のための関数を提供する。</p>
<hr class="docutils" />
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SmartPtr&lt;T&gt;</span></code> と <code class="docutils literal notranslate"><span class="pre">T*</span></code> の等価性テストのため、考え得る全ての組み合わせの
<code class="docutils literal notranslate"><span class="pre">operator==</span></code> および <code class="docutils literal notranslate"><span class="pre">operator!=</span></code> を提供する。</p></li>
<li><p>なおかつ、<code class="docutils literal notranslate"><span class="pre">SmartPtr&lt;T&gt;</span></code> と <code class="docutils literal notranslate"><span class="pre">U*</span></code> のテストのために、テンプレート版 (p. 187)
も追加する。</p></li>
<li><p>算術型への変換は <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">bool</span></code> と同じ理由で推奨できない (p. 188)</p></li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>順序比較のセクションは、読むのが面倒になったのでスキップ。</p>
</div>
<hr class="docutils" />
<p>&lt;スマート・ポインタにおけるチェックの問題は、初期化時と参照外し時という 2 つのカテゴリに分類できます&gt; (p. 192)</p>
<ul class="simple">
<li><p>&lt;経験則としては、ポインタのチェックを厳格に行うことから始めて、プロファイラ結果に応じて、チェックの除去が可能なスマート・ポインタを選ぶというのが良いでしょう&gt; (p. 193)</p></li>
<li><p>&lt;エラーを報告するための最も優れた方法は、例外をスローすることです&gt; (p. 193)</p></li>
</ul>
<hr class="docutils" />
<p>マルチスレッド問題は付録 A まで取っておくか。</p>
<ul class="simple">
<li><p>ここ (p. 196) で紹介されている <code class="docutils literal notranslate"><span class="pre">LockingProxy</span></code> での <code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> トリックはおさえること。</p></li>
<li><p>マルチスレッド参照カウント方式と、マルチスレッド参照リンク方式。</p></li>
<li><p>クラスレベルのロックと、オブジェクトレベルのロック。</p></li>
</ul>
<hr class="docutils" />
<p>これまでの分析を総合する。</p>
<ul>
<li><p>&lt;私たちは問題をポリシーと呼ぶ小さなクラスへと分割するのです。そして、各ポリシー・クラスでは、たった 1 つの問題を取り扱います&gt; (p. 200)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">SmartPtr</span></code> の宣言中に現れるポリシーの順序は、最も良くカスタマイズされるものが先頭に来るようになっています&gt; (p. 201)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"></span>
<span class="o">&lt;</span><span class="w"></span>
<span class="w">   </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">OwnershipPolicy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RefCounted</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">ConversionPolicy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DisallowConversion</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">CheckingPolicy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AssertCheck</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">StoragePolicy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultSPStorage</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">SmartPtr</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">第 8 章 オブジェクト・ファクトリ</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>この章のテーマは Factory Method デザインパターン。個人的には C++ では最もコードが書きにくいパターンだと思っているので、楽しく読めた。</p>
<ul class="simple">
<li><p>&lt;ここで問題になるのは、実際に導出を行う <code class="docutils literal notranslate"><span class="pre">Derived</span></code> という型名を <code class="docutils literal notranslate"><span class="pre">new</span></code> 演算子の起動時に記述しなければならない点です。（略）ある意味では、使用してはいけないとされているコード中の数値定数と良く似ています&gt; (p. 209)</p></li>
<li><p>&lt;型は必ずコンパイル時点で既知のものでなければならないのです&gt; (p. 209)</p></li>
<li><p>&lt;C++ におけるオブジェクトの生成では、呼び出し側と導出された具体的なクラスを束縛することになるのです&gt; (p. 210)</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>例えば、ライブラリーがユーザー定義クラスのオブジェクト生成を行う必要がある場合、これはオブジェクト・ファクトリが必要とされるケースのひとつだ。</p></li>
<li><p>説明コードの <code class="docutils literal notranslate"><span class="pre">DocumentManager::NewDocument</span></code> では <code class="docutils literal notranslate"><span class="pre">new</span></code> 演算子ではなく、
<code class="docutils literal notranslate"><span class="pre">CreateDocument</span></code> 仮想メソッド呼び出しで（ユーザー定義型の）オブジェクトを生成する。</p>
<ul>
<li><p>この <code class="docutils literal notranslate"><span class="pre">CreateDocument</span></code> のような役割を持つメソッドを Factory Method と呼ぶ。</p></li>
</ul>
</li>
<li><p>保存ファイルからオブジェクトを再現する際にも、オブジェクト・ファクトリが必要だ。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;何故言語自身にオブジェクトを生成するための柔軟な手段が備わっていないのでしょうか？&gt; (p. 212)</p></li>
<li><p>&lt;C++ でオブジェクト・ファクトリを作り出すのは難しい問題になる&gt; (p. 213)</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Drawing::Load</span></code> コード (pp. 214-215) は現場でよく見かけるパターン。いい題材だ。</p></li>
<li><p>&lt;唯一の問題は、オブジェクト指向にける最も重要な規則に反している点です&gt;
(p. 215)</p>
<ul>
<li><p>型の「タグ」に基づいて <code class="docutils literal notranslate"><span class="pre">switch</span></code> 文を書いている点。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Shape</span></code> の派生クラスへの言及が、単独のソースファイルに集積される点。</p></li>
<li><p>拡張することが難しい。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">ShapeFactory</span></code> で <code class="docutils literal notranslate"><span class="pre">Shape</span></code> 派生オブジェクトを生成する関数のポインタのマップを管理する。</p>
<ul>
<li><p>各 <code class="docutils literal notranslate"><span class="pre">Shape</span></code> 派生クラスの実装ファイルで、p. 217 のコードを機械的に記述すればよい。</p></li>
<li><p>&lt;このコードは、<code class="docutils literal notranslate"><span class="pre">std::map</span></code> クラス・テンプレートに馴染みのない方にとっては、若干説明が必要かもしれません&gt; (p. 218) とあるが、そんな方はこの本の読者なんかやってないと思う。</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>マップのキーを整数型ではなく、もっとそれらしいものにしようではないかという議論。</p>
<p>&lt;こういったことから帰結できる唯一の結論は、型識別子の管理はオブジェクト・ファクトリ自身の管轄ではないということです。 C++ という言語が、ユニークで永続的な型 ID
を保証していない以上、型 ID の管理はプログラマが対処しなければならない問題なのです&gt; (p. 219)</p>
<hr class="docutils" />
<p>ここからオブジェクト・ファクトリの一般化について議論する。</p>
<ul class="simple">
<li><p>&lt;ファクトリは具体的な成果物を知る必要がない&gt; (p. 220) ので、「具体的な成果物」は <code class="docutils literal notranslate"><span class="pre">Factory</span></code> のテンプレートパラメータにならない。</p></li>
<li><p>&lt;エラー時の取り扱いコードを <code class="docutils literal notranslate"><span class="pre">CreateObject</span></code> メンバ関数から無くし、
<code class="docutils literal notranslate"><span class="pre">FactoryError</span></code> ポリシーに分離しなければなりません&gt; (p. 221)</p></li>
</ul>
<hr class="docutils" />
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"></span>
<span class="o">&lt;</span><span class="w"></span>
<span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">AbstractProduct</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">IdentifierType</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">ProductCreator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AbstractProduct</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(),</span><span class="w"></span>
<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">      </span><span class="k">class</span><span class="w"> </span><span class="nc">FactoryErrorPolicy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultFactoryError</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Factory</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>クローン・ファクトリは読みとばす。「共変の戻り型」の用語解説はおさえておくこと。</p>
</div>
<hr class="docutils" />
<p>オブジェクト・ファクトリは通常 Singleton であることが自然。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 228 より引用</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">SingletonHolder</span><span class="o">&lt;</span><span class="w"> </span><span class="n">Factory</span><span class="o">&lt;</span><span class="n">Shape</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ShapeFactory</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>以前の <code class="docutils literal notranslate"><span class="pre">Functor</span></code> を <code class="docutils literal notranslate"><span class="pre">ProductCreator</span></code> とすることも可能。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 228 より引用</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">SingletonHolder</span><span class="w"></span>
<span class="o">&lt;</span><span class="w"></span>
<span class="w">   </span><span class="n">Factory</span><span class="o">&lt;</span><span class="n">Shape</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Functor</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"></span>
<span class="n">ShapeFactory</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note1.html" title="Previous document">Modern C++ Design 読書ノート 1/3</a>
        </li>
        <li>
          <a href="note3.html" title="Next document">Modern C++ Design 読書ノート 3/3</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-sympy/index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powertoys/index.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Modern C++ Design 読書ノート</a><ul>
      <li>Previous: <a href="note1.html" title="previous chapter">Modern C++ Design 読書ノート 1/3</a></li>
      <li>Next: <a href="note3.html" title="next chapter">Modern C++ Design 読書ノート 3/3</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>