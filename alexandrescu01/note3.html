<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Modern C++ Design 読書ノート 3/3 &#8212; 読書ノート 1.6dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=c9b0a06a" />
    <script src="../_static/documentation_options.js?v=4354bf25"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="Effective STL 読書ノート" href="../meyers01.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート 2/3" href="note2.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
    <div class="related top">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note2.html" title="Previous">Modern C++ Design 読書ノート 2/3</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">Modern C++ Design 読書ノート</a>
        </li>
        <li>
          <a href="../meyers01.html" title="Next">Effective STL 読書ノート</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>


          <div class="body" role="main">
            
  <section id="modern-c-design-3-3">
<h1><a class="toc-backref" href="#id4" role="doc-backlink">Modern C++ Design 読書ノート 3/3</a><a class="headerlink" href="#modern-c-design-3-3" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">著者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Andrey Alexandrescu</p>
</dd>
<dt class="field-even">訳者<span class="colon">:</span></dt>
<dd class="field-even"><p>村上雅章</p>
</dd>
<dt class="field-odd">出版社<span class="colon">:</span></dt>
<dd class="field-odd"><p>ピアソン・エデュケーション</p>
</dd>
<dt class="field-even">発行年<span class="colon">:</span></dt>
<dd class="field-even"><p>2001 年</p>
</dd>
<dt class="field-odd">ISBN<span class="colon">:</span></dt>
<dd class="field-odd"><p>978-4-89471-435-9</p>
</dd>
</dl>
<nav class="contents" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#modern-c-design-3-3" id="id4">Modern C++ Design 読書ノート 3/3</a></p>
<ul>
<li><p><a class="reference internal" href="#abstract-factory" id="id5">第 9 章 Abstract Factory</a></p></li>
<li><p><a class="reference internal" href="#visitor" id="id6">第 10 章 Visitor</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id7">第 11 章 マルチメソッド</a></p></li>
<li><p><a class="reference internal" href="#a" id="id8">付録 A 最小限のマルチスレッド・ライブラリ</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id9">感想</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="abstract-factory">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">第 9 章 Abstract Factory</a><a class="headerlink" href="#abstract-factory" title="Link to this heading">¶</a></h2>
<p>&lt;もしも、<code class="docutils literal notranslate"><span class="pre">ConventionalDialog</span></code> 中では <code class="docutils literal notranslate"><span class="pre">FunkyButton</span></code> を使用させたくないのであれば、Abstract Factory デザイン・パターンを使用することによって <code class="docutils literal notranslate"><span class="pre">FunkyDialog</span></code>
中でのみ <code class="docutils literal notranslate"><span class="pre">FunkyButton</span></code> が使用されるように保証することができます&gt; (p. 231)</p>
<hr class="docutils" />
<p>&lt;ゲーム中に登場する全てのオブジェクトを生成する関数を 1 ヶ所に集めておくのが良いでしょう&gt; (p. 232)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AbstractEnemyFactory</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">Soldier</span><span class="o">*</span><span class="w"> </span><span class="n">MakeSoldier</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">Monster</span><span class="o">*</span><span class="w"> </span><span class="nf">MakeMonster</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">SuperMonster</span><span class="o">*</span><span class="w"> </span><span class="nf">MakeSuperMonster</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">EasyLevelEnemyFactory</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">AbstractEnemyFactory</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DieHardLevelEnemyFactory</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">AbstractEnemyFactory</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;Abstract Factory の主な欠点は、それが型と強く結びついている点です。（略）Abstract Factory の基底クラスは、生成を行う全ての抽象的な成果物を知っていなければならないのです&gt; (p. 234)</p></li>
<li><p>&lt;型の安全性を取るか、それとも低依存性を取るかという古典的なジレンマが、C++ ではしばしば発生するわけです&gt; (p. 234)</p></li>
</ul>
<hr class="docutils" />
<p>ここからジェネリックな Abstract Factory の設計に入る。</p>
<p>構造は、以前取り扱った <code class="docutils literal notranslate"><span class="pre">GenScatterHierarchy</span></code> と、ファクトリーユニットなるクラステンプレートの群を合体させたようなもの。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 235 より引用。</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AbstractFactoryUnit</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">DoCreate</span><span class="p">(</span><span class="n">Type2Type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">AbstractFactoryUnit</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span>
<span class="o">&lt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">TList</span><span class="p">,</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AbstractFactoryUnit</span>
<span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AbstractFactory</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">GenScatterHierarchy</span><span class="o">&lt;</span><span class="n">TList</span><span class="p">,</span><span class="w"> </span><span class="n">Unit</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">TList</span><span class="w"> </span><span class="n">ProductList</span><span class="p">;</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">Create</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Unit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">unit</span><span class="p">.</span><span class="n">DoCreate</span><span class="p">(</span><span class="n">Type2Type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// p. 236</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">AbstractFactory</span>
<span class="o">&lt;</span>
<span class="w">   </span><span class="n">TYPELIST_3</span><span class="p">(</span><span class="n">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">Monster</span><span class="p">,</span><span class="w"> </span><span class="n">SuperMonster</span><span class="p">)</span>
<span class="o">&gt;</span>
<span class="n">AbstractEnemyFactory</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Type2Type</span></code> は、オーバーロード関数の曖昧さを無くすという目的のみを持った単純なテンプレート&gt; (p. 235) &lt;<code class="docutils literal notranslate"><span class="pre">AbstractFactoryUnit</span></code> の実体が同じ継承階層にいくつも現れることになる&gt; (p. 235) ので、 <code class="docutils literal notranslate"><span class="pre">DoCreate</span></code> にこの引数が要る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AbstractFactory::Create</span></code> は、&lt;生成要求を適切な基底クラスへと振り分けるディスパッチャ&gt; (p. 236) となる。</p></li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">AbstractFactory</span></code> は固まったので、次は <code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> を設計する。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> だけでなく、concrete な <code class="docutils literal notranslate"><span class="pre">AbstractFactoryUnit</span></code> も必要。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> はクラステンプレート <code class="docutils literal notranslate"><span class="pre">GenLinearHierarchy</span></code> から導出する。何をしたいのかと言うと、Factory Unit のクラス継承を直列させたいわけだ。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 238 より引用</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ConcreteProduct</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OpNewFactoryUnit</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="c1">// Base は多分 AbstractFactoryUnit&lt;ConcreteProduct&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// この AbstractProduct を typedef するのがちょっと頭を使う。</span>
<span class="w">    </span><span class="n">ConcreteProduct</span><span class="o">*</span><span class="w"> </span><span class="n">DoCreate</span><span class="p">(</span><span class="n">Type2Type</span><span class="o">&lt;</span><span class="n">AbstractProduct</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcreteProduct</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// p. 239</span>
<span class="k">template</span>
<span class="o">&lt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">AbstractFact</span><span class="p">,</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Creator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpNewFactoryUnit</span><span class="p">,</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">TList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AbstractFact</span><span class="o">::</span><span class="n">ProductList</span>
<span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ConcreteFactory</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">GenLinearHierarchy</span><span class="o">&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Prototype バージョンを設計する。</p>
<ul>
<li><p>テンプレートクラス <code class="docutils literal notranslate"><span class="pre">PrototypeFactoryUnit</span></code> を定義する。<code class="docutils literal notranslate"><span class="pre">DoCreate</span></code> の実装では、何かオブジェクトを参照しておいて、そこからクローン作成。</p></li>
<li><p>先程の <code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> がそのまま利用できる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">ConcreteFactory</span>
<span class="o">&lt;</span>
<span class="w">    </span><span class="n">AbstractEnemyFactory</span><span class="p">,</span>
<span class="w">    </span><span class="n">PrototypeFactoryUnit</span>
<span class="o">&gt;</span>
<span class="n">EnemyFactory</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>&lt;Abstract Factory デザイン・パターンを手作業で実装して、こういった利点全てを満足するようなものを作る手間を考えてみてください&gt; (p. 244): 大変なことはよく理解した。</p></li>
</ul>
</section>
<section id="visitor">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">第 10 章 Visitor</a><a class="headerlink" href="#visitor" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>メリット：クラス階層や既存コードを再コンパイルせずに、仮想関数を追加できる。</p></li>
<li><p>デメリット：&lt;階層の末端にクラスを追加した場合、階層や全ての既存のコードの再コンパイルが必要になる&gt; (p. 249)</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;機能拡張は、新たなクラスを追加するか、新たな仮想メンバ関数を追加するかのいずれかによって実現できます&gt; (p. 249)</p></li>
<li><p>&lt;新たなクラスの追加は簡単であり、新たな仮想メンバ関数の追加は難しい&gt; (p. 250)</p></li>
<li><p>従って、こういう場合の裏に対しては、Visitor が役に立つ。</p></li>
</ul>
<p>ここから架空の文書エディターを開発する場合を考察していく。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// pp. 250-251 引用一部略</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DocStats</span><span class="w"> </span><span class="c1">// 文書の統計情報</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">AddChars</span><span class="p">(</span><span class="n">xxxx</span><span class="p">);</span><span class="w"> </span><span class="c1">// 文字数</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">AddWords</span><span class="p">(</span><span class="n">xxxx</span><span class="p">);</span><span class="w"> </span><span class="c1">// 単語数</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">AddImages</span><span class="p">(</span><span class="n">xxxx</span><span class="p">);</span><span class="w"> </span><span class="c1">// 画像数</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Display</span><span class="p">();</span><span class="w"> </span><span class="c1">// 統計情報表示</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DocElement</span><span class="p">;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Paragraph</span><span class="p">;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">RasterBitmap</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DocElement</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// DocElement が Paragraph だったら AddChars や AddWords を利用するし、</span>
<span class="w">    </span><span class="c1">// RasterBitmap だったら AddImages を利用して、統計をとる。</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">UpdateStats</span><span class="p">(</span><span class="n">DocStats</span><span class="o">&amp;</span><span class="w"> </span><span class="n">statistics</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>いくつか欠点がある。</p>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">DocStats</span></code> を修正する度に、<code class="docutils literal notranslate"><span class="pre">DocElement</span></code> 階層全体を再コンパイルする必要がある&gt; (p. 251)</p></li>
<li><p>&lt;統計情報の収集を行う実際の処理が、<code class="docutils literal notranslate"><span class="pre">UpdateStats</span></code> の実装全体に散りばめられます&gt; (p. 251)</p></li>
<li><p>その他</p></li>
</ul>
<p>発想を変えて、<code class="docutils literal notranslate"><span class="pre">UpdateStats</span></code> を <code class="docutils literal notranslate"><span class="pre">DocStats</span></code> に移動させてみると、&lt;今度は
<code class="docutils literal notranslate"><span class="pre">DocStats</span></code> が、処理対象となる具体的な <code class="docutils literal notranslate"><span class="pre">DocElement</span></code> に依存することになります&gt;
(p. 252)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 252 より引用一部略</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">DocStats::UpdateStats</span><span class="p">(</span><span class="n">DocElement</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">Paragraph</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Paragraph</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Paragraph の統計収集...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">RasterBitmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// RasterBitmap の統計収集...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで Visitor の導入となる。まずはデザインパターンの教科書通りのインターフェイスを持つクラスを書いてみる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 253 より</span>
<span class="c1">// まず Visitor の抽象基底クラス</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DocElementVisitor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">VisitParagraph</span><span class="p">(</span><span class="n">Paragraph</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">VisitRasterBitmap</span><span class="p">(</span><span class="n">RasterBitmap</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// DocElement::Visit を宣言。</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DocElement</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">DocElementVisitor</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Paragraph::Accept</span><span class="p">(</span><span class="n">DocElementVisitor</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">VisitParagraph</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// RasterBitmap も同様。</span>

<span class="c1">// そして DocStats は DocElementVisitor を実装する。</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DocStats</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DocElementVisitor</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ... VisitParagraph や VisitRasterBitmap を実装 ...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VisitXXXX</span></code> は <code class="docutils literal notranslate"><span class="pre">XXXX</span></code> の <code class="docutils literal notranslate"><span class="pre">public</span></code> な部分しかアクセスできない。</p></li>
<li><p>新たな操作を追加する場合、 <code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> から新たなクラスを導出するだけでよい。p. 254 の <code class="docutils literal notranslate"><span class="pre">IncrementFontSize</span></code> の例を見るといい。</p></li>
</ul>
<hr class="docutils" />
<p>オーバーロードについて解説あり。</p>
<ul class="simple">
<li><p>各 <code class="docutils literal notranslate"><span class="pre">VisitXXXX</span></code> の関数名は単に <code class="docutils literal notranslate"><span class="pre">Visit</span></code> とすることができる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DocElementVisitor::Visit(DocElement&amp;)</span></code> もアイディアとしてはアリ。</p></li>
</ul>
<hr class="docutils" />
<p>非循環式 Visitor という、魅惑的なタイトル。</p>
<ul>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> の <code class="docutils literal notranslate"><span class="pre">VisitXxx</span></code> メンバ関数名にクラス名が埋め込まれるため、<code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> のクラス定義をコンパイルする際には、<code class="docutils literal notranslate"><span class="pre">DocElement</span></code>
階層に存在する全ての具体的なクラスに関する知識（少なくとも名前）が必要になります&gt; (p. 257)</p></li>
<li><p>&lt;循環依存は、保守上のボトルネックになる&gt; (p. 257)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DocElement</span></code> 階層にサブクラスを追加するときに必要な作業を列挙している。&lt;こういった作業は面倒くさい&gt; (p. 258)</p></li>
<li><p>Robert Martin (1996) 考案による <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> を用いた変形 Visitor パターン。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> に <code class="docutils literal notranslate"><span class="pre">VisitXxxx</span></code> を宣言しない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">XxxxVisitor</span></code> は <code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> を継承しないで、<code class="docutils literal notranslate"><span class="pre">VisitXxxx</span></code> を純粋仮想関数として宣言する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DocElement</span></code> のサブクラス <code class="docutils literal notranslate"><span class="pre">Xxxx::Accept</span></code> 関数にて、引数の
<code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> を <code class="docutils literal notranslate"><span class="pre">XxxxVisitor</span></code> に <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> するテストを加える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 259 より引用</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Paragraph::Accept</span><span class="p">(</span><span class="n">DocElementVisitor</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">ParagraphVisitor</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">ParagraphVisitor</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">VisitParagraph</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>具体的な Visitor クラスの定義は、例えば次のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 260 より引用。</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DocStats</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">DocElementVisitor</span><span class="p">,</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">ParagraphVisitor</span><span class="p">,</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">RasterBitmapVisitor</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="c1">// VisitXxxx をこのクラスで実装する。</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">VisitParagraph</span><span class="p">(</span><span class="n">Paragraph</span><span class="o">&amp;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">VisitRasterBitmap</span><span class="p">(</span><span class="n">RasterBitmap</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>非循環式 Visitor パターンは循環依存をなくす代わりに、&lt;<code class="docutils literal notranslate"><span class="pre">DocElement</span></code> をルートに持つ被訪問階層のクラス群と、具体的な被訪問クラス毎に対応する訪問クラス
<code class="docutils literal notranslate"><span class="pre">XxxVisitor</span></code> 群という2 つの並列したクラス群を保守しなければならなくなります&gt;
(p. 261)</p></li>
<li><p>&lt;高名な GoF の Ralph Gamma ですら、Visitor がボトム 10 パターンの中のかなり下の方に位置付けられると言っているのです (Vlissides 1999)&gt; (p. 262)</p></li>
</ul>
<hr class="docutils" />
<p>ここでジェネリック化の議論に入る。</p>
<ul class="simple">
<li><p>&lt;できるだけ多くのコードをライブラリに収納するようにするのです&gt; (p. 262)</p></li>
<li><p>最初に非循環式 Visitor を実装し、その後 &lt;標準とも言える&gt; (p. 262): GoF 版
Visitor を実装する流れ。</p></li>
</ul>
<p>非循環式。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">BaseVisitor</span></code>: 先の例の <code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> と同じ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Visitor</span></code>: <code class="docutils literal notranslate"><span class="pre">XxxxVisitor</span></code> 用。クラステンプレートとして宣言。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 263</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Visitor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="n">ReturnType</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">ReturnType</span><span class="w"> </span><span class="nf">Visit</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">BaseVisitable</span></code>: <code class="docutils literal notranslate"><span class="pre">Accept</span></code> するクラスの基底クラスとして利用するためのクラステンプレート。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Visitor</span></code> 同様に <code class="docutils literal notranslate"><span class="pre">Accept</span></code> の戻り値がテンプレート引数になる。</p></li>
<li><p>ユーザーが <code class="docutils literal notranslate"><span class="pre">Accept</span></code> を実装をするための補助的なマクロ
<code class="docutils literal notranslate"><span class="pre">DEFINE_VISITABLE()</span></code> と補助関数 <code class="docutils literal notranslate"><span class="pre">AcceptImpl(T&amp;,</span> <span class="pre">BaseVisitor&amp;)</span></code> を用意する。</p>
<ul>
<li><p>&lt;場合によっては <code class="docutils literal notranslate"><span class="pre">DEFINE_VISITABLE()</span></code> マクロを用いるのではなく、自分で
<code class="docutils literal notranslate"><span class="pre">Accept</span></code> を実装する必要が出てくる&gt; (p. 268) が、問題ない。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>続いて循環式。<code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> を用いないために高速に動作する。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CyclicVisitor</span></code> ではタイプリストを利用する。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">GenScatterHierarchy&lt;TList,</span> <span class="pre">略&gt;</span></code> から継承する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Visit</span></code> メンバ関数テンプレートは <code class="docutils literal notranslate"><span class="pre">Visitor</span></code> を用いて実装する。
<code class="docutils literal notranslate"><span class="pre">CyclicVisitor</span></code> は <code class="docutils literal notranslate"><span class="pre">TList</span></code> 中の各型 <code class="docutils literal notranslate"><span class="pre">T</span></code> について、クラス
<code class="docutils literal notranslate"><span class="pre">Visitor&lt;T&gt;</span></code> の派生クラスであるからできる芸当。</p></li>
</ul>
</li>
<li><p>マクロ <code class="docutils literal notranslate"><span class="pre">DEFINE_CYCLIC_VISITABLE()</span></code> を提供する。</p></li>
</ul>
<p>循環式の場合、ユーザーコードが圧倒的に少なくて済むようだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// pp. 270-271 より引用</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">CyclicVisitor</span>
<span class="o">&lt;</span>
<span class="w">    </span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="c1">// 戻り値</span>
<span class="w">    </span><span class="n">TYPELIST_3</span><span class="p">(</span><span class="n">DocElement</span><span class="p">,</span><span class="w"> </span><span class="n">Paragraph</span><span class="p">,</span><span class="w"> </span><span class="n">RasterBitmap</span><span class="p">)</span>
<span class="o">&gt;</span>
<span class="n">MyVisitor</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DocElement</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Visit</span><span class="p">(</span><span class="n">MyVisitor</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Paragraph</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DocElement</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">DEFINE_CYCLIC_VISITABLE</span><span class="p">(</span><span class="n">MyVisitor</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="id2">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">第 11 章 マルチメソッド</a><a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>マルチメソッドという用語は CLOS から借用した (p. 277)</p></li>
</ul>
<hr class="docutils" />
<p>C++ におけるポリモフィズムとは何かをまず考える。関数オーバーロード、関数テンプレートはともに静的なディスパッチメカニズムであり、仮想メンバ関数呼び出しは動的なディスパッチメカニズムであるとみなせる。</p>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">obj.Fun(引数群)</span></code> という呼び出しシンタックスでは、引数群よりも <code class="docutils literal notranslate"><span class="pre">obj</span></code> に優先的な役割が与えられているのです&gt; (p. 278)</p></li>
<li><p>マルチメソッド、多重ディスパッチとは &lt;関数呼び出しに用いられているオブジェクト群の動的な型に依存して、異なった関数にディスパッチするようなメカニズム&gt;
(p. 278) のこと。</p></li>
</ul>
<hr class="docutils" />
<p>マルチメソッドの必要性について論じる。ここでは <code class="docutils literal notranslate"><span class="pre">Shape</span></code> （のサブクラス）オブジェクト同士の交差部分処理という、C++ プログラム開発経験者ならまず膝を叩く例が挙げられている。</p>
<p>手許に <code class="docutils literal notranslate"><span class="pre">Shape</span></code> への異なるポインターが 2 つあるとして、それをどのオーバーロードに適用するの？ という問題だ。</p>
<hr class="docutils" />
<p>最初に一番愚直と思われる方法、力任せに <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> テストをして、動的な型に見合うオーバーロード関数に引き渡すコードを示している。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// pp. 280-281 より一部抜粋（一部だけで雰囲気が思い出せるから）</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">DoHatchArea1</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">DoHatchArea2</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">DoHatchArea3</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Poly</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">...</span>

<span class="kt">void</span><span class="w"> </span><span class="n">DoubleDispatch</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Rectangle</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Rectangle</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">))</span>
<span class="w">            </span><span class="n">DoHatchArea1</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">Ellipse</span><span class="o">*</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Ellipse</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">))</span>
<span class="w">            </span><span class="n">DoHatchArea2</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span>
<span class="w">            </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span>
<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>問題点は明らか。</p>
<ul>
<li><p>&lt;この実装は、階層中に存在する全クラスを知っていなければならないのです&gt;
(p. 281)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">if</span></code> ステートメントの順序が処理に影響を与えてしまう&gt; (p. 281) - &lt;最も下位にあるクラスが最初に判定されるよう、<code class="docutils literal notranslate"><span class="pre">if</span></code> の判定を「ソートする」&gt; (p. 282)
ようでなければ問題が出る。</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>ここから本書らしいアプローチが始まる。先程の <code class="docutils literal notranslate"><span class="pre">DoubleDispatch</span></code> 相当のコードを、クラステンプレート <code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> とクラス <code class="docutils literal notranslate"><span class="pre">HatchingExecutor</span></code> に分割して、次のような構造で表現する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// pp. 283-286 から断続的に引用。</span>

<span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="cm">/* 略 */</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// 本を読んで。</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StaticDispatcher</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TypesLhs</span><span class="o">::</span><span class="n">Head</span><span class="w"> </span><span class="n">Head</span><span class="p">;</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TypesLhs</span><span class="o">::</span><span class="n">Tail</span><span class="w"> </span><span class="n">Tail</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ResultType</span><span class="w"> </span><span class="n">Go</span><span class="p">(</span><span class="n">BaseLhs</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">BaseRhs</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="n">Executor</span><span class="w"> </span><span class="n">exec</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">Head</span><span class="o">*</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Head</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">StaticDispatcher</span><span class="o">&lt;</span><span class="w"> </span><span class="n">NullType</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 略 */</span><span class="w"> </span><span class="o">&gt;::</span><span class="n">DispatchRhs</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="n">exec</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">StaticDispatcher</span><span class="o">&lt;</span><span class="w"> </span><span class="n">Tail</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 略 */</span><span class="w"> </span><span class="o">&gt;::</span><span class="n">Go</span><span class="p">(</span><span class="cm">/* 略 */</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">SomeLhs</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ResultType</span><span class="w"> </span><span class="n">DispatchRhs</span><span class="p">(</span><span class="n">SomeLhs</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">BaseRhs</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="n">Executor</span><span class="w"> </span><span class="n">exec</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ここで Head, Tail に対する typedef を「上書き」する。</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">Head</span><span class="o">*</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Head</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">exec</span><span class="p">.</span><span class="n">Fire</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">StaticDispatcher</span><span class="o">&lt;</span><span class="n">NullType</span><span class="p">,</span><span class="w"> </span><span class="n">Tail</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 略 */</span><span class="o">&gt;::</span><span class="n">DispatchRhs</span><span class="p">(</span><span class="cm">/* 略 */</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// TODO: StaticDispatcher の部分特殊化 1: TypeLhs = NullType で</span>
<span class="c1">// ダミーの static メソッド Go を実装する。</span>

<span class="c1">// TODO: StaticDispatcher の部分特殊化 2: TypeRhs = NullType で</span>
<span class="c1">// ダミーの static メソッド DispatchRhs を実装する。</span>

<span class="k">class</span><span class="w"> </span><span class="nc">HatchingExecutor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Fire</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Fire</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">&amp;</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">OnError</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Go</span></code> から <code class="docutils literal notranslate"><span class="pre">Go</span></code> を呼び出す様子は再帰呼び出しに見えるかもしれないが、
<code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> の別な実体化の同名メソッドを呼び出している。
<code class="docutils literal notranslate"><span class="pre">DispatchRhs</span></code> も同様。</p></li>
<li><p>&lt;結果的に、<code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> は、2 つのタイプリストと特定のコードから指数に比例した分量のコードを生成するわけです。（略）つまり、大きなコードによってコンパイル時間、プログラム・サイズ、実行時間の全てに打撃が与えられるのです&gt;
(p. 284)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> は境界条件が発生した場合、元々の（キャストしない）
<code class="docutils literal notranslate"><span class="pre">lhs</span></code> と <code class="docutils literal notranslate"><span class="pre">rhs</span></code> を用いて単に <code class="docutils literal notranslate"><span class="pre">Executor::OnError</span></code> を呼び出します&gt; (p. 286)</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 286 より。</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">StaticDispatcher</span><span class="o">&lt;</span><span class="n">HatchingExecutor</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="p">,</span>
<span class="w">    </span><span class="n">TYPELIST_3</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span><span class="w"> </span><span class="n">Ellipse</span><span class="p">,</span><span class="w"> </span><span class="n">Poly</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Dispatcher</span><span class="p">;</span>

<span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">HatchingExecutor</span><span class="w"> </span><span class="n">exec</span><span class="p">;</span>
<span class="n">Dispatcher</span><span class="o">::</span><span class="n">Go</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">exec</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>タイプリストに記述するクラスの順序に注意。先程と同様の注意が要る。&lt;継承階層で最も下位にあるものをタイプリストの先頭に持ってくることです&gt; (p. 287)</p></li>
</ul>
<hr class="docutils" />
<p>次に引数の順序を意識せずに済むように改造していく。対称型マルチメソッド。
<code class="docutils literal notranslate"><span class="pre">BaseLhs</span></code> と <code class="docutils literal notranslate"><span class="pre">BaseRhs</span></code> が同一型かつ <code class="docutils literal notranslate"><span class="pre">TypesLhs</span></code> と <code class="docutils literal notranslate"><span class="pre">TypesRhs</span></code> が同一型の場合に意味がある。</p>
<ul>
<li><p>&lt;理想的には、追加の <code class="docutils literal notranslate"><span class="pre">bool</span></code> テンプレート・パラメータを <code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code>
に引き渡して、対称性が選択できるようにするべきでしょう&gt; (p. 289)</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> に <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">symmetric</span></code> テンプレート引数を追加する。</p></li>
<li><p>クラス内の <code class="docutils literal notranslate"><span class="pre">private</span></code> 部分にクラステンプレート <code class="docutils literal notranslate"><span class="pre">InvocationTraits</span></code> を定義する。これは <code class="docutils literal notranslate"><span class="pre">static</span></code> メンバー関数 <code class="docutils literal notranslate"><span class="pre">DoDispatch</span></code> だけを含む構造体。</p>
<p><code class="docutils literal notranslate"><span class="pre">DoDispatch</span></code> の内容は単に <code class="docutils literal notranslate"><span class="pre">exec.Fire(lhs,</span> <span class="pre">rhs);</span></code> のみ。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">InvocationTraits</span></code> の部分特殊化版を定義し、そちらの <code class="docutils literal notranslate"><span class="pre">DoDispatch</span></code> の内容は <code class="docutils literal notranslate"><span class="pre">exec.Fire(rhs,</span> <span class="pre">lhs);</span></code> とする。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">StaticDispatcher::DispatchRhs</span></code> の定義で、<code class="docutils literal notranslate"><span class="pre">if</span></code> ブロック内をこのようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// p. 291 より引用</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">swapArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">symmetric</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">    </span><span class="n">IndexOf</span><span class="o">&lt;</span><span class="n">Head</span><span class="p">,</span><span class="w"> </span><span class="n">TypeRhs</span><span class="o">&gt;::</span><span class="n">result</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">IndexOf</span><span class="o">&lt;</span><span class="n">BaseLhs</span><span class="p">,</span><span class="w"> </span><span class="n">TypesLhs</span><span class="o">&gt;::</span><span class="n">result</span><span class="w"> </span><span class="p">};</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">InvocationTraits</span><span class="o">&lt;</span><span class="n">swapArgs</span><span class="p">,</span><span class="w"> </span><span class="n">BaseLhs</span><span class="p">,</span><span class="w"> </span><span class="n">Head</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">CallTraits</span><span class="p">;</span>
<span class="k">return</span><span class="w"> </span><span class="n">CallTraits</span><span class="o">::</span><span class="n">DoDispatch</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>型リストから型を探索する効率を対数時間に持っていこうとするのか。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">std::type_info::before</span></code> によって &lt;プログラム中における全ての型に対する順序関係が提供されるのです&gt; (p. 291)</p></li>
<li><p>第 2 章で紹介されたラッパークラス <code class="docutils literal notranslate"><span class="pre">TypeInfo</span></code> を利用する。&lt;<code class="docutils literal notranslate"><span class="pre">TypeInfo</span></code> は、値のセマンティックスと演算子 <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code> を提供しています。このため、標準コンテナに <code class="docutils literal notranslate"><span class="pre">TypeInfo</span></code> オブジェクトを格納することができるのです&gt; (p. 292)</p></li>
<li><p>&lt;特に、ソート済みベクタと二分探索アルゴリズムを組み合わせれば、連想コンテナよりも空間的および時間的に優れたものとなる場合もあるのです。これは、挿入頻度よりもアクセス頻度の方が多い場合に起こり得ます&gt; (p. 292)</p>
<p>つまり、コンテナ内容がある時点から固定されるような場合は連想コンテナを採用しないように、か。</p>
</li>
<li><p>ただし、便宜的に両者のデータ構造を共に「マップ」と呼ぶことにする。(p. 293)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BasicDispatcher</span></code></p>
<ul>
<li><p>最終的なディスパッチ先の関数の引数 <code class="docutils literal notranslate"><span class="pre">(lhs,</span> <span class="pre">rhs)</span></code> ペアの型を
<code class="docutils literal notranslate"><span class="pre">std::pair&lt;TypeInfo,</span> <span class="pre">TypeInfo&gt;</span></code> で表現する。</p></li>
<li><p>上記のペア型をキー型とし、<code class="docutils literal notranslate"><span class="pre">ResultType</span> <span class="pre">(*)(BaseLhs&amp;,</span> <span class="pre">BaseRhs&amp;)</span></code> 型の関数ポインタを値型とするマップを定義する。</p></li>
<li><p>そのマップオブジェクトをメンバーデータに持つ。</p></li>
<li><p>テンプレートメンバー関数 <code class="docutils literal notranslate"><span class="pre">Add</span></code> を定義し、マップに関数ポインタを動的に追加できるようにする。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Go</span></code> は次のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ResultType</span><span class="w"> </span><span class="nf">Go</span><span class="p">(</span><span class="n">BaseLhs</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">BaseRhs</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callbackMap_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span>
<span class="w">        </span><span class="n">KeyType</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">callbackMap_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ... 例外送出</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)(</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>&lt;継承とともに用いると正しく動作しません&gt; (p. 294)</p></li>
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">BasicDispatcher</span></code> に対して、全てのペアを注意深く登録していかなければならないのです&gt; (p. 295)</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>次に <code class="docutils literal notranslate"><span class="pre">BasicDispatcher</span></code> を利用して <code class="docutils literal notranslate"><span class="pre">FnDispatcher</span></code> を定義するのだが、もうついていけないのでスキップ。</p>
<p><code class="docutils literal notranslate"><span class="pre">Trampoline</span></code> という面白い技法を利用してディスパッチを実現する。</p>
</div>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;値のセマンティックスは実行時のポリモフィズムとうまく調和できない&gt; (p. 299)</p></li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">static_cast</span></code> or <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> という問題。これまでは <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> 一丁で押し通してきた理由を解説。</p>
<ul class="simple">
<li><p>仮想継承を伴なうダイアモンド型クラス階層が対象となるとき、&lt;仮想基底オブジェクトから導出した型へは <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> することができない&gt; (p. 302)</p></li>
<li><p>仮想継承を伴わないダイアモンド型クラス階層が対象となるとき、基底クラスが曖昧になるケースがある。</p></li>
</ul>
<hr class="docutils" />
<p>&lt;多重ディスパッチと C++ において、特にいやらしかった問題は、可変引数関数を表現する統一した方法が存在しないということだったのです&gt; (p. 312)</p>
</section>
<section id="a">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">付録 A 最小限のマルチスレッド・ライブラリ</a><a class="headerlink" href="#a" title="Link to this heading">¶</a></h2>
<p>C++ に関する書籍は、マルチスレッドをテーマにした文章が付録になる傾向がある。本書もその例に漏れない。</p>
<ul class="simple">
<li><p>&lt;ユーザは砂時計のカーソルが表示されることを望んでいないため、プログラマはマルチスレッド・プログラムを記述しなければならないのです&gt; (p. 317)</p></li>
<li><p>&lt;ライブラリもスレッドを考慮する必要があります。こういった機能は、ライブラリが自身のスレッドを用いていない場合であっても、組み込んでおかなければならないのです&gt; (p. 317)</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;マルチスレッドがシングルプロセッサ・マシンでも必要となる理由は、リソースを効果的に使用できるという点があるからです&gt; (p. 318)</p></li>
<li><p>&lt;これらは物理的に独立した機器であるため、同時にリソースを使用することができるのです&gt; (p. 318)</p></li>
<li><p>&lt;非同期実行は、マルチスレッドの実行と比較すると状態遷移の多いプログラムになるという欠点があります&gt; (p. 318)</p></li>
<li><p>&lt;アトミックな操作だと思っていたものがそうではなくなってしまう&gt; (p. 318)</p></li>
<li><p>&lt;マルチスレッドのプログラムは、リソースの共有に大きな問題を抱えている&gt;
(p. 319)</p></li>
<li><p>マルチスレッドプログラミングにおける重要な技法のひとつに、同期化オブジェクトがある。</p></li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">++x</span></code> というステートメントに関する考察を始める。</p>
<ul class="simple">
<li><p>こういう (read-modify-write) 操作を RMW 操作と呼ぶ (p. 320)</p></li>
<li><p>マルチプロセッサ環境では、あるプロセッサが変数を更新している間にも、別のプロセッサがメモリにアクセスできる。</p></li>
<li><p>&lt;どちらのプロセッサ（スレッド）も、インクリメントができなかったことを検出できない&gt; (p. 320)</p></li>
<li><p>通常、アトミックなインクリメント・デクリメント操作は OS が C 関数の形式でサポートしている。</p></li>
</ul>
<p>ライブラリでアトミック演算をまとめるようだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SomeThreadingModel</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IntType</span><span class="p">;</span><span class="w"> </span><span class="c1">// int にはプラットフォーム規定整数型名がくる。</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IntType</span><span class="w"> </span><span class="nf">AtomicAdd</span><span class="p">(</span><span class="k">volatile</span><span class="w"> </span><span class="n">IntType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lval</span><span class="p">,</span><span class="w"> </span><span class="n">IntType</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>&lt;コピー操作でさえも非アトミックな場合があるため、<code class="docutils literal notranslate"><span class="pre">AtomicAssign</span></code> 関数も 2 つ必要となるわけです&gt; (p. 321)</p></li>
</ul>
<hr class="docutils" />
<p>ミューテックスの話題。</p>
<ul>
<li><p>&lt;マルチスレッド環境下におけるオペレーティング・システムのスケジューラは、ある種の同期化オブジェクトを提供しなければならないということが、 Edgar Dijkstra によって証明されています。マルチスレッド・アプリケーションを正しく記述するためには、こういったものが必要不可欠なのです&gt; (p. 321)</p>
<p>とても重要。丸暗記しよう。</p>
</li>
<li><p>&lt;ミューテックス (mutex) とは、相互排他 (Mutual Exclusive) の略であり、同期化用のプリミティブ・オブジェクトの機能を解説するための用語です&gt; (p. 321)</p></li>
<li><p>&lt;たった 1 つのスレッドのみがミューテックスを獲得できるのです&gt; (p. 322)</p>
<p>獲得は <code class="docutils literal notranslate"><span class="pre">Acquire</span></code> で、解放は <code class="docutils literal notranslate"><span class="pre">Release</span></code> か。</p>
</li>
<li><p>コード中の <code class="docutils literal notranslate"><span class="pre">mtx.Acquire()</span></code> 呼び出しと <code class="docutils literal notranslate"><span class="pre">mtx.Release()</span></code> 呼び出しで囲まれた部分が、 <code class="docutils literal notranslate"><span class="pre">mtx</span></code> オブジェクトに関してアトミックとなる。これを利用して &lt;スレッド間で共有させたいリソース毎にミューテックス・オブジェクトを 1 つ割り当てることになります&gt; (p. 322)</p></li>
<li><p>マルチスレッドプログラミングの教科書にありがちな「銀行口座クラスの預金引き出しメソッド実装例」コードあり。</p>
<ul class="simple">
<li><p>&lt;<code class="docutils literal notranslate"><span class="pre">Lock</span></code> オブジェクトをスタック上に割り当てておけば、例外発生の有無とは関係なく、<code class="docutils literal notranslate"><span class="pre">Acquire</span></code> と <code class="docutils literal notranslate"><span class="pre">Release</span></code> のペアが正しく実行される&gt; (p. 323)</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>&lt;オブジェクト指向プログラムでは、リソースはオブジェクトになります&gt; (p. 323)</p></li>
<li><p>オブジェクト・レベルのロックと、クラス・レベルのロックがある。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Host</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ObjectLevelLockable</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Lock</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">Lock</span><span class="p">(</span><span class="n">Host</span><span class="o">&amp;</span><span class="p">);</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BankAccount</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ObjectLevelLockable</span><span class="o">&lt;</span><span class="n">BankAccount</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Deposite</span><span class="p">(</span><span class="cm">/* 略 */</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Lock</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// ... 入金トランザクション</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>&lt;<code class="docutils literal notranslate"><span class="pre">volatile</span></code> の指定によってコンパイラはある種の最適化を抑止するため、シングルスレッド・モデルでは指定するべきではないのです&gt; (p. 325)</p>
<hr class="docutils" />
<p>&lt;ポータブルなマルチスレッド・ライブラリとして ACE (Adaptive Communication
Environment) を調査することをお勧めします (Schmidt 2000)&gt; (p. 326)</p>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">感想</a><a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>一周読むのに鉛筆片手に 10 時間、このノートをとるのに 13 時間近く要した。これまで読んできた C++ 関連書籍中「初心者にお勧めできない」度ナンバーワンは間違いなく本書だ。</p></li>
<li><p>コーディング・コンパイル・動作確認を一切しないという不埒な読書姿勢。</p></li>
<li><p>理解度もかなり低いだろう。</p></li>
</ul>
</section>
</section>


          </div>
    <div class="related bottom">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="note2.html" title="Previous">Modern C++ Design 読書ノート 2/3</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">Modern C++ Design 読書ノート</a>
        </li>
        <li>
          <a href="../meyers01.html" title="Next">Effective STL 読書ノート</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>

      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="../index.html" title="読書ノート Home"><img src="../_images/logo.svg"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2024, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>