
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Modern C++ Design 読書ノート 3/3 &#8212; 読書ノート v1.4</title>
    <link rel="stylesheet" href="../_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/mathjaxconf.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="next" title="Effective STL 読書ノート" href="../meyers01.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート 2/3" href="note2.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../meyers01.html" title="Effective STL 読書ノート"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="note2.html" title="Modern C++ Design 読書ノート 2/3"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Modern C++ Design 読書ノート</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="modern-c-design-3-3">
<h1><a class="toc-backref" href="#id4">Modern C++ Design 読書ノート 3/3</a><a class="headerlink" href="#modern-c-design-3-3" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Andrey Alexandrescu</td>
</tr>
<tr class="field-even field"><th class="field-name">訳者:</th><td class="field-body">村上雅章</td>
</tr>
<tr class="field-odd field"><th class="field-name">出版社:</th><td class="field-body">ピアソン・エデュケーション</td>
</tr>
<tr class="field-even field"><th class="field-name">発行年:</th><td class="field-body">2001 年</td>
</tr>
<tr class="field-odd field"><th class="field-name">ISBN:</th><td class="field-body">978-4-89471-435-9</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#modern-c-design-3-3" id="id4">Modern C++ Design 読書ノート 3/3</a><ul>
<li><a class="reference internal" href="#abstract-factory" id="id5">第 9 章 Abstract Factory</a></li>
<li><a class="reference internal" href="#visitor" id="id6">第 10 章 Visitor</a></li>
<li><a class="reference internal" href="#id2" id="id7">第 11 章 マルチメソッド</a></li>
<li><a class="reference internal" href="#a" id="id8">付録 A 最小限のマルチスレッド・ライブラリ</a></li>
<li><a class="reference internal" href="#id3" id="id9">感想</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract-factory">
<h2><a class="toc-backref" href="#id5">第 9 章 Abstract Factory</a><a class="headerlink" href="#abstract-factory" title="Permalink to this headline">¶</a></h2>
<p>&lt;もしも、<code class="docutils literal notranslate"><span class="pre">ConventionalDialog</span></code> 中では <code class="docutils literal notranslate"><span class="pre">FunkyButton</span></code> を使用させたくないのであれば、
Abstract Factory デザイン・パターンを使用することによって <code class="docutils literal notranslate"><span class="pre">FunkyDialog</span></code> 中でのみ
<code class="docutils literal notranslate"><span class="pre">FunkyButton</span></code> が使用されるように保証することができます&gt; (p. 231)</p>
<hr class="docutils" />
<p>&lt;ゲーム中に登場する全てのオブジェクトを生成する関数を 1 ヶ所に集めておくのが良いでしょう&gt; (p. 232)</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AbstractEnemyFactory</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="n">Soldier</span><span class="o">*</span> <span class="n">MakeSoldier</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">MakeMonster</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">virtual</span> <span class="n">SuperMonster</span><span class="o">*</span> <span class="n">MakeSuperMonster</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">EasyLevelEnemyFactory</span> <span class="p">:</span> <span class="n">public</span> <span class="n">AbstractEnemyFactory</span>
<span class="p">{</span>
    <span class="o">...</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">DieHardLevelEnemyFactory</span> <span class="p">:</span> <span class="n">public</span> <span class="n">AbstractEnemyFactory</span>
<span class="p">{</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;Abstract Factory の主な欠点は、それが型と強く結びついている点です。（略）Abstract Factory の基底クラスは、生成を行う全ての抽象的な成果物を知っていなければならないのです&gt; (p. 234)</li>
<li>&lt;型の安全性を取るか、それとも低依存性を取るかという古典的なジレンマが、
C++ ではしばしば発生するわけです&gt; (p. 234)</li>
</ul>
<hr class="docutils" />
<p>ここからジェネリックな Abstract Factory の設計に入る。</p>
<p>構造は、以前取り扱った <code class="docutils literal notranslate"><span class="pre">GenScatterHierarchy</span></code> と、ファクトリーユニットなるクラステンプレートの群を合体させたようなもの。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// p. 235 より引用。
template &lt;class T&gt;
class AbstractFactoryUnit
{
public:
    virtual T* DoCreate(Type2Type&lt;T&gt;) = 0;
    virtual ~AbstractFactoryUnit() {}
};

template
&lt;
    class TList,
    template &lt;class&gt; class Unit = AbstractFactoryUnit
&gt;
class AbstractFactory : public GenScatterHierarchy&lt;TList, Unit&gt;
{
public:
    typedef TList ProductList;
    template &lt;class T&gt; T* Create()
    {
        Unit&lt;T&gt;&amp; unit = *this;
        return unit.DoCreate(Type2Type&lt;T&gt;());
    }
};

// p. 236
typedef AbstractFactory
&lt;
   TYPELIST_3(Soldier, Monster, SuperMonster)
&gt;
AbstractEnemyFactory;
</pre></div>
</div>
<ul class="simple">
<li>&lt;<code class="docutils literal notranslate"><span class="pre">Type2Type</span></code> は、オーバーロード関数の曖昧さを無くすという目的のみを持った単純なテンプレート&gt; (p. 235)
&lt;<code class="docutils literal notranslate"><span class="pre">AbstractFactoryUnit</span></code> の実体が同じ継承階層にいくつも現れることになる&gt; (p. 235) ので、
<code class="docutils literal notranslate"><span class="pre">DoCreate</span></code> にこの引数が要る。</li>
<li><code class="docutils literal notranslate"><span class="pre">AbstractFactory::Create</span></code> は、&lt;生成要求を適切な基底クラスへと振り分けるディスパッチャ&gt; (p. 236) となる。</li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">AbstractFactory</span></code> は固まったので、次は <code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> を設計する。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> だけでなく、concrete な <code class="docutils literal notranslate"><span class="pre">AbstractFactoryUnit</span></code> も必要。</li>
<li><code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> はクラステンプレート <code class="docutils literal notranslate"><span class="pre">GenLinearHierarchy</span></code> から導出する。何をしたいのかと言うと、Factory Unit のクラス継承を直列させたいわけだ。</li>
</ul>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// p. 238 より引用
template &lt;class ConcreteProduct, class Base&gt;
class OpNewFactoryUnit : public Base // Base は多分 AbstractFactoryUnit&lt;ConcreteProduct&gt;
{
    ...

public:
    // この AbstractProduct を typedef するのがちょっと頭を使う。
    ConcreteProduct* DoCreate(Type2Type&lt;AbstractProduct&gt;)
    {
        return new ConcreteProduct;
    }
};

// p. 239
template
&lt;
    class AbstractFact,
    template &lt;class, class&gt; class Creator = OpNewFactoryUnit,
    class TList = typename AbstractFact::ProductList
&gt;
class ConcreteFactory
    : public GenLinearHierarchy&lt; ... &gt;
{
    ...
};
</pre></div>
</div>
<hr class="docutils" />
<p>Prototype バージョンを設計する。</p>
<ul>
<li><p class="first">テンプレートクラス <code class="docutils literal notranslate"><span class="pre">PrototypeFactoryUnit</span></code> を定義する。
<code class="docutils literal notranslate"><span class="pre">DoCreate</span></code> の実装では、何かオブジェクトを参照しておいて、そこからクローン作成。</p>
</li>
<li><p class="first">先程の <code class="docutils literal notranslate"><span class="pre">ConcreteFactory</span></code> がそのまま利用できる。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">ConcreteFactory</span>
<span class="o">&lt;</span>
    <span class="n">AbstractEnemyFactory</span><span class="p">,</span>
    <span class="n">PrototypeFactoryUnit</span>
<span class="o">&gt;</span>
<span class="n">EnemyFactory</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;Abstract Factory デザイン・パターンを手作業で実装して、こういった利点全てを満足するようなものを作る手間を考えてみてください&gt; (p. 244)</p>
<p>→大変なことはよく理解した。</p>
</li>
</ul>
</div>
<div class="section" id="visitor">
<h2><a class="toc-backref" href="#id6">第 10 章 Visitor</a><a class="headerlink" href="#visitor" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>メリット：クラス階層や既存コードを再コンパイルせずに、仮想関数を追加できる。</li>
<li>デメリット：&lt;階層の末端にクラスを追加した場合、階層や全ての既存のコードの再コンパイルが必要になる&gt; (p. 249)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;機能拡張は、新たなクラスを追加するか、新たな仮想メンバ関数を追加するかのいずれかによって実現できます&gt; (p. 249)</li>
<li>&lt;新たなクラスの追加は簡単であり、新たな仮想メンバ関数の追加は難しい&gt; (p. 250)</li>
<li>従って、こういう場合の裏に対しては、Visitor が役に立つ。</li>
</ul>
<p>ここから架空の文書エディターを開発する場合を考察していく。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// pp. 250-251 引用一部略
class DocStats // 文書の統計情報
{
public:
    void AddChars(xxxx); // 文字数
    void AddWords(xxxx); // 単語数
    void AddImages(xxxx); // 画像数
    ...

    void Display(); // 統計情報表示
};

class DocElement;
    class Paragraph;
    class RasterBitmap;

class DocElement
{
public:
    // DocElement が Paragraph だったら AddChars や AddWords を利用するし、
    // RasterBitmap だったら AddImages を利用して、統計をとる。
    virtual void UpdateStats(DocStats&amp; statistics) = 0;
};
</pre></div>
</div>
<p>いくつか欠点がある。</p>
<ul class="simple">
<li>&lt;<code class="docutils literal notranslate"><span class="pre">DocStats</span></code> を修正する度に、<code class="docutils literal notranslate"><span class="pre">DocElement</span></code> 階層全体を再コンパイルする必要がある&gt; (p. 251)</li>
<li>&lt;統計情報の収集を行う実際の処理が、<code class="docutils literal notranslate"><span class="pre">UpdateStats</span></code> の実装全体に散りばめられます&gt; (p. 251)</li>
<li>その他</li>
</ul>
<p>発想を変えて、<code class="docutils literal notranslate"><span class="pre">UpdateStats</span></code> を <code class="docutils literal notranslate"><span class="pre">DocStats</span></code> に移動させてみると、
&lt;今度は <code class="docutils literal notranslate"><span class="pre">DocStats</span></code> が、処理対象となる具体的な <code class="docutils literal notranslate"><span class="pre">DocElement</span></code> に依存することになります&gt; (p. 252)</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span><span class="o">.</span> <span class="mi">252</span> <span class="n">より引用一部略</span>
<span class="n">void</span> <span class="n">DocStats</span><span class="p">::</span><span class="n">UpdateStats</span><span class="p">(</span><span class="n">DocElement</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Paragraph</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">Paragraph</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Paragraph</span> <span class="n">の統計収集</span><span class="o">...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">RasterBitmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">RasterBitmap</span> <span class="n">の統計収集</span><span class="o">...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで Visitor の導入となる。まずはデザインパターンの教科書通りのインターフェイスを持つクラスを書いてみる。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// p. 253 より
// まず Visitor の抽象基底クラス
class DocElementVisitor
{
public:
    virtual void VisitParagraph(Paragraph&amp;) = 0;
    virtual void VisitRasterBitmap(RasterBitmap&amp;) = 0;
    ...
};

// DocElement::Visit を宣言。

class DocElement
{
public:
    virtual void Accept(DocElementVisitor&amp;) = 0;
    ...
};

void Paragraph::Accept(DocElementVisitor&amp; v)
{
    v.VisitParagraph(*this);
}
// RasterBitmap も同様。

// そして DocStats は DocElementVisitor を実装する。

class DocStats : public DocElementVisitor
{
    // ... VisitParagraph や VisitRasterBitmap を実装 ...
};
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">VisitXXXX</span></code> は <code class="docutils literal notranslate"><span class="pre">XXXX</span></code> の public な部分しかアクセスできない。</li>
<li>新たな操作を追加する場合、
<code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> から新たなクラスを導出するだけでよい。
p. 254 の <code class="docutils literal notranslate"><span class="pre">IncrementFontSize</span></code> の例を見るといい。</li>
</ul>
<hr class="docutils" />
<p>オーバーロードについて解説あり。</p>
<ul class="simple">
<li>各 <code class="docutils literal notranslate"><span class="pre">VisitXXXX</span></code> の関数名は単に <code class="docutils literal notranslate"><span class="pre">Visit</span></code> とすることができる。</li>
<li><code class="docutils literal notranslate"><span class="pre">DocElementVisitor::Visit(DocElement&amp;)</span></code> もアイディアとしてはアリ。</li>
</ul>
<hr class="docutils" />
<p>非循環式 Visitor という、魅惑的なタイトル。</p>
<ul>
<li><p class="first">&lt;<code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> の <code class="docutils literal notranslate"><span class="pre">VisitXxx</span></code> メンバ関数名にクラス名が埋め込まれるため、
<code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> のクラス定義をコンパイルする際には、
<code class="docutils literal notranslate"><span class="pre">DocElement</span></code> 階層に存在する全ての具体的なクラスに関する知識（少なくとも名前）が必要になります&gt; (p. 257)</p>
</li>
<li><p class="first">&lt;循環依存は、保守上のボトルネックになる&gt; (p. 257)</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">DocElement</span></code> 階層にサブクラスを追加するときに必要な作業を列挙している。
&lt;こういった作業は面倒くさい&gt; (p. 258)</p>
</li>
<li><p class="first">Robert Martin (1996) 考案による dynamic_cast を用いた変形 Visitor パターン。</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> に <code class="docutils literal notranslate"><span class="pre">VisitXxxx</span></code> を宣言しない。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">XxxxVisitor</span></code> は <code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> を継承しないで、
<code class="docutils literal notranslate"><span class="pre">VisitXxxx</span></code> を純粋仮想関数として宣言する。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">DocElement</span></code> のサブクラス <code class="docutils literal notranslate"><span class="pre">Xxxx::Accept</span></code> 関数にて、引数の <code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> を <code class="docutils literal notranslate"><span class="pre">XxxxVisitor</span></code> に dynamic_cast するテストを加える。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span><span class="o">.</span> <span class="mi">259</span> <span class="n">より引用</span>
<span class="n">void</span> <span class="n">Paragraph</span><span class="p">::</span><span class="n">Accept</span><span class="p">(</span><span class="n">DocElementVisitor</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ParagraphVisitor</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">ParagraphVisitor</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">VisitParagraph</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">具体的な Visitor クラスの定義は、例えば次のようになる。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// p. 260 より引用。
class DocStats :
    public DocElementVisitor,
    public ParagraphVisitor,
    public RasterBitmapVisitor
{
    ...

    // VisitXxxx をこのクラスで実装する。
    void VisitParagraph(Paragraph&amp;);
    void VisitRasterBitmap(RasterBitmap&amp;);
};
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">非循環式 Visitor パターンは循環依存をなくす代わりに、
&lt;<code class="docutils literal notranslate"><span class="pre">DocElement</span></code> をルートに持つ被訪問階層のクラス群と、具体的な被訪問クラス毎に対応する訪問クラス <code class="docutils literal notranslate"><span class="pre">XxxVisitor</span></code> 群という
2 つの並列したクラス群を保守しなければならなくなります&gt; (p. 261)</p>
</li>
<li><p class="first">&lt;高名な GoF の Ralph Gamma ですら、
Visitor がボトム 10 パターンの中のかなり下の方に位置付けられると言っているのです (Vlissides 1999)&gt;
(p. 262)</p>
</li>
</ul>
<hr class="docutils" />
<p>ここでジェネリック化の議論に入る。</p>
<ul class="simple">
<li>&lt;できるだけ多くのコードをライブラリに収納するようにするのです&gt; (p. 262)</li>
<li>最初に非循環式 Visitor を実装し、その後 &lt;標準とも言える&gt; (p. 262) GoF 版 Visitor を実装する流れ。</li>
</ul>
<p>非循環式。</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">BaseVisitor</span></code> - 先の例の <code class="docutils literal notranslate"><span class="pre">DocElementVisitor</span></code> と同じ。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Visitor</span></code> - <code class="docutils literal notranslate"><span class="pre">XxxxVisitor</span></code> 用。クラステンプレートとして宣言。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span><span class="o">.</span> <span class="mi">263</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">typename</span> <span class="n">R</span> <span class="o">=</span> <span class="n">void</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Visitor</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">typedef</span> <span class="n">R</span> <span class="n">ReturnType</span><span class="p">;</span>
    <span class="n">virtual</span> <span class="n">ReturnType</span> <span class="n">Visit</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">BaseVisitable</span></code> - <code class="docutils literal notranslate"><span class="pre">Accept</span></code> するクラスの基底クラスとして利用するためのクラステンプレート。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Visitor</span></code> 同様に <code class="docutils literal notranslate"><span class="pre">Accept</span></code> の戻り値がテンプレート引数になる。</li>
<li>ユーザーが <code class="docutils literal notranslate"><span class="pre">Accept</span></code> を実装をするための補助的なマクロ <code class="docutils literal notranslate"><span class="pre">DEFINE_VISITABLE()</span></code> と補助関数
<code class="docutils literal notranslate"><span class="pre">AcceptImpl(T&amp;,</span> <span class="pre">BaseVisitor&amp;)</span></code> を用意する。<ul>
<li>&lt;場合によっては <code class="docutils literal notranslate"><span class="pre">DEFINE_VISITABLE()</span></code> マクロを用いるのではなく、自分で <code class="docutils literal notranslate"><span class="pre">Accept</span></code> を実装する必要が出てくる&gt; (p. 268) が、問題ない。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>続いて循環式。dynamic_cast を用いないために高速に動作する。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">CyclicVisitor</span></code> ではタイプリストを利用する。<ul>
<li><code class="docutils literal notranslate"><span class="pre">GenScatterHierarchy&lt;TList,</span> <span class="pre">略&gt;</span></code> から継承する。</li>
<li><code class="docutils literal notranslate"><span class="pre">Visit</span></code> メンバ関数テンプレートは <code class="docutils literal notranslate"><span class="pre">Visitor</span></code> を用いて実装する。
<code class="docutils literal notranslate"><span class="pre">CyclicVisitor</span></code> は <code class="docutils literal notranslate"><span class="pre">TList</span></code> 中の各型 <code class="docutils literal notranslate"><span class="pre">T</span></code> について、クラス <code class="docutils literal notranslate"><span class="pre">Visitor&lt;T&gt;</span></code> の派生クラスであるからできる芸当。</li>
</ul>
</li>
<li>マクロ <code class="docutils literal notranslate"><span class="pre">DEFINE_CYCLIC_VISITABLE()</span></code> を提供する。</li>
</ul>
<p>循環式の場合、ユーザーコードが圧倒的に少なくて済むようだ。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">pp</span><span class="o">.</span> <span class="mi">270</span><span class="o">-</span><span class="mi">271</span> <span class="n">より引用</span>
<span class="n">typedef</span> <span class="n">CyclicVisitor</span>
<span class="o">&lt;</span>
    <span class="n">void</span><span class="p">,</span> <span class="o">//</span> <span class="n">戻り値</span>
    <span class="n">TYPELIST_3</span><span class="p">(</span><span class="n">DocElement</span><span class="p">,</span> <span class="n">Paragraph</span><span class="p">,</span> <span class="n">RasterBitmap</span><span class="p">)</span>
<span class="o">&gt;</span>
<span class="n">MyVisitor</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DocElement</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="n">void</span> <span class="n">Visit</span><span class="p">(</span><span class="n">MyVisitor</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Paragraph</span> <span class="p">:</span> <span class="n">public</span> <span class="n">DocElement</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">DEFINE_CYCLIC_VISITABLE</span><span class="p">(</span><span class="n">MyVisitor</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id7">第 11 章 マルチメソッド</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>マルチメソッドという用語は CLOS から借用した (p. 277)</li>
</ul>
<hr class="docutils" />
<p>C++ におけるポリモフィズムとは何かをまず考える。関数オーバーロード、関数テンプレートはともに静的なディスパッチメカニズムであり、仮想メンバ関数呼び出しは動的なディスパッチメカニズムであるとみなせる。</p>
<ul class="simple">
<li>&lt;<code class="docutils literal notranslate"><span class="pre">obj.Fun(引数群)</span></code> という呼び出しシンタックスでは、引数群よりも <code class="docutils literal notranslate"><span class="pre">obj</span></code> に優先的な役割が与えられているのです&gt; (p. 278)</li>
<li>マルチメソッド、多重ディスパッチとは
&lt;関数呼び出しに用いられているオブジェクト群の動的な型に依存して、異なった関数にディスパッチするようなメカニズム&gt; (p. 278) のこと。</li>
</ul>
<hr class="docutils" />
<p>マルチメソッドの必要性について論じる。ここでは <code class="docutils literal notranslate"><span class="pre">Shape</span></code> （のサブクラス）オブジェクト同士の交差部分処理という、
C++ プログラム開発経験者ならまず膝を叩く例が挙げられている。</p>
<p>手許に <code class="docutils literal notranslate"><span class="pre">Shape</span></code> への異なるポインターが 2 つあるとして、それをどのオーバーロードに適用するの？ という問題だ。</p>
<hr class="docutils" />
<p>最初に一番愚直と思われる方法、力任せに dynamic_cast テストをして、動的な型に見合うオーバーロード関数に引き渡すコードを示している。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// pp. 280-281 より一部抜粋（一部だけで雰囲気が思い出せるから）

void DoHatchArea1(Rectangle&amp;, Rectangle&amp;);
void DoHatchArea2(Rectangle&amp;, Ellipse&amp;);
void DoHatchArea3(Rectangle&amp;, Poly&amp;);
...

void DoubleDispatch(Shape&amp; lhs, Shape&amp; rhs)
{
    if(Rectangle* p1 = dynamic_cast&lt;Rectangle*&gt;(&amp;lhs))
    {
        if(Rectangle* p2 = dynamic_cast&lt;Rectangle*&gt;(&amp;rhs))
            DoHatchArea1(*p1, *p2);
        else if(Ellipse* p2 = dynamic_cast&lt;Ellipse*&gt;(&amp;rhs))
            DoHatchArea2(*p1, *p2);
        else if
            ...
    }
    else if
        ...
}
</pre></div>
</div>
<ul class="simple">
<li>問題点は明らか。<ul>
<li>&lt;この実装は、階層中に存在する全クラスを知っていなければならないのです&gt; (p. 281)</li>
<li>&lt;<code class="docutils literal notranslate"><span class="pre">if</span></code> ステートメントの順序が処理に影響を与えてしまう&gt; (p. 281) -
&lt;最も下位にあるクラスが最初に判定されるよう、
<code class="docutils literal notranslate"><span class="pre">if</span></code> の判定を「ソートする」&gt; (p. 282) ようでなければ問題が出る。</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>ここから本書らしいアプローチが始まる。先程の <code class="docutils literal notranslate"><span class="pre">DoubleDispatch</span></code> 相当のコードを、クラステンプレート <code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> とクラス <code class="docutils literal notranslate"><span class="pre">HatchingExecutor</span></code> に分割して、次のような構造で表現する。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// pp. 283-286 から断続的に引用。

template&lt; /* 略 */ &gt; // 本を読んで。
class StaticDispatcher
{
    typedef typename TypesLhs::Head Head;
    typedef typename TypesLhs::Tail Tail;
public:
    static ResultType Go(BaseLhs&amp; lhs, BaseRhs&amp; rhs, Executor exec)
    {
        if(Head* p1 = dynamic_cast&lt;Head*&gt;(&amp;lhs))
        {
            return StaticDispatcher&lt; NullType, /* 略 */ &gt;::DispatchRhs(*p1, rhs, exec);
        }
        else
        {
            return StaticDispatcher&lt; Tail, /* 略 */ &gt;::Go(/* 略 */);
        }
    }

    template &lt;class SomeLhs&gt;
    static ResultType DispatchRhs(SomeLhs&amp; lhs, BaseRhs&amp; rhs, Executor exec)
    {
        // ここで Head, Tail に対する typedef を「上書き」する。

        if(Head* p2 = dynamic_cast&lt;Head*&gt;(&amp;rhs))
        {
            return exec.Fire(lhs, *p2)
        }
        else
        {
            return StaticDispatcher&lt;NullType, Tail, /* 略 */&gt;::DispatchRhs(/* 略 */);
        }
    }
};

// TODO: StaticDispatcher の部分特殊化 1: TypeLhs = NullType で
// ダミーの static メソッド Go を実装する。

// TODO: StaticDispatcher の部分特殊化 2: TypeRhs = NullType で
// ダミーの static メソッド DispatchRhs を実装する。

class HatchingExecutor
{
public:
    void Fire(Rectangle&amp;, Rectangle&amp;);
    void Fire(Rectangle&amp;, Ellipse&amp;);
    ...

    void OnError(Shape&amp;, Shape&amp;);
};
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Go</span></code> から <code class="docutils literal notranslate"><span class="pre">Go</span></code> を呼び出す様子は再帰呼び出しに見えるかもしれないが、
<code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> の別な実体化の同名メソッドを呼び出している。
<code class="docutils literal notranslate"><span class="pre">DispatchRhs</span></code> も同様。</li>
<li>&lt;結果的に、<code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> は、
2 つのタイプリストと特定のコードから指数に比例した分量のコードを生成するわけです。（略）つまり、大きなコードによってコンパイル時間、プログラム・サイズ、実行時間の全てに打撃が与えられるのです&gt; (p. 284)</li>
<li>&lt;<code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> は境界条件が発生した場合、元々の（キャストしない） <code class="docutils literal notranslate"><span class="pre">lhs</span></code> と <code class="docutils literal notranslate"><span class="pre">rhs</span></code> を用いて単に
<code class="docutils literal notranslate"><span class="pre">Executor::OnError</span></code> を呼び出します&gt; (p. 286)</li>
</ul>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>// p. 286 より。
typedef StaticDispatcher&lt;HatchingExecutor, Shape,
    TYPELIST_3(Rectangle, Ellipse, Poly)&gt; Dispatcher;

Shape* p1 = ...;
Shape* p2 = ...;
HatchingExecutor exec;
Dispatcher::Go(*p1, *p2, exec);
</pre></div>
</div>
<ul class="simple">
<li>タイプリストに記述するクラスの順序に注意。先程と同様の注意が要る。
&lt;継承階層で最も下位にあるものをタイプリストの先頭に持ってくることです&gt; (p. 287)</li>
</ul>
<hr class="docutils" />
<p>次に引数の順序を意識せずに済むように改造していく。対称型マルチメソッド。
<code class="docutils literal notranslate"><span class="pre">BaseLhs</span></code> と <code class="docutils literal notranslate"><span class="pre">BaseRhs</span></code> が同一型かつ
<code class="docutils literal notranslate"><span class="pre">TypesLhs</span></code> と <code class="docutils literal notranslate"><span class="pre">TypesRhs</span></code> が同一型の場合に意味がある。</p>
<ul>
<li><p class="first">&lt;理想的には、追加の <code class="docutils literal notranslate"><span class="pre">bool</span></code> テンプレート・パラメータを <code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> に引き渡して、対称性が選択できるようにするべきでしょう&gt; (p. 289)</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">StaticDispatcher</span></code> に <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">symmetric</span></code> テンプレート引数を追加する。</p>
</li>
<li><p class="first">クラス内の private 部分にクラステンプレート <code class="docutils literal notranslate"><span class="pre">InvocationTraits</span></code> を定義する。これは static メンバー関数 <code class="docutils literal notranslate"><span class="pre">DoDispatch</span></code> だけを含む構造体。</p>
<p><code class="docutils literal notranslate"><span class="pre">DoDispatch</span></code> の内容は単に <code class="docutils literal notranslate"><span class="pre">exec.Fire(lhs,</span> <span class="pre">rhs);</span></code> のみ。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">InvocationTraits</span></code> の部分特殊化版を定義し、そちらの
<code class="docutils literal notranslate"><span class="pre">DoDispatch</span></code> の内容は <code class="docutils literal notranslate"><span class="pre">exec.Fire(rhs,</span> <span class="pre">lhs);</span></code> とする。</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">StaticDispatcher::DispatchRhs</span></code> の定義で、if ブロック内をこのようにする。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">p</span><span class="o">.</span> <span class="mi">291</span> <span class="n">より引用</span>
<span class="n">enum</span> <span class="p">{</span> <span class="n">swapArgs</span> <span class="o">=</span> <span class="n">symmetric</span> <span class="o">&amp;&amp;</span>
    <span class="n">IndexOf</span><span class="o">&lt;</span><span class="n">Head</span><span class="p">,</span> <span class="n">TypeRhs</span><span class="o">&gt;</span><span class="p">::</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">IndexOf</span><span class="o">&lt;</span><span class="n">BaseLhs</span><span class="p">,</span> <span class="n">TypesLhs</span><span class="o">&gt;</span><span class="p">::</span><span class="n">result</span> <span class="p">};</span>
<span class="n">typedef</span> <span class="n">InvocationTraits</span><span class="o">&lt;</span><span class="n">swapArgs</span><span class="p">,</span> <span class="n">BaseLhs</span><span class="p">,</span> <span class="n">Head</span><span class="o">&gt;</span>
    <span class="n">CallTraits</span><span class="p">;</span>
<span class="k">return</span> <span class="n">CallTraits</span><span class="p">::</span><span class="n">DoDispatch</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>型リストから型を探索する効率を対数時間に持っていこうとするのか。</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">std::type_info::before</span></code> によって &lt;プログラム中における全ての型に対する順序関係が提供されるのです&gt; (p. 291)</p>
</li>
<li><p class="first">第 2 章で紹介されたラッパークラス <code class="docutils literal notranslate"><span class="pre">TypeInfo</span></code> を利用する。
&lt;<code class="docutils literal notranslate"><span class="pre">TypeInfo</span></code> は、値のセマンティックスと演算子 <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code> を提供しています。このため、標準コンテナに <code class="docutils literal notranslate"><span class="pre">TypeInfo</span></code> オブジェクトを格納することができるのです&gt; (p. 292)</p>
</li>
<li><p class="first">&lt;特に、ソート済みベクタと二分探索アルゴリズムを組み合わせれば、連想コンテナよりも空間的および時間的に優れたものとなる場合もあるのです。これは、挿入頻度よりもアクセス頻度の方が多い場合に起こり得ます&gt; (p. 292)</p>
<p>つまり、コンテナ内容がある時点から固定されるような場合は連想コンテナを採用しないように、か。</p>
</li>
<li><p class="first">ただし、便宜的に両者のデータ構造を共に「マップ」と呼ぶことにする。(p. 293)</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">BasicDispatcher</span></code></p>
<ul>
<li><p class="first">最終的なディスパッチ先の関数の引数 <code class="docutils literal notranslate"><span class="pre">(lhs,</span> <span class="pre">rhs)</span></code> ペアの型を <code class="docutils literal notranslate"><span class="pre">std::pair&lt;TypeInfo,</span> <span class="pre">TypeInfo&gt;</span></code> で表現する。</p>
</li>
<li><p class="first">上記のペア型をキー型とし、
<code class="docutils literal notranslate"><span class="pre">ResultType</span> <span class="pre">(*)(BaseLhs&amp;,</span> <span class="pre">BaseRhs&amp;)</span></code> 型の関数ポインタを値型とするマップを定義する。</p>
</li>
<li><p class="first">そのマップオブジェクトをメンバーデータに持つ。</p>
</li>
<li><p class="first">テンプレートメンバー関数 <code class="docutils literal notranslate"><span class="pre">Add</span></code> を定義し、マップに関数ポインタを動的に追加できるようにする。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Go</span></code> は次のようになる。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ResultType</span> <span class="n">Go</span><span class="p">(</span><span class="n">BaseLhs</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">BaseRhs</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MapType</span><span class="p">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">callbackMap_</span><span class="o">.</span><span class="n">find</span><span class="p">(</span>
        <span class="n">KeyType</span><span class="p">(</span><span class="n">typeid</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">typeid</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">callbackMap_</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="o">...</span> <span class="n">例外送出</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;継承とともに用いると正しく動作しません&gt; (p. 294)</p>
</li>
<li><p class="first">&lt;<code class="docutils literal notranslate"><span class="pre">BasicDispatcher</span></code> に対して、全てのペアを注意深く登録していかなければならないのです&gt; (p. 295)</p>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>次に <code class="docutils literal notranslate"><span class="pre">BasicDispatcher</span></code> を利用して <code class="docutils literal notranslate"><span class="pre">FnDispatcher</span></code> を定義するのだが、もうついていけないのでスキップ。</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">Trampoline</span></code> という面白い技法を利用してディスパッチを実現する。</p>
</div>
<hr class="docutils" />
<ul class="simple">
<li>&lt;値のセマンティックスは実行時のポリモフィズムとうまく調和できない&gt; (p. 299)</li>
</ul>
<hr class="docutils" />
<p>static_cast or dynamic_cast という問題。これまでは dynamic_cast 一丁で押し通してきた理由を解説。</p>
<ul class="simple">
<li>仮想継承を伴なうダイアモンド型クラス階層が対象となるとき、
&lt;仮想基底オブジェクトから導出した型へは static_cast することができない&gt; (p. 302)</li>
<li>仮想継承を伴わないダイアモンド型クラス階層が対象となるとき、基底クラスが曖昧になるケースがある。</li>
</ul>
<hr class="docutils" />
<p>&lt;多重ディスパッチと C++ において、特にいやらしかった問題は、可変引数関数を表現する統一した方法が存在しないということだったのです&gt; (p. 312)</p>
</div>
<div class="section" id="a">
<h2><a class="toc-backref" href="#id8">付録 A 最小限のマルチスレッド・ライブラリ</a><a class="headerlink" href="#a" title="Permalink to this headline">¶</a></h2>
<p>C++ に関する書籍は、マルチスレッドをテーマにした文章が付録になる傾向がある。本書もその例に漏れない。</p>
<ul class="simple">
<li>&lt;ユーザは砂時計のカーソルが表示されることを望んでいないため、プログラマはマルチスレッド・プログラムを記述しなければならないのです&gt; (p. 317)</li>
<li>&lt;ライブラリもスレッドを考慮する必要があります。こういった機能は、ライブラリが自身のスレッドを用いていない場合であっても、組み込んでおかなければならないのです&gt; (p. 317)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;マルチスレッドがシングルプロセッサ・マシンでも必要となる理由は、リソースを効果的に使用できるという点があるからです&gt; (p. 318)</li>
<li>&lt;これらは物理的に独立した機器であるため、同時にリソースを使用することができるのです&gt; (p. 318)</li>
<li>&lt;非同期実行は、マルチスレッドの実行と比較すると状態遷移の多いプログラムになるという欠点があります&gt; (p. 318)</li>
<li>&lt;アトミックな操作だと思っていたものがそうではなくなってしまう&gt; (p. 318)</li>
<li>&lt;マルチスレッドのプログラムは、リソースの共有に大きな問題を抱えている&gt; (p. 319)</li>
<li>マルチスレッドプログラミングにおける重要な技法のひとつに、同期化オブジェクトがある。</li>
</ul>
<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">++x</span></code> というステートメントに関する考察を始める。</p>
<ul class="simple">
<li>こういう (read-modify-write) 操作を RMW 操作と呼ぶ (p. 320)</li>
<li>マルチプロセッサ環境では、あるプロセッサが変数を更新している間にも、別のプロセッサがメモリにアクセスできる。</li>
<li>&lt;どちらのプロセッサ（スレッド）も、インクリメントができなかったことを検出できない&gt; (p. 320)</li>
<li>通常、アトミックなインクリメント・デクリメント操作は OS が C 関数の形式でサポートしている。</li>
</ul>
<p>ライブラリでアトミック演算をまとめるようだ。</p>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span>template &lt;typename T&gt;
class SomeThreadingModel
{
public:
    typedef int IntType; // int にはプラットフォーム規定整数型名がくる。

    static IntType AtomicAdd(volatile IntType&amp; lval, IntType val);
    ...
};
</pre></div>
</div>
<ul class="simple">
<li>&lt;コピー操作でさえも非アトミックな場合があるため、
<code class="docutils literal notranslate"><span class="pre">AtomicAssign</span></code> 関数も 2 つ必要となるわけです&gt; (p. 321)</li>
</ul>
<hr class="docutils" />
<p>ミューテックスの話題。</p>
<ul>
<li><p class="first">&lt;マルチスレッド環境下におけるオペレーティング・システムのスケジューラは、ある種の同期化オブジェクトを提供しなければならないということが、
Edgar Dijkstra によって証明されています。マルチスレッド・アプリケーションを正しく記述するためには、こういったものが必要不可欠なのです&gt; (p. 321)</p>
<p>とても重要。丸暗記しよう。</p>
</li>
<li><p class="first">&lt;ミューテックス (mutex) とは、相互排他 (Mutual Exclusive) の略であり、同期化用のプリミティブ・オブジェクトの機能を解説するための用語です&gt; (p. 321)</p>
</li>
<li><p class="first">&lt;たった 1 つのスレッドのみがミューテックスを獲得できるのです&gt; (p. 322)</p>
<p>獲得は <code class="docutils literal notranslate"><span class="pre">Acquire</span></code> で、解放は <code class="docutils literal notranslate"><span class="pre">Release</span></code> か。</p>
</li>
<li><p class="first">コード中の <code class="docutils literal notranslate"><span class="pre">mtx.Acquire()</span></code> 呼び出しと <code class="docutils literal notranslate"><span class="pre">mtx.Release()</span></code> 呼び出しで囲まれた部分が、
<code class="docutils literal notranslate"><span class="pre">mtx</span></code> オブジェクトに関してアトミックとなる。</p>
<p>これを利用して &lt;スレッド間で共有させたいリソース毎にミューテックス・オブジェクトを
1 つ割り当てることになります&gt; (p. 322)</p>
</li>
<li><p class="first">マルチスレッドプログラミングの教科書にありがちな「銀行口座クラスの預金引き出しメソッド実装例」コードあり。</p>
<ul class="simple">
<li>&lt;<code class="docutils literal notranslate"><span class="pre">Lock</span></code> オブジェクトをスタック上に割り当てておけば、例外発生の有無とは関係なく、
<code class="docutils literal notranslate"><span class="pre">Acquire</span></code> と <code class="docutils literal notranslate"><span class="pre">Release</span></code> のペアが正しく実行される&gt; (p. 323)</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;オブジェクト指向プログラムでは、リソースはオブジェクトになります&gt; (p. 323)</li>
<li>オブジェクト・レベルのロックと、クラス・レベルのロックがある。</li>
</ul>
<div class="code c++ highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Host</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ObjectLevelLockable</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Lock</span>
    <span class="p">{</span>
    <span class="n">public</span><span class="p">:</span>
        <span class="n">Lock</span><span class="p">(</span><span class="n">Host</span><span class="o">&amp;</span><span class="p">);</span>
        <span class="o">...</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BankAccount</span> <span class="p">:</span> <span class="n">public</span> <span class="n">ObjectLevelLockable</span><span class="o">&lt;</span><span class="n">BankAccount</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="o">...</span>

    <span class="n">void</span> <span class="n">Deposite</span><span class="p">(</span><span class="o">/*</span> <span class="n">略</span> <span class="o">*/</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Lock</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
        <span class="o">//</span> <span class="o">...</span> <span class="n">入金トランザクション</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>&lt;<code class="docutils literal notranslate"><span class="pre">volatile</span></code> の指定によってコンパイラはある種の最適化を抑止するため、シングルスレッド・モデルでは指定するべきではないのです&gt; (p. 325)</p>
<hr class="docutils" />
<p>&lt;ポータブルなマルチスレッド・ライブラリとして ACE
(Adaptive Communication Environment) を調査することをお勧めします (Schmidt 2000)&gt; (p. 326)</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">感想</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>一周読むのに鉛筆片手に 10 時間、このノートをとるのに 13 時間近く要した。これまで読んできた C++ 関連書籍中「初心者にお勧めできない」度ナンバーワンは間違いなく本書だ。</li>
<li>コーディング・コンパイル・動作確認を一切しないという不埒な読書姿勢。</li>
<li>理解度もかなり低いだろう。</li>
</ul>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../meyers01.html" title="Effective STL 読書ノート"
             >next</a></li>
        <li class="right" >
          <a href="note2.html" title="Modern C++ Design 読書ノート 2/3"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Modern C++ Design 読書ノート</a> &#187;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2018, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>