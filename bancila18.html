
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Modern C++ チャレンジ 読書ノート &#8212; 読書ノート v1.5dev</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/prefab.css" />
    
    <script src="_static/mathjax-v3.js"></script>
    
    <link rel="next" title="Eloquent JavaScript 読書ノート" href="haverbeke18/index.html" />
    <link rel="prev" title="Effective Debugging 読書ノート" href="speinellis17.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="haverbeke18/index.html" title="Eloquent JavaScript 読書ノート"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="speinellis17.html" title="Effective Debugging 読書ノート"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Modern C++ チャレンジ 読書ノート</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="modern-c">
<h1><a class="toc-backref" href="#id17">Modern C++ チャレンジ 読書ノート</a><a class="headerlink" href="#modern-c" title="Permalink to this headline">¶</a></h1>
<p>〈C++17 プログラミング力を鍛える 100 問〉ということなので読み進める。</p>
<dl class="field-list simple">
<dt class="field-odd">著者</dt>
<dd class="field-odd"><p>Marius Bancila</p>
</dd>
<dt class="field-even">訳者</dt>
<dd class="field-even"><p>黒川利明</p>
</dd>
<dt class="field-odd">技術監修</dt>
<dd class="field-odd"><p>島敏博</p>
</dd>
<dt class="field-even">出版社</dt>
<dd class="field-even"><p>オライリー・ジャパン</p>
</dd>
<dt class="field-odd">発行年</dt>
<dd class="field-odd"><p>2019 年</p>
</dd>
<dt class="field-even">ISBN</dt>
<dd class="field-even"><p>978-4-87311-869-7</p>
</dd>
</dl>
<div class="contents topic" id="id1">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#modern-c" id="id17">Modern C++ チャレンジ 読書ノート</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id18">まえがき</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id19">1 章 数学の問題</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id20">2 章 言語機能</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id21">3 章 文字列と正規表現</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id22">4 章 ストリームとファイルシステム</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id23">5 章 日付と時間</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id24">6 章 アルゴリズムとデータ構造</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id25">7 章 並行処理</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id26">8 章 デザインパターン</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id27">9 章 データシリアライゼーション</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id28">10 章 アーカイブ、画像、データベース</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id29">11 章 暗号</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id30">12 章 ネットワークとサービス</a></p></li>
<li><p><a class="reference internal" href="#a" id="id31">付録 A 参考文献</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id32">訳者あとがき</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id33">追加的作業</a></p>
<ul>
<li><p><a class="reference internal" href="#cmakelists-txt" id="id34"><code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> を検証する</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="id2">
<h2><a class="toc-backref" href="#id18">まえがき</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>〈本書は、C++ 言語および標準ライブラリの機能だけでなく、多くのサードパーティのクロスプラットフォームのライブラリを練習できるように設計された実世界の問題を
100 問集めたものです。しかし、これらの問題で C++ 特有なのはわずかで、他のプログラミング言語でも解けるものです〉このことをよく覚えておくことだ。</p>
<p>〈本書の問題の回答のコードファイルは、GitHub と Packt のサポートページ（登録が必要）から入手できます〉とあり、前者の URL は次のようになっている：</p>
<p><a class="reference external" href="https://github.com/PacktPublishing/The-Modern-Cpp-Challenge">https://github.com/PacktPublishing/The-Modern-Cpp-Challenge</a></p>
<p>ここで、上記リポジトリーをローカルディスクに clone して、ソースコードにコメントを付けていくスタイルで学習労力を省略化することにする。こうすると、どういうわけか本書が手許にないときでも学習を止めずに済む。</p>
<p>さらに、これらの問題の答案コードごとにすべてビルドすることにする。その過程で C++ 開発力のようなものも鍛えることを期待する。事実、かなり勉強させられた。</p>
<p>〈本書の解答全てがクロスプラットフォームですので、どのプラットフォームでも動作します〉とある。私は WSL 環境でビルドをしていく。</p>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id19">1 章 数学の問題</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>全体的に <code class="docutils literal notranslate"><span class="pre">auto</span></code>, <code class="docutils literal notranslate"><span class="pre">decltype</span></code>, <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>, <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> を付加する余地がある関数が多い。例えば解答 4 の関数 <code class="docutils literal notranslate"><span class="pre">is_prime</span></code> は <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> の他に <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> も付加できる。</p>
<ul class="simple">
<li><p>大きな上限まで加算するために <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> を使う (p. 3)</p></li>
<li><p>解答 1 の <code class="docutils literal notranslate"><span class="pre">for</span></code> ループのカウンター宣言に <code class="docutils literal notranslate"><span class="pre">decltype(limit)</span></code> としたい。</p></li>
<li><p>C++17 には <code class="docutils literal notranslate"><span class="pre">&lt;numeric&gt;</span></code> に <code class="docutils literal notranslate"><span class="pre">std::gcd()</span></code> がある (p. 4)</p></li>
<li><p>解答 2 の自作関数は <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 宣言できる。</p></li>
<li><p>C++17 には <code class="docutils literal notranslate"><span class="pre">&lt;numeric&gt;</span></code> に <code class="docutils literal notranslate"><span class="pre">std::lcm()</span></code> がある (p. 5)</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIt</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lcmr</span><span class="p">(</span><span class="n">InputIt</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">InputIt</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// C++ 17 では &lt;numeric&gt; に std::lcm() がある (p. 5) が、</span>
<span class="w">    </span><span class="c1">// 次のようにテンプレート引数を明示しないと g++ 9.3.0 はエラーを出す。</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">IntType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span> <span class="nc">InputIt</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">lcm</span><span class="o">&lt;</span><span class="n">IntType</span><span class="p">,</span><span class="w"> </span><span class="n">IntType</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul>
<li><p>C++17 ならば <code class="docutils literal notranslate"><span class="pre">if</span></code> 文の変数スコープも細かく直そうと思えば直せる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_proper_divisors</span><span class="p">(</span><span class="n">number</span><span class="p">);</span><span class="w"> </span><span class="n">sum1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// code</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>解答 8 でラムダ式登場。</p></li>
<li><p>解答 8 のクラステンプレート <code class="docutils literal notranslate"><span class="pre">perf_timer</span></code> は難しい要素が多い。
<code class="docutils literal notranslate"><span class="pre">std::invoke()</span></code> を使うには <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> をインクルードする必要がある。</p></li>
<li><p>本書では修正されているところが多いが <code class="docutils literal notranslate"><span class="pre">cbegin()</span></code>, <code class="docutils literal notranslate"><span class="pre">cend()</span></code> が使えるアルゴリズム呼び出しが多い。</p></li>
<li><p>解答 9 改変例</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">prime_factors</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// code</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>解答 10 で範囲 <code class="docutils literal notranslate"><span class="pre">for</span></code> 文初登場。</p></li>
<li><p>解答 12 のコードを私が書き直すと <code class="docutils literal notranslate"><span class="pre">decltype(limit)</span></code> があちこちに出る。これは良くなるか？</p></li>
<li><p>解答 13 で乱数登場。</p></li>
<li><p>地味なので <code class="docutils literal notranslate"><span class="pre">std::ref()</span></code> は付け忘れそうだ。</p></li>
</ul>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id20">2 章 言語機能</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>可能な限り <code class="docutils literal notranslate"><span class="pre">begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">end()</span></code> を <code class="docutils literal notranslate"><span class="pre">cbegin()</span></code>, <code class="docutils literal notranslate"><span class="pre">cend()</span></code> にそれぞれ置き換える。</p>
<ul>
<li><p>クラステンプレート <code class="docutils literal notranslate"><span class="pre">std::array</span></code> を利用できないか意識する。</p>
<ul class="simple">
<li><p>この配列型は要素次第の型次第でコンストラクターやコピー操作が <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> に指定できる。</p></li>
</ul>
</li>
<li><p>コンストラクターに対しても <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> をできないか意識する。</p></li>
<li><p>コンストラクター呼び出しは中括弧のほうが利用頻度が高くなりそうだ。</p></li>
<li><p>解答 17 はいろいろと加筆できる。例えば <code class="docutils literal notranslate"><span class="pre">cbegin()</span></code>, <code class="docutils literal notranslate"><span class="pre">cend()</span></code> を実装するとか。
<code class="docutils literal notranslate"><span class="pre">main()</span></code> の最後で <code class="docutils literal notranslate"><span class="pre">std::copy()</span></code> を呼び出すところでこれらを利用したい。</p></li>
<li><p>解答 18 でパラメーターパックが出る。ちなみに <code class="docutils literal notranslate"><span class="pre">std::min()</span></code> が本問の要求の本質的に満たす：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;&gt;</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>解答 19 では畳み込みを習う。このコードは覚えにくい。</p>
<ul class="simple">
<li><p>実際には <code class="docutils literal notranslate"><span class="pre">.insert()</span></code> を使うといい？</p></li>
</ul>
</li>
<li><p>解答 20 でも畳み込み。短絡評価が効くことを覚えておくこと。</p>
<ul class="simple">
<li><p>パラメーターパックと組み合わさった <code class="docutils literal notranslate"><span class="pre">T&amp;&amp;</span></code> に注意。特に <code class="docutils literal notranslate"><span class="pre">contains_none()</span></code> の実装で <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> が出てくることを意識する。</p></li>
</ul>
</li>
<li><p>解答 21 は Windows 専用のように見えるが WSL でも実行はできる。というか、ダミーの <code class="docutils literal notranslate"><span class="pre">if</span></code> 文によりドライバー関数が終了する。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code> のために <code class="docutils literal notranslate"><span class="pre">&lt;stdexcept&gt;</span></code> をインクルードする。</p></li>
<li><p>RAII クラスではコンパイラーが生成するデフォルトコンストラクターとコピー代入演算子を禁止するのがよい。</p></li>
<li><p>メンバー関数 <code class="docutils literal notranslate"><span class="pre">release()</span></code> で <code class="docutils literal notranslate"><span class="pre">std::exchange()</span></code> が使えそうだ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::vector&lt;char&gt;</span> <span class="pre">buffer(1024)</span></code> を <code class="docutils literal notranslate"><span class="pre">std::array&lt;char,</span> <span class="pre">1024&gt;</span></code> に置き換えることもできる。</p></li>
</ul>
</li>
<li><p>解答 22 でリテラル演算子の定義を学べる。このコードの関数群は特に <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> を付けられるものが多い。</p></li>
</ul>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id21">3 章 文字列と正規表現</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> を使いこなせるようにすること。関数の引数リストに書くときには値渡しとする？</p></li>
<li><p>解答 25 の冒頭は別名テンプレートという機能か。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std::string_literals;</span></code> と宣言する。これによりリテラル文字列の suffix に <code class="docutils literal notranslate"><span class="pre">s</span></code> を付けると <code class="docutils literal notranslate"><span class="pre">std::basic_string</span></code> オブジェクトであるとして扱われる。</p></li>
<li><p>解答 27 で関数が <code class="docutils literal notranslate"><span class="pre">inline</span></code> 宣言されているが、これは特に深い意味はなさそうだ。</p></li>
<li><p>解答 28 の関数 <code class="docutils literal notranslate"><span class="pre">longest_palindrome</span></code> の最後で
<code class="docutils literal notranslate"><span class="pre">std::string</span></code> のコンストラクターが必要な理由はオブジェクト <code class="docutils literal notranslate"><span class="pre">str.substr()</span></code> がビューだからだ。この関数の戻り値を変えれば、あるいは……。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decltype(x)</span></code> で <code class="docutils literal notranslate"><span class="pre">x</span></code> から cv を外したい場合はどうするか？</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::regex</span></code> を使いこなせるようにすること。Python とほとんど変わらない感覚で書けるか。</p></li>
<li><p>C++ の生文字列は若干タイプしづらい。ダブルクォーテーションの隣に丸括弧が必要だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(*i)[1].matched</span></code> みたいな書き方しかできないか？</p></li>
<li><p>解答 30 で <code class="docutils literal notranslate"><span class="pre">parse_uri()</span></code> の引数を <code class="docutils literal notranslate"><span class="pre">std::string</span></code> から <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> に置き換えることを考える。そのとき次が必要：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">std::smatch</span></code> を <code class="docutils literal notranslate"><span class="pre">std::cmatch</span></code> に変える。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::regex_match()</span></code> へ渡す実引数 <code class="docutils literal notranslate"><span class="pre">uri</span></code> を <code class="docutils literal notranslate"><span class="pre">uri.data()</span></code> に変える。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::stoi()</span></code> 系の関数を使いこなせるようにすること。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">{}</span></code></p></li>
</ul>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id22">4 章 ストリームとファイルシステム</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>解答 32 の Pascal の三角形。ストリーム要素もファイルシステム要素も目新しさはない。</p></li>
<li><p>解答 33 を見て思う。<code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> は文字列表示機能がないのか。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::filesystem</span></code> は新しいライブラリーだ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::uintmax_t</span></code> なる型が <code class="docutils literal notranslate"><span class="pre">&lt;numeric&gt;</span></code> に定義されている。</p></li>
<li><p>解答 36 ファイル更新時刻を取り扱う。</p>
<ul>
<li><p>ファイルの最終更新時刻を取得するのは <code class="docutils literal notranslate"><span class="pre">std::filesystem::last_write_time()</span></code></p></li>
<li><p>現在の時刻を取得するのは <code class="docutils literal notranslate"><span class="pre">std::chrono::system_clock::now()</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::filesystem::recursive_directory_iterator()</span></code> のパスをたどる基準のようなものは？</p></li>
<li><p>WSL 環境では、解答 38 をコンパイルするのに <code class="docutils literal notranslate"><span class="pre">apt</span> <span class="pre">install</span> <span class="pre">uuid-dev</span></code> を必要とする。さらに <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> が宣言されていないとエラーが出るはずなので、
<code class="docutils literal notranslate"><span class="pre">uuid.h</span></code> をインクルードする前に <code class="docutils literal notranslate"><span class="pre">&lt;cstring&gt;</span></code> をインクルードする必要がある。</p></li>
<li><p>解答 38 の <code class="docutils literal notranslate"><span class="pre">logger::~logger()</span></code> は例外を握りつぶしているマナーの悪いコードに見えるかもしれないが、妥当だ。</p></li>
</ul>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id23">5 章 日付と時間</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">std::invoke()</span></code> を使うのなら <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> をインクルードする必要がある。</p></li>
<li><p>解答 39 のクラステンプレート <code class="docutils literal notranslate"><span class="pre">perf_timer</span></code> で完全転送の使い方を学ぶ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::this_thread::sleep_for()</span></code></p></li>
<li><p>解答 40, 41 で使っているライブラリー</p>
<ul class="simple">
<li><p>丸括弧キャストを <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> に書き換え可能</p></li>
</ul>
</li>
<li><p>解答 43 は curlcpp をリンクする必要がある。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bash$ ./build/problem_43</span>
<span class="go">Hour:23</span>
<span class="go">Minutes:16</span>
<span class="go">Local time:    2020-12-28 23:16:00 JST</span>
<span class="go">Ildiko         2020-12-28 15:16:00 CET</span>
<span class="go">Jens           2020-12-28 15:16:00 CET</span>
<span class="go">Jane           2020-12-28 09:16:00 EST</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id8">
<h2><a class="toc-backref" href="#id24">6 章 アルゴリズムとデータ構造</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>この章で扱う標準アルゴリズムは反復子を入れ替えるものが多いことに注意する。それでもなお、GitHub のコードには <code class="docutils literal notranslate"><span class="pre">cbegin()</span></code>, <code class="docutils literal notranslate"><span class="pre">cend()</span></code> で置き換える余地のあるものが残されている。</p>
<p>ラムダ式を grep するのがたいへん難しい。けっこう困る。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::push_heap()</span></code>, <code class="docutils literal notranslate"><span class="pre">std::pop_heap()</span></code> には <code class="docutils literal notranslate"><span class="pre">cbegin()</span></code>, <code class="docutils literal notranslate"><span class="pre">cend()</span></code> を渡せないことは理解している。</p></li>
<li><p>解答 45 <code class="docutils literal notranslate"><span class="pre">.top()</span></code> も <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> のはず。</p></li>
<li><p>ここのフリー関数テンプレート <code class="docutils literal notranslate"><span class="pre">swap()</span></code> の <code class="docutils literal notranslate"><span class="pre">noexcept()</span></code> の付け方をよく理解すること。</p></li>
<li><p>解答 46 のリングバッファーの反復子のカテゴリーをランダムアクセス反復子とするのは違和感がある。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pop()</span></code> が値を返すのは微妙な設計なのではなかったか。</p></li>
<li><p>解答 47 のダブルバッファー実装は理屈だけでも理解しておくこと。特に、<code class="docutils literal notranslate"><span class="pre">mutex</span></code> の使い方は基本的なので外さないこと。</p></li>
<li><p>解答 53 の <code class="docutils literal notranslate"><span class="pre">truncated_mean()</span></code> の途中で <code class="docutils literal notranslate"><span class="pre">rbegin()</span></code> も使える。</p></li>
<li><p>そういえばラムダ式の引数リストの型には <code class="docutils literal notranslate"><span class="pre">auto</span></code> が許されるのか。</p></li>
<li><p>解答 56 の最初の <code class="docutils literal notranslate"><span class="pre">select()</span></code> は難しい。</p></li>
<li><p>解答 57 の <code class="docutils literal notranslate"><span class="pre">print()</span></code> はランダムアクセス反復子である必要はまったくなく、
<code class="docutils literal notranslate"><span class="pre">++</span></code> さえ機能する反復子なら十分だ。</p></li>
<li><p>解答 58 は Boost.Graph の <code class="docutils literal notranslate"><span class="pre">dijkstra_shortest_path()</span></code> のようなものを作る。</p></li>
<li><p>解答 59 のラムダ式、先述のとおり <code class="docutils literal notranslate"><span class="pre">auto</span></code> と書ける。以下同様。</p></li>
<li><p>解答 60 の <code class="docutils literal notranslate"><span class="pre">cell()</span></code> は <code class="docutils literal notranslate"><span class="pre">const</span></code> 版も欲しい。そうすることでいくつかのメンバー関数も <code class="docutils literal notranslate"><span class="pre">const</span></code> にできる。</p></li>
</ul>
</section>
<section id="id9">
<h2><a class="toc-backref" href="#id25">7 章 並行処理</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>この章の問題はすでに標準ライブラリーが提供している機能を求めるものがある。その確認も行うこと。</p>
<p>WSL でビルドする場合には、コンパイルオプション <code class="docutils literal notranslate"><span class="pre">-pthread</span></code> を追加することが必要となる。</p>
<ul class="simple">
<li><p>解答 61 にも <code class="docutils literal notranslate"><span class="pre">std::forward()</span></code> の用例がある。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::transform()</span></code> の第一範囲は const_iterator を指定するのが丁寧だ。</p></li>
<li><p>解答 62 のスレッドのコンテナに <code class="docutils literal notranslate"><span class="pre">.emplace_back()</span></code> でラムダ式を追加している。キャプチャーリストに注意。</p></li>
<li><p>解答 63 は <code class="docutils literal notranslate"><span class="pre">std::future</span></code> のコンテナを取り扱う。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">typename</span> <span class="pre">std::iterator_traits&lt;Iterator&gt;::value_type</span></code> が二度出てくる。
<code class="docutils literal notranslate"><span class="pre">using</span></code> で別名を定義するべきだろう。</p></li>
</ul>
</li>
<li><p>解答 64 は解答 57 の変種。クイックソートは並列化のいい練習問題だ。</p></li>
<li><p>これまでも何度か目にしたが <code class="docutils literal notranslate"><span class="pre">std::generate()</span></code> 系アルゴリズムの応用がうまい。</p></li>
<li><p>解答 65 のクラス <code class="docutils literal notranslate"><span class="pre">logger</span></code> は Singleton デザインパターンの現代風の実装を教えてくれる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code></p></li>
<li><p>解答 66 は Consumers/Producers パターン。
<code class="docutils literal notranslate"><span class="pre">std::condition_variable</span></code> の連携がわかりにくい。</p></li>
</ul>
</section>
<section id="id10">
<h2><a class="toc-backref" href="#id26">8 章 デザインパターン</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>デザインパターンは基本的なのでしっかり見ていく。</p>
<p>解答 67 はパスワードの検証ということで Decorator パターンを適用している。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">validator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">symbol_password_validator</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">case_password_validator</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">digit_password_validator</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">length_validator</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">8</span><span class="p">))));</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>パターンとは関係ないが、継承ツリー最下層のクラスを <code class="docutils literal notranslate"><span class="pre">final</span></code> 宣言する。</p></li>
<li><p>これも関係ないが、オーバーライドメンバー関数を明示的に <code class="docutils literal notranslate"><span class="pre">override</span></code> 宣言する。</p></li>
<li><p>装飾されるオブジェクトを <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> で持つ。これは値渡しとする。その際コンストラクターで <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> を併用する。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> を <code class="docutils literal notranslate"><span class="pre">std::make_unique()</span></code> で生成するのがよい。</p></li>
</ul>
<p>解答 68 は Composite パターンを適用して、パスワードをランダムに生成する。前項の Decorator パターンと同様に <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> を駆使するのがコツとなる。状況によって <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> になることもあるだろう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">composite_password_generator</span><span class="w"> </span><span class="n">generator</span><span class="p">;</span><span class="w"></span>
<span class="n">generator</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">symbol_generator</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="n">generator</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">digit_generator</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="n">generator</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">upper_letter_generator</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="n">generator</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">lower_letter_generator</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">password</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generator</span><span class="p">.</span><span class="n">generate</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>解答 69 は Template Method パターン。基本的なパターンゆえにモダンも何もない気がする。</p>
<ul class="simple">
<li><p>抽象基底クラスの純粋仮想関数に <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> と書くのは度胸が要る。</p></li>
<li><p>乱数生成コードは毎回 5 行くらいの決まり切ったものになるので、
VS Code などの snippets として定義しておくのがいいだろう。</p></li>
<li><p>メンバー関数 <code class="docutils literal notranslate"><span class="pre">next_random()</span></code> で出来合いの乱数器から乱数を得る。</p></li>
</ul>
<p>解答 70 は Chain of Responsibility パターン。メンバー関数 <code class="docutils literal notranslate"><span class="pre">approve()</span></code> を見ればわかるだろう。従業員が自分の一存で扱える金額ならば経費を処理し、そうでなければ直属の上役の決裁を仰ぐ。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::numeric_limits&lt;double&gt;::max()</span></code> は覚えておこう。</p></li>
</ul>
<p>解答 71 は Observer パターン。</p>
<ul class="simple">
<li><p>冒頭の <code class="docutils literal notranslate"><span class="pre">to_string()</span></code> は C++ 言語でサポートしてくれないか。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[[nodiscard]]</span></code> が付いているメンバー関数がある。余計なおせっかいという気もする。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">push_back(T&amp;&amp;)</span></code> は universal reference ではなくて、ふつうの右辺値参照引数だ。テンプレート引数は確定している。</p></li>
</ul>
<p>解答 72 は Strategy パターン。値引額を決定するという、どこかで見た問題設定だ。</p>
</section>
<section id="id11">
<h2><a class="toc-backref" href="#id27">9 章 データシリアライゼーション</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>この章からは非標準ライブラリーを利用する解答が多い。
C++ によるプログラミング能力だけではなく、そのようなライブラリーをビルド、リンクする能力も備えろ。</p>
<p>ただし、これ以降に登場するような問題は Python で書いたほうがいいと思う。あとで各問題の Python による解答を用意するのも面白いだろう。時間があればやりたい。</p>
<p>XML ファイルのシリアライズには pugixml というライブラリーを採用。これはソースファイルが一つしかないので <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> と同時にコンパイルすればいい。解答 73 と 74 の <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> を見るとそのようにしている。</p>
<p>JSON ファイルのシリアライズには nlohmann/json を採用。構文が直観的にわかりやすいそうだ。これはヘッダーファイルしかないライブラリーなので、ビルドをしなくて済む。</p>
<ul class="simple">
<li><p>解答 75 の関数 <code class="docutils literal notranslate"><span class="pre">to_json()</span></code> は <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> からは呼び出されていないが、
<code class="docutils literal notranslate"><span class="pre">nlohmann::json</span></code> 内のシリアライズ機能が参照する。コメントアウトしてはならない。</p></li>
</ul>
<p>PDF ファイルのシリアライズには PDF-Writer を利用する。
Python のときもそうだが、PDF の問題はフォントの設定で困ることが多い。</p>
<p>PDF-Writer のビルドを別途する必要がある。このディレクトリーに移動して
<code class="docutils literal notranslate"><span class="pre">cmake</span></code> 作業をする。このビルドの出力先を変える場合、解答 77 の <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> も編集する必要があるかもしれない。</p>
</section>
<section id="id12">
<h2><a class="toc-backref" href="#id28">10 章 アーカイブ、画像、データベース</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>こういうプログラムを C++ で書くのは勘弁願いたいものだ。</p>
<ul class="simple">
<li><p>解答 79 のコードを見るに、ZipLib のインターフェイスは洗練されているとは言えないようだ。しかもヘッダーファイルをインクルードするとコンパイラーが警告を多数出す。</p></li>
<li><p>範囲 <code class="docutils literal notranslate"><span class="pre">for</span></code> 文のコロンの右側で関数呼び出しをしても一度しか呼ばれないで済むようだ。</p></li>
<li><p>解答 80 で <code class="docutils literal notranslate"><span class="pre">std::function</span></code> の利用例を見られる。コールバックとして利用している。</p></li>
<li><p>解答 83 のフォント周りの処理は Linux 専用コードを書く必要がある。</p></li>
<li><p>解答 85, 86 の関数 <code class="docutils literal notranslate"><span class="pre">get_directors()</span></code> 内などのラムダ式の引数リストでは <code class="docutils literal notranslate"><span class="pre">auto</span></code> が許されない。</p></li>
<li><p>解答 87 の <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> はよろしくない。<code class="docutils literal notranslate"><span class="pre">&amp;data[0]</span></code> が正解。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::stoi()</span></code></p></li>
</ul>
</section>
<section id="id13">
<h2><a class="toc-backref" href="#id29">11 章 暗号</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>C++ 新機能の学習からは離れていく。最初の 2, 3 問は標準ライブラリーしか利用していないので気が楽だ。</p>
<ul>
<li><p>解答 90 は <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> の切り替えが何なのかよくわからない。</p></li>
<li><p>範囲を引数に取るコンストラクターを使って勝手に書き直す：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">from_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">(</span><span class="n">data</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">from_range</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">(</span><span class="n">data</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>解答 91 以降で Crypto++ というライブラリーを利用する。
<code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> の静的リンクライブラリーファイル名がミスっているので修正する。</p></li>
<li><p>解答 91 の <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> は <code class="docutils literal notranslate"><span class="pre">char*</span></code> を <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char*</span></code> にキャストする。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::filesystem::path::string()</span></code></p></li>
<li><p>解答 94 については本書の説明を読むこと。わかりやすさのために無駄なことをしている。</p></li>
</ul>
</section>
<section id="id14">
<h2><a class="toc-backref" href="#id30">12 章 ネットワークとサービス</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>C++ のコードとして面白いかというとそんなことはない。</p>
<ul class="simple">
<li><p>Asio はヘッダーファイルからなるライブラリーだ。</p></li>
<li><p>解答 96 の解答は 2 ディレクトリーに分かれている。サーバー側をバックグランドで起動すると良い。</p></li>
<li><p>ソケットプログラミングにおける <code class="docutils literal notranslate"><span class="pre">std::array</span></code> の存在感のしっくりさ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::enable_shared_from_this</span></code> は説明を要する。これを継承するサブクラスは、メンバー関数内で <code class="docutils literal notranslate"><span class="pre">shared_from_this()</span></code> を呼び出すことによりサブクラス自身の <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> オブジェクトを得る。このコードで言うとメンバー関数 <code class="docutils literal notranslate"><span class="pre">read()</span></code> の冒頭でそれを確認できる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::error_code</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">curl</span></code> 系ライブラリーのビルドにはひじょうに苦労させられた。</p>
<ul class="simple">
<li><p>解答 98 のコードを使って自分の Gmail のアカウントにアクセスしてみたが失敗した。</p></li>
<li><p>解答 99, 100 のコードは Microsoft Azure の各種サービスを使う。アカウントを
sign up しておく必要がある。面倒なのでやっていない。</p></li>
<li><p>解答 99 はエンコーディング変換関数の実装例。</p>
<ul>
<li><p>最後の <code class="docutils literal notranslate"><span class="pre">for</span></code> ループは初めて見るタイプの構文だ。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span></code></p></li>
</ul>
</section>
<section id="a">
<h2><a class="toc-backref" href="#id31">付録 A 参考文献</a><a class="headerlink" href="#a" title="Permalink to this headline">¶</a></h2>
<p>すべての論文・ライブラリーについて URL が併記されている。</p>
</section>
<section id="id15">
<h2><a class="toc-backref" href="#id32">訳者あとがき</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>〈「モダン」な解法の難しいところは、外部のライブラリや API に依存するところです〉とある。そのためかどうか知らないが、本書で印刷されているコードと GitHub のコードとで細かい差異が多数あった。それを確認するのもいい勉強になった。</p>
<p>その外部のライブラリをビルドする手順は本書ではほとんど記されていないので、著者が確認した環境以外で試そうとすると、ほんとうに challenge になる。</p>
</section>
<section id="id16">
<h2><a class="toc-backref" href="#id33">追加的作業</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<section id="cmakelists-txt">
<h3><a class="toc-backref" href="#id34"><code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> を検証する</a><a class="headerlink" href="#cmakelists-txt" title="Permalink to this headline">¶</a></h3>
<p>自然なビルド手順は、トップレベルにある <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> を参照した <code class="docutils literal notranslate"><span class="pre">cmake</span></code> コマンドを実行することで各解答に対応するサブディレクトリーの <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> により
<code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> が適宜コンパイル、リンクされて、実行形式がトップ直下の <code class="docutils literal notranslate"><span class="pre">bin</span></code>
サブディレクトリーに生成されるというものだろう。</p>
<p>WSL (Ubuntu) 環境でこのビルドを実行すると失敗する。原因は大きく分けて二つある。まず、サードパーティー製ライブラリーの一部が <code class="docutils literal notranslate"><span class="pre">cmake</span></code> でビルドできないことだ。</p>
<ul class="simple">
<li><p>Crypto++ は <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> が全然作り込まれていないことから、これを使うとビルドできないのは想像に難くない。
<code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code> があるということは <code class="docutils literal notranslate"><span class="pre">make</span></code> しろということだろう。事実、時間はかかるがそれでモノが生成する。特定のソースコードのコンパイルに長時間かかる。</p></li>
<li><p>cURL はビルド手順を忘れた。いつの間にかなんとかなっていた。</p></li>
<li><p>cURL と curlcpp のライブラリーファイルはトップレベル直下の <code class="docutils literal notranslate"><span class="pre">bin/libs</span></code> には来ない？</p></li>
</ul>
<p>それから、解答コードの一部がビルドに失敗することだ。著者は Windows と Mac で動作確認をしたとあり、
Linux についてはビルドが成功することを保証しているわけではない。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> で、インクルードが不足しているものがある。これは修正が容易だし、C++ の学習にもなるので不問にしてよい。</p></li>
<li><p>マルチスレッド関連の解答ではコンパイルオプション <code class="docutils literal notranslate"><span class="pre">-pthread</span></code>
あるいは同等のオプションの明示的追加が必要。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">include_directories(${LIBS_PATH}/stduuid)</span></code></p></li>
<li><p>リンクするライブラリー名が他の環境と異なっている？</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c">#add_library (cryptlib STATIC ${headers} ${sources})</span>
<span class="nb">add_library</span> <span class="p">(</span><span class="s">cryptopp</span> <span class="s">STATIC</span> <span class="o">${</span><span class="nv">headers</span><span class="o">}</span> <span class="o">${</span><span class="nv">sources</span><span class="o">}</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>リンク順がビルドの結果に影響する可能性がある。気のせいかも知れない。</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">problem_97</span> <span class="s">curl</span> <span class="s">curlcpp</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="haverbeke18/index.html" title="Eloquent JavaScript 読書ノート"
             >next</a></li>
        <li class="right" >
          <a href="speinellis17.html" title="Effective Debugging 読書ノート"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">読書ノート</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Modern C++ チャレンジ 読書ノート</a></li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2021, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>