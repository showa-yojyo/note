======================================================================
入門 bash 読書ノート 3/3
======================================================================

.. include:: /_include/book-details/newham05.txt

.. contents:: ノートの目次

8 章 プロセスの操作
======================================================================

Cygwin ユーザーが読んでも役に立つと信じて本章を読む。

* <UNIX は、ユーザーごとに複数のプロセスの制御を可能にした最初の小型コンピュータ
  オペレーティングシステムとしてもよく知られている> (p. 209)
* <プロセスを識別し、ログインセッションやシェルスクリプトでそれらを制御するため
  の最も基本的な要素から見ていく> (p. 209)
* <プロセスどうしを通信させる仕組みについて調べる> (p. 209)

8.1 プロセス ID とジョブ番号
----------------------------------------------------------------------

* <プロセスが生成されると、必ず **プロセス ID** という番号が振られる> (p. 210)
  コマンドを ``&`` 付きで実行すると、コンソールに ``[1] 4000`` のような表示が出
  る。最初の括弧つきの番号が **ジョブ番号** を示す。
* <ジョブという言葉は、基本的に、シェルから呼び出されたコマンドラインを指す> (p.
  210)

8.2 ジョブ制御
----------------------------------------------------------------------

* <ただし、ジョブ番号のほうは重要だ。 **ジョブ制御** を行うシェルコマンドで使用
  するからである> (p. 211)
* <ジョブをバックグラウンドで起動した後は、そのまま完了させるか、**フォアグラウ
  ンド** へ移すか、または **シグナル** というメッセージを送りつけることができる>
  (p. 211)

8.2.1 フォアグラウントとバックグラウンド
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* :command:`jobs` コマンドでジョブの一覧表示。オプションが色々ある。
* 引数なしで :command:`fg` と入力すると、バックグランドで最後に実行されたジョブ
  がフォアグラウンドに移る。

8.2.2 ジョブの一時停止
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <一時停止するには、ジョブの実行中に :kbd:`Ctrl` + :kbd:`Z` キーを押す> (p.
  213) ここで :kbd:`Ctrl` + :kbd:`Z` は ``susp`` に設定されていることを仮定して
  いる。
* <停止したジョブを再開し、フォアグラウンドで続行したい場合には、ここで
  :command:`fg` と入力すればよい> (p. 213)
* <（いつものように）コマンドをフォアグラウンドに実行したところ、思ったよりも処
  理に時間がかかっていることに気付く。コマンドはきちんと終了させたいが、端末の制
  御を取り戻して他の作業も行いたい。このような場合には、:kbd:`Ctrl` + :kbd:`Z`
  キーを押してから :kbd:`bg` と入力すれば、ジョブをバックグラウンドに移すことが
  できる> (p. 214) 脚注のネットワーク経由での実行に関する注意も読む。

8.3 シグナル
----------------------------------------------------------------------

* :kbd:`Ctrl` + :kbd:`Z` と :kbd:`Ctrl` + :kbd:`C` は、<どちらもプロセスに
  **シグナル** を送信するという特殊な行動をとる> (p. 214)
* シグナルとは、あるプロセスから別のプロセスに送信されるメッセージととらえればよ
  いようだ。
* シグナルを使用するスクリプトを書くときは、可搬性を高めるために番号ではなく名前
  を使用する。:command:`kill -l` で一覧できる。

8.3.1 コントロールキーのシグナル
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <説明しておいて何だが、この方法はお勧めできないことを付け加えておかなければな
  らない> (p. 216)

8.3.2 :command:`kill`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* デフォルトでは :command:`kill` は TERM シグナルを送信する。
  ただ、効果としては INT シグナルと同じとのこと。
* <すべてを説明すると込み入った話になるので、次の説明で勘弁して欲しい> (p. 216)
* :command:`kill %1` は「ジョブ番号 1 のプロセスを（TERM シグナルで）停止す
  る」。
* :command:`kill -QUIT %1` は「ジョブ番号 1 のプロセスを（QUIT シグナルで）終了
  する」。
* :command:`kill -KILL %1` は「ジョブ番号 1 のプロセスを（KILL シグナルで）終了
  する」。
* <TERM シグナルと QUIT シグナルは、プロセスを終了する前に「後始末」をする機会を
  設けるが、KILL シグナルは、たとえ計算中であったとしても、プロセスを強制終了す
  る。 **KILL シグナルは最後の手段として使用すること。**> (pp. 217-218)

8.3.3 :program:`ps`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <プロセス ID は :program:`ps` コマンドで取得することができる> (p. 218)
* <:program:`ps` にはオプションが複数あるが、UNIX のバージョンによって異なる>
  (p. 218) Cygwin 環境では :command:`ps -ax` が怒られるから、BSD ではなく System
  V 系統なのだろうか。

8.4 トラップ
----------------------------------------------------------------------

8.4.2 プロセス ID と一時ファイル
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <``$$`` は、現在のシェルのプロセス ID を保持する特別なシェル変数である> (p.
  224)
* <``$!`` には、最後に実行したバックグラウンドジョブのプロセス ID が含まれている
  > (p. 224)
* <:command:`trap` コマンドに指定されたコマンド文字列が、実行されるまで **評価さ
  れない** ことに注意しよう。したがって、コマンド文字列の ``$msgfile`` には、必
  ず正しい値が含まれる。コマンド文字列を単一引用符で囲んだのは、そのためである>
  (p. 225)

8.4.5 トラップのリセット
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* :command:`trap` コマンドに引数としてハイフンだけを指定すると、シグナル受信時の
  動作がデフォルト（プロセスの中止）に戻る。

8.5 コルーチン
----------------------------------------------------------------------

* <2 つ（以上）のプロセスが同時に実行されるようにプログラムされていて、プロセス
  どうしが互いにやり取りすることが可能である場合、それらを **コルーチン**
  (coroutine) という> (p. 227)
* <パイプラインはコルーチンの一例だ> (p. 227)

8.5.1 :command:`wait`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <引数を指定しないと、:command:`wait` はバックグラウンドジョブがすべて終了する
  まで待機する> (p. 228)

8.5.2 コルーチンの利点と欠点
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

以下の用語がだいたい人に説明できる程度まで、複数プロセス同時実行のメリットに関す
る理解を深めたい。

* CPU 集約型
* 入出力集約型
* 対話型
* スラッシンング

8.5.3 並列化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <プロセスをコルーチンに分割することを、ジョブを **並列化** するとも言う> (p.
  229)
* <この場合、コルーチンの実行時間は、すべてのプロセスの実行時間を合計したもので
  はなく、基本的には、実行時間が最も長いものに若干のオーバーヘッドを足したものと
  なる（ただし、すべての CPU が 1 つのディスクドライブを共有していた場合、I/O 関
  連のスラッシングの可能性はまだ消えない）> (p. 230)
* <せっかく並列化を施して処理時間を短縮したのに、追加したコードの実行時間で相殺
  されてしまったのでは意味がない> (p. 231)
* <複雑な並列プログラムになると、本体の目的を達成するコードよりも、特殊な状況に
  対応するコードのほうが圧倒的に多いほどである> (p. 231)

8.6 サブシェル
----------------------------------------------------------------------

8.6.2 入れ子のサブシェル
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <シェルコードの一部を（中かっこではなく）かっこで囲むと、そのコードはサブシェ
  ルで実行される。これを **入れ子** の（またはネストした）サブシェルと言う> (p.
  232)

  * 通常は、コマンドブロック（中括弧）の場合よりも効率が悪い。
  * サブシェルとコマンドブロックの違いは、そのほとんどが「スコープ」に関係するも
    の。シェル変数やシグナルトラップの有効範囲が違う。

* <コードの入れ子をサポートしている言語では、入れ子のコード内で定義されるものに
  は、そこだけに限定されたスコープが割り当てられることが望ましい、とされている。
  このため、変数やシグナルトラップのスコープに関しては、入れ子のサブシェルのほう
  がコマンドブロックよりも厳密な制御が可能である。したがって、変数の定義やシグナ
  ルトラップが必要で、効率を度外視できるのであれば、コマンドブロックよりもサブ
  シェルを使用したほうがよいだろう> (p. 233)

8.7 プロセス置換
----------------------------------------------------------------------

.. code:: bash

   cmp <(program1) <(program2)

1. :program:`program1` と :program:`program2` を同時に実行して、
2. それらの出力を **名前付きパイプ** につなぎ、
3. :program:`cmp` がそれぞれのパイプからデータを読み取り、比較する。

9 章 シェルプログラミングのデバッグ
======================================================================

9.1 基本的なデバッグ補助
----------------------------------------------------------------------

9.1.1 :command:`set` のオプション
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 組み込み変数 ``PS4`` は :command:`set -o xtrace` の出力行の先頭の文字列。展開
  レベル次第で、出力行の先頭の文字列の先頭に ``PS4`` の 1 文字目が付加される。

9.2 :program:`bash` デバッガ
----------------------------------------------------------------------

* <プログラムにおいて実行を停止する場所を指定する。これを **ブレークポイント**
  という> (p. 245)
* <プログラムにおいて指定された数の文を実行する。これを **ステップ実行** という>
  (p. 245)
* <:command:`exec` に引数としてコマンドラインを渡すと、それらは現在のプログラム
  （同じプロセス）で実行される。したがって、:command:`exec` を実行するとシェルが
  **直ちに停止し、** :command:`exec` の引数と置換される> (p. 247)

  :command:`exec` が危険な存在であることを指摘している。

10 章 :program:`bash` の管理
======================================================================

10.1 標準シェルとしての :program:`bash` のインストール
----------------------------------------------------------------------

* <1 行目では、``$PATH`` 環境変数を ``for`` ループの項目リストとして使用できるよ
  うにしている> (p. 268)

  .. code:: bash

     IFS=:
     for d in $PATH; do
         # 何か処理

10.1.1 POSIX モード
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* POSIX は Portable Operating System Interface の略らしい。X はどこから？
* <:program:`bash` はデフォルトのモードでも POSIX にほぼ 100% 準拠している。
  POSIX へのこだわりがあるならば、:program:`bash` を POSIX モードで実行すること
  ができる。そのためには、``--posix`` オプションを指定するか、シェルで
  :command:`set -o posix` を設定する> (p. 269)

10.1.2 コマンドラインオプション
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 表 10-1 より、使えそうなものをノート：

  ``-c string``    ``string`` からコマンドを読み取る。
  ``-i``           対話型シェル。
  ``-l, --login``  ログインシェル。
  ``--help``       使用法を示すメッセージを表示する。
  ``--noprofile``  :file:`/etc/profile` やユーザーの初期設定ファイルをロードしない。
  ``--norc``       対話型シェルの場合、:file:`~/.bashrc` をロードしない。
  ``--rcfile file``  対話型シェルの場合、:file:`~/.bashrc` の代わりに :file:`file` をロードする。
  ``--init-file file``  同上。

* <コマンドラインで複数文字のオプションを指定する場合には、1 文字のオプションよ
  りも前に指定しなければならない> (p. 270)

10.2 環境のカスタマイズ
----------------------------------------------------------------------

* :program:`bash` は :file:`/etc/profile` を読み込んでから
  :file:`~/.bash_profile` を読み込む。:command:`umask` や :command:`ulimit` コマ
  ンドを使用するのは前者。

10.2.1 :command:`umask`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <ここでは 8 進表記を使用して :command:`umask` の説明をする。おそらく知っている
  と思うが、パーミッションの数字は、（左から右に）所有者、所有者が属するグルー
  プ、その他のユーザーへのパーミッションを表す。数字はそれぞれ 3 ビットで構成さ
  れ、左から右に、読み取り、書き込み、実行のパーミッションを指定する。 （ファイ
  ルがディレクトリの場合、「実行」パーミッションは「検索」パーミッションとなる。
  検索パーミッションとは、ディレクトリを移動したりファイルの一覧を取得したりする
  ためのパーミッションである> (p. 271)

10.2.2 :command:`ulimit`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* :command:`ulimit` コマンドで、ユーザーが利用できるシステムリソースに制限を設け
  ることができる。

11 章 シェルスクリプティング
======================================================================

本章では、<保守可能なシェルスクリプトを作成する方法を紹介> (p. 279) するようだ。

11.1 スクリプトは何をするのか
----------------------------------------------------------------------

11.1.2 変数と定数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* <ヘッダーとコメントは、コードを文書化するための方法の 1 つにすぎない> (p. 281)
* <よい名前とは、短くてわかりやすいものである。（略）長い名前にしてはならない。
  （略）わかりやすい名前のメリットを帳消しにするほど、スクリプトを煩雑にするだけ
  である> (p. 281)

11.2 スクリプトの起動
----------------------------------------------------------------------

* <プログラマはユーザーの操作ができるだけ楽になるように努力しなければならない>
  (p. 281)
* <Free Software Foundation では、GNU ソフトウェアを作成するためのガイドラインを
  公開し、 UNIX ユーティリティの標準的な使用法を提案している> (p. 282) URL が脚
  注にある。
* <注意しなければならない点が 1 つある。それは、ユーザーの環境において特定の環境
  変数が設定されていることを前提とする場合である。環境変数が設定されていることを
  あてにするくらいなら、スクリプトの設計を見直して、その値を引数として指定できる
  ようにしたほうがよいだろう> (p. 283)

11.3 その他の問題点
----------------------------------------------------------------------

:program:`bash` スクリプトに関するものだけノート。

* 必ず ``#!/bin/bash`` とすること。
* ホワイトスペースに注意する。等号の前後、開き括弧の後ろ、閉じ括弧の前が危ない。
* 評価演算子 ``[...]`` の使用に注意。``=`` なのか ``-eq`` なのか等。

11.4 :program:`bash` を使用しない
----------------------------------------------------------------------

* 大量の処理をすばやく実行する場合や、数学的な計算を要する場合は C/C++ の使用を
  検討したり、システム間の可搬性を重視する場合は、 Python や Perl のほうが適して
  いるといった判断をすること。適材適所。

12 章 :program:`bash` の導入
======================================================================

Cygwin ユーザーである記者は特に読まなくてよい？

付録 A 関連シェル
======================================================================

A.3 Korn シェル
----------------------------------------------------------------------

* <唯一の欠点は、数年おきにしかアップグレードされないことだ> (p. 302)とある。今
  でもそうなのだろうか。

A.5 :program:`zsh`
----------------------------------------------------------------------

* <特に「パワーユーザー」にお勧めである> (p. 303)

付録 B リファレンス
======================================================================

B.8 入出力リダイレクト
----------------------------------------------------------------------

* 出力・エラーリダイレクトには ``&>file`` と ``>&file`` の 2 つの形式がある。後
  者のほうが望ましい。

付録 D プログラム可能な補完
======================================================================

* <補完メカニズムにフックを仕掛けて、2 章で説明した組み込みのテキスト補完機能を
  拡張するものである> (p. 333)
* :kbd:`Tab` キーが押されたときのシェルの対応を :command:`complete` コマンドで指
  定する。

  .. code:: bash

     # -A file が「補完するのはファイルリストだ」ということを指示する
     #
     # -X '!*.@(Z|gz|tgz)' がファイル名パターンのフィルターを指示する
     complete -A file -X '!*.@(Z|gz|tgz)' gunzip

* :command:`compgen` は補完文字列を確認するのに利用できる。

  .. code:: bash

     complete -A file -X '!*.@(Z|gz|tgz)'
