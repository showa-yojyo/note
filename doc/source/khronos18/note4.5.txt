4.5. Interpolation Qualifiers
---------------------------------------------------------------------------------

補間される可能性のある入力および出力は、以下の補間修飾子のうち高々一つによってさ
らに修飾される：

.. csv-table::
   :delim: @
   :header: 修飾子, 意味

   ``smooth`` @ 透視図法的補正補間
   ``flat`` @ 補間なし
   ``noperspective`` @ 線形補間

補間の有無と型は上記の補間修飾子と補助格納修飾子 ``centroid`` と ``sample`` に
よって制御される。補間修飾子がない場合は ``smooth`` 補間が行われる。複数の補間修
飾子を使用するとコンパイルエラーとなる。補助格納修飾子 ``patch`` は補間には使用
されない。補間修飾子を ``patch`` と共に使用するとコンパイルエラーとなる。

``flat`` と指定された変数は補間されない。代わりに、基本形状内の断片みんなに対し
て同じ値を持つ。この値は、API で説明されているように、単一の provoking vertex か
ら得られる。``flat`` と修飾された変数は ``centroid`` や ``sample`` と修飾される
こともあり、これは ``flat`` としか修飾されていないのと同じ意味になる。

.. admonition:: 読者ノート

   この provoking vertex とは？

``smooth`` と修飾された変数は、レンダリングされている基本形状の上に、透視図法的
な補正による方法で補間される。遠近法的に正しい方法での補間は、OpenGL 仕様の式
14.7 および 14.5 "Line Segments" で規定されている。

``nonperspective`` と修飾された変数は、OpenGL 仕様書 3.5 "Line Segments" の式
3.7 で述べられているように、スクリーン空間内で線形に補間しなければならない。

多重採取ラスタライズが無効の場合、または ``centroid`` 修飾も ``sample`` 修飾もな
い断片シェーダー入力変数の場合、割り当てられた変数の値は、OpenGL 仕様で許可され
ている範囲内で、画素内の任意の場所に補間することができ、画素内の各標本に単一の値
を割り当てることができる。

多重採取ラスタライズが有効な場合、``centroid`` と ``sample`` を使用して、修飾さ
れた断片シェーダー入力の採取位置と頻度を制御することができる。断片シェーダー入力
が ``centroid`` で修飾されている場合、その変数には画素内のすべての標本に対して単
一の値を割り当てることができるが、その値は、基本形状で網羅されている画素の標本を
含めて、画素とレンダリングされている基本形状の両方に位置する場所で補間されなけれ
ばならない。変数が補間される位置は隣接する画素で異なる可能性があり、微係数は隣接
する画素間の差を計算することで算出されるため、``centroid`` 採取された入力の微係
数は、``centroid`` 以外で補間された変数のそれよりも精度が低い可能性がある。断片
シェーダーの入力が ``sample`` で修飾されている場合、その変数には、画素内の網羅さ
れた標本ごとに個別の値が割り当てられなければならず、その値は個々の標本の位置で採
取されなければならない。

同一段階内で同じ名前の変数の補間修飾子が一致しないとリンクエラーになる。

4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

互換性プロファイルを使用する場合、次の宣言済み変数を補間修飾子付きで再宣言でき
る。

* 頂点、細分化制御、細分化評価、幾何の各言語

  * ``gl_FrontColor``
  * ``gl_BackColor``
  * ``gl_FrontSecondaryColor``
  * ``gl_BackSecondaryColor``

* 断片言語

  * ``gl_Color``
  * ``gl_SecondaryColor``

例：

.. code:: glsl

   in vec4 gl_Color;            // predeclared by the fragment language
   flat in vec4 gl_Color;       // redeclared by user to be flat
   flat in vec4 gl_FrontColor;  // input to geometry shader, no "gl_in[]"
   flat out vec4 gl_FrontColor; // output from geometry shader

理想的には、:ref:`khronos18-7.1.7` で記述されるように、インターフェイスブロック
の再宣言の一部としてこれらを再宣言する。しかし、上記の目的のために、インターフェ
イスブロックの外部で、大域スコープの個々の変数として再宣言することもできる。この
ような再宣言をすると、出力変数に変換反響修飾子である ``xfb_buffer``,
``xfb_stride``, ``xfb_offset`` を付けることもできる。

* 変数上の ``xfb_buffer`` は大域既定バッファーを変化させない。

シェーダーが、インタフェイスブロックの再宣言と、そのインタフェイスブロックのメン
バーの再宣言を、このインタフェースブロックの再宣言の外側で別々に行うと、コンパイ
ルエラーになる。

``gl_Color`` が補間修飾子で再宣言された場合、``gl_FrontColor`` と
``gl_BackColor`` も同じ補間修飾子で再宣言されなければならず、その逆もまた然り。
``gl_SecondaryColor`` が補間修飾子付きで再宣言されたならば、
``gl_FrontSecondaryColor`` と ``gl_BackSecondaryColor`` も同じ補間修飾子付きで再
宣言されなければならず、その逆もまた然り。このような、宣言済みの変数に対する修飾
子の符合判定は、プログラム中のシェーダー内で静的に使用される変数に対してのみ必要
だ。

4.6. Parameter Qualifiers
---------------------------------------------------------------------------------

精度修飾子とメモリー修飾子に加えて、次のパラメータ修飾子を引数に付けることができ
る：

.. csv-table::
   :delim: @
   :header: 修飾子, 意味

   なし（既定） @ ``const`` と同じ
   ``const`` @ 書き込めない引数
   ``in`` @ 関数に渡される引数
   ``out`` @ 関数に渡される引数のうち、初期化されていないもの
   ``inout`` @ 関数の中と外の両方に渡される引数

引数修飾子については :ref:`khronos18-6.1.1` に記述がある。

4.7. Precision and Precision Qualifiers
---------------------------------------------------------------------------------

Vulkan を対象にしていない場合：精度修飾子は OpenGL ES とのコードの可搬性のために
追加されたものであって、機能的なものではない。精度修飾子は OpenGL ES と同じ構文
を持つが、セマンティックな意味はなく、変数の格納や演算に使用される精度にも影響し
ない。拡張機能が OpenGL ES 2.0 仕様の精度修飾子と同じセマンティクスと機能を追加
する場合は、その目的のために本節で記述されるキーワードを再利用することができる。

Vulkan を対象とする場合：インターフェイスの照合処理では、一様変数、一様ブロッ
ク、バッファーブロックメンバーは、同じ精度修飾を持たなければならない。同じシェー
ダー段階にリンクされていて異なるコンパイル単位で宣言された大域変数は、同じ精度修
飾子で宣言されなければならない。

あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判断する目的では、
精度修飾子が一致する必要はない。

.. _khronos18-4.7.1:

4.7.1. Range and Precision
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``highp`` 単精度および倍精度浮動小数点変数の精度は 32 ビットおよび 64 ビット浮動
小数点数の IEEE 754 規格により定義される。

これには、``NaN`` と ``Inf``、および正と負のゼロの対処が含まれる。

以下の規則は、単精度と倍精度の演算の両方で ``highp`` に適用される。符号付きの無
限大とゼロは、IEEE の規定に従って生成されるが、次の表（省略）で許可されている精
度が適用される。シェーダーに入力された非正規化値、またはシェーダー内の任意の演算
で潜在的に生成される値は、0 に flush することができる。丸めモードは設定すること
ができず、未定義だが、結果に 1ULP 以上の影響を与えてはならない。``NaN`` を生成す
る必要はない。``NaN`` の signaling の対処は必須ではなく、例外は決して発生しな
い。``NaN``を操作する組み込み関数を含む操作は、結果として ``NaN`` を返す必要はな
い。しかし、``NaN`` が生成された場合 ``isnan()`` は正しい値を返さなければならな
い。

特に断りのない限り、精度は ULP 単位で最大相対誤差で表される。

単精度演算の場合、精度は以下のように（略）求められる。

.. admonition:: 読者ノート

   ちょっとした表が入るが、省略。

上記の操作から作られた式を持つ、仕様書で定義された組み込み関数は、上記の誤差を継
承する。

これらには、例えば、幾何関数、共通関数、および多くの行列関数が含まれる。上記に記
載されておらず、上記の方程式で定義されていない組み込み関数は、精度が未定義だ。例
えば、三角関数や行列式などが該当する。

倍精度演算の精度は、少なくとも単精度のそれはある。

.. _khronos18-4.7.2:

4.7.2. Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

単精度浮動小数点型、整数型、不透明型宣言では、これらの精度修飾子の一つを型の前に
付けることができる：

.. csv-table::
   :delim: @
   :header: 修飾子, 意味

   ``highp`` @ 整数に対しては 32 ビット長 2の補数、浮動小数点数に対しては 32 ビット長 IEEE 754 浮動小数点
   ``mediump`` @ Vulkan を対象にしている場合は SPIR-V RelaxedPrecision, それ以外の場合はなし。
   ``lowp`` @ 同上

例：

.. code:: glsl

   lowp float color;
   out mediump vec2 P;
   lowp ivec2 foo(lowp mat3);
   highp mat4 m;

リテラル定数には精度修飾子がない。真偽変数にもない。コンストラクターにもない。

この段落で言う「操作」には演算子、組み込み関数、コンストラクターを含み、「オペ
ランド」には関数実引数とコンストラクター実引数を含むことにする。演算を内部的に評
価するために使用される精度と、その後に生じる中間値に関連する精度修飾子は、演算に
よって消費されるオペランドの最高精度修飾子と少なくとも同じでなければならない。

オペランドが精度修飾子を持たない場合には、精度修飾子は他のオペランドから得られ
る。精度修飾子のあるオペランドがない場合は、式の中で次に消費される演算のオペラン
ドの精度修飾子が使用される。この規則は、精度修飾されたオペランドが見つかるまで再
帰的に適用することができる。必要に応じて、代入のための左辺値の精度修飾、初期化子
のための被宣言変数の精度修飾、関数呼び出し実引数に対する仮引数の精度修飾、関数戻
り値のための関数戻り型の精度修飾も含まれる。この方法で精度が決定できない場合、例
えば、式全体が精度修飾子のないオペランドだけで構成されていて、その結果が代入され
たり実引数として渡されたりしない場合は、その型の既定精度あるいはそれ以上で評価さ
れる。断片シェーダーでこのような事態が発生した場合、既定の精度を定義する必要があ
る。

例えば、次の文を考える：

.. code:: glsl

   uniform highp float h1;
   highp float h2 = 2.3 * 4.7; // operation and result are highp precision
   mediump float m;
   m = 3.7 * h1 * h2; // all operations are highp precision
   h2 = m * h1; // operation is highp precision
   m = h2 - h1; // operation is highp precision
   h2 = m + m; // addition and result at mediump precision
   void f(highp float p);
   f(3.3); // 3.3 will be passed in at highp precision

精度修飾子は、他の修飾子と同様に、変数の基本型には影響しない。特に、精度変換のた
めのコンストラクターはない。コンストラクターは型を変換するだけだ。同様に、精度修
飾子は、他の修飾子と同様に、引数型に基づく関数のオーバーロードには関与しない。
:ref:`khronos18-6.1.1` で述べられているように、関数入出力はコピーによって行われ
るので、修飾子は一致しなくても構わない。

変数の精度はその変数が宣言された時点で決定され、その後変化することはあり得ない。

定整数式または定浮動小数点式の精度が指定されていない場合、評価は ``highp`` で行
われる。この規則は式の精度修飾には影響しない。

定数式の評価は不変でなければならず、通常はコンパイル時に実行される。

.. _khronos18-4.7.3:

4.7.3. Default Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

精度文

| ``precision`` *precision-qualifier* *type*;

を既定精度修飾子を設定するために使用することができる。*type* 欄は ``int``,
``float``, 不透明型のいずれかであり、*precision-qualifier* には ``lowp``,
``mediump``, ``highp`` が宣言される。

これ以外の型や修飾子を指定するとコンパイルエラーになる。``type`` が ``float`` の
場合、この指令は精度修飾のない単精度浮動小数点型（スカラー、ベクトル、行列）の宣
言に適用される。``type`` が ``int`` の場合は、精度修飾のない整数型（スカラー、ベ
クトルー、符号あり、符号なし）の宣言に適用される。これには、大域変数宣言、関数戻
り値宣言、関数引数タ宣言、局所変数宣言が含まれる。

精度修飾のない宣言は、スコープ内にある直近の精度文で指定された精度修飾子を使用す
る。``precision`` 文には変数宣言と同じスコープ規則がある。複文の中で宣言された場
合、その効果は宣言された最も内側の文の終わりで停止する。入れ子になったスコープ内
の精度文は、外側のスコープ内の精度文を上書きする。同じ基本型に対する複数の精度文
が同じスコープ内に現れることができ、そのスコープ内で遅れて現れる文が早く現れる文
を上書きする。

精度修飾子を受け付ける型に対する既定精度修飾子は ``highp`` だ。精度修飾子を必要
とする全ての型には既定精度があるので、精度修飾子の省略によるエラーはない。

4.7.4. Available Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

組み込みマクロ ``GL_FRAGMENT_PRECISION_HIGH`` は 1 に定義されている：

.. code:: glsl

   #define GL_FRAGMENT_PRECISION_HIGH 1

このマクロは計算以外の言語すべてで使用できる。

4.8. Variance and the Invariant Qualifier
---------------------------------------------------------------------------------

この節でいうばらつき (variance) とは、異なるプログラムにある同じ式から異なる値が
得られる可能性を意味する。例えば、異なるプログラムにある二つの頂点シェーダーがそ
れぞれ ``gl_Position`` を同じ式で設定し、その式への入力値が両方のシェーダーの実
行時に同じであるとする。シェーダー二つが独立してコンパイルされているため、これら
の実行時に ``gl_Position`` に代入される値が完全に同じではないことがあり得る。こ
の例では、多重パスアルゴリズムにおける幾何の alignment に問題が生じ得る。

一般的には、シェーダー間のこのようなばらつきは許容される。特定の出力変数にそのよ
うなばらつきがない場合、その変数は不変である (invariant) と言われる。

.. _khronos18-4.8.1:

4.8.1. The Invariant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

特定の出力変数が不変であることを保証するには、修飾子 ``invariant`` を使用する。
この修飾子を以前に宣言された変数が不変であることを修飾するのに使用することもでき
る：

.. code:: glsl

   invariant gl_Position; // make existing gl_Position be invariant
   out vec3 Color;
   invariant Color;       // make existing Color be invariant

または、変数が宣言されたときにその宣言の一部とする：

.. code:: glsl

   invariant centroid out vec3 Color;

不変性の候補はシェーダーの出力変数しかない。ユーザー定義の出力変数と組み込み出力
変数を含む。不変宣言できるのは出力のみなので、あるシェーダー段階の出力は、入力が
不変宣言されていなくても後続段階の入力と一致する。

ブロック上の入力または出力インスタンス名は、組み込み変数を再宣言する際には使用さ
れない。

キーワード ``invariant`` の後には、以前に宣言された識別子をカンマで区切って列挙
することができる。``invariant`` の使用はすべて、大域スコープまたはブロックメン
バー上で、かつ ``invariant`` として宣言された変数が使用される前でなければならな
い。

特定の出力変数の不変性を二つのプログラムを横断して保証するには、次も成り立ってい
なければならない：

* 出力変数が両方のプログラムで不変であると宣言されている。
* 出力変数に割り当てられた値に関与する式や制御フローで消費されるシェーダー入力変
  数すべてに同じ値を入力する必要がある。
* テクスチャーフォーマット、テクセル値、およびテクスチャーフィルタリングは、出力
  変数の値に関与するすべてのテクスチャー関数呼び出しに対して同じ方法に設定され
  る。
* 入力値すべてが同じ方法ですべて操作される。消費される式と中間式の操作すべてが、
  評価の順序が同じになるように、オペランドの順序と結合性（左結合とか右結合とかの
  こと）を同じにしなければならない。中間変数と関数は、同じ明示的または暗黙的精度
  修飾子を持つ同じ型として宣言されなければならない。出力値に影響を与えるすべての
  制御フローは同じでなければならず、この制御フローを決定するために消費されるどん
  な式も、これらの不変性規則に従わなければならない。
* 不変出力変数を設定するためのデータフローと制御フローすべては、単一のコンパイル
  単位に宿る。

原則的に、不変出力に至るデータフローと制御フローのすべてで一致しなければならな
い。

初期状態では、既定で、すべての出力変数に ``variant`` が許されている。すべての出
力変数を強制的に ``invariant`` にするには、プラグマ：

.. code:: glsl

   #pragma STDGL invariant(all)

をシェーダー内のすべての宣言の前に使用する。このプラグマがいずれかの変数や関数の
宣言の後に使用された場合、不変の動作をする出力集合は未定義となる。

一般に、不変性は最適化の柔軟性を犠牲にして確保されるため、不変性を使用することで
パフォーマンスが低下する可能性がある。したがって、このプラグマの使用は、出力変数
すべてを一つ一つ ``invariant`` と宣言するのを避けるためのデバッグ支援を目的とし
ている。

4.8.2. Invariance of Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

定数式には不変性が保証されなければならない。特定の定数式は、それが同じシェーダー
に現れようが異なるシェーダーに現れようが、同じ結果になるように評価しなければなら
ない。これには、同じ式が同じ言語の二つのシェーダーに現れる場合と、二つの異なる言
語のシェーダーに現れる場合が含まれる。

定数式は、前述の不変変数と同様に操作しても、同じ結果に評価しなければならない。

4.9. The Precise Qualifier
---------------------------------------------------------------------------------

アルゴリズムの中には、ほぼ同等の結果をより高いパフォーマンスで得られる最適化を対
処している実装であっても、ソースコードで指定された演算順序に正確に従い、すべての
演算を着実に処理することを浮動小数点計算に要求するものがある。例えば、多くの実装
は、次のような浮動小数点式を計算する multiply-add 命令を対処している：

.. code:: glsl

   result = (a * b) + (c * d);

これは三度の演算の代わりに二度で、すなわち、二度の乗算と一度の加算の代わりに、一
度の乗算と一度の multiply-add 演算を行う。

浮動小数点の multiply-add 結果は、最初に浮動小数点の結果が得られる乗算を行ってか
ら浮動小数点の加算を行った場合と同じになるとは限らない。したがって、この例では、
二つの乗算はつじつまが合うようには扱われず、二つの乗算は事実上、異なる精度である
ように見える可能性がある。

一貫性を持たせる必要がある重要な計算は、細分化の際に現れる。下図（注：本書には巨
大な図式が掲載されている）のように、細分化のための中間点が異なる方向に合成される
が、同じ結果を得る必要がある。

.. admonition:: 読者ノート

   ここにあるイラストは、細分化を実装するようなプログラマーでないと理解できない
   ものだと思う。

最適化されたコードが最適化されていないコードと比較してわずかに異なる結果をもたら
すかもしれなくても、実装は修飾子なしで、式の評価に使用される演算の順序または数を
効果的に変更する最適化を実行することが許可される。

修飾子 ``precise`` は変数の値に与する演算が、指定された順序で、演算子の一貫性を
持って行われることを保証する。演算子の順序は、:ref:`khronos18-5.1` で記述されて
いるように、演算子の優先順位と括弧によって決定される。演算子の一貫性とは、例えば
乗算演算子 ``*`` のような特定の演算子について、その演算が常に同じ精度で計算され
ることを意味する。具体的には、コンパイラーで生成されたコードで計算された値は、以
下の恒等式に従わなければならない：

| a + b = b + a
| a * b = b * a
| a * b + c * d = b * a + c* d = d * c + b * a = <any other mathematically valid combination>

次を防ぐことができる一方：

* ``a + (b + c)`` が ``(a + b) + c`` になることは許されない。
* ``a * (b * c)`` が ``(a * b) * c`` になることは許されない。
* ``a * b + c`` が単一の演算 ``fma(a, b, c)`` になることは許されない 。

ここで ``a``, ``b``, ``c``, ``d`` は行列ではなく、スカラーまたはベクトルとする
（行列は一般には可換でない）。これらの規則に基づいて計算を表現するのはシェーダー
作成者の責任であり、これらの規則に従うのはコンパイラーの責任だ。細分化段階が従う
べき規則については ``gl_TessCoord`` の説明を参照。これらの規則は、上記と合わせ
て、細分化する際のひび割れを避けることができる。

例：

.. code:: glsl

   precise out vec4 position;

は ``position`` の値を生成するために使用される演算が、ソースコードで指定された順
序で正確に実行されなければならず、すべての演算子が着実に扱われなければならないこ
とを宣言している。修飾子 ``invariant`` と同様に、修飾子 ``precise`` は組み込み変
数や事前に宣言されたユーザー定義変数が正確であることを修飾するために使用できる。

.. code:: glsl

   out vec3 Color;
   precise Color; // make existing Color be precise

ブロック、構造体型、または構造体型の変数に ``precise`` を適用すると、変数のメン
バーそれぞれに再帰的に ``precise`` を適用することになる。

この修飾子は、特定の関数内の右辺値の評価に影響を与えるが、それは、その結果が最終
的に同じ関数内で ``precise`` と修飾された左辺値によって消費される場合に、かつそ
の場合に限られる。関数内の他の式は影響を受けない。これには、``precise`` 宣言され
ていないが、関数の外で ``precise`` 修飾された変数によって最終的に消費される戻り
値や出力引数も含まれる。影響を受けない式には、選択文と反復文と条件演算子の条件式
とにある式を制御するものも含まれる。

``precise`` の使用例（略）。

あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判定する目的では、
修飾子 ``precise`` は入力と出力の間で一致する必要はない。

すべての定数式は ``precise`` が存在するかどうかにかかわらず、それが存在するかの
ように評価される。ただし、コンパイル時の定数式が対応する非定数式と同じ値に評価さ
れるという要件はない (:ref:`khronos18-4.3.3`)。

.. _khronos18-4.10:

4.10. Memory Qualifiers
---------------------------------------------------------------------------------

シェーダー格納ブロックとその内側で宣言された変数と画像型（キーワードに
``"image"`` を含む基本不透明型）として宣言された変数は、以下（略）の記憶修飾子の
一つまたは複数を追加的に修飾することができる：

.. csv-table::
   :delim: @
   :header: 修飾子, 意味

   ``coherent`` @ （面倒なので本文参照）
   ``volatile`` @
   ``restrict`` @
   ``readonly`` @
   ``writeonly`` @

修飾子 ``coherent`` を使って宣言された画像変数へのメモリーアクセスは、他のシェー
ダー呼び出しからの同じ場所へのアクセスとともに密着的に実行される。特に
``coherent`` 宣言された変数を読み出す場合、戻り値には、他のシェーダー呼び出しで
実行された以前に完了した書き込みの結果が反映される。また、``coherent`` 宣言され
た変数を書き込む場合、書き込まれた値は、他のシェーダー呼び出しで実行された後の密
着的読み込みに反映される。

OpenGL 仕様書の 7.12 "Shader Memory Access" にあるように、シェーダーメモリーの読
み取りと書き込みは、ほとんど定義されていない順序で行われる。必要であれば、組み込
み関数 ``memoryBarrier()`` を使って、単一のシェーダー呼び出しで実行されるメモ
リーアクセスの完了と相対的な順序を保証できる。

``coherent`` と宣言されていない変数を使ってメモリーにアクセスする場合、シェー
ダーがアクセスするそのメモリーは、同じアドレスへの将来のアクセスのために、実装が
キャッシュすることがある。メモリー格納は、書き込まれた値が同じメモリーにアクセス
する他のシェーダー呼び出しから見えないような方法でキャッシュされることがある。実
装は、メモリー読みによって持ってきた値をキャッシュし、内在するメモリーが最初のメ
モリー読み以降に変更された場合でも、同じメモリーにアクセスするシェーダー呼び出し
に同じ値を返すことができる。``coherent`` と宣言されていない変数は、シェーダー呼
び出し間の通信には役立たないかもしれないが、非密着式のアクセスを使用することで、
より高いパフォーマンスが得られる可能性がある。

----

修飾子 ``volatile`` を使用して宣言された画像変数へのメモリーアクセスは、シェー
ダー実行中の任意の時点で、実行中のシェーダー呼び出し以外のソースによって読み書き
される可能性があるかのように、内在するメモリーを扱わなければならない。
``volatile`` 変数が読み取られた場合、その値は、読み取りを実行するシェーダー呼び
出しが以前に同じメモリーからその値を持ってきていたとしても、内在するメモリーから
再取得されなければならない。``volatile`` 変数が書き込まれた場合、その値が後続の
書き込みによって上書きされることをコンパイラーが明確に判断したとしても、その値は
内在するメモリーに書き込まれなければならない。``volatile`` 変数を読み書きする外
部ソースは別のシェーダー呼び出しである可能性があるため、``volatile`` 宣言された
変数は自動的に ``coherent`` として扱われる。

----

修飾子 ``restrict`` を使って宣言された画像変数へのメモリーアクセスは、メモリーア
クセスを行うために使用される変数が、当該シェーダー段階を使って内在するメモリーに
アクセスする唯一の方法であると仮定してコンパイルすることができる。これにより、コ
ンパイラーは他のコードが内在する画像を読み書きしないと仮定できるので、非
``restrict`` 画像変数では許可されない方法で、``restrict`` 画像変数を使用して
ロードや格納をまとめたり、並べ替えたりすることができます。アプリケーションは
``restrict`` 変数が参照する画像メモリーが同じスコープの他の変数から参照されない
ようにする責任がある。

----

修飾子 ``readonly`` を使用して宣言された画像変数へのメモリーアクセスは内在するメ
モリに対する読み取りのみ可能で、読み取り専用のメモリーとして扱われ、書き込みはで
きない。``readonly`` 画像変数を ``imageStore()`` やその他画像メモリーを変更する
組み込み関数に渡すとコンパイルエラー。

----

修飾子 ``writeonly`` を使用して宣言された画像変数へのメモリーアクセスは内在する
メモリーに対する書き込みのみ可能で、内在するメモリーを読み取ることはできない。
``writeonly`` 画像変数を ``imageLoad()`` やその他画像メモリーを読み込む組み込み
関数に渡すとコンパイルエラー。

----

変数を ``readonly`` と ``writeonly`` の両方で修飾して、読み込みと書き込みの両方
を禁止することもできる。このような変数でも、``imageSize()`` や ``.length()`` な
ど、いくつかの問い合わせで使用することができる。

記憶修飾子 ``coherent``, ``volatile``, ``restrict``, ``readonly``, ``writeonly``
は、バッファー変数（つまりシェーダー格納ブロックのメンバー）の宣言に使用できる。
バッファー変数が記憶修飾子付きで宣言されている場合、上述の画像変数を含むメモリー
アクセスに指定された動作は、そのバッファー変数を含むメモリーアクセスにも同じよう
に適用される。``readonly`` バッファー変数への代入や ``writeonly`` バッファー変数
からの読み出しはコンパイルエラー。``readonly writeonly`` の組み合わせは可能。

さらに、シェーダー格納ブロックのブロックレベルの宣言では、``readonly writeonly``
の組み合わせを含む記憶修飾子を使用することができる。ブロック宣言が記憶修飾子で修
飾されている場合、そのブロックのすべてのメンバーが同じ記憶修飾子で宣言されている
かのようになる。例えば、

.. code:: glsl

   coherent buffer Block {
       readonly vec4 member1;
       vec4 member2;
   };

このブロック宣言は次のものに等価だ：

.. code:: glsl

   buffer Block {
       coherent readonly vec4 member1;
       coherent vec4 member2;
   };

記憶修飾子は画像変数、バッファー変数、シェーダー格納ブロックの宣言でしか対処され
ていない。その他の宣言でこれらの修飾子を使用するとエラーとなる。

ユーザー定義関数を呼び出す際、``coherent``, ``volatile``, ``readonly``,
``writeonly`` で修飾された変数を、そのような修飾語がない仮引数を持つ関数に渡すこ
とはできない。仮引数に記憶修飾子を追加することは合法だが、修飾子 ``restrict`` を
持たない仮引数が呼び出し引数から取り去ることができるのは ``restrict`` だけだ。

組み込み関数が呼び出されたとき、生成されるコードは実引数の実際の修飾子に基づくも
のであり、プロトタイプの仮引数に指定された記憶修飾子のリストに基づくのではない。

.. code:: glsl

   vec4 funcA(restrict image2D a) { ... }
   vec4 funcB(image2D a) { ... }
   layout(rgba32f) uniform image2D img1;
   layout(rgba32f) coherent uniform image2D img2;

   funcA(img1);        // OK, adding "restrict" is allowed
   funcB(img2);        // illegal, stripping "coherent" is not

レイアウト修飾子は仮引数には使用できず、引数照合処理に含まれない。

画像変数の宣言で ``const`` を使用すると、参照する画像ではなく、宣言されている変
数の ``const`` 性を修飾することに注意してください。修飾子 ``readonly`` は（その
変数を介してアクセスされる）画像メモリーを修飾し、修飾子 ``const`` は変数自体を
修飾する。

.. _khronos18-4.11:

4.11. Specialization-Constant Qualifier
---------------------------------------------------------------------------------

特殊化定数は SPIR-V でのみ使用され、レイアウト修飾子 ``constant_id`` を使用して
宣言される。例えば：

.. code:: glsl

   layout(constant_id = 17) const int arraySize = 12;

これは既定値が 12 である特殊化定数を作る。17 という数字は、API や他のツールが後
でこの独特な特殊化定数を参照するために、著者が選んだ例示的な ID だ。それが final
lowering 前に決して変更されなければ 12 の値を維持する。スカラー ``bool``,
``int``, ``uint``, ``float``, ``double`` の SPIR-V 生成以外で修飾子
``constant_id`` を使用するとコンパイルエラー。

組み込み定数を特殊化定数として宣言することができる。例えば：

.. code:: glsl

   layout(constant_id = 31) gl_MaxClipDistances; // add specialization_id

この宣言では、先に宣言された組み込み変数の名前だけを使用し、レイアウト修飾子
``constant_id`` 宣言をしている。定数が使用された後にこれを行うとコンパイルエラー
となる。定数は厳密に非特殊化定数か特殊化定数のどちらか一方であり、両方ではない。

組み込み定数ベクトル ``gl_WorkGroupSize`` は、修飾子 ``local_size_{x,y,z}_id``
を使って、成分に個別に ID を与えることで特殊化できる。例えば：

.. code:: glsl

   layout(local_size_x_id = 18, local_size_z_id = 19) in;

``gl_WorkGroupSize.y`` は非特殊化定数として残され、``gl_WorkGroupSize`` は部分的
に特殊化されたベクトルとなる。その ``x``, ``z`` 成分は、SPIR-V を生成した後にID
18 および 19 を使用して、後で特殊化することができる。これらの ID は作業グループ
サイズの宣言とは別に宣言される。

.. code:: glsl

   layout(local_size_x = 32, local_size_y = 32) in;   // size is (32,32,1)
   layout(local_size_x_id = 18) in;                   // constant_id for x
   layout(local_size_z_id = 19) in;                   // constant_id for z

``local_size_{xyz}`` の宣言に関する既存の規則は変化しない。
``local_size_{xz}_id`` については、同じ ID に異なる ID 値を与えたり、使用後に ID
値を与えたりするとコンパイルエラーとなる。それ以外では、順序、配置、文の個数、お
よび複製はエラーにならない。

特殊化定数でサイズ調整された二つの配列は、同じ記号でサイズ調整され、かつ演算を伴
わない場合に限り、同じ型となる。例えば：

.. code:: glsl

   layout(constant_id = 51) const int aSize = 20;
   const int pad = 2;
   const int total = aSize + pad; // specialization constant
   int a[total], b[total];        // a and b have the same type
   int c[22];                     // different type than a or b
   int d[aSize + pad];            // different type than a, b, or c
   int e[aSize + 2];              // different type than a, b, c, or d

.. admonition:: 読者ノート

   なぜこのようになるのか説明できるか？

特殊化定数でサイズ調整された配列を含む型を比較すること、集約として代入すること、
初期化を使って宣言すること、初期化として使用することができない。ただし、同じ型の
仮引数を持つ関数の実引数として渡すことはできる。配列の配列として宣言された変数の
最も外側の次元しか特殊化定数とはならず、そうでなければコンパイルエラーとなる。

ブロック内の配列のサイズを特殊化定数で指定することはできるものの、ブロックは静的
レイアウトを有するようになる。特殊化サイズを変化させても、ブロックは再配置されな
い。明示的なオフセットがない場合は、そのレイアウトは配列の既定サイズに基づいたも
のになる。

4.12. Order and Repetition of Qualification
---------------------------------------------------------------------------------

一つの宣言に修飾子が複数ある場合、それらの順序は何でもよいが、型の前にすべて置か
なければならない。修飾子 ``layout`` は、一度を超えて現れることができる唯一の修飾
子だ。さらに、一つの宣言は、格納修飾子、補助格納修飾子、補間修飾子を高々一つ持て
る。``inout`` が使用された場合、``in`` も ``out`` も使用できまない。記憶修飾子を
複数使用することができる。これらの規則に違反すると、コンパイルエラーとなる。

4.13. Empty Declarations
---------------------------------------------------------------------------------

**空宣言** (empty declarations) とは、変数名のない宣言のことであって、その宣言に
よってインスタンス化されるオブジェクトがないことを意味する。一般的に、空宣言は許
されている。構造体を宣言するときに便利なものもあれば、何の効果もないものもある。
例えば：

.. code:: glsl

   int;               // No effect
   struct S {int x;}; // Defines a struct S

コンパイルエラーやリンクエラーが発生する修飾子の組み合わせは、例えば、宣言が空で
あってもなくても同じだ。

.. code:: glsl

   invariant in float x; // Error. An input cannot be invariant.
   invariant in float;   // Error even though no variable is declared.
