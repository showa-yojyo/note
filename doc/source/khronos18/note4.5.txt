4.5. Interpolation Qualifiers
---------------------------------------------------------------------------------

補間される可能性のある入力および出力は、以下の補間修飾子のうち高々一つによって
さらに修飾される：

.. csv-table::
   :delim: @
   :header: 修飾子, 意味

   ``smooth`` @ 透視図法的補正補間
   ``flat`` @ 補間なし
   ``noperspective`` @ 線形補間

補間の有無と型は上記の補間修飾子と補助格納修飾子 ``centroid`` と ``sample``
によって制御される。
補間修飾子がない場合は ``smooth`` 補間が行われる。
複数の補間修飾子を使用するとコンパイルエラーとなる。
補助格納修飾子 ``patch`` は補間には使用されない。
補間修飾子を ``patch`` と共に使用するとコンパイルエラーとなる。

``flat`` と指定された変数は補間されない。
代わりに、基本形状内の断片みんなに対して同じ値を持つ。
この値は、API で説明されているように、単一の provoking vertex から得られる。
``flat`` と修飾された変数は ``centroid`` や ``sample`` と修飾されることもあり、
これは ``flat`` としか修飾されていないのと同じ意味になる。

.. admonition:: コメント

   この provoking vertex とは？

``smooth`` と修飾された変数は、レンダリングされている基本形状の上に、
透視図法的な補正による方法で補間される。遠近法的に正しい方法での補間は、
OpenGL 仕様の式 14.7 および 14.5 "Line Segments" で規定されている。

``nonperspective`` と修飾された変数は、OpenGL 仕様書 3.5 "Line Segments" の
式 3.7 で述べられているに、スクリーン空間内で線形に補間しなければならない。

多重採取ラスタライズが無効の場合、または ``centroid`` 修飾も ``sample`` 修飾もない
断片シェーダー入力変数の場合、割り当てられた変数の値は、
OpenGL 仕様で許可されている範囲内で、画素内の任意の場所に補間することができ、
画素内の各標本に単一の値を割り当てることができる。

多重採取ラスタライズが有効な場合、
``centroid`` と ``sample`` を使用して、修飾された断片シェーダー入力の
採取位置と頻度を制御することができる。断片シェーダー入力が
``centroid`` で修飾されている場合、その変数には画素内のすべての標本に対して
単一の値を割り当てることができるが、その値は、基本形状で網羅されている画素の標本を含めて、
画素とレンダリングされている基本形状の両方に位置する場所で補間されなければならない。
変数が補間される位置は隣接する画素で異なる可能性があり、
微係数は隣接する画素間の差を計算することで算出されるため、
``centroid`` 採取された入力の微係数は、
``centroid`` 以外で補間された変数のそれよりも精度が低い可能性がある。
断片シェーダーの入力が ``sample`` で修飾されている場合、その変数には、
画素内の網羅された標本ごとに個別の値が割り当てられなければならず、
その値は個々の標本の位置で採取されなければならない。

同一段階内で同じ名前の変数の補間修飾子が一致しないとリンクエラーになる。

4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

互換性プロファイルを使用する場合、次の宣言済み変数を補間修飾子付きで再宣言できる。

* 頂点、細分化制御、細分化評価、幾何の各言語

  * ``gl_FrontColor``
  * ``gl_BackColor``
  * ``gl_FrontSecondaryColor``
  * ``gl_BackSecondaryColor``

* 断片言語

  * ``gl_Color``
  * ``gl_SecondaryColor``

例：

.. code:: glsl

   in vec4 gl_Color;            // predeclared by the fragment language
   flat in vec4 gl_Color;       // redeclared by user to be flat
   flat in vec4 gl_FrontColor;  // input to geometry shader, no "gl_in[]"
   flat out vec4 gl_FrontColor; // output from geometry shader

理想的には、:ref:`7.1.7. Compatibility Profile Built-In Language Variables`
で記述されるように、
インターフェイスブロックの再宣言の一部としてこれらを再宣言する。
しかし、上記の目的のために、インターフェイスブロックの外部で、
大域スコープの個々の変数として再宣言することもできる。
このような再宣言をすると、出力変数に変換反響修飾子である
``xfb_buffer``, ``xfb_stride``, ``xfb_offset`` を付けることもできる。

* 変数上の ``xfb_buffer`` は大域既定バッファーを変化させない。

シェーダーが、インタフェイスブロックの再宣言と、そのインタフェイスブロックの
メンバーの再宣言を、このインタフェースブロックの再宣言の外側で別々に行うと、
コンパイルエラーになる。

``gl_Color`` が補間修飾子で再宣言された場合、
``gl_FrontColor`` と ``gl_BackColor`` も同じ補間修飾子で再宣言されなければならず、
その逆もまた然り。
``gl_SecondaryColor`` が補間修飾子付きで再宣言されたならば、
``gl_FrontSecondaryColor`` と ``gl_BackSecondaryColor`` も同じ補間修飾子付きで
再宣言されなければならず、その逆もまた然り。
このような、宣言済みの変数に対する修飾子の符合判定は、
プログラム中のシェーダー内で静的に使用される変数に対してのみ必要だ。

4.6. Parameter Qualifiers
---------------------------------------------------------------------------------

精度修飾子とメモリー修飾子に加えて、次のパラメータ修飾子を引数に付けることができる：

.. csv-table::
   :delim: @
   :header: 修飾子, 意味

   なし（既定） @ ``const`` と同じ
   ``const`` @ 書き込めない引数
   ``in`` @ 関数に渡される引数
   ``out`` @ 関数に渡される引数のうち、初期化されていないもの
   ``inout`` @ 関数の中と外の両方に渡される引数

引数修飾子については :ref:`6.1.1. Function Calling Conventions` に記述がある。

4.7. Precision and Precision Qualifiers
---------------------------------------------------------------------------------

Vulkan を対象にしていない場合：
精度修飾子は OpenGL ES とのコードの可搬性のために追加されたものであって、機能的なものではない。
精度修飾子は OpenGL ES と同じ構文を持ちますが、セマンティックな意味はなく、
変数の格納や演算に使用される精度にも影響しない。
拡張機能が OpenGL ES 2.0 仕様の精度修飾子と同じセマンティクスと機能を追加する場合は、
その目的のために本節で記述されるキーワードを再利用することができる。

Vulkan を対象とする場合：
インターフェイスの照合処理では、一様変数、一様ブロック、バッファーブロックメンバーは、
同じ精度修飾を持たなければならない。
同じシェーダー段階にリンクされていて異なるコンパイル単位で宣言された大域変数は、
同じ精度修飾子で宣言されなければならない。

あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判断する目的では、
精度修飾子が一致する必要はない。

4.7.1. Range and Precision
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``highp`` 単精度および倍精度浮動小数点変数の精度は 32 ビットおよび 64 ビット
浮動小数点数の IEEE 754 規格により定義される。

これには、NaN と Inf、および正と負のゼロの対処が含まれる。

以下の規則は、単精度と倍精度の演算の両方で ``highp`` に適用される。
符号付きの無限大とゼロは、IEEE の規定に従って生成されるが、
次の表（省略）で許可されている精度が適用される。
シェーダーに入力された非正規化値、またはシェーダー内の任意の演算で潜在的に生成される値は、
0 に flush することができる。
丸めモードは設定することができず、未定義だが、結果に 1ULP 以上の影響を与えてはならない。
NaN を生成する必要はない。
NaN の signaling の対処は必須ではなく、例外は決して発生しない。
NaN を操作する組み込み関数を含む操作は、結果として NaN を返す必要はない。
しかし、NaN が生成された場合 ``isnan()`` は正しい値を返さなければならない。

特に断りのない限り、精度は ULP 単位で最大相対誤差で表される。

単精度演算の場合、精度は以下のように（略）求められる。

.. admonition:: コメント

   ちょっとした表が入るが、省略。

上記の操作から作られた式を持つ、仕様書で定義された組み込み関数は、上記の誤差を継承する。

これらには、例えば、幾何関数、共通関数、および多くの行列関数が含まれる。
上記に記載されておらず、上記の方程式で定義されていない組み込み関数は、精度が未定義だ。
例えば、三角関数や行列式などが該当する。

倍精度演算の精度は、少なくとも単精度のそれはある。

4.7.2. Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

単精度浮動小数点型、整数型、不透明型宣言では、これらの精度修飾子の一つを型の前に
付けることができる：

.. csv-table::
   :delim: @
   :header: 修飾子, 意味

   ``highp`` @ 整数に対しては 32 ビット長 2の補数、浮動小数点数に対しては 32 ビット長 IEEE 754 浮動小数点
   ``mediump`` @ Vulkan を対象にしている場合は SPIR-V RelaxedPrecision, それ以外の場合はなし。
   ``lowp`` @ 同上

例：

.. code:: glsl

   lowp float color;
   out mediump vec2 P;
   lowp ivec2 foo(lowp mat3);
   highp mat4 m;

リテラル定数には精度修飾子がない。真偽変数にもない。コンストラクターにもない。

この段落で言う「操作」には演算子、組み込み関数、コンストラクターを含み、
「オペランド」には関数実引数とコンストラクター実引数を含むことにする。
演算を内部的に評価するために使用される精度と、その後に生じる中間値に関連する精度修飾子は、
演算によって消費されるオペランドの最高精度修飾子と少なくとも同じでなければならない。

オペランドが精度修飾子を持たない場合には、精度修飾子は他のオペランドから得られる。
精度修飾子のあるオペランドがない場合は、式の中で次に消費される演算のオペランドの
精度修飾子が使用される。
この規則は、精度修飾されたオペランドが見つかるまで再帰的に適用することができる。
必要に応じて、代入のための左辺値の精度修飾、初期化子のための被宣言変数の精度修飾、
関数呼び出し実引数に対する仮引数の精度修飾、関数戻り値のための関数戻り型の
精度修飾も含まれる。
この方法で精度が決定できない場合、例えば、式全体が精度修飾子のないオペランドだけ
で構成されていて、
その結果が代入されたり実引数として渡されたりしない場合は、その型の既定精度
あるいはそれ以上で評価される。
断片シェーダーでこのような事態が発生した場合、既定の精度を定義する必要がある。

例えば、次の文を考える：

.. code:: glsl

   uniform highp float h1;
   highp float h2 = 2.3 * 4.7; // operation and result are highp precision
   mediump float m;
   m = 3.7 * h1 * h2; // all operations are highp precision
   h2 = m * h1; // operation is highp precision
   m = h2 - h1; // operation is highp precision
   h2 = m + m; // addition and result at mediump precision
   void f(highp float p);
   f(3.3); // 3.3 will be passed in at highp precision

精度修飾子は、他の修飾子と同様に、変数の基本型には影響しない。
特に、精度変換のためのコンストラクターはない。コンストラクターは型を変換するだけだ。
同様に、精度修飾子は、他の修飾子と同様に、引数型に基づく関数のオーバーロードには関与しない。
:ref:`6.1.1. Function Calling Conventions` で述べられているように、
関数入出力はコピーによって行われるので、修飾子は一致しなくても構わない。

変数の精度はその変数が宣言された時点で決定され、その後変化することはあり得ない。

This rule does not affect the precision qualification of the expression.
定整数式または定浮動小数点式の精度が指定されていない場合、評価は ``highp`` で行われる。
この規則は式の精度修飾には影響しない。

定数式の評価は不変でなければならず、通常はコンパイル時に実行される。

4.7.3. Default Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

精度文

| ``precision`` *precision-qualifier* *type*;

を既定精度修飾子を設定するために使用することができる。
*type* 欄は ``int``, ``float``, 不透明型のいずれかであり、
*precision-qualifier* には ``lowp``, ``mediump``, ``highp`` が宣言される。

これ以外の型や修飾子を指定するとコンパイルエラーになる。
``type`` が ``float`` の場合、この指令は精度修飾のない単精度浮動小数点型
（スカラー、ベクトル、行列）の宣言に適用される。
``type`` が ``int`` の場合は、精度修飾のない整数型（スカラー、ベクトルー、
符号あり、符号なし）の宣言に適用される。これには、大域変数宣言、関数戻り値宣言、
関数引数タ宣言、局所変数宣言が含まれる。

精度修飾のない宣言は、スコープ内にある直近の精度文で指定された精度修飾子を使用する。
``precision`` 文には変数宣言と同じスコープ規則がある。
複文の中で宣言された場合、その効果は宣言された最も内側の文の終わりで停止する。
入れ子になったスコープ内の精度文は、外側のスコープ内の精度文を上書きする。
同じ基本型に対する複数の精度文が同じスコープ内に現れることができ、
そのスコープ内で遅れて現れる文が早く現れる文を上書きする。

精度修飾子を受け付ける型に対する既定精度修飾子は ``highp`` だ。
精度修飾子を必要とする全ての型には既定精度があるので、精度修飾子の省略による
エラーはない。

4.7.4. Available Precision Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

組み込みマクロ ``GL_FRAGMENT_PRECISION_HIGH`` は 1 に定義されている：

.. code:: glsl

   #define GL_FRAGMENT_PRECISION_HIGH 1

このマクロは計算以外の言語すべてで使用できる。

4.8. Variance and the Invariant Qualifier
---------------------------------------------------------------------------------

この節でいうばらつき (variance) とは、異なるプログラムにある同じ式から異なる値が
得られる可能性を意味する。
例えば、異なるプログラムにある二つの頂点シェーダーがそれぞれ
``gl_Position`` を同じ式で設定し、その式への入力値が両方のシェーダーの実行時に
同じであるとする。
シェーダー二つが独立してコンパイルされているため、これらの実行時に
``gl_Position`` に代入される値が完全に同じではないことがあり得る。
この例では、多重パスアルゴリズムにおける幾何の alignment に問題が生じ得る。

一般的には、シェーダー間のこのようなばらつきは許容される。
特定の出力変数にそのようなばらつきがない場合、その変数は不変である (invariant)
と言われる。

4.8.1. The Invariant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

特定の出力変数が不変であることを保証するには、修飾子 ``invariant`` を使用する。
この修飾子を以前に宣言された変数が不変であることを修飾するのに使用することもできる：

.. code:: glsl

   invariant gl_Position; // make existing gl_Position be invariant
   out vec3 Color;
   invariant Color;       // make existing Color be invariant

または、変数が宣言されたときにその宣言の一部とする：

.. code:: glsl

   invariant centroid out vec3 Color;

不変性の候補はシェーダーの出力変数しかない。
ユーザー定義の出力変数と組み込み出力変数を含む。
不変宣言できるのは出力のみなので、あるシェーダー段階の出力は、
入力が不変宣言されていなくても後続段階の入力と一致します。

ブロック上の入力または出力インスタンス名は、組み込み変数を再宣言する際には使用されない。

キーワード ``invariant`` の後には、以前に宣言された識別子をカンマで区切って
列挙することができる。
``invariant`` の使用はすべて、大域スコープまたはブロックメンバー上で、
かつ ``invariant`` として宣言された変数が使用される前でなければならない。

特定の出力変数の不変性を二つのプログラムを横断して保証するには、次も成り立って
いなければならない：

* 出力変数が両方のプログラムで不変であると宣言されている。
* 出力変数に割り当てられた値に関与する式や制御フローで消費されるシェーダー入力変数
  すべてに同じ値を入力する必要がある。
* テクスチャーフォーマット、テクセル値、およびテクスチャーフィルタリングは、
  出力変数の値に関与するすべてのテクスチャー関数呼び出しに対して同じ方法に設定される。
* 入力値すべてが同じ方法ですべて操作される。
  消費される式と中間式の操作すべてが、評価の順序が同じになるように、オペランドの
  順序と結合性（左結合とか右結合とかのこと）を同じにしなければならない。
  中間変数と関数は、同じ明示的または暗黙的精度修飾子を持つ同じ型として宣言され
  なければならない。
  出力値に影響を与えるすべての制御フローは同じでなければならず、
  この制御フローを決定するために消費されるどんな式も、これらの不変性規則に
  従わなければならない。
* 不変出力変数を設定するためのデータフローと制御フローすべては、単一の
  コンパイル単位に宿る。

原則的に、不変出力に至るデータフローと制御フローのすべてで一致しなければならない。

初期状態では、既定で、すべての出力変数に ``variant`` が許されている。
すべての出力変数を強制的に ``invariant`` にするには、プラグマ：

.. code:: glsl

   #pragma STDGL invariant(all)

をシェーダー内のすべての宣言の前に使用する。
このプラグマがいずれかの変数や関数の宣言の後に使用された場合、不変の動作をする
出力集合は未定義となる。

一般に、不変性は最適化の柔軟性を犠牲にして確保されるため、
不変性を使用することでパフォーマンスが低下する可能性がある。
したがって、このプラグマの使用は、出力変数すべてを一つ一つ ``invariant`` と
宣言するのを避けるためのデバッグ支援を目的としている。

4.8.2. Invariance of Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

定数式には不変性が保証されなければならない。
特定の定数式は、それが同じシェーダーに現れようが異なるシェーダーに現れようが、
同じ結果になるように評価しなければならない。
これには、同じ式が同じ言語の二つのシェーダーに現れる場合と、
二つの異なる言語のシェーダーに現れる場合が含まれる。

定数式は、前述の不変変数と同様に操作しても、同じ結果に評価しなければならない。

4.9. The Precise Qualifier
---------------------------------------------------------------------------------

アルゴリズムの中には、ほぼ同等の結果をより高いパフォーマンスで得られる最適化を
対処している実装であっても、ソースコードで指定された演算順序に正確に従い、
すべての演算を着実に処理することを浮動小数点計算に要求するものがある。
例えば、多くの実装は、次のような浮動小数点式を計算する multiply-add 命令を
対処している：

.. code:: glsl

   result = (a * b) + (c * d);

これは三度の演算の代わりに二度で、すなわち、二度の乗算と一度の加算の代わりに、
一度の乗算と一度の multiply-add 演算を行う。

浮動小数点の multiply-add 結果は、最初に浮動小数点の結果が得られる乗算を行ってから
浮動小数点の加算を行った場合と同じになるとは限らない。
したがって、この例では、二つの乗算はつじつまが合うようには扱われず、
二つの乗算は事実上、異なる精度であるように見える可能性がある。

一貫性を持たせる必要がある重要な計算は、細分化の際に現れる。
下図（注：本書には巨大な図式が掲載されている）のように、細分化のための中間点が
異なる方向に合成されるが、同じ結果を得る必要がある。

.. admonition:: コメント

   ここにあるイラストは、細分化を実装するようなプログラマーでないと理解できないものだと思う。

最適化されたコードが最適化されていないコードと比較してわずかに異なる結果をもたらす
かもしれなくても、実装は修飾子なしで、式の評価に使用される演算の順序または数を
効果的に変更する最適化を実行することが許可される。

修飾子 ``precise`` は変数の値に与する演算が、指定された順序で、
演算子の一貫性を持って行われることを保証する。演算子の順序は、
:ref:`5.1. Operators` で記述されているように、演算子の優先順位と括弧によって
決定される。演算子の一貫性とは、例えば乗算演算子 ``*`` のような特定の演算子について、
その演算が常に同じ精度で計算されることを意味する。
具体的には、コンパイラーで生成されたコードで計算された値は、以下の恒等式に
従わなければならない：

| a + b = b + a
| a * b = b * a
| a * b + c * d = b * a + c* d = d * c + b * a = <any other mathematically valid combination>

次を防ぐことができる一方：

* ``a + (b + c)`` が ``(a + b) + c`` になることは許されない。
* ``a * (b * c)`` が ``(a * b) * c`` になることは許されません。
* ``a * b + c`` が単一の演算 ``fma(a, b, c)`` になることは許されない 。

ここで ``a``, ``b`` ,``c`` ,``d`` は行列ではなく、スカラーまたはベクトルとする
（行列は一般には可換でない）。
これらの規則に基づいて計算を表現するのはシェーダー作成者の責任であり、
これらの規則に従うのはコンパイラーの責任だ。
細分化段階が従うべき規則については ``gl_TessCoord`` の説明を参照。
これらの規則は、上記と合わせて、細分化する際のひび割れを避けることができる。

例：

.. code:: glsl

   precise out vec4 position;

は ``position`` の値を生成するために使用される演算が、
ソースコードで指定された順序で正確に実行されなければならず、
すべての演算子が着実に扱われなければならないことを宣言している。
修飾子 ``invariant`` と同様に、修飾子 ``precise`` は組み込み変数や事前に宣言された
ユーザー定義変数が正確であることを修飾するために使用できる。

.. code:: glsl

   out vec3 Color;
   precise Color; // make existing Color be precise

ブロック、構造体型、または構造体型の変数に ``precise`` を適用すると、
変数のメンバーそれぞれに再帰的に ``precise`` を適用することになる。

この修飾子は、特定の関数内の右辺値の評価に影響を与えるが、
それは、その結果が最終的に同じ関数内で ``precise`` と修飾された左辺値によって
消費される場合に、かつその場合に限られる。
関数内の他の式は影響を受けない。これには、
``precise`` 宣言されていないが、関数の外で ``precise`` 修飾された変数によって
最終的に消費される戻り値や出力引数も含まれる。
影響を受けない式には、選択文と反復文と条件演算子の条件式とにある式を制御するもの
も含まれる。

``precise`` の使用例（略）。

あるシェーダー段階の出力が直後の段階の入力と一致するかどうかを判定する目的では、
修飾子 ``precise`` は入力と出力の間で一致する必要はない。

すべての定数式は ``precise`` が存在するかどうかにかかわらず、それが存在するかの
ように評価される。
ただし、コンパイル時の定数式が対応する非定数式と同じ値に評価されるという要件はない
(:ref:`4.3.3. Constant Expressions`)。

4.10. Memory Qualifiers
---------------------------------------------------------------------------------

シェーダー格納ブロックとその内側で宣言された変数と画像型
（キーワードに ``"image"`` を含む基本不透明型）として宣言された変数は、
以下（略）の記憶修飾子の一つまたは複数を追加的に修飾することができる：

.. csv-table::
   :delim: @
   :header: 修飾子, 意味

   ``coherent`` @ （面倒なので本文参照）
   ``volatile`` @
   ``restrict`` @
   ``readonly`` @
   ``writeonly`` @

修飾子 ``coherent`` を使って宣言された画像変数へのメモリーアクセスは、
他のシェーダー呼び出しからの同じ場所へのアクセスとともに密着的に実行される。
特に ``coherent`` 宣言された変数を読み出す場合、戻り値には、
他のシェーダー呼び出しで実行された以前に完了した書き込みの結果が反映される。
また、
``coherent`` 宣言された変数を書き込む場合、書き込まれた値は、
他のシェーダー呼び出しで実行された後の密着的読み込みに反映される。

OpenGL 仕様書の 7.12 "Shader Memory Access" にあるように、
シェーダーメモリーの読み取りと書き込みは、ほとんど定義されていない順序で行われる。
必要であれば、組み込み関数 ``memoryBarrier()`` を使って、
単一のシェーダー呼び出しで実行されるメモリーアクセスの完了と相対的な順序を保証できる。

``coherent`` と宣言されていない変数を使ってメモリーにアクセスする場合、
シェーダーがアクセスするそのメモリーは、同じアドレスへの将来のアクセスのために、
実装がキャッシュすることがある。
メモリー格納は、書き込まれた値が同じメモリーにアクセスする他のシェーダー呼び出しから
見えないような方法でキャッシュされることがある。
実装は、メモリー読みによって持ってきた値をキャッシュし、
内在するメモリーが最初のメモリー読み以降に変更された場合でも、
同じメモリーにアクセスするシェーダー呼び出しに同じ値を返すことができる。
``coherent`` と宣言されていない変数は、シェーダー呼び出し間の通信には役立たない
かもしれないが、非密着式のアクセスを使用することで、より高いパフォーマンスが
得られる可能性がある。

----

修飾子 ``volatile`` を使用して宣言された画像変数へのメモリーアクセスは、
シェーダー実行中の任意の時点で、実行中のシェーダー呼び出し以外のソースによって
読み書きされる可能性があるかのように、内在するメモリーを扱わなければならない。
``volatile`` 変数が読み取られた場合、その値は、読み取りを実行するシェーダー呼び出しが
以前に同じメモリーからその値を持ってきていたとしても、
内在するメモリーから再取得されなければならない。
``volatile`` 変数が書き込まれた場合、その値が後続の書き込みによって上書きされることを
コンパイラーが明確に判断したとしても、その値は内在するメモリーに書き込まれなければならない。
``volatile`` 変数を読み書きする外部ソースは別のシェーダー呼び出しである可能性があるため、
``volatile`` 宣言された変数は自動的に ``coherent`` として扱われる。

----

修飾子 ``restrict`` を使って宣言された画像変数へのメモリーアクセスは、
メモリーアクセスを行うために使用される変数が、
当該シェーダー段階を使って内在するメモリーにアクセスする唯一の方法であると仮定して
コンパイルすることができる。
これにより、コンパイラーは他のコードが内在する画像を読み書きしないと仮定できるので、
非 ``restrict`` 画像変数では許可されない方法で、
``restrict`` 画像変数を使用してロードや格納をまとめたり、
並べ替えたりすることができます。
アプリケーションは ``restrict`` 変数が参照する画像メモリーが
同じスコープの他の変数から参照されないようにする責任がある。

----

修飾子 ``readonly`` を使用して宣言された画像変数へのメモリーアクセスは
内在するメモリに対する読み取りのみ可能で、読み取り専用のメモリーとして扱われ、
書き込みはできない。
``readonly`` 画像変数を ``imageStore()`` やその他画像メモリーを変更する
組み込み関数に渡すとコンパイルエラー。

----

修飾子 ``writeonly`` を使用して宣言された画像変数へのメモリーアクセスは
内在するメモリーに対する書き込みのみ可能で、内在するメモリーを読み取ることはできない。
``writeonly`` 画像変数を ``imageLoad()`` やその他画像メモリーを読み込む
組み込み関数に渡すとコンパイルエラー。

----

変数を ``readonly`` と ``writeonly`` の両方で修飾して、読み込みと書き込みの両方を
禁止することもできる。このような変数でも、
``imageSize()`` や ``.length()`` など、いくつかの問い合わせで使用することができる。

記憶修飾子 ``coherent``, ``volatile``, ``restrict``, ``readonly``, ``writeonly`` は、
バッファー変数（つまりシェーダー格納ブロックのメンバー）の宣言に使用できる。
バッファー変数が記憶修飾子付きで宣言されている場合、上述の画像変数を含む
メモリーアクセスに指定された動作は、そのバッファー変数を含むメモリーアクセスにも
同じように適用される。
``readonly`` バッファー変数への代入や ``writeonly`` バッファー変数からの読み出し
はコンパイルエラー。
``readonly writeonly`` の組み合わせは可能。

さらに、シェーダー格納ブロックのブロックレベルの宣言では、
``readonly writeonly`` の組み合わせを含む記憶修飾子を使用することができる。
ブロック宣言が記憶修飾子で修飾されている場合、
そのブロックのすべてのメンバーが同じ記憶修飾子で宣言されているかのようになる。
例えば、

.. code:: glsl

   coherent buffer Block {
       readonly vec4 member1;
       vec4 member2;
   };

このブロック宣言は次のものに等価だ：

.. code:: glsl

   buffer Block {
       coherent readonly vec4 member1;
       coherent vec4 member2;
   };

記憶修飾子は画像変数、バッファー変数、シェーダー格納ブロックの宣言でしか対処
されていない。その他の宣言でこれらの修飾子を使用するとエラーとなる。

ユーザー定義関数を呼び出す際、
``coherent``, ``volatile``, ``readonly``, ``writeonly`` で修飾された変数を、
そのような修飾語がない仮引数を持つ関数に渡すことはできない。
仮引数に記憶修飾子を追加することは合法だが、修飾子 ``restrict`` を持たない
仮引数が呼び出し引数から取り去ることができるのは ``restrict`` だけだ。

組み込み関数が呼び出されたとき、生成されるコードは実引数の実際の修飾子に基づくものであり、
プロトタイプの仮引数に指定された記憶修飾子のリストに基づくのではない。

.. code:: glsl

   vec4 funcA(restrict image2D a) { ... }
   vec4 funcB(image2D a) { ... }
   layout(rgba32f) uniform image2D img1;
   layout(rgba32f) coherent uniform image2D img2;

   funcA(img1);        // OK, adding "restrict" is allowed
   funcB(img2);        // illegal, stripping "coherent" is not

レイアウト修飾子は仮引数には使用できず、引数照合処理に含まれない。

画像変数の宣言で ``const`` を使用すると、参照する画像ではなく、
宣言されている変数の ``const`` 性を修飾することに注意してください。
修飾子 ``readonly`` は（その変数を介してアクセスされる）画像メモリーを修飾し、
修飾子 ``const`` は変数自体を修飾する。

4.11. Specialization-Constant Qualifier
---------------------------------------------------------------------------------

特殊化定数は SPIR-V でのみ使用され、レイアウト修飾子 ``constant_id`` を使用して
宣言される。例えば：

.. code:: glsl

   layout(constant_id = 17) const int arraySize = 12;

If it is never changed before final lowering
これは既定値が 12 である特殊化定数を作る。
17 という数字は、API や他のツールが後でこの独特な特殊化定数を参照するために、
著者が選んだ例示的な ID だ。
それが final lowering 前に決して変更されなければ 12 の値を維持する。
スカラー ``bool``, ``int``, ``uint``, ``float``, ``double`` の SPIR-V 生成以外で
修飾子 ``constant_id`` を使用するとコンパイルエラー。

組み込み定数を特殊化定数として宣言することができる。例えば：

.. code:: glsl

   layout(constant_id = 31) gl_MaxClipDistances; // add specialization_id

この宣言では、先に宣言された組み込み変数の名前だけを使用し、
レイアウト修飾子 ``constant_id`` 宣言をしている。
定数が使用された後にこれを行うとコンパイルエラーとなる。
定数は厳密に非特殊化定数か特殊化定数のどちらか一方であり、両方ではない。

組み込み定数ベクトル ``gl_WorkGroupSize`` は、
修飾子 ``local_size_{xyz}_id`` を使って、成分に個別に ID を与えることで特殊化できる。
例えば：

.. code:: glsl

   layout(local_size_x_id = 18, local_size_z_id = 19) in;

``gl_WorkGroupSize.y`` は非特殊化定数として残され、
``gl_WorkGroupSize`` は部分的に特殊化されたベクトルとなる。
その ``x``, ``z`` 成分は、SPIR-V を生成した後に
ID 18 および 19 を使用して、後で特殊化することができる。
これらの ID は作業グループサイズの宣言とは別に宣言される。

.. code:: glsl

   layout(local_size_x = 32, local_size_y = 32) in;   // size is (32,32,1)
   layout(local_size_x_id = 18) in;                   // constant_id for x
   layout(local_size_z_id = 19) in;                   // constant_id for z

``local_size_{xyz}`` の宣言に関する既存の規則は変化しない。
``local_size_{xz}_id`` については、同じ ID に異なる ID 値を与えたり、
使用後に ID 値を与えたりするとコンパイルエラーとなる。
それ以外では、順序、配置、文の個数、および複製はエラーにならない。

特殊化定数でサイズ調整された二つの配列は、
同じ記号でサイズ調整され、かつ演算を伴わない場合に限り、同じ型となる。
例えば：

.. code:: glsl

   layout(constant_id = 51) const int aSize = 20;
   const int pad = 2;
   const int total = aSize + pad; // specialization constant
   int a[total], b[total];        // a and b have the same type
   int c[22];                     // different type than a or b
   int d[aSize + pad];            // different type than a, b, or c
   int e[aSize + 2];              // different type than a, b, c, or d

.. admonition:: コメント

   なぜこのようになるのか説明できるか？

特殊化定数でサイズ調整された配列を含む型を比較すること、集約として代入すること、
初期化を使って宣言すること、初期化として使用することができない。
ただし、同じ型の仮引数を持つ関数の実引数として渡すことはできる。
配列の配列として宣言された変数の最も外側の次元しか特殊化定数とはならず、
そうでなければコンパイルエラーとなる。

ブロック内の配列のサイズを特殊化定数で指定することはできるものの、ブロックは
静的レイアウトを有するようになる。
特殊化サイズを変化させても、ブロックは再配置されません。
明示的なオフセットがない場合は、そのレイアウトは配列の既定サイズに基づいたものになる。

4.12. Order and Repetition of Qualification
---------------------------------------------------------------------------------

一つの宣言に修飾子が複数ある場合、それらの順序は何でもよいが、型の前にすべて
置かなければならない。
修飾子 ``layout`` は、一度を超えて現れることができる唯一の修飾子だ。
さらに、一つの宣言は、格納修飾子、補助格納修飾子、補間修飾子を高々一つ持てる。
``inout`` が使用された場合、
``in`` も ``out`` も使用できまない。
記憶修飾子を複数使用することができる。
これらの規則に違反すると、コンパイルエラーとなる。

4.13. Empty Declarations
---------------------------------------------------------------------------------

**空宣言** (empty declarations) とは、変数名のない宣言のことであって、
その宣言によってインスタンス化されるオブジェクトがないことを意味する。
一般的に、空宣言は許されている。
構造体を宣言するときに便利なものもあれば、何の効果もないものもある。
例えば：

.. code:: glsl

   int;               // No effect
   struct S {int x;}; // Defines a struct S

コンパイルエラーやリンクエラーが発生する修飾子の組み合わせは、
例えば、宣言が空であってもなくても同じだ。

.. code:: glsl

   invariant in float x; // Error. An input cannot be invariant.
   invariant in float;   // Error even though no variable is declared.
