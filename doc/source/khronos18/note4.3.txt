4.3. Storage Qualifiers
----------------------------------------------------------------------

変数宣言では、型の前に高々一つの格納修飾子を指定することができる。

.. glossary::

   （格納修飾子なし：既定値）
       局所的な読み書き可能なメモリー、または関数の入力引数。

   ``const``
       値を変更することができない変数。

   ``in``
       前の段階のシェーダーにリンケージを持つ場合、変数が入力コピーされる。

   ``out``
       シェーダの後段へにリンケージを持つ場合、変数が出力コピーされる。

   ``attribute``
       互換性プロファイルおよび頂点言語のみ。頂点シェーダーの場合は ``in`` と同
       じ。

   ``uniform``
       処理される基本形状間で値が変化しない、一様変数はシェーダー、API, アプリ
       ケーション間のリンクを形成する。

   ``varying``
       互換性プロファイルのみ、頂点言語および断片言語のみ。頂点シェーダーの場合
       は ``out`` と同じ。断片シェーダーの場合は ``in`` と同じ。

   ``buffer``
       値はバッファーオブジェクトに格納され、シェーダー呼び出しと API の両方で読
       み書きできる。

   ``shared``
       計算シェーダーのみ。変数格納は作業グループ内のすべての作業項目で共有され
       る。

入出力修飾変数の中には、高々一つの補助格納修飾子を追加できるものがある。

.. glossary::

   ``centroid``
      重心基準補間
   ``sample``
      一標本ごとの補間
   ``patch``
      細分化一パッチごとの属性

すべての修飾子の組み合わせが許されるわけではない。補助格納修飾子は ``in`` または
``out`` 修飾子と一緒にしか使用できない。その他の修飾子の規則については、以降の節
で説明。

局所変数は ``const`` 修飾子のみ使用できる（または格納修飾子を使用しない）。

関数の引数には ``const``, ``in``, ``out`` を使用できるが、引数修飾子としては使用
できないことに注意。引数修飾子については:ref:`khronos18-6.1.1` を参照。

関数の戻り値の型や構造体のメンバーには格納修飾子を使用しない。

大域宣言の初期化子は、格納修飾子がないか、``const`` 修飾子があるか、または
``uniform`` 修飾子がある大域変数の宣言でしか使用できない。

格納修飾子のない大域変数は、その宣言またはアプリケーションで初期化されないと、初
期化されずに未定義の値で ``main()`` に入る。

あるシェーダー段階の出力と後続のシェーダー段階の入力を比較するとき、補助修飾子
（またはその欠落）が同じでない場合、入力と出力は一致しない。

4.3.1. Default Storage Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

大域変数に修飾子がない場合、その変数はアプリケーションや他のパイプライン段階で実
行されるシェーダーとはリンクしていない。大域変数でも局所変数でも、修飾されていな
い変数では、宣言は対象となる処理器に関連するメモリーが割り当てられているように見
える。この変数は、この割り当てられたメモリーへの読み取り・書き込みアクセスを提供
する。

.. admonition:: 読者ノート

   意味不明。

4.3.2. Constant Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

名前付きのコンパイル時定数や読み取り専用の変数は ``const`` 修飾子を使って宣言で
きる。``const`` 修飾子は、非 ``void`` 透過基本データ型や、それらの構造体や配列で
使用できる。宣言されていない ``const`` 変数に書き込むコードはコンパイルエラーと
なるから、宣言時に初期化する必要がある。

.. code:: glsl

   const vec3 zAxis = vec3(0.0, 0.0, 1.0);
   const float ceiling = a + b; // a and b not necessarily constants

構造体のメンバーは ``const`` で修飾することはできない。構造体変数は ``const`` と
して宣言し、構造体のコンストラクターまたは初期化子で初期化できる。

大域スコープでの ``const`` 宣言の初期化子は、次節で定義されるように、定数式でな
ければならない。

.. _khronos18-4.3.3:

4.3.3. Constant Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SPIR-V の特殊化定数は、:ref:`khronos18-4.11` で記述されるように、GLSL では
``const`` にレイアウト修飾子 ``const_id`` を付けて表現される。

**定数式** (a constant expression) とは次のいずれかだ：

* リテラル値
* ``const`` 修飾子と初期化子で宣言された変数で、初期化子が定数式であるもの。これ
  は ``layout(const_id = ...)`` のような特殊化定数レイアウト修飾子を付けて宣言さ
  れた``const`` と、特殊化定数レイアウト修飾子を付けずに宣言された ``const`` の
  両方を含む。
* ``const`` として修飾された組み込み変数。
* 定数配列の要素、定数構造体のメンバー、定数ベクトルの構成要素の取得など、すべて
  定数式であるオペランドに対して演算子で形成される式。
* オブジェクト自体が定数であるかどうかに関わらず、明示的なサイズのオブジェクトに
  対する ``length()`` メソッドの適切な使用（暗黙的なサイズの配列や実行時サイズの
  配列は定数式を返さない）。
* 引数がすべて定数式であるコンストラクター。
* 非特殊化定数の場合のみ：引数がすべて定数式である特定の組み込み関数の呼び出しの
  戻り値（少なくとも以下のリストを含む）。メモリーにアクセスしないその他の組み込
  み関数（テクスチャー探索関数、画像アクセス、不可分計数器などを除く）であって、
  戻り値の型が非 ``void`` で ``out`` 引数がなく、ノイズ関数ではないものも定数と
  みなされる場合がある。関数が特殊化定数である引数で呼び出された場合、その結果は
  定数式ではない。

  * 角度および三角関数
  * 指数関数
  * 普通の関数
  * 幾何関数

* ユーザー定義関数（非組み込み関数）の関数呼び出しは、定数式には使用できない。

----

**定整数式** (a constant integral expression) とは定数式であって、スカラーの符号
付きまたは符号なしの整数に評価されるものだ。

定数式は不変的な方法で評価されるため、複数のシェーダーに同じ定数式が現れた場合、
同じ値が生成される。:ref:`khronos18-4.8.1`, :ref:`khronos18-4.7.2` を参照。

定数式は ``precision`` 修飾子と ``invariant`` 修飾子を尊重するが、そのような修飾
子の使用とは関係なく、常に不変的に評価されるため、複数のシェーダーに同じ定数式が
現れた場合には、同じ値が生成される。

定数式はホストプラットフォームで評価される可能性がある。それゆえ同じ式がシェー
ダー実行対象で評価するような値と同じものを計算する必要はない。ただし、ホストは対
象が使用するのと同じか、それ以上の精度を使用しなければならない。精度修飾子が決定
できない場合、式は ``highp`` で評価される。 :ref:`khronos18-4.7.3` 参照。

特殊化定数式は、コンパイラーのフロントエンドでは評価されないで、
代わりに、後でホスト上で評価するために必要な式の操作を留めておく。

.. _khronos18-4.3.4:

4.3.4. Input Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

シェーダーの入力変数は ``in`` 格納修飾子で宣言される。この変数は、API パイプライ
ンの前段階と宣言したシェーダーとの間の入力インターフェイスを形成する。入力変数は
大域スコープで宣言しなければならない。前のパイプライン段階から来る値は、シェー
ダー実行開始時に入力変数にコピーされる。入力として宣言された変数に書き込むコード
はコンパイルエラーとなる。

前の段階で書き込む必要があるのは、静的に読み込まれる入力変数だけであり、入力変数
の宣言が余計に付いていても構わない。

.. admonition:: 読者ノート

   本文ではこのことをまとめた表がここに示されているが、割愛する。

消費エラーは静的な使用にしかよらない。未定義の値を消費する可能性のある動的な使用
方法をコンパイラーが推論する場合、エラーではなく警告を発する。組み込み入力名の一
覧は :ref:`khronos18-7` を参照。

頂点シェーダーの入力変数（または属性）は、頂点ごとのデータを受け取る。頂点シェー
ダー入力に補助格納修飾子や補間修飾子を使用すると、コンパイルエラーとなる。コピー
された値は API またはレイアウト識別子 ``location`` の使用により設けられる。

以下の型で頂点シェーダー入力を宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型
* 構造体

----

頂点シェーダーにおける入力宣言の例を示す：

.. code:: glsl

   in vec4 position;
   in vec3 normal;
   in vec2 texCoord[4];

----

グラフィックスハードウェアでは、頂点入力を渡すための固定のベクトル場所が足りない
ことが予想される。そのため、OpenGL Shading Language では、行列以外の入力変数は、
そのようなベクトル位置を一つ使用すると定義している。使用できる場所の数には実装依
存の制限があり、これを超えるとリンクエラーが発生する（静的使用でないと宣言された
入力変数は、この制限に含まれない）。スカラー入力は ``vec4`` と同じようにカウント
されるので、アプリケーションでは、内在するハードウェアの性能をよりよく活用するた
めに、関係のない 4 つの ``float`` 入力のグループをまとめてベクトルにすることを検
討するとよいだろう。行列入力は、複数の場所を使用する。使用される場所の数は、行列
の列数と同じだ。

細分化制御、細分化評価、幾何シェーダーの入力変数は、前のアクティブシェーダー段階
で同じ名前の出力変数によって書き出された、頂点ごとの値を取得する。これらの入力で
は ``centroid`` や補間修飾子が使えるが、効果はない。細分化制御、細分化評価、幾何
シェーダーは頂点集合を操作するので、各入力変数（または入力ブロック、下記のイン
ターフェイスブロックを参照）は配列として宣言する必要がある。

.. code:: glsl

   in float foo[]; // geometry shader input for vertex "out float foo"

このような配列の各要素は、処理される基本形状の一つの頂点に対応する。各配列はオプ
ションでサイズを宣言することができる。幾何シェーダーの場合、配列のサイズ
は、:ref:`khronos18-4.4.1`のように、入力基本形状の型を設定する入力 ``layout`` 宣
言によって設定される。

----

入力と出力は配列されているものもある。これは、シェーダー段階二つの間にあるイン
ターフェイスでは、入力または出力の宣言を一致させるために、余分なレベルの配列イン
デックスが必要になることを意味する。例えば、頂点シェーダーと幾何シェーダーのイン
ターフェイスでは、頂点シェーダーの出力変数と幾何シェーダーの入力変数の同名の変数
は、型が一致していなければならない。ただし、幾何シェーダーは、頂点のインデックス
付けを可能にするために、頂点シェーダーよりも 1 多い配列次元を持つことになる。こ
のように配列されたインターフェイス変数が、必要である追加的入力・出力配列次元で宣
言されていない場合、リンクエラーとなる。幾何シェーダー入力、細分化制御シェーダー
入出力、細分化評価入力はすべて、他のシェーダー入出力に比べて追加的配列レベルを
持っている。これらの入力と出力は、頂点ごとに配列された (per-vertex-arrayed) 入力
と出力として知られている。配列されたインターフェイス
(``gl_MaxTessControlInputComponents``, etc.) の成分制限は、インターフェイス全体
に対する制限ではなく、頂点ごとの制限だ。

非配列のインターフェイス（＝段階間配列の次元が変わらない）では、入力変数が一致す
る出力変数と配列の次元を含めて同じ型で宣言されていないとリンクエラーとなる。

リンク時の型マッチング規則は、使用されているか否かに関わらず、宣言されたすべての
入力変数と出力変数に適用される。

さらに、細分化評価シェーダーは ``patch`` および ``in`` 修飾子で宣言された
``patch`` ごとの入力変数を対処している。パッチごとの入力変数には、細分化制御
シェーダーによって書き込まれたパッチごとの出力変数の値が入る。パッチごとの入力は
一次元配列として宣言できるが、頂点数によるインデックスは付けられない。入力への
``patch`` 修飾子の適用は、細分化評価シェーダでしか行えない。他の入力変数と同様
に、パッチごとの入力は、前の（細分化制御）シェーダー段階からのパッチごとの出力と
同じ型と修飾子を使って宣言しなければならない。他の段階の入力で ``patch`` を使用
することは、コンパイルエラーとなる。

細分化制御、細分化評価、幾何シェーダーの入力を、以下のいずれかの型で宣言するとコ
ンパイルエラーとなる：

* 真偽型
* 不透明型

----

断片シェーダーの入力は、前の段階の出力から補間された断片ごとの値をふつうは取得す
る。補助格納修飾子 ``centroid`` と ``sample`` も、補間修飾子 ``flat``,
``noperspective``, `smooth`` と同様に適用できる。

断片シェーダーの入力を次のいずれかの型で宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

整数型または倍精度浮動小数点型であるか、またはそれを含む断片シェーダー入力には補
間修飾子 ``flat`` が必要だ。

断片入力は以下の例のように宣言される：

.. code:: glsl

   in vec3 normal;
   centroid in vec2 TexCoord;
   invariant centroid in vec4 Color;
   noperspective in float temperature;
   flat in vec3 myColor;
   noperspective centroid in vec2 myTexCoord;

断片シェーダーの入力は、頂点処理パイプラインにおける最終アクティブシェーダーとの
インターフェイスを形成する。このインターフェイスでは、最終アクティブシェーダー段
階出力変数と断片シェーダーの入力変数の同名の変数は、いくつかの例外（格納修飾子の
一方は ``in`` で他方は ``out`` でなければならない）を除いて、型と修飾子が一致し
ていなければならない。また、補間修飾子や補助修飾子も異なる場合がある。これらのミ
スマッチは任意の段階対の間で許される。補間修飾子や補助修飾子が一致しない場合は、
断片シェーダーで提供される修飾子が前段階で提供される修飾子よりも優先される。断片
シェーダーにそのような修飾子が全くない場合は、前段階で宣言されていた修飾子ではな
く、既定の修飾子が使用される。つまり、重要なのは断片シェーダーで何が宣言されてい
るかであり、前段階のシェーダーで何が宣言されているかではないということだ。

----

シェーダー段階間のインターフェイスが別々のプログラムオブジェクトのシェーダーを
使って形成されている場合、プログラムがリンクされたときに入力と出力の間の不一致を
検出することはできない。このようなインターフェイスでは、入力と出力の間に不一致が
あると、インターフェイスを介して渡される値は、部分的にまたは完全に未定義となる。

シェーダーで入出力レイアウト修飾子 (:ref:`khronos18-4.4.1`,
:ref:`khronos18-4.4.2`) を使用するか、ブロックや変数の入力宣言と出力宣言を同一に
することで、このようなインターフェイス間のマッチングを担保することができる。イン
ターフェイスのマッチングに関する完全な規則は、OpenGL 仕様書の 7.4.1 "Shader
Interface Matching" に記載されている。

----

計算シェーダはユーザ定義の入力変数を許可せず、他のシェーダー段階との正式なイン
ターフェイスを形成しない。組み込みの計算シェーダー入力変数については
:ref:`khronos18-7.1.6` を参照。計算シェーダーへの他のすべての入力は、画像ロー
ド、テクスチャー取得、一様変数または一様バッファーからのロード、または他のユー
ザーコードによって明示的に取得される。計算シェーダーの組み込み入力変数を再宣言す
ることはできない。

4.3.5. Uniform Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. admonition:: 読者ノート

   英単語 uniform をどう訳したらしっくり来るだろうか。数学科専攻としては「一様」
   にしたい。中国語の仕様書を見たら「統一」に相当する単語をあてているようだ。

修飾子 ``uniform`` は、処理される基本形状全体で値が同じになる大域変数を宣言する
ために用いられる。``uniform`` 変数はすべて読み取り専用で、リンク時または API を
通じて外部から初期化される。リンク時の初期値は、変数の初期化子が存在する場合はそ
の値で、存在しない場合は 0 だ。不透明型は初期化子を持つことができず、そうでない
場合はコンパイルエラーが発生する。

.. code:: glsl

   uniform vec4 lightPosition;
   uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time

修飾子 ``uniform`` は、基本的なデータ型のいずれか、または構造体を型とする変数を
宣言するとき、あるいはこれらのいずれかの配列を宣言するときに使用できる。

シェーダーの種類ごとに使用できる ``uniform`` 用変数の収容量には実装依存の制限が
ある。これを超えるとコンパイル時またはリンク時にエラーとなる。宣言されているが使
用されていない ``uniform`` 変数はこの制限に入らない。ユーザー定義の ``uniform``
変数の個数と、シェーダー内で使用されている組み込みの ``uniform`` 変数の個数の和
で、利用可能な収容量を超えているかどうかを判断する。

シェーダー内の ``uniform`` 変数は、プログラムまたは分割可能なプログラムにリンク
されている場合、すべて単一の大域名前空間を共有する。したがって、同じ名前で静的に
使用される ``uniform`` 変数の型、初期化子、および任意の ``location`` 指定子は、
単一プログラムにリンクされているすべてのシェーダーで一致しなければならない。ただ
し、リンクされたすべてのシェーダーで初期化子や `location`` 指定子を繰り返す必要
はない。``uniform`` 変数名がある段階（例：頂点シェーダー）で宣言され、別の段階
（例：断片シェーダー）で宣言されていない場合、その名前は別の段階で別の用途に使用
することが許される。

.. _khronos18-4.3.6:

4.3.6. Output Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

シェーダー出力変数は ``out`` 格納修飾子で宣言される。出力変数は、宣言したシェー
ダーと API パイプラインの後続段階との間の出力インターフェイスを形成する。出力変
数は大域スコープで宣言しなければならない。シェーダーの実行中は、修飾のない通常の
大域変数として振る舞う。シェーダーの終了時にその値は後続のパイプライン段階にコ
ピーされる。後続のパイプライン段階で読まれる出力変数だけが書き込まれる必要があ
り、出力変数の余計な宣言があっても構わない。

単一の変数名をシェーダーの入力と出力の両方として宣言するための ``inout`` のよう
な格納修飾子は存在しない。一つの変数に ``in`` と ``out`` の両方の修飾子をつけて
宣言することもまたできない。コンパイル時またはリンク時にエラーとなる。出力変数
は、入力変数とは異なる名前で宣言しなければならない。ただし、インスタンス名を持つ
インターフェイスブロックの中に入力または出力を入れ子にすると、ブロックのインスタ
ンス名で参照されるものと同じ名前を使うことができる。

頂点、細分化評価、幾何の出力変数は、頂点ごとのデータを出力し、``out`` 修飾子を用
いて宣言される。出力への ``patch`` の適用は、細分化制御シェーダーでのみ可能だ。
それ以外の段階での適用はコンパイルエラーとなる。

頂点、細分化評価、細分化制御、幾何それぞれのシェーダーの出力を、以下の型のいずれ
かで宣言するとコンパイルエラーとなる：

* 真偽型
* 不透明型

.. code:: glsl

   out vec3 normal;
   centroid out vec2 TexCoord;
   invariant centroid out vec4 Color;
   flat out vec3 myColor;
   sample out vec4 perSampleColor;

これらは :ref:`khronos18-4.3.9` で述べられるように、インターフェイスブロックにも
出現する。インターフェイスブロックでは、頂点シェーダーから幾何シェーダーへのイン
ターフェイスに、より単純に配列を追加することができる。また、断片シェーダーに、あ
る頂点シェーダーの幾何シェーダーと同じ入力インターフェイスを持たせることができ
る。

----

細分化制御シェーダーの出力変数は、頂点ごとのデータとパッチごとのデータを出力する
ために用いられる。頂点ごとの出力変数は配列され (:ref:`khronos18-4.3.4`)、``out``
修飾子で ``patch`` 修飾子なしに宣言される。パッチごとの出力変数は ``patch`` 修飾
子と ``out`` 修飾子で宣言される。

細分化制御シェーダーは、複数の頂点からなる配列された基本形状を生成するため、各頂
点ごとの出力変数（または出力ブロック）は、配列として宣言する必要がある：

.. code:: glsl

   out float foo[]; // feeds next stage input "in float foo[]"

このような配列の要素それぞれが、生成される基本形状一つの頂点に対応する。各配列は
オプションでサイズを宣言することができる。配列のサイズは出力パッチの頂点の数を定
める出力レイアウト宣言によって設定される (:ref:`Tessellation Control
Outputs`)（または、宣言されている場合は、それと一致しなければならない）。

各細分化制御シェーダー呼び出しは、対応する出力パッチの頂点を持ち、その対応する頂
点に属しているときに限り、頂点ごとの出力に値を割り当てることができる。頂点ごとの
出力変数を左辺値として使用する場合、頂点のインデックスを示す式が識別子
``gl_InvocationID`` でないと、コンパイルエラーまたはリンクエラーになる。

同じ入力パッチに対する他の呼び出しに対する細分化制御シェーダー呼び出しの相対的な
実行順序は、組み込み関数 ``barrier()`` が使用されない限り、未定義だ。これによ
り、相対的な実行順序の制御が可能になる。シェーダーの呼び出しが ``barrier()`` を
呼び出すと、他のすべての呼び出しが同じ実行箇所に到達するまでその実行は一時停止す
る。``barrier()`` を呼び出す前に実行された任意の呼び出しによって実行された出力変
数の割り当ては、``barrier()`` の呼び出しが戻った後、他の任意の呼び出しから見える
ようになる。

細分化制御シェーダーの呼び出しは、障壁間で未定義の順序で実行されるので、頂点ご
と、あるいはパッチごとの出力変数の値は時々未定義になる。シェーダー実行の開始と終
了、および ``barrier()`` の各呼び出しを同期時点と考えるといい。出力変数の値が不
定になるのは、以下の三つの場合のいずれかだ：

1. 実行の開始時
2. 以下の場合を除く各同期時点：

   * 前回の同期時点の後に値が定義され、その後どの呼び出しによっても書き込まれな
     かった場合、または
   * 前回の同期時点以降、厳密に一つのシェーダー呼び出しによって値が書き込まれた
     場合、または
   * 前回の同期時点以降に複数のシェーダー呼び出しによって値が書き込まれ、そのよ
     うなすべての呼び出しによって実行された最後の書き込みが同じ値を書き込んだ場
     合。

3. シェーダーの呼び出しによって読み込まれたとき、もし

   * その値が前回の同期時点で未定義であり、その後同じシェーダー呼び出しによって
     書き込まれていない場合、または
   * 前回と次回の同期時点の間に他のシェーダー呼び出しによって出力変数が書き込ま
     れた場合（その割り当てが読み取り後のコードで発生したときでさえ）

----

断片出力は、断片ごとのデータを出力し、``out`` 修飾子で宣言される。断片シェーダー
出力の宣言に補助格納修飾子や補間修飾子を使用するとコンパイルエラーとなる。断片
シェーダー出力を以下の型で宣言するとコンパイルエラーとなる：

* 真偽型
* 倍精度スカラーまたはベクトル (``double``, ``dvec2``, ``dvec3``, ``dvec4``)
* 不透明型
* 行列型
* 構造体

断片出力宣言の例：

.. code:: glsl

   out vec4 FragmentColor;
   out uint Luminosity;

----

計算シェーダーは組み込みの出力変数を持たず、ユーザー定義の出力変数も対処せず、他
のシェーダー段階との正式なインターフェイスを形成しない。計算シェーダーからの出力
はすべて、画像格納や不可分計数器の演算などの副作用の形をとる。

4.3.7. Buffer Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

修飾子 ``buffer`` は API を通じて束縛されたバッファーオブジェクトのデータ格納空
間に値が格納される大域変数を宣言するために使用される。バッファー変数はすべてのア
クティブなシェーダー呼び出しの間で内包される格納空間を共有して読み書きすることが
できる。単一のシェーダー呼び出し内でのバッファー変数のメモリーの読み取りと書き込
みは順番に処理される。しかし、ある起動で実行される読み込みと書き込みの順序は、他
の呼び出しで実行されるものと比較するとほとんど未定義だ。バッファー変数は内包され
ているメモリーへのアクセス方法に影響を与えるメモリー修飾子
(:ref:`khronos18-4.10`) で修飾することができる。

修飾子 ``buffer`` は、インターフェイスブロック (:ref:`khronos18-4.3.9`) を宣言す
るために使用することができ、これらのブロックはシェーダー格納ブロックとして参照さ
れる。ブロックの外でバッファー変数を宣言するとコンパイルエラーとなる。

.. code:: glsl

   // use buffer to create a buffer block (shader storage block)
   buffer BufferName { // externally visible name of buffer
       int count;      // typed, shared memory...
       ...             // ...
       vec4 v[];       // last member may be an array that is not sized
                       // until after link time (dynamically sized)
   } Name;             // name of block within the shader

シェーダーの種類ごとに使用されるシェーダー格納ブロックの数、プログラムに使用され
るシェーダー格納格納ブロックの合計数、個々のシェーダー格納ブロックが必要とする格
納空間の量には、実装に依存した制限がある。これらの制限を超えた場合は、コンパイル
時またはリンク時にエラーが発生する。

複数のシェーダーがリンクされている場合、それらのシェーダーは単に大域バッファー変
数の名前空間を共有することになる。したがって、同じ名前で宣言されたバッファー変数
の型は、単一のプログラムにリンクされているすべてのシェーダーで一致しなければなら
ない。

.. _khronos18-4.3.8:

4.3.8. Shared Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

修飾子 ``shared`` は、計算シェーダー作業グループ内のすべての作業項目間で共有され
る格納空間がある大域変数を宣言するために用いられる。``shared`` として宣言された
変数は、計算シェーダーでしか使用されない (:ref:`khronos18-2.6`)。それ以外の共有
変数の宣言は、コンパイルエラーとなる。共有変数は暗黙的に ``coherent``
(:ref:`khronos18-4.10`) だ。

共有変数として宣言された変数は初期化子を持たず、シェーダーの実行開始時にはその内
容は未定義だ。共有変数に書き込まれたどんなデータも、同じ作業グループ内の他の作業
項目（同じシェーダーを実行中）から見えるということになる。

同期が行われていない場合、シェーダーの異なる呼び出しによる同じ ``shared`` 変数へ
の読み書きの順序は未定義とする。

共有変数への読み書きの順序を決めるためには、関数 ``barrier()`` を使って制御フ
ローの障壁を設ける必要がある(:ref:`khronos-8.16`)。

単一のプログラムで共有変数として宣言されたすべての変数の合計サイズには制限があ
る。Basic machine units 単位で表されるこの制限は、OpenGL API を使って
``MAX_COMPUTE_SHARED_MEMORY_SIZE`` の値を照会することで決定できる。

.. admonition:: 読者ノート

   最後のパラグラフ中の basic machine units なる用語がわからない。

.. _khronos18-4.3.9:

4.3.9. Interface Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

入力、出力、一様、バッファー変数の宣言は、名前の付いたインターフェイスブロックに
まとめることができ、個別の宣言では達せられない粗い粒度の backing が可能になる。
これらはオプションでインスタンス名を持つことができ、シェーダー内でそのメンバーを
参照するために用いられる。あるプログラム可能段階の出力ブロックは、後続のプログラ
ム可能段階の対応する入力ブロックによって back される。一様ブロック (a uniform
block) は、アプリケーションによってバッファーオブジェクトで back される。シェー
ダー格納ブロック (a shader storage block) と呼ばれるバッファー変数のブロックも、
アプリケーションによってバッファーオブジェクトで back される。頂点シェーダーの入
力ブロックや断片シェーダーの出力ブロックを持つことは、コンパイルエラーとなる。こ
れらの用途は将来のために予約されている。

インターフェイスブロックは、キーワード ``in`, ``out``, ``uniform``, ``buffer``
と、ブロック名、そして中括弧 ``{`` で始まる。

.. admonition:: 読者ノート

   BNF による一覧を省略。

----

次のコードは ``Transform`` という名前の一様ブロックを定義する。``uniform`` 変数
四つがグループ化される。

.. code:: glsl

   uniform Transform {
       mat4 ModelViewMatrix;
       mat4 ModelViewProjectionMatrix;
       uniform mat3 NormalMatrix;      // allowed restatement of qualifier
       float Deformation;
   };

----

型と宣言子は、ブロック外の他の入力、出力、一様、バッファー変数の宣言と同じだ、以
下の例外がある：

* 初期化子は許されない。
* 不透明型は許されない。
* ブロック内での構造体定義の入れ子は許されない。

これらはいずれもコンパイルエラーになる。

メンバー宣言にオプションの修飾子がない場合、メンバーの修飾には、
*interface-qualifier* で決定されるすべての ``in``, ``out``, ``patch``,
``uniform``, ``buffer`` が含まれる。オプション修飾子を使用する場合、補間修飾子、
補助格納修飾子、格納修飾子を含むことができ、ブロックのインターフェイス修飾子と一
致する入力、出力、一様メンバーを宣言しなければならない。すなわち、入力変数、出力
変数、一様変数、``buffer`` メンバーは、``in`` ブロック、``out`` ブロック、
``uniform`` ブロック、シェーダー格納ブロック内それぞれにしか存在しない。

メンバーの格納修飾子に ``in``, ``out``, ``patch``, ``uniform``, ``buffer`` のい
ずれかのインターフェイス修飾子を繰り返すことはオプションだ。例えば：

.. code:: glsl

   in Material {
       smooth in vec4 Color1; // legal, input inside in block
       smooth vec4 Color2;    // legal, 'in' inherited from 'in Material'
       vec2 TexCoord;         // legal, TexCoord is an input
       uniform float Atten;   // illegal, mismatched storage qualifier
   };

----

**シェーダーインターフェイス** (a shader interface) とは、次のうちの一つとする：

* プログラムの中で宣言されたすべての一様変数と一様ブロック。これは、一つのプログ
  ラム内でリンクされているすべてのコンパイル単位に及ぶ。
* プログラム内で宣言された ``buffer`` ブロックすべて。
* 隣接するプログラム可能パイプライン段階間の境界。最初の段階のコンパイル単位すべ
  てで宣言された出力すべてと、次の段階のコンパイル単位すべて宣言された入力すべて
  に及ぶ。なお、実際には断片シェーダーに渡された値すべては、まずラスタライザーと
  補間器を通過するが、この定義では、断片シェーダーと先行するシェーダーは境界を共
  有すると考えられる。

ブロック名 (*block-name*) は、シェーダーインターフェイス内での照合に用いられる。
つまり、あるパイプライン段階の出力ブロックは、後続のパイプライン段階の同名の入力
ブロックに合致する。一様ブロックやシェーダー格納ブロックの場合、アプリケーション
はブロック名を使ってブロックを識別する。シェーダー内ではインターフェイスの照合以
外にはブロック名を利用できない。大域スコープのブロック名をブロック名として以外に
使用することはコンパイルエラーとなる（例えば、大域変数名や関数名にブロック名を使
用することが現在予約されている）。ブロックの内容が同じであっても、一つのシェー
ダー内の同じシェーダーインターフェイスの複数のブロック宣言に同じブロック名を使用
すると、コンパイルエラーとなる。

一つのシェーダインターフェイスの中で合致したブロック名は、同じ数の宣言と同じ型の
並び、同じメンバー名の並び、そしてメンバーごとのレイアウト修飾が一致していなけれ
ばならない。一致した一様ブロック名またはシェーダー格納ロック名（入力ブロック名ま
たは出力ブロック名ではない）は、すべてインスタンス名がないか、またはすべてインス
タンス名があり、それらのメンバーが同じスコープレベルにあることも必要だ。合致した
ブロック名の上にインスタンス名がある場合、インスタンス名が違っていても構わない。
さらに、合致ブロックが配列として宣言されている場合は、配列のサイズまでも一致して
いなければならない。 （または、連続するシェーダー段階間のシェーダーインターフェ
イスの配列一致規則に従う）。不一致の場合、リンクタイムエラーとなる。ブロック名
は、同一シェーダー内の異なるシェーダーインターフェイスで異なる定義であることが許
されており、例えば、入力ブロックと出力ブロックが同じ名前であることも可能である。

インスタンス名 (*instance-name*) を使用しない場合、ブロック内で宣言された名前は
大域レベルでスコープされ、ブロックの外で宣言されたかのようにアクセスされる。イン
スタンス名を使用すると、スコープ内のすべてのメンバーが独自の名前空間内に置かれ、
構造体と同様の、フィールドセレクター演算子 ``.`` でアクセスされる：

.. code:: glsl

   in Light {
       vec4 LightPos;
       vec3 LightColor;
   };
   in ColoredTexture {
       vec4 Color;
       vec2 TexCoord;
   } Material;           // instance name
   vec3 Color;           // different Color than Material.Color
   vec4 LightPos;        // illegal, already defined
   ...
   ... = LightPos;       // accessing LightPos
   ... = Material.Color; // accessing Color in ColoredTexture block

シェーディング言語の外では、メンバーは同様に識別されるが、インスタンス名の代わり
にブロック名が常に使用される。API のアクセスはシェーダーではなくシェーダーイン
ターフェイスに対して行われるのだ。インスタンス名がない場合、API はメンバーにアク
セスするためにブロック名を使用せず、メンバー名だけを使用する。

シェーダーインターフェイス内では、同じ大域名の宣言すべては同じオブジェクトに対す
るものでなければならず、型や、インスタンス名のないブロックの変数やメンバーを宣言
しているかどうかが一致していなければならない。また、API はシェーダーインターフェ
イス内のオブジェクトを一意に識別するためにこの名前を必要とする。次のどちらかが成
り立つならば、どのシェーダーインターフェイスもリンクエラーになる：

* インスタンス名を持たず、同じ名前のメンバーを持つ相異なるブロックが含まれてい
  る。
* ブロック外の変数と、インスタンス名のないブロックで、その変数がブロック内のメン
  バーと同じ名前である。

.. code:: glsl

   out Vertex {
       vec4 Position;  // API transform/feedback will use "Vertex.Position"
       vec2 Texture;
   } Coords;           // shader will use "Coords.Position"
   out Vertex2 {
       vec4 Color;     // API will use "Color"
       float Color2;
   };

   // in same program as Vertex2 above:
   out Vertex3 {
       float Intensity;
       vec4 Color;     // ERROR, name collision with Color in Vertex2
   };
   float Color2;       // ERROR, collides with Color2 in Vertex2

----

配列として宣言されたブロックでは、メンバーにアクセスする際に配列のインデックスも
含める必要がある：

.. code:: glsl

   uniform Transform { // API uses "Transform[2]" to refer to instance 2
       mat4 ModelViewMatrix;
       mat4 ModelViewProjectionMatrix;
       vec4 a[]; // array will get implicitly sized
       float Deformation;
   } transforms[4];
   ...
   ... = transforms[2].ModelViewMatrix; // shader access of instance 2
   // API uses "Transform.ModelViewMatrix" to query an offset or other query
   transforms[x].a.length(); // same length for 'a' for all x
   Transform[x];             // illegal, must use 'transforms'
   Transform.a.length();     // illegal, must use 'transforms'
   ...transforms[2].a[3]...  // if these are the only two dereferences of 'a',
   ...transforms[3].a[7]...  // then 'a' must be size 8, for all
   transforms[x]

配列として宣言された一様ブロックやシェーダー格納ブロックでは、個々の配列要素が、
ブロックのインスタンス一つを back する、個別のバッファーオブジェクトの結合範囲に
対応する。配列のサイズは必要なバッファーオブジェクトの数を示すため、一様ブロック
やシェーダー格納ブロックの配列宣言では、配列のサイズを指定する必要がある。一様ブ
ロックやシェーダー格納ブロックの配列は、動的一様な整数式でしかインデックスを付け
ることができず、それ以外の場合は結果が未定義だ。

OpenGL API の入場点を使用してブロックの配列内の個々のブロックの名前を特定する場
合、``Transform[2]`` のようにして、名前の文字列に配列のインデックスを含めること
ができる。OpenGL API の入場点を使用してブロックメンバーのオフセットやその他の性
質を参照する場合、``Transform.ModelViewMatrix`` のように、配列インデックスを抜か
なければならない。

細分化制御、細分化評価、幾何シェーダー入力ブロックは、配列として宣言されなければ
ならず、それぞれの段階のシェーダー入力すべては配列宣言とリンク規則に従わなければ
ならない。その他のすべての入出力ブロックの配列は、配列サイズを指定しなければなら
ない。

段階ごとに使用できる一様ブロックの個数とシェーダー格納ブロックの個数は、実装依存
の制限がある。いずれかの制限を超えた場合、リンクエラーとなる。
