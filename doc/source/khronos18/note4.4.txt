.. _khronos18-4.4:

4.4. Layout Qualifiers
----------------------------------------------------------------------

レイアウト修飾子は宣言形式がいくつかある。前節の文法で示したように、インターフェ
イスブロックの定義やブロックメンバーの一部として現れることがある。一つの
*layout-qualifier* だけで、その修飾子を使った他の宣言のレイアウトを設定すること
もできる。

| *layout-qualifier* *interface-qualifier* ;

また、インターフェイス修飾子で宣言された個別の変数で出現することもある：

| *layout-qualifier* *interface-qualifier* *declaration* ;

レイアウトの宣言は、大域スコープまたはブロックメンバーでしか行えず、以下の節で示
される場所でしか行えない。

レイアウト修飾子は次のように展開する：

|   *layout-qualifier* :
|       ``layout (`` *layout-qualifier-id-list* ``)``
|
|   *layout-qualifier-id-list* :
|       *layout-qualifier-id*
|       *layout-qualifier-id* , *layout-qualifier-id-list*
|
|   *layout-qualifier-id* :
|       *layout-qualifier-name*
|       *layout-qualifier-name* = *layout-qualifier-value*
|       ``shared``
|
|   *layout-qualifier-value* :
|       *integer-constant-expression*

*layout-qualifier-name* に使用されるトークンは、キーワードではなく識別子で、
*layout-qualifier-id* としてキーワード **shared** を使用することができる。一般的
に、これらはどのような順序でも並べてよい。順序に依存する意味は、下で明示されてい
る場合に限り存在する。同様に、これらの識別子は、明示的に別段の記載がない限り、大
文字と小文字を区別しない。

単一の宣言にレイアウト修飾子を複数含めることができる。また、同じ
*layout-qualifier-name* が、一つのレイアウト修飾子の中で複数回現れたり、同じ宣言
の中で複数のレイアウト修飾子にまたがって現れたりすることがある。同じ
*layout-qualifier-name* が単一の宣言の中で複数回出現する場合、最後に出現したもの
がそれ以前に出現したものよりも優先される。さらに、このような
*layout-qualifier-name* が後続の宣言やその他の観察可能な挙動に影響する場合、影響
を与えるのは最後に出現するものだけであり、以前に出現したものは存在しないかのよう
に振る舞う。これは *layout-qualifier-name* を上書きする場合にも当てはまり、一方
が他方を上書き場合 (e.g. ``row_major`` vs. ``column_major``) には、最後に出現す
るものだけが影響を及ぼす。

*integer-constant-expression* は :ref:`khronos18-4.3.3` で *constant integral
expression* として定義されており、*integer-constant-expression* が特殊化定数であ
ることはコンパイルエラーになる。

.. admonition:: 読者ノート

   仕様書本文ではレイアウト修飾子の使用法の概要が表になって掲載されている。巨大
   なデータなので引用は控える。

.. _khronos18-4.4.1:

4.4.1. Input Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

計算シェーダーを除くすべてのシェーダーでは、入力変数宣言、入力ブロック宣言、入力
ブロックメンバー宣言に対してレイアウト修飾子 ``location`` を使うことができる。こ
のうち、変数とブロックメンバー（ブロックは不可）には、さらにレイアウト修飾子
``component`` が使用できる。

| *layout-qualifier-id* :
| ``location`` = *layout-qualifier-value*
| ``component`` = *layout-qualifier-value*

例：

.. code:: glsl

   layout(location = 3) in vec4 normal;
   const int start = 6;
   layout(location = start + 2) int vec4 v;

これにより、シェーダー入力の ``normal`` はベクトル位置番号 3 に、``v`` は位置番
号 8 に割り当てられる。頂点シェーダー入力の場合、位置を入力値を取得する頂点属性
の番号で指定する。他のすべてのシェーダー型の入力では、そのシェーダーが別のプログ
ラムオブジェクト内にあったとしても、位置を以前のシェーダー段階からの出力との照合
に使用できるベクトル番号で指定する。

続く言語では、特定の型で消費される位置の数を記述する。ただし、幾何シェーダー入
力、細分化制御シェーダー入出力、細分化評価入力はすべて、他のシェーダー入出力に対
して追加の配列レベルを持っている。この外側の配列レベルは、型が消費する位置の数を
考慮する前に、型から取り除かれる。

Vulkan を対象にしている場合を除き、頂点シェーダー入力が任意のスカラーまたはベク
トル型である場合、位置を一つを消費する。非頂点シェーダーの入力や Vulkan を対象に
している場合の段階入力が ``dvec3`` や ``dvec4`` 以外のスカラー型やベクトル型の場
合は、位置を一つを消費するが、``dvec3`` や ``dvec4`` 型の場合は連続した二つの位
置を消費する。``double`` 型や ``dvec2`` 型の入力は、段階すべてで一つの位置しか
消費しない。

上述のように外側の配列レベルを削除した後、宣言された入力がサイズ n の配列で、各
要素が m 個の位置を取る場合、指定された位置から始まる m×n 個の連続した位置が割り
当てられる。例えば：

.. code:: glsl

   layout(location = 6) in vec4 colors[3];

これにより、シェーダーの入力色がベクトルの位置番号 6, 7, 8 に割り当てられること
が確定する。

宣言された入力が n×m 行列の場合は、指定された位置から始まる複数の位置が割り当て
られる。各行列に割り当てられる位置の数は、m 成分のベクトルの n 要素の配列と同じ
になる。例えば：

.. code:: glsl

   layout(location = 9) in mat4 transforms[2];

これにより、シェーダー入力 ``transforms`` がベクトルの 9..16番に割り当てられる：

* ``transforms[0]`` が 9, 10, 11, 12 番に、
* ``transforms[1]`` が 13, 14, 15, 16 番に

割り当てられる。

----

宣言された入力が構造体やブロックの場合、そのメンバーには宣言順に連続した位置が割
り当てられ、最初のメンバーにはレイアウト修飾子で指定された位置が割り当てられる。
構造体の場合、この処理は構造体全体に適用される。``layout`` 修飾子を構造体のメン
バーに使用するとコンパイルエラーとなる。ブロックの場合、この処理はブロック全体に
適用される。つまり ``location`` レイアウト修飾子を持つ最初のメンバーに到達するま
で適用される。

ブロックのメンバーが ``location`` 修飾子付きで宣言されている場合、そのメンバーの
位置はその修飾子に由来し、メンバーの ``location`` 修飾子がブロックレベルの宣言よ
りも優先される。後続のメンバーには、次の ``location`` 修飾子が宣言されたメンバー
まで、最新の位置に基づいて連続した位置が再び割り当てられる。位置に使用される値
は、昇順に宣言する必要はない。

ブロックレベルの ``location`` 修飾子がないブロックでは、そのメンバーのすべてが
``location`` 修飾子を持つか、またはそれを一つも持たないことが要求される。さもな
いとコンパイルエラーとなる。配列として宣言されたブロックには ``location`` がブ
ロックレベルでしか適用できないものがある。ブロックが配列として宣言されていて、ブ
ロックの配列要素ごとに各メンバーに追加の位置が必要な場合、ブロックのメンバーに位
置を指定するとコンパイルエラーになる。つまり、ブロックメンバー上に位置を適用する
ことで指定不足になる場合、それは認められない。配列されたインターフェイス（一般に
インターフェイスの拡張により余計な配列を持つもの）では、この規則を適用する前に外
側の配列が取り除かれる。

ブロックや構造体のメンバーが消費する位置は、構造体のメンバーが同じ型の入力変数と
して宣言されているかのように、上記の規則を再帰的に適用して決定される：

.. code:: glsl

   layout(location = 3) in struct S
   {
       vec3 a;                      // gets location 3
       mat2 b;                      // gets locations 4 and 5
       vec4 c[2];                   // gets locations 6 and 7
       layout(location = 8) vec2 A; // ERROR, can't use on struct member
   } s;
   layout(location = 4) in block
   {
       vec4 d;                      // gets location 4
       vec4 e;                      // gets location 5
       layout(location = 7) vec4 f; // gets location 7
       vec4 g;                      // gets location 8
       layout(location = 1) vec4 h; // gets location 1
       vec4 i;                      // gets location 2
       vec4 j;                      // gets location 3
       vec4 k;                      // ERROR, location 4 already used
   };

シェーダーが利用できる入力位置の数には制限がある。頂点シェーダーでは、その制限は
公示された頂点属性の数だ。その他のシェーダーでは、制限は実装に依存し、公示された
最大入力成分数の 1/4 以上でなければならない。

取り付けられたシェーダーが対処されている個数を超える位置を使用している場合、デバ
イス依存最適化がプログラムに利用可能なハードウェア資源内に収まるようにさせない限
り、プログラムはリンクに失敗する。

明示的な位置割り当てにより、リンカーが他の明示的割り当てのない変数のための空間を
見つけられない場合、プログラムはリンクに失敗する。

非頂点入力が以前のシェーダー段階の出力と一致するかどうかを判断するためには、
``location`` レイアウト修飾子がもしあれば一致していなければならない。

シェーダーテキストに位置が割り当てられていない頂点シェーダー入力変数に OpenGL
APIで指定された位置がある場合は、その指定位置が使用される。そうでなければ、その
ような変数はリンカーによって場所が割り当てられる。入力変数が同じ言語の複数の
シェーダーで宣言されていて、位置が競合している場合、リンクエラー。

修飾子 ``component`` を使用すると、スカラーやベクトルの位置をより細かく指定する
ことができ、消費される位置内の個々の成分まで指定することができる修飾子
``location`` を指定せずに ``component`` を使用すると、コンパイルエラーになる（順
序は重要でない）。位置内の成分は 0, 1, 2, 3 だ。成分 N で始まる変数やブロックメ
ンバーは、そのサイズまでの成分 N, N+1, N+2, ... を消費する。この成分の並びが 3
より大きくなると、コンパイルエラーになる。スカラー ``double`` はこれらの成分のう
ち二つを消費し、``dvec2`` はある位置で利用可能な四つの成分全てを消費する。
``dvec3`` や ``dvec4`` は成分指定なしでしか宣言できない。``dvec3`` は一つ目の位
置の四つの成分と、二つ目の位置の成分 0 と 1 をすべて消費する。これにより、成分 2
と 3 は他の成分修飾された宣言に使用できる。

.. code:: glsl

   // a consumes components 2 and 3 of location 4
   layout(location = 4, component = 2) in vec2 a;

   // b consumes component 1 of location 4
   layout(location = 4, component = 1) in float b;

   // ERROR: c overflows component 3
   layout(location = 3, component = 2) in vec3 c;

   // d consumes components 2 and 3 of location 5
   layout(location = 5, component = 2) in double d;

   // ERROR: e overflows component 3 of location 6
   layout(location = 6, component = 2) in dvec2 e;

   // ERROR: f overlaps with g
   layout(location = 7, component = 0) double f;
   layout(location = 7, component = 1) float g;

   layout(location = 8) in dvec3 h; // components 0,1,2 and 3 of location 8
                                    // and components 0 and 1 of location 9
   layout(location = 9, component = 2) in float i; // okay, compts 2 and 3

変数が配列の場合、配列の各要素は順番に連続した位置に割り当てられるが、各位置の中
ですべて同じ指定された成分になる：

.. code:: glsl

   // component 3 in 6 locations are consumed
   layout(location = 2, component = 3) in float d[6];

この場合、位置 2 の成分 3 は ``d[0]`` を、位置 3 の成分 3 は ``d[1]`` を、... 位
置 7 の成分 3 に ``d[5]`` を格納する。

これにより二つの配列を同じ位置にまとめることができる：

.. code:: glsl

   // e consumes beginning (components 0, 1 and 2) of each of 6 slots
   layout(location = 0, component = 0) in vec3 e[6];

   // f consumes last component of the same 6 slots
   layout(location = 0, component = 3) in float f[6];

これを配列の配列に適用する場合は、すべてのレベルの配列性が取り除かれ、指定された
成分に位置ごとに割り当てられた要素になる。これらの非配列要素は
:ref:`khronos18-4.1.9` が指定する順序で配列の配列に対する位置を埋める。

修飾子 ``component`` を行列、構造体、ブロック、またはこれらを含む配列に適用する
とコンパイルエラーになる。``component`` 1 または 3 を ``double`` または ``dvec2``
の先頭に使用するとコンパイルエラーになる。プログラム内で同じ変数に異なる成分を指
定すると、リンクエラーになる。

----

**位置エイリアシング** (location aliasing) とは、二つの変数やブロックメンバーに
同じ位置番号を持たせることだ。**成分エイリアシング** (component aliasing) とは、
二つの位置エイリアスに同じ（つまり重複する）成分番号を割り当てることだ（
``component`` を使用しない場合は 0 から始まる成分が割り当てられることを思い出
せ）。一つの例外を除いて、位置エイリアシングは成分エイリアシングを起こさない場合
に限り許される。さらに、位置エイリアシングを行う場合、その位置を共有するエイリア
スは、内在する数値型とビット幅が同じでなければならず、補助格納修飾子と補間修飾子
も同じでなければならない。成分エイリアシングが許可される例外とは、頂点シェーダー
への二つの入力変数（ブロックメンバーではない）に対して OpenGL を対象にする場合
で、これらは成分エイリアシングが許されている。この頂点変数の成分エイリアシング
は、各実行パスがエイリアシングされた各成分ごとに高々一つの入力にアクセスする頂点
シェーダーを対処することしか目的としていない。頂点シェーダー実行形式を通るすべて
の実行パスが、任意の単一成分にエイリアスされた複数の入力にアクセスすることを検出
した場合、実装はこれをリンクタイムエラーとすることが許されているが、必須ではな
い。

Tessellation Evaluation Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

細分化評価シェーダーで使える追加的な入力レイアウト修飾子の識別子は次の通り：

| *layout-qualifier-id* :
|     *primitive-mode*
|     *vertex-spacing*
|     *ordering*
|     *point-mode*

識別子 *primitive-mode* は細分化基本形状生成器が使用する。

| *primitive-mode*:
|     ``triangles``
|     ``quads``
|     ``isolines``

*primitive-mode* がもしあれば、細分化基本形状生成器は三角形をより小さな三角形
に、四角形を三角形に、四角形を線の集合体にそれぞれ細分するべきだと指定する。

レイアウト識別子の二番目のグループである頂点間隔は、細分化基本形状生成器が辺を細
分化する際の間隔を指定するために用いられる。

| *vertex-spacing*:
|     ``equal_spacing``
|     ``fractional_even_spacing``
|     ``fractional_odd_spacing``

``equal_spacing`` は辺を同じ大きさのセグメントの集まりに分割することを指定する。

``fractional_even_spacing`` は、辺を偶数個の同じ長さのセグメントとさらに二つのよ
り短い「小数」のセグメントに分割することを指定する。

``fractional_odd_spacing`` は、辺を奇数個の同じ長さのセグメントとさらに二つの
より短い「小数」セグメントに分割することを指定する。

三番目のレイアウト識別子である *ordering* は、細分化基本形状生成器が、OpenGL 仕
様にある座標系に従い、時計回りまたは反時計回りのどちらの順序で三角形を生成するの
かを指定する。

| *ordering*:
|     cw
|     ccw

識別子 ``cw`` と ``ccw`` は、それぞれ時計回りと反時計回りの三角形を示す。細分化
基本形状生成器が三角形を生成しない場合、この順序は無視される。

最後の *point-mode* は、細分化基本形状生成器が、線や三角形を生成するのではなく、
細分化された基本形状のそれぞれの紛れのない頂点に対して一点を生成するべきであるこ
とを示す。

| *point-mode*:
|     point_mode

----

これらの識別子は、単一の入力レイアウト宣言の中で、一回またはそれ以上指定すること
ができる。プログラムの細分化評価シェーダーの中で、*primitive-mode*,
*vertex-spacing*, *ordering* が複数回宣言されている場合、そのような宣言はすべて
同じ識別子を使用しなければならない。

プログラム内の少なくとも一つの細分化評価シェーダー（コンパイル単位）は、その入力
レイアウトで *primitive-mode* を宣言しなければならない。*vertex-spacing*,
*ordering*, *point_mode* 識別子の宣言はオプションだ。プログラム内の細分化評価
シェーダーすべてが *primitive_mode* を宣言するということは必須ではない。
*vertex-spacing* や *ordering* の宣言が省略された場合、細分化基本形状生成器は、
それぞれ等間隔または反時計回りの頂点順序を採用する。*point-mode* の宣言が省略さ
れた場合、細分化基本形状生成器は、*primitive-mode* に従って線分または三角形を生
成する。

Geometry Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

幾何シェーダー入力に対する追加のレイアウト修飾子識別子には、基本形状 (primitive)
識別子と呼び出し回数 (invocation count) 識別子がある：

| *layout-qualifier-id* :
|     ``points``
|     ``lines``
|     ``lines_adjacency``
|     ``triangles``
|     ``triangles_adjacency``
|     ``invocations`` = *layout-qualifier-value*

識別子 ``points``, ``lines``, ``lines_adjacency``, ``triangles``,
``triangles_adjacency`` は、幾何シェーダーが受け付ける入力基本形状の種類を指定す
るためのもので、これらのうちただ一つを受け付ける。プログラム内の少なくとも一つの
幾何シェーダー（コンパイル単位）は、この入力基本形状のレイアウトを宣言しなければ
ならず、プログラム内の幾何シェーダーすべての入力レイアウト宣言は同じレイアウトを
宣言しなければならない。プログラム内のすべての幾何シェーダーが入力基本形状レイア
ウトを宣言することは必須ではない。

識別子 ``invocations`` は、受けとった入力基本形状それぞれに対して幾何シェーダー
実行形式が呼び出される回数を指定するために用いられる。回数の宣言はオプションだ。
プログラム内のどの幾何シェーダーでも回数が宣言されていない場合、幾何シェーダーは
入力基本形状それぞれに対して一度実行される。宣言されている場合は、すべての宣言で
同じ回数を指定しなければならない。シェーダーが実装依存の最大値を超える呼び出し回
数を指定したり、ゼロ以下の呼び出し回数を指定したりすると、コンパイルエラーとな
る。

.. code:: glsl

   layout(triangles, invocations = 6) in;

例えば上の宣言では、幾何シェーダーへの入力はすべて三角形であり、幾何シェーダーの
実行形式は、処理される三角形ごとに 6 回実行される。

幾何シェーダー入力サイズなし配列宣言のすべてで、以前の入力基本形状レイアウト修飾
子がある場合、サイズが変更される：

* ``points``: 1
* ``lines``: 2
* ``lines_adjacency``: 4
* ``triangles``: 3
* ``triangles_adjacency``: 6

内在的に宣言された入力配列 ``gl_in[]`` は、任意の入力基本形状レイアウト宣言に
よってもサイズが決定される。そのため、式 ``gl_in.length()`` 式は上にある値を返
す。

``gl_in`` などの内在的に宣言された入力、配列サイズを持たずに宣言された入力につい
ては、メソッド ``length()`` を使用する前か、配列サイズを知る必要のあるその他の配
列使用の前にレイアウトを宣言しなければならない。

レイアウト宣言の配列サイズが、同じシェーダー内の入力変数の宣言で指定されている明
示的な配列サイズすべてと一致しない場合はコンパイルエラーとなる。コンパイルエラー
の例：

.. code:: glsl

   // code sequence within one shader...
   in vec4 Color1[];     // legal, size still unknown
   in vec4 Color2[2];    // legal, size is 2
   in vec4 Color3[3];    // illegal, input sizes are inconsistent
   layout(lines) in;     // legal for Color2, input size is 2, matching Color2
   in vec4 Color4[3];    // illegal, contradicts layout of lines
   layout(lines) in;     // legal, matches other layout() declaration
   layout(triangles) in; // illegal, does not match earlier layout() declaration

プログラム内の幾何シェーダーすべてにおいて、提供されたサイズのすべて（サイズ付き
入力配列とレイアウトサイズ）が一致しない場合は、リンクエラーとなる。

Fragment Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``gl_FragCoord`` には以下のような追加的断片レイアウト修飾子がある：

| *layout-qualifier-id* :
|     ``origin_upper_left``
|     ``pixel_center_integer``

OpenGL の ``gl_FragCoord`` は既定ではウィンドウの座標は左下を原点とし、画素中心
は半画素の座標にあるとしている。例えば、ウィンドウの左下端の画素に対しては ``(x,
y)`` 座標 ``(0.5, 0.5)`` が返される。原点は ``gl_FragCoord`` に
``origin_upper_left`` 修飾子を付けて再宣言することで変更することができ、
``gl_FragCoord`` の原点をウィンドウの左上に移動させ、``y`` はウィンドウの下に向
かって値を大きくしていく。また、返される値は、``pixel_center_integer`` によっ
て、``x`` と ``y`` の両方で半画素ずつずらすことができ、画素が整数のオフセットで
中心に置かれているように見える。これは ``gl_FragCoord`` で返される ``(x, y)`` の
値が既定値が ``(0.5, 0.5)`` であるのに対し、``pixel_center_integer`` で ``(0.0,
0.0)`` に移動する。

Vulkan を対象にする場合、``gl_FragCoord`` の原点は左上で、画素中心は半画素座標に
配置されていると仮定し、要求される。この原点を明示的に設定するには
``gl_FragCoord`` を ``origin_upper_left`` 識別子で再宣言する。

再宣言は次のように行う：

.. code:: glsl

   in vec4 gl_FragCoord; // redeclaration that changes nothing is allowed

   // All the following are allowed redeclaration that change behavior
   layout(origin_upper_left) in vec4 gl_FragCoord;
   layout(pixel_center_integer) in vec4 gl_FragCoord;
   layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;

``gl_FragCoord`` がプログラム内のいずれかの断片シェーダーで再宣言された場合、そ
のプログラム内で ``gl_FragCoord`` を静的に使用しているすべての断片シェーダーで再
宣言されなければならない。単一のプログラム内にある断片シェーダーすべてにおける
``gl_FragCoord`` の再宣言はすべてが同じ修飾子の集合でなければならない。どの
シェーダー内でも ``gl_FragCoord`` の最初の再宣言が ``gl_FragCoord`` のどの使用の
前にも現れなければならない。組み込み ``gl_FragCoord`` は断片シェーダーでしか事前
に宣言されていないので、他のシェーダー言語で再宣言するとコンパイルエラーになる。

``origin_upper_left`` 修飾子と ``pixel_center_integer`` 修飾子の両方とも、または
いずれか一方をつけて ``gl_FragCoord`` を再宣言しても ``gl_FragCoord.x`` と
``gl_FragCoord.y`` にしか影響しない。ラスタライズ、座標変換、その他の API パイプ
ラインや言語機能には影響しない。

断片シェーダーでは、OpenGL 仕様書の 15.2.4 "Early Fragment Tests" に記載されてい
るように、断片シェーダーの実行前に断片検定を行うことを要求するために、``in`` の
みで次のレイアウト修飾子を使用することが許される（変数宣言では不可）：

| *layout-qualifier-id* :
|     early_fragment_tests

.. code:: glsl

   layout(early_fragment_tests) in;

例えば上の宣言では、断片シェーダーの実行前に断片ごとの検定が行われるようになる。
これを宣言しない場合は、断片シェーダーの実行後に断片ごとの検定が行われる。この宣
言が必要となるのは、一つの断片シェーダー（コンパイル単位）だけだが、複数の断片
シェーダーが宣言することもできる。少なくとも一つがこれを宣言していれば有効にな
る。

Compute Shader Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

計算シェーダー入力にはレイアウト位置修飾子がない。

計算シェーダー入力に対するレイアウト修飾子の識別子は、作業グループサイズ修飾子
だ：

| *layout-qualifier-id* :
|     ``local_size_x`` = *layout-qualifier-value*
|     ``local_size_y`` = *layout-qualifier-value*
|     ``local_size_z`` = *layout-qualifier-value*

``local_size_x``, ``local_size_y``, ``local_size_z`` 各修飾子は、それぞれ 1, 2,
3 次元の計算シェーダーによる固定作業グループのサイズを宣言するために用いられる。
シェーダーが次元のサイズをここから指定していない場合、その次元は 1 となる。

例えば、計算シェーダーで次のように宣言した場合、

.. code:: glsl

   layout(local_size_x = 32, local_size_y = 32) in;

作業グループサイズが 32×32 要素の二次元計算シェーダーを宣言するために用いられ
る。これは、3次元目のサイズが 1 である三次元計算シェーダーに相当する。

.. admonition:: 読者ノート

   上の一文は何を言っているのか。

もう一つ別の例として、次の宣言は、一次元の計算シェーダーがコンパイルされており、
そのサイズが実質的には 8 要素であることを指定している：

.. code:: glsl

   layout(local_size_x = 8) in;

いずれかの次元におけるシェーダーの固定作業グループサイズがゼロ以下、または実装で
対処される最大サイズよりも大きい場合、コンパイルエラー。また、このようなレイアウ
ト修飾子が同一シェーダー内で複数回宣言されている場合、それらの宣言はすべて同じ作
業グループサイズの集合を設定し、同じ値を設定しなければならない。さもなければコン
パイルエラー。単一のプログラムオブジェクトに取り付けられた複数の計算シェーダーが
固定作業グループサイズを宣言する場合、その宣言は同一でなければならない。さもなけ
ればリンクエラー。

さらに、プログラムオブジェクトが計算シェーダーを何か含む場合、少なくとも一つはプ
ログラムの固定作業グループサイズを指定する入力レイアウト修飾子を含まなければなら
ない。さもなければリンクエラー。

.. _khronos18-4.4.2:

4.4.2. Output Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

出力レイアウト修飾子には、シェーダー段階すべてに適用されるものと、特定の段階にし
か適用されないものがある。ここでは前者を議論する。

入力レイアウト修飾子と同様に、計算シェーダーを除くすべてのシェーダーでは、出力変
数宣言、出力ブロック宣言、出力ブロックメンバー宣言に対して ``location`` レイアウ
ト修飾子を許す。このうち、変数とブロックメンバー（ブロックは不可）には、さらに
``component`` レイアウト修飾子を許す。

| *layout-qualifier-id* :
|     ``location`` = *layout-qualifier-value*
|     ``component`` = *layout-qualifier-value*

ブロックや構造体に ``location`` 修飾子や ``component`` 修飾子を適用する際の使い
方や規則は :ref:`khronos18-4.4.1` のとおりだ。また、断片シェーダーの出力では、二
つの変数が同じ位置に配置される場合、それらの変数の内容される型は同じでなければな
らない（浮動小数点・整数）。出力変数やメンバーの成分エイリアスは許されない。

断片シェーダーでは ``index`` 出力レイアウト修飾子を追加的に付けられる：

| *layout-qualifier-id* :
|     ``index`` = *layout-qualifier-value*

これらの修飾子は、それぞれ高々一度現れる。``index`` が指定された場合 ``location``
も指定しなければならない。``index`` が指定されていない場合は値 0 が使用される。

例えば次の断片シェーダーでは、断片シェーダー出力色を混合方程式の最初（インデック
ス 0）の入力として断片カラー 3 に割り当てる設定をする：

.. code:: glsl

   layout(location = 3) out vec4 color;

次の例は、断片シェーダーの出力係数が、混合方程式の 2 番目（インデックス 1）の入
力として断片色 3 に割り当てる設定をする：

.. code:: glsl

   layout(location = 3, index = 1) out vec4 factor;

断片シェーダーの出力では、位置とインデックスは、出力の値を受け取る色出力番号とイ
ンデックスを指定する。他のすべてのシェーダー段階の出力では、位置は、後続のシェー
ダー段階の入力と照合するために使用できるベクトル番号を指定する（シェーダーが別の
プログラムオブジェクトにある場合も同様）。

宣言された出力が ``dvec3`` または ``dvec4`` 以外のスカラーまたはベクトル型である
場合は、単一の位置を消費する。``dvec3`` または ``dvec4`` 型の出力は連続した二つ
の場所を消費する。``double`` 型や ``dvec2`` 型の出力は全ての段階で一つの位置しか
消費しない。

宣言された出力が配列の場合は、指定された場所から連続した場所が割り当てられる。例
えば、次の宣言ではベクトルの位置番号 2, 3, 4 に ``colors`` が割り当てられる。

.. code:: glsl

    layout(location = 2) out vec4 colors[3];

宣言された出力が n×m の行列の場合、指定された位置から始まる複数の位置が割り当て
られる。割り当てられる場所の数は m 成分ベクトルの n 要素の配列と同じだ。

宣言された出力が構造体の場合、そのメンバーには宣言された順に連続した場所が割り当
てられ、構造体に指定された場所が最初のメンバーに割り当てられる。構造体のメンバー
が消費する位置の個数は、その構造体のメンバーが同じ型の出力変数として宣言されてい
るかのように、前述の規則が再帰的に適用される。

``location`` レイアウト修飾子は、構造体として宣言された出力変数に使用することが
できる。ただし、構造体メンバーに ``location`` 修飾子を使用するとコンパイルエラー
となる。``location`` レイアウト修飾子は出力ブロックと出力ブロックメンバーに使用
できる。

シェーダーで使用できる出力位置の数は限界がある。断片シェーダーでは、その限界は公
表されたドローバッファー数だ。

その他のシェーダーの場合、制限は実装依存であり、公表されている最大出力成分数の
1/4 以上でなければならない（計算シェーダーには出力がない）。取り付けられたシェー
ダーが対処されている個数以上の位置を使用している場合、デバイス依存最適化によって
プログラムが利用可能なハードウェア資源内に収まるようにしない限り、プログラムはリ
ンクに失敗する。

また、コンパイル時にリンクが失敗することがわかっている場合には、コンパイルエラー
があり得る。出力位置が負の場合は、コンパイルエラーになる。断片シェーダーがレイア
ウトインデックスを 0 未満または 1 以上に設定した場合も、コンパイルエラーとなる。

次のいずれかが発生すると、コンパイルエラーまたはリンクエラー：

* 断片シェーダーの出力変数の二つが両者とも同じ位置とインデックスに割り当てられて
  いる。
* 同じ（頂点｜細分化｜幾何）シェーダー段階からの出力変数二つが同じ位置に割り当て
  られている。

断片シェーダー出力では ``layout`` 修飾子または OpenGL API を使用して位置を割り当
てることができる。

すべてのシェーダー型において、明示的な位置の割り当てが明示的な割り当てのない他の
変数のための空間をリンカーに見つけさせられなくなる場合、プログラムはリンクに失敗
する。

シェーダーテキストで位置やインデックスが割り当てられていない出力変数が OpenGL
APIを通じて位置を指定されている場合は API で指定された位置が採用される。それ以外
の場合は、リンカーがそのような変数に場所を割り当てる。このような割り当てはすべ
て、色インデックスがゼロになる。詳細は、OpenGL 仕様書の 15.2 "Shader Execution"
を参照。出力変数が同じ言語の複数のシェーダで宣言されており、位置やインデックスの
値が衝突している場合、リンクエラーが発生する。

断片ではない出力が後続のあるシェーダー段階からの入力と一致するかどうかを判定する
ために、``location`` レイアウト修飾子が（もしあれば）一致しなければならない。

Transform Feedback Layout Qualifiers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

頂点、細分化、幾何各段階では、シェーダーが変換反響を制御することができる。それを
するときに、シェーダーはどの変換反響バッファーを使用するか、どの出力変数をどの
バッファーに書き込むか、各バッファーをどのようにレイアウトするかを決定する。これ
を実現するために、シェーダでは出力宣言に次のレイアウト修飾子識別子を使用できる：

| *layout-qualifier-id* :
|     ``xfb_buffer`` = *layout-qualifier-value*
|     ``xfb_offset`` = *layout-qualifier-value*
|     ``xfb_stride`` = *layout-qualifier-value*

これらの ``xfb_`` 修飾子を（前処理後に）静的に使用するシェーダーは、変換反響捕捉
モードとなり、変換反響の設定を記述する責任が生じる。このモードでは
``xfb_offset`` で選択された出力を、直接または間接的に、変換反響バッファーに取り込
むことになる。

``xfb_offset`` で選択された出力をどの変換反響バッファーに取り込むかは
``xfb_buffer`` 修飾子が指定する。``xfb_buffer`` 修飾子は ``out`` 修飾子、出力変
数、出力ブロック、出力ブロックメンバーのどれにでも適用できる。変換反響捕捉モード
のシェーダーには次の初期の大域既定がある：

.. code:: glsl

   layout(xfb_buffer = 0) out;

この既定を変更するには、インターフェイス修飾子 ``out`` に ``xfb_buffer`` をつけ
て別のバッファーを宣言する。これが大域既定を変更する唯一の方法だ。
``xfb_buffer`` 修飾子を付けずに変数や出力ブロックを宣言した場合は、大域既定バッ
ファーを継承する。``xfb_buffer`` 修飾子をつけて変数や出力ブロックを宣言すると、
その宣言されたバッファーを持る。あるブロックのメンバーすべてがそのブロックのバッ
ファーを継承する。メンバーは ``xfb_buffer`` を宣言することができるが、そのバッ
ファーはそのブロックから継承されたバッファーと一致しなければならない。そうでなけ
ればコンパイルエラー。

.. code:: glsl

   layout(xfb_buffer=2, xfb_offset=0) out block { // block's buffer is 2
       layout(xfb_buffer = 2) vec4 v; // okay, matches the inherited 2
       layout(xfb_buffer = 3) vec4 u; // ERROR, mismatched buffer
       vec4 w; // inherited
   };
   layout(xfb_offset=16) out vec4 t;  // initial default is buffer 0
   layout(xfb_buffer=1) out;          // new global default of 1
   out block {                        // block has buffer 1
       vec4 x;                        // x has buffer 1 (not captured)
       layout(xfb_buffer = 1) vec4 y; // okay (not captured)
       layout(xfb_buffer = 0) vec4 z; // ERROR, mismatched buffer
   };
   layout(xfb_offset=0) out vec4 g;   // g has buffer 1
   layout(xfb_buffer=2) out vec4 h;   // does not change global default
   layout(xfb_offset=16) out vec4 j;  // j has buffer 1

これが意味するのは、ブロックのメンバーのうち、変換反響バッファーに行くものはすべ
て同じバッファーに行くということだ。

ブロックが配列として宣言されている場合、ブロックの配列要素 0 のメンバーすべて
は、前述のように、宣言または継承された ``xfb_buffer`` に取り込まれる。一般に、ブ
ロックの大きさ N の配列は、N 個の連続したバッファに取り込まれ、ブロックの配列要
素 E のメンバーすべては、バッファ B に取り込まれる。ここで、B は宣言または継承さ
れた ``xfb_buffer`` に E を加えたものに等しくなる。

``xfb_buffer`` には、ブロックの配列を捕捉するために必要な追加のバッファーを含め
て、0 より小さいか、実装依存の定数 ``gl_MaxTransformFeedbackBuffers`` 以上の値
を指定すると、コンパイルエラーかリンクエラーとなる。

修飾子 ``xfb_offset`` は、変換反響バッファー内のバイトオフセットを割り当てる。
``xfb_offset`` をつけることができるのは、変数、ブロックメンバー、またはブロック
しかない。ブロックが ``xfb_offset`` で修飾されていれば、そのブロックのメンバーす
べてに変換反響バッファー内のオフセットが割り当てられる。ブロックが
``xfb_offset`` で修飾されていない場合、そのようなブロックのメンバーには変換反響
バッファーのオフセットは割り当てられない。オフセットが割り当てられた変数やブロッ
クメンバーだけが捕捉される（つまり、ブロックの適切な部分集合が捕捉される）。この
ような変数やブロックメンバーがシェーダー内で書き込まれるたびに、書き込まれた値は
割り当てられたオフセットで捕捉される。シェーダーの呼び出し時の間にこのようなブ
ロックメンバーや変数が書き込まれない場合、割り当てられたオフセットでのバッファー
の内容は未定義となる。変換反響オフセットが割り当てられている変数やメンバーへの静
的な書き込みがない場合でも、その空間はバッファーに割り当てられ、ストライドに影響
を与える。

``xfb_offset`` で修飾された変数やブロックメンバーには、スカラー、ベクトル、行
列、構造体、およびこれらの（サイズ付き）配列を指定できる。このオフセットは、最初
に修飾された変数やブロックメンバーの第一成分のサイズの倍数でなければならない。そ
うでなければコンパイルエラー。さらに、``double`` を含む集合体に適用される場合、
オフセットもバッファーに取られる空間も 8 の倍数でなければならない。与えられたオ
フセットは、修飾されたエンティティの最初のメンバーの最初の成分に適用される。その
後、修飾された実体中で、後続の成分はそれぞれその成分のサイズの倍数に整列した、次
に利用可能なオフセットに順に割り当てられる。集約型は成分レベルまで平坦化され、こ
の成分の並びが得られる。サイズなし配列の宣言に ``xfb_offset`` を適用するとコンパ
イルエラー。

出力バッファーのエイリアシングは許されない。変換反響オフセットが重なり合っている
変数を指定するとコンパイルエラーまたはリンクエラー。

修飾子 ``xfb_stride`` は、捕捉した各頂点が何バイト消費するかを指定する。その宣言
の変換反響バッファーが継承されているか、明示的に宣言されているかに関わらず、これ
が適用される。この修飾子は、変数、ブロック、ブロックメンバー、あるいは単に修飾子
``out`` にも適用できる。バッファーが倍精度成分を持つ出力を捕捉する場合、バッ
ファー幅は 8 の倍数であるか、そうでない場合は 4 の倍数でなければならず、そうでな
い場合はコンパイルエラーかリンクエラー。``xfb_stride`` をオーバーフローさせるよ
うな ``xfb_offset`` を持つことは、``xfb_stride`` の前後の宣言であろうと、異なる
コンパイル単位であろうと、コンパイルエラーかリンクエラー。``xfb_stride`` は、同
じバッファーに対して複数回宣言することができるが、異なる値のストライドを指定する
とコンパイルエラーかリンクエラー。

.. code:: glsl

   // buffer 1 has 32-byte stride
   layout(xfb_buffer = 1, xfb_stride = 32) out;

   // same as previous example; order within layout does not matter
   layout(xfb_stride = 32, xfb_buffer = 1) out;

   // everything in this block goes to buffer 0
   layout(xfb_buffer = 0, xfb_stride = 32) out block1 {
       layout(xfb_offset = 0) vec4 a;  // a goes to byte offset 0 of buffer 0
       layout(xfb_offset = 16) vec4 b; // b goes to offset 16 of buffer 0
   };

   layout(xfb_buffer = 3, xfb_offset = 12) out block2 {
       vec4 v;  // v will be written to byte offsets 12 through 27 of buffer
       float u; // u will be written to offset 28
       layout(xfb_offset = 40) vec4 w;
       vec4 x;  // x will be written to offset 56, the next available offset
   };

   layout(xfb_buffer = 2, xfb_stride = 32) out block3 {
       layout(xfb_offset = 12) vec3 c;
       layout(xfb_offset = 24) vec3 d; // ERROR, requires stride of 36
       layout(xfb_offset = 0) vec3 g;  // okay, increasing order not required
   };

バッファーに ``xfb_stride`` が指定されていない場合、バッファー幅は、最も高いオフ
セットに置かれた変数を保持するのに必要な最小値となり、必要な詰め物 (padding) も
含まれる：

.. code:: glsl

   // if there no other declarations for buffer 3, it has stride 32
   layout(xfb_buffer = 3) out block4 {
       layout(xfb_offset = 0) vec4 e;
       layout(xfb_offset = 16) vec4 f;
   };

結果のバッファー幅（暗黙的または明示的）を 4 で割って、実装依存の定数
``gl_MaxTransformFeedbackInterleavedComponents`` 以下でなければならない。

.. _khronos18-4.4.2-TCO:

Tessellation Control Outputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

変換反響レイアウト修飾子を除き、細分化制御シェーダーでは、出力ブロック、ブロック
メンバー、または変数宣言ではなく、インターフェイス修飾子 ``out`` 上でのみ出力レ
イアウト修飾子を使用することができる。細分化制御シェーダーで使用できる出力レイア
ウト修飾子の識別子は次のとおり：

| *layout-qualifier-id* :
|     ``vertices`` = *layout-qualifier-value*

識別子 ``vertices`` は細分化制御シェーダーが生成する出力パッチの頂点数を指定し、
細分化制御シェーダーの呼び出し回数も指定する。出力頂点数がゼロ以下であったり、
実装依存の最大パッチサイズより大きかったりすると、コンパイルエラーやリンクエラー
となる。

内在的に宣言された細分化制御出力配列 ``gl_out[]`` は、任意の出力レイアウト宣言に
よってもサイズが決定される。したがって、次の式は以前の出力レイアウト修飾子で指定
された出力パッチの頂点数を返す：

.. code:: glsl

   gl_out.length()

内在的に宣言された出力を含む、配列サイズなし宣言された出力については、メソッド
``length()`` の使用や、サイズを知る必要のある他の配列使用の前に、レイアウトを宣
言しなければならない。

出力レイアウト修飾子で指定された出力パッチ頂点数が、同じシェーダー内の出力変数宣
言で指定された配列サイズのどれとも一致しない場合は、コンパイルエラーとなる。

プログラム内のすべての細分化制御シェーダーのレイアウト宣言は、同じ出力パッチ頂点
数を指定しなければならない。細分化制御シェーダーを含むプログラムには、出力パッチ
の頂点数を指定するレイアウト修飾子が少なくとも一つ必要だが、すべての細分化制御
シェーダーでそのような宣言が必要ということではない。

Geometry Outputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

幾何シェーダーは、出力基本形状型、最大出力頂点数、出力ごとのストリーム番号の三種
の出力レイアウト識別子を追加的に持てる。基本形状型と頂点数の識別子は、出力ブロッ
ク、ブロックメンバー、変数宣言ではなく、インターフェイス修飾子 ``out`` でしか許
されない。ストリーム識別子は、インターフェイス修飾子 ``out``, 出力ブロック、変数
宣言上で許される。

幾何シェーダー出力に対するレイアウト修飾子の識別子は次のとおり：

| *layout-qualifier-id* :
|     ``points``
|     ``line_strip``
|     ``triangle_strip``
|     ``max_vertices`` = *layout-qualifier-value*
|     ``stream`` = *layout-qualifier-value*

基本形状型識別子の ``points``, ``line_strip``, ``triangle_strip`` は、幾何シェー
ダーが生成する出力基本形状の型を指定するために使用され、これらのうちただ一つが受
け入れられる。プログラム内の少なくとも一つの幾何シェーダー（コンパイル単位）は、
出力基本形状型を宣言しなければならず、プログラム内のすべての幾何シェーダーの出力
基本形状型宣言は、同じ基本形状型を宣言しなければならない。プログラム内のすべての
幾何シェーダーが出力基本形状型宣言をすることは必須ではない。

頂点数識別子 ``max_vertices`` は、シェーダーが単一の呼び出しで出力する最大の頂点
数を指定するために使用される。プログラム内の少なくとも一つの幾何シェーダー（コン
パイル単位）は、最大出力頂点数を宣言しなければならず、プログラム内のすべての幾何
シェーダーの出力頂点数宣言は、同じ回数を宣言しなければならない。プログラム内のす
べての幾何シェーダーが回数を宣言することは必須ではない。

.. code:: glsl

   layout(triangle_strip, max_vertices = 60) out; // order does not matter
   layout(max_vertices = 60) out;  // redeclaration okay
   layout(triangle_strip) out;     // redeclaration okay
   layout(points) out;             // error, contradicts triangle_strip
   layout(max_vertices = 30) out;  // error, contradicts 60

この例では、幾何シェーダーからの出力はすべて三角形であって、シェーダーから出力さ
れるのは高々 60 個の頂点だ。最大の頂点数が ``gl_MaxGeometryOutputVertices`` より
も大きい場合はエラーとなる。

識別子 ``stream`` は、幾何シェーダーの出力変数またはブロックが、特定の頂点スト
リーム（ゼロから始まる番号）に関連付けられていることを指定するために用いられる。
ストリーム番号の既定値を、次の例のようにインターフェイス修飾子 ``out`` によって
大域スコープで宣言することができる：

.. code:: glsl

   layout(stream = 1) out;

このような宣言で指定されたストリーム番号は、それまでの既定値を置き換え、新しい既
定値が設定されるまで、後続のすべてのブロックおよび変数の宣言に適用される。初期設
定のストリーム番号はゼロだ。

各出力ブロックまたは非ブロック出力変数は、頂点ストリームに関連付けられる。ブロッ
クまたは変数がストリーム識別子とともに宣言されている場合は、指定されたストリーム
に関連付けられ、そうでない場合は、現在の既定ストリームに関連付けられる。ブロック
メンバーはストリーム識別子を付けて宣言することができるが、指定されたストリームは
含まれるブロックに関連付けられたそれと一致しなければならない。例：

.. code:: glsl

   layout(stream=1) out;           // default is now stream 1
   out vec4 var1;                  // var1 gets default stream (1)
   layout(stream=2) out Block1 {   // "Block1" belongs to stream 2
       layout(stream=2) vec4 var2; // redundant block member stream decl
       layout(stream=3) vec2 var3; // ILLEGAL (must match block stream)
       vec3 var4;                  // belongs to stream 2
   };
   layout(stream=0) out;           // default is now stream 0
   out vec4 var5;                  // var5 gets default stream (0)
   out Block2 {                    // "Block2" gets default stream (0)
       vec4 var6;
   };
   layout(stream=3) out vec4 var7; // var7 belongs to stream 3

幾何シェーダーで出力された各頂点は、特定のストリームに割り当てられ、出力された頂
点の属性は、対象となるストリームに割り当てられた出力ブロックと変数の集合から取得
される。各頂点が放出された後、すべての出力変数の値は未定義となる。さらに、各頂点
ストリームに関連する出力変数は、格納を共有してもよい。あるストリームに関連する出
力変数に書き込むと、他のストリームに関連する出力変数が上書きされることがある。幾
何シェーダーは、各頂点を放出する際に、その頂点が放出されるストリームに関連するす
べての出力に書き込み、他のストリームに関連する出力には書き込まない。

幾何シェーダー出力ブロックや同変数が複数回宣言された場合、そのような宣言のすべて
で、その変数は同じ頂点ストリームに関連付けられなければならない。存在しないスト
リーム番号を指定したストリーム宣言がある場合、シェーダーのコンパイルは失敗する。

組み込み幾何シェーダー出力は頂点ストリーム 0 に常に関連付けられる。

プログラム内のすべての幾何シェーダー出力レイアウト宣言は、同じレイアウトと同じ
``max_vertices`` 値を宣言しなければならない。幾何シェーダーがプログラムに含まれ
ている場合、そのプログラムのどこかに少なくとも一つの幾何出力レイアウト宣言がなけ
ればならないが、すべての幾何シェーダー（コンパイル単位）がそれを宣言する必要はな
い。

Fragment Outputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

組み込み断片シェーダ変数 ``gl_FragDepth`` は、次のレイアウト修飾子のいずれかを使
用して再宣言することができる：

| *layout-qualifier-id* :
|     ``depth_any``
|     ``depth_greater``
|     ``depth_less``
|     ``depth_unchanged``

``gl_FragDepth`` に対するレイアウト修飾子は、任意のシェーダー呼び出しによって書
き込まれる ``gl_FragDepth`` の最終値の意図を制約する。レイアウト修飾子に整合する
``gl_FragDepth`` のすべての値が不合格・合格する場合には、与えられた断片に対して
奥行き検定が不合格・合格すると仮定して最適化を行うことが GL 実装はできる。これに
は、断片がさえぎられ、シェーダーに副作用がないために廃棄される場合に、シェーダー
の実行を飛ばすことが含まれる可能性がある。``gl_FragDepth`` の最終値がそのレイア
ウト修飾子と整合しない場合、対応する断片の奥行き検定の結果は未定義となる。しか
し、この場合にはエラーとはならない。奥行き検定が合格し、奥行き書き込みが有効な場
合、奥行きバッファーに書き込まれる値は、レイアウト修飾子と整合しているか否かに関
わらず、常に ``gl_FragDepth`` の値となる。

既定では ``gl_FragDepth`` は ``depth_any`` として修飾される。``gl_FragDepth`` の
レイアウト修飾子が ``depth_any`` の場合、シェーダーコンパイラーは
``gl_FragDepth`` への割り当てが未知の方法で変更されていることに留意し、奥行き検
定は常にシェーダーの実行後に行われる。レイアウト修飾子が ``depth_greater`` の場
合、``gl_FragDepth`` の最終値が ``gl_FragCoord`` の ``z`` 成分で与えられる断片の
補間奥行き値以上であると仮定することができる。レイアウト修飾子が ``depth_less``
の場合、``gl_FragDepth`` を修正してもその値が減少するだけだと考えることができ
る。レイアウト修飾子が ``depth_unchanged`` の場合、シェーダーコンパイラーは
``gl_FragDepth`` のいかなる修正も尊重するが、他の部分は ``gl_FragDepth`` に新し
い値が割り当てられていないと仮定することができる。

``gl_FragDepth`` の再宣言は以下のように行われる：

.. code:: glsl

   // redeclaration that changes nothing is allowed +
   out float gl_FragDepth;

   // assume it may be modified in any way
   layout(depth_any) out float gl_FragDepth;

   // assume it may be modified such that its value will only increase
   layout(depth_greater) out float gl_FragDepth;

   // assume it may be modified such that its value will only decrease
   layout(depth_less) out float gl_FragDepth;

   // assume it will not be modified
   layout(depth_unchanged) out float gl_FragDepth;

``gl_FragDepth`` がプログラム内のいずれかの断片シェーダーで再宣言された場合、
``gl_FragDepth`` への静的割り当てを持つそのプログラム内の断片シェーダー
すべてで再宣言されなければならない。
単一プログラム内の断片シェーダーすべてにおける
``gl_FragDepth`` の再宣言のすべてが同じ修飾子の集合を持たなければならない。
どのシェーダー内でも、
``gl_FragDepth`` の最初の再宣言がその使用よりも前に現れなければならない。
組み込み ``gl_FragDepth`` は断片シェーダーでのみ事前宣言されているので、
他のシェーダー言語で再宣言するとコンパイルエラーになる。

.. _khronos18-4.4.3:

4.4.3. Uniform Variable Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

レイアウト修飾子は、一様変数とサブルーチン一様に使用できる。一様変数とサブルーチ
ン一様（変数）に対するレイアウト修飾子識別子は次のとおり：

| *layout-qualifier-id* :
|     ``location`` = *layout-qualifier-value*

位置識別子は、既定ブロック一様変数とサブルーチン一様（変数）で使用できる。位置
は、API が一様を参照し、その値を更新するための位置を指定する。一様配列の個々の要
素には連続した位置が割り当てられ、最初の要素は位置 ``location`` だ。プログラム内
でリンクされた同じ位置を共有する既定ブロック一様変数宣言は、名前、型、修飾子、配
列性が一致しなければならない。配列の場合は、配列の次元と配列のサイズが一致してい
なければならない。構造体の場合、この規則がメンバーすべてに再帰的に適用される。サ
ブルーチン一様変数二つが同じシェーダー段階内で同じ位置に存在することはできない。
コンパイルエラーかリンクエラーとなる。既定ブロック変数の有効な位置は、0 から実装
定義の一様位置の最大数から 1 を引いた範囲にある。サブルーチン一様（変数）の有効
な位置は、0 から実装定義の段階ごとのサブルーチン一様（変数）の最大位置数から 1
を引いた値までの範囲にある。

位置は既定ブロック一様配列や構造体に割り当てることができる。最も内側にある最初の
スカラー、ベクトル、行列のメンバーや要素は指定された ``location`` を取り、コンパ
イラーは次の最も内側にあるメンバーや要素に次の増分の位置値を割り当てる。それ以降
の最内側のメンバーや要素は、構造体や配列全体の増分の位置を取得する。この規則
は、入れ子になった構造体や配列にも適用され、最も内側にあるスカラー、ベクトル、行
列の各メンバーに一意の位置を与える。明示的サイズのない配列の場合は、静的な使用量
に基づいてサイズが計算される。リンカーが明示的位置のない一様（変数）の位置を生成
する場合、明示的位置のある一様（変数）すべてについて、その配列要素や構造体のメン
バーがすべて使用されていると仮定し、その要素やメンバーが使用されていないと判断さ
れた場合でも、リンカーは競合する位置を生成しない。

個々の（既定ブロック）透明一様変数を受け入れる API に対する SPIR-V を生成すると
き、それらを宣言するときに位置を含めないとコンパイルエラー。

Vulkan を対象にしている場合、修飾子 ``push_constant`` はブロック全体を宣言するた
めに使用され、Vulkan API で定義されているように、定数 ``push`` の集合を表す。こ
れを一様ブロック宣言以外に適用したり、Vulkan を対象にしていない場合はコンパイル
エラー。ブロック内の値は Vulkan API の仕様に基づいて初期化される。
``layout(push_constant)`` で宣言されたブロックは、オプションで *instance-name*
を含めることができる。``push_constant`` ブロックは段階ごとに一つだけで、そうでな
い場合はコンパイルエラーやリンクエラー。``push_constant`` 配列は、動的一様なイン
デックスでしかインデックスを付けられない。``push_constant`` で宣言された一様ブ
ロックは、宣言されていないブロックとは異なる資源を使用し、別々に計上される。

4.4.4. Subroutine Function Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

レイアウト修飾子をサブルーチン関数に使用できる。サブルーチン関数のレイアウト修飾
子識別子は次のとおり：

| *layout-qualifier-id* :
|     ``index`` = *layout-qualifier-value*

シェーダー内でインデックス修飾子を持つ各サブルーチンには、一意のインデックスが与
えられなければならない。そうでない場合はコンパイルエラーまたはリンクエラー。イン
デックスは 0 から実装定義のサブルーチン最大数から 1 を引いた範囲でなければならな
い。OpenGL サブルーチン関数列挙 API がアクティブインデックスすべてに対して空では
ない名前を返すように、シェーダーは 0 から始まる飛び飛びにならないインデックス値
の範囲を割り当てることを推奨するが、必須ではない。

4.4.5. Uniform and Shader Storage Block Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

レイアウト修飾子は一様およびシェーダー格納ブロックに使用できるが、非ブロック一様
宣言には使用できない。一様およびシェーダー格納ブロックのレイアウト修飾子の識別子
（および ``shared`` キーワード）は次のとおり：

| *layout-qualifier-id* :
|     ``shared``
|     ``packed``
|     ``std140``
|     ``std430``
|     ``row_major``
|     ``column_major``
|     ``binding`` = *layout-qualifier-value*
|     ``offset`` = *layout-qualifier-value*
|     ``align`` = *layout-qualifier-value*

これらはいずれも、宣言されている変数の使用法に意味的な影響を全く与えず、メモリー
内でのデータの配置方法を示すに過ぎない。例えば、行列のセマンティクスは、どのよう
なレイアウト修飾子が使用されていても、この仕様の他の部分で述べられたように、常に
列に基づく。

（一様｜シェーダー格納）ブロックレイアウト修飾子は、大域スコープ、単一の（一様｜
シェーダー格納ブロック｜ブロックメンバー）宣言上で宣言することができる。

一様ブロックには大域スコープでの既定レイアウトが次のように設定されている：

.. code:: glsl

   layout(layout-qualifier-id-list) uniform;

シェーダー格納ブロックの場合には：

.. code:: glsl

   layout(layout-qualifier-id-list) buffer;

これが行われると、直前の既定修飾がまず継承され、それから宣言にある各修飾につい
て、以下に述べる上書き規則に従って上書きされる。その結果、後続の（一様｜シェー
ダー格納）ブロックの定義に適用される新しい既定修飾となる。

SPIR-V を生成する際のコンパイルの初期状態は、次のように宣言されたかのようなものだ：

.. code:: glsl

   layout(std140, column_major) uniform;
   layout(std430, column_major) buffer;

ところが ``push_constant`` を宣言すると、バッファーの既定レイアウトは ``std430``
になる。この既定を大域的に設定する方法はない。

SPIR-V を生成していないときのコンパイルの初期状態は、次のように宣言されたかのよ
うなものだ：

.. code:: glsl

   layout(shared, column_major) uniform;
   layout(shared, column_major) buffer;

（一様｜シェーダー格納）ブロックは、オプションでレイアウト修飾子を付けて宣言する
ことができ、その個々のメンバー宣言も同様だ。このようなブロックレイアウト修飾は、
ブロックの内容にのみ適用される。大域レイアウト宣言と同様に、ブロックレイアウト修
飾は、まず現在の既定の修飾を継承し、次にそれを上書きする。同様に、個々のメンバー
のレイアウト修飾は、メンバー宣言だけに適用され、ブロックの修飾を継承して上書きす
る。

修飾子 ``shared`` は ``std140``, ``std430``, および ``packed`` 修飾子のみを上書
きし、その他の修飾子は継承される。コンパイラーかリンカーは、すべての配列が明示的
なサイズで宣言され、すべての行列が一致する ``row_major`` 修飾子と
``column_major`` 修飾子の両方を、または一方を（ブロック定義外の宣言から得られる
場合もある）持つ限り、この定義を含む複数のプログラムおよびプログラム可能段階が、
このブロックのために同じメモリーレイアウトを共有することを保証する。これにより、
異なるプログラム間で同じバッファーを使用して同じブロック定義をback することがで
きる。SPIR-Vを生成する際に ``shared`` を使用するとコンパイルエラーとなる。

修飾子 ``packed`` は ``std140``, ``std430``, ``shared`` のみを上書きし、その他の
修飾子は継承される。``packed`` を使用した場合、共有可能なレイアウトは保証されま
せん。コンパイラーとリンカーは、どの変数が活発的に使用されるかや、その他の条件に
基づいて、メモリー使用を最適化することができる。ブロック内のどこにどの変数がある
かを保証する方法が他にないため、オフセットを問い合わせる必要がある。

プログラム内の複数の段階で同じ充満一様ブロックやシェーダー格納ブロックにアクセス
するとリンクエラー。プログラム間で同じ充満一様ブロックやシェーダー格納ブロックに
アクセスしようとすると、メンバーオフセットが衝突したり、未定義の値が読み込まれた
りする可能性がある。しかし、実装では充満ブロックのための標準的なレイアウトを使用
することで、充満ブロックのアプリケーション管理を支援することができる。SPIR-V の
生成時に ``packed`` 修飾子を使用するとコンパイルエラー。

``std140`` および ``std430`` 修飾子は ``packed``, ``shared``, ``std140``,
``std430`` 修飾子のみを上書きし、その他の修飾子は継承される。``std430`` 修飾子は
シェーダー格納ブロックでのみ対処されている。一様ブロックに ``std430`` 修飾子を使
用したシェーダーは、それが ``push_constant`` も修飾されていない限りコンパイルエ
ラー。

OpenGL 仕様書の 7.6.2.2 "Standard Uniform Block Layout" に記載されているように、
レイアウトはこれによって明示的に決定される。したがって、上記の ``shared`` と同様
に、結果となるレイアウトはプログラムをまたがって共有可能だ。

メンバー宣言のレイアウト修飾子には ``shared``, ``packed``, ``std140``,
``std430`` の各修飾子は使用できない。これらの修飾子は、（オブジェクトなし）大域ス
コープまたはブロック宣言でのみ使用でき、使用しない場合はコンパイルエラー。

``row_major`` および ``column_major`` 修飾子は、構造体や配列に含まれるすべての行
列を含むすべての入れ子の深さの行列のレイアウトにしか影響を与えない。これらの修飾
子は他の型にも適用できるが、効果はない。

``row_major`` 修飾子は ``column_major`` 修飾子のみを上書きし、その他の修飾子は継
承される。行列の行内の要素は、メモリー内で連続している。

``column_major`` 修飾子は ``row_major`` 修飾子よりも優先されるが、その他の修飾子
は継承される。行列の列内の要素は、メモリー内で連続している。

``binding`` 修飾子は（一様｜シェーダー格納）ブロックに対応する一様バッファー束縛
点を指定し、ブロックのメンバー変数の値を取得するのに使用される。大域スコープやブ
ロックメンバーの宣言に束縛修飾子を指定することはコンパイルエラーとなる。
``binding`` 修飾子を指定せずに宣言された（一様｜シェーダー格納）ブロックは、最初
はブロック束縛点 0 に割り当てられる。プログラムがリンクされた後、``binding`` 修
飾子の有無にかかわらず宣言された（一様｜シェーダー格納）ブロックに使用される束縛
点は API によって更新することができる。

OpenGL で使用する場合、``binding`` 修飾子が配列としてインスタンス化された一様ブ
ロックやシェーダー格納ブロックで使用されると、配列の最初の要素は指定されたブロッ
ク束縛を取り、それ以降の各要素は次の連続した束縛点を取る。配列の配列では、要素そ
れぞれ（例えば ``a[2][3]`` の場合は 6 要素）が束縛点を得て、
:ref:`khronos18-4.1.9` で説明した配列の配列の順序に従って順序付けられる。

Vulkan を対象にした場合、配列としてインスタンス化された一様ブロックやバッファー
ブロックで ``binding`` 修飾子が使用されると、配列全体が提供された束縛番号のみを
受け取る。次の連続した束縛番号を別のオブジェクトで利用できる。配列の配列の場合、
記述子集合アクセスに使用される記述子集合配列要素の番号は、
:ref:`khronos18-4.1.9` で説明した配列の配列の順序に従って順序付けられる。

（一様｜シェーダー格納）ブロックインスタンスの束縛点がゼロより小さい場合、または
対応する実装依存のバッファー束縛の最大数以上の場合は、コンパイルエラーとなる。
（一様｜シェーダー格納）ブロックのインスタンスをサイズ N の配列として
``binding`` 修飾子を使用する場合、*binding* から *binding* + N - 1 までの配列の
すべての要素は、この範囲内に収まらなければならない。同じ束縛番号を複数の一様ブ
ロックや複数のバッファーブロックに使用するとコンパイルエラーまたはリンクエラーと
なる。

修飾子 ``set`` は Vulkan を対象にしている場合に限り使用できる。このオブジェクト
が属する記述子集合を指定する。独立した修飾子、ブロックメンバー、または記述子集合
を対処する API を対象にしていない場合に ``set`` を適用するとコンパイルエラー。
``push_constant`` 修飾されたブロックに ``set`` を適用するとコンパイルエラー。既
定では ``set`` 識別子なしで宣言された非 ``push-constant`` （一様｜シェーダー格
納）ブロックは、記述子集合 0 に割り当てられる。同様に、``set`` 識別子なしで一様
として宣言された採取器、テクスチャー、またはサブパス入力型も、記述子集合 0 に割
り当てられる。

配列として宣言されたオブジェクトに適用された場合、その配列のすべての要素は、指定
された ``set`` に属する。

SPIR-V を生成する際に ``set`` または ``binding`` の値がフロントエンド構成で指定
された最大値を超えるとコンパイルエラーとなる。

一つのレイアウト宣言に複数の引数がリストされている場合、左から右の順に一つずつ宣
言されたのと同じ効果が得られる。それぞれが前の修飾の結果を引き継いで上書きする。
例えば、次の例は ``column_major`` 修飾になる：

.. code:: glsl

   layout(row_major, column_major)

さらなる例：

.. code:: glsl

   layout(shared, row_major) uniform; // default is now shared and row_major

   layout(std140) uniform Transform { // layout of this block is std140
       mat4 M1;                       // row major
       layout(column_major) mat4 M2;  // column major
       mat3 N1;                       // row major
   };

   uniform T2 {                       // layout of this block is shared
       ...
   };

   layout(column_major) uniform T3 {  // shared and column major
       mat4 M3;                       // column major
       layout(row_major) mat4 m4;     // row major
       mat3 N2;                       // column major
   };

----

Vulkan を対象にしている場合、ブロックおよびブロックメンバーの ``offset`` および
``align`` 修飾子は、一様ブロックおよびバッファーブロックに限り使用できる。
Vulkan を対象にしていない場合、これらの修飾子は ``std140`` または ``std430`` レ
イアウトで宣言されたブロックに限り使用できる。

修飾子 ``offset`` はブロックメンバーに限り使用できる。修飾子 ``offset`` は、修飾
されたメンバーを指定された *layout-qualifier-value* （バッファーの先頭からのバイ
トオフセット）以降に強制的に開始させる。ブロックの他のメンバー内にあるオフセット
を明示的または代入的に持たせるとコンパイルエラーとなる。SPIR-V を生成しない場
合、ブロック内の直前のメンバーのオフセットよりも小さいオフセットを指定するとコン
パイルエラーとなる。同じプログラム内で同じブロック名でリンクされた二つのブロック
は、``offset`` で修飾されたメンバーの集合が全く同じであり、それらの
*layout-qualifier-value* の値が同じでなければならず、そうでなければリンクエラー
となる。指定されたオフセットは、それが修飾するブロックメンバーの型の base
alignment の倍数でなければならず、そうでなければコンパイルエラーになる。

----

修飾子 ``align`` は、各ブロックメンバーの開始点を最小の byte alignment にする。
各メンバー内の内部レイアウトには影響を与えず、``std140`` または ``std430`` の規
則に従う。指定された alignment は 0 よりも大きく、かつ 2 のべき乗でなければなら
ず、そうでない場合はコンパイルエラー。

メンバーの実際の alignment は、指定された ``align`` alignmentと、そのメンバーの
型の標準（``std140`` など）base alignment のうち大きい方になる。メンバーの実際の
オフセットは次のように計算される： ``offset`` が宣言されている場合は、そのオフ
セットから開始し、そうでない場合は、宣言順で先行メンバーの直後のオフセットから開
始する。結果オフセットが実際の alignment の倍数でない場合は、実際の alignment の
倍数である最初のオフセットまで増やす。これにより、メンバーの実際のオフセットが得
られる。

``align`` が配列に適用された場合、配列の開始点のみに影響し、配列の内部幅には影響
しない。宣言では ``offset`` 修飾子と ``align`` 修飾子の両方を指定できる。

修飾子 ``align`` は、ブロックで使用された場合、ブロックで宣言されたのと同じ
``align`` 値で各メンバーを修飾するのと同じ効果があり、これが行われた場合と同じコ
ンパイル結果とコンパイルエラーが得られる。前述のように、個々のメンバーは独自の
``align`` を指定することができ、それはブロックレベルの ``align`` よりも優先され
るが、そのメンバーに限られる。

例：

.. code:: glsl

   layout(std140) uniform block {
       vec4 a;                         // a takes offsets 0-15
       layout(offset = 32) vec3 b;     // b takes offsets 32-43
       layout(offset = 40) vec2 c;     // ERROR, lies within previous member
       layout(offset = 48) vec2 d;     // d takes offsets 48-55
       layout(align = 16) float e;     // e takes offsets 64-67
       layout(align = 2) double f;     // f takes offsets 72-79
       layout(align = 6) double g;     // ERROR, 6 is not a power of 2
       layout(offset = 80) float h;    // h takes offsets 80-83
       layout(align = 64) dvec3 i;     // i takes offsets 128-151
       layout(offset = 164, align = 8)
       float j;                        // j takes offsets 168-171
   };

.. _khronos18-4.4.6:

4.4.6. Opaque Uniform Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

不透明な一様変数は、結合のために一様レイアウト修飾子を取ることができる。

| *layout-qualifier-id* :
|     ``binding`` = *layout-qualifier-value*

``binding`` 修飾子は、その変数が束縛される点を指定する。``binding`` 修飾子なしで
宣言された不透明変数は、既定束縛 0 になる。

OpenGL で使用する場合、``binding`` 修飾子が配列とともに使用されると、配列の最初
の要素は指定された束縛点を取り、それ以降の各要素は連続した次の束縛点を取る。配列
の配列の場合は先程の ``a[2][3]`` の例を述べた文と同じ。

Vulkan を対象にした場合、配列で ``binding`` 修飾子が使用されると、提供された束縛
番号だけを配列全体が取る。次の連続した束縛番号は、別のオブジェクトに利用できる。

``binding`` が 0 より小さい場合、または実装依存の対処される束縛点の最大数以上の
場合は、コンパイルエラーとなる。サイズ N の配列で ``binding`` 修飾子を使う場合、
番号 *binding* から番号 *binding* + N - 1 までの配列のすべての要素は、この範囲内
に収まる必要がある。同じ番号 *binding* を共有する不可分計数器のオフセットがすべ
て異なっていない限り、複数の不可分計数器に同じ束縛番号を使用すると、コンパイルエ
ラーまたはリンクエラーとなる。

一つのプログラム内のシェーダー二つが同じ *opaque-uniform* 名に対して異なる
*layout-qualifier-value* 束縛を指定するとリンクエラーとなる。ただし、次の例のよ
うに、同じ名前の宣言の一部に ``binding`` を指定しても、すべての宣言に
``binding`` を指定してもエラーではない：

.. code:: glsl

   // in one shader...
   layout(binding=3) uniform sampler2D s; // s bound to point 3

   // in another shader...
   uniform sampler2D s;                   // okay, s still bound at 3

   // in another shader...
   layout(binding=4) uniform sampler2D s; // ERROR: contradictory bindings

.. _khronos18-4.4.7:

4.4.7. Atomic Counter Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vulkan を対象にした場合、不可分計数器は使用できない。

不可分計数器のレイアウト修飾子は、その宣言で使用できる：

| *layout-qualifier-id* :
|     ``binding`` = *layout-qualifier-value*
|     ``offset`` = *layout-qualifier-value*

例えば下は、不可分計数器 ``a`` の不透明ハンドルを、不可分計数器バッファーの束縛
点 2 に、そのバッファーの 4 基本マシン単位のオフセットで束縛するように設定する。
束縛点 2 の既定オフセットは 4（不可分計数器のサイズ）で後置インクリメントされ
る：

.. code:: glsl

   layout(binding = 2, offset = 4) uniform atomic_uint a;

後続の不可分計数器宣言は、直前の（インクリメントされた）オフセットを継承する。例
えば次の宣言では、不可分計数器 ``bar`` がバッファーの束縛点 2 に 8基本マシン単位
のオフセットで束縛されるように設定する。結合点 2 のオフセットは、再び 4 だけ後置
インクリメントされる：

.. code:: glsl

   layout(binding = 2) uniform atomic_uint bar;

一つのレイアウト宣言に複数の変数がリストされている場合、左から右の順に一つずつ宣
言したのと同じ効果が得られる。

束縛点は継承されず、オフセットのみが継承される。各束縛点では、同じ束縛を使用する
後続の変数の継承のために、それ自身の現在の既定オフセットを追跡する。コンパイルの
初期状態では、すべての束縛点のオフセットが 0 になる。オフセットは、大域スコープ
で（変数を宣言せずに）束縛点ごとに設定できる。例えば、以下のようになる：

.. code:: glsl

   layout(binding = 2, offset = 4) uniform atomic_uint;

上記は結合点 2 に対する次の ``atomic_uint`` 宣言がオフセット 4 を継承するように
設定する（ただし、既定束縛は設定しない）。

.. code:: glsl

   layout(binding = 2) uniform atomic_uint bar; // offset is 4
   layout(offset = 8) uniform atomic_uint bar;  // error, no default binding

不可分計数器は同じ束縛点を共有することができるが、束縛が共有されている場合、それ
らのオフセットは、明示的または暗黙的に一意的であり、重なり合わないことが必要だ。

シェーダーの先頭を想定した、有効な一様宣言の例：

.. code:: glsl

   layout(binding=3, offset=4) uniform atomic_uint a; // offset = 4
   layout(binding=2) uniform atomic_uint b;           // offset = 0
   layout(binding=3) uniform atomic_uint c;           // offset = 8
   layout(binding=2) uniform atomic_uint d;           // offset = 4

無効な一様宣言の例：

.. code:: glsl

   layout(offset=4) ...               // error, must include binding
   layout(binding=1, offset=0) ... a; // okay
   layout(binding=2, offset=0) ... b; // okay
   layout(binding=1, offset=0) ... c; // error, offsets must not be shared
                                      // between a and c
   layout(binding=1, offset=2) ... d; // error, overlaps offset 0 of a

``gl_MaxAtomicCounterBindings`` 以上の束縛値で不可分計数器を束縛するとコンパイル
エラーになる。サイズなし ``atomic_uint`` の配列を宣言するとコンパイルエラー。

4.4.8. Format Layout Qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

フォーマットレイアウト修飾子は、画像変数の宣言（キーワードに ``"image"`` を持つ
基本型で宣言されたもの）に使用できる。画像変数宣言のためのフォーマットレイアウト
修飾子の識別子は次のとおり（一部略）：

| *layout-qualifier-id* :
|     *float-image-format-qualifier*
|     *int-image-format-qualifier*
|     *uint-image-format-qualifier*
|     ``binding`` = *layout-qualifier-value*
|
| *float-image-format-qualifier* :
|     ``rgba32f``
|     ``rgba16f``
|     (etc.)
|
| *int-image-format-qualifier* :
|     ``rgba32i``
|     (etc.)
|
| *uint-image-format-qualifier* :
|     ``rgba32ui``
|     (etc.)

``format`` レイアウト修飾子は、宣言された画像変数に関連する画像表現形式を指定す
る。画像変数宣言一個につき、フォーマット修飾子を一つだけ指定できる。浮動小数点成
分型（``"image"`` で始まるキーワード）、符号付き整数成分型（``"iimage"`` で始ま
るキーワード）、または符号なし整数成分型（``"uimage"`` で始まるキーワード）の画
像変数では、使用するフォーマット修飾子は、それぞれ
*float-image-format-qualifier*, *int-image-format-qualifier*,
*uint-image-format-qualifier* 文法規則に一致しなければならない。フォーマット修飾
子が画像変数の型と一致しない画像変数を宣言するとコンパイルエラーとなる。

画像読み込みや不可分操作に使用される画像変数は、フォーマットレイアウト修飾子を指
定しなければならない。フォーマットレイアウト修飾子なしで宣言された画像一様変数や
関数引数を画像読み込みや不可分関数に渡すとコンパイルエラーとなる。

``writeonly`` で修飾されていない一様（変数）はフォーマットレイアウト修飾子を持た
なければならない。読み込みアクセスのために関数に渡された画像変数を ``writeonly``
として宣言することはできないので、フォーマットレイアウト修飾子を付けて宣言しなけ
ればならないことに注意を要する。

修飾子 ``binding`` については :ref:`khronos18-4.4.6` に記述がある。

4.4.9. Subpass Input Qualifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

サブパス入力は Vulkan を対象にしている場合に限り利用可能だ。

サブパス入力は、基本 ``subpassInput`` 型で宣言される。これらはレイアウト修飾子
``input_attachment_index`` を付けて宣言しないとコンパイルエラー。例えば：

.. code:: glsl

   layout(input_attachment_index = 2) uniform subpassInput t;

これはどのサブパスから入力が読み込まれるかを選択する。
``input_attachment_index`` に割り当てられた値、たとえば i とする
(``input_attachment_index = i``) と、パスの入力リストの中のその i 番目の登場を選
択する。

サイズ N の配列が宣言されている場合は、提供されたものから始まる N 個の連続した
``input_attachment_index`` 値を消費する。

同じ ``input_attachment_index`` を異なる変数に宣言すると、コンパイルエラーまたは
リンクエラーとなる。これには、配列宣言で消費される暗黙の
``input_attachment_index`` の重複も含まれる。

``input_attachment_index`` に割り当てられた値が ``gl_MaxInputAttachments`` 以上
の場合、コンパイルエラーとなる。
