======================================================================
Python 入門［２＆３対応］読書ノート 2/3
======================================================================

.. include:: /_include/book-details/hosoda10.txt

.. contents:: ノート目次

第 9 章 イテレータ
===================================
* ストリーム処理のためのポインタ的な役割
* 遅延評価

9.1 イテレータとは
-----------------------------------
* Python におけるイテレータとは、``next`` メソッドを実装するオブジェクトのこと。
* ``next`` メソッドと ``StopIteration`` 例外を理解しておく。
  イテレータが ``next`` し切れなくなったら、そこから例外が送出されるイメージ。

* 囲み記事。Python 3 からは一部の関数がイテレータを返すように仕様変更になっている。
  特に、イテレータの ``next`` メソッドがなくなり、単なるフリー関数になるようだ。
  ``it.next()`` ではなく ``next(it)`` ということ。

9.2 ジェネレーター
-----------------------------------
この本はなぜか語尾の -or のカタカナ表記が揺らいでいる。

* <関数に結びつく広義のイテレータ> (p. 146)
* <ジェネレーターの特徴は、イテレータを進めるまで、関数内のローカル変数を保持したまま、
  次のシーケンス要素生成までの評価が中断されることです> (p. 146)

* <ジェネレーターも内包表記で書くことができます> (p. 148)

  >>> gen = (i * 3 for i in range(10)) # (p. 148)
  >>> gen.next()
  0
  >>> gen.next()
  3
  >>> gen.next()
  6

* 囲み記事の ``send`` は読みとばす。

第 10 章 文字列
===================================
10.1 文字列の概要
-----------------------------------
* どういうわけか、手許の IDLE だと ``len(u'日本語')`` が 6 を返す。3 が正解。
* ``u'日本語'.encode('utf8')`` のタイプは ``str`` だ。

10. 2 文字列の作成
-----------------------------------
* <``r`` の文字を置くとエスケープシーケンスを無視する raw 文字列のリテラル表現になります> (p. 154)
* <``%`` 演算子を利用した旧来の方法は、今後廃止される予定です> (p. 157)
* Python 3 風 ``format`` の使い方がすぐに理解できない。後で復習。

* ``join`` メソッドには慣れておくこと。例えば CSV テキストを文字列リストから素早く構築できる。

10.3 文字列の読み込み
-----------------------------------
* 文字検索には ``find``, ``rfind`` と ``index``, ``rindex`` メソッドが使える。
  見つからなかったときに例外 ``ValueError`` を投げるのが ``index`` 系。(p. 159)

* ``isdigit``, ``isnumeric`` メソッドは
  <Unicode 型および Python 3 からは全角に対応しています> (p. 162)
  とある。全角文字の１やらローマ数字やらを試して遊んでみよう。

* <printable な文字とは、
  ``print`` 関数で何かしらの文字列が
  ``sys.stdout`` に表示される文字のこと> (p. 165)

10.4 文字列の更新
-----------------------------------
これが理解するのが難しかった。

* <変更したように見える操作もありますが、新しく文字列を作成して、そのコピーを返しているだけ> (p. 166)
  らしい。

* ``split`` メソッドは、<何も指定しないか、None を指定した場合は、分割アルゴリズムが変わります> (p. 167)
  空白文字がきれいにトリムされるようだ。

* ``splitlines`` という、改行文字に特化した ``split`` のようなメソッドがある。
* ``partition``, ``rpartition`` は ``split`` の弱いやつか。

整形系メソッドは興味がわいたら読み返す。

10.5 文字列の削除
-----------------------------------
削除に見えても、実は新しくオブジェクトを作って返す操作だ。

10.6 Unicode 文字列と文字コード変換
-----------------------------------
* <Unicode は 18 ビットで 1 文字を表現する> (p. 175) とあるが、それは真実なのか。
* Unicode 文字列のほうは、<``isdecimal`` メソッドと ``isnumeric`` メソッドの
  2 つが追加されています> (p. 176)

* sitecustomize.py で ``sys.setdefaultencoding('utf-8')`` する例が書いてある。(p. 177)

* <``unicode`` 関数と ``decode`` メソッドは、ともに、通常の文字列を
  Unicode 文字列に変換します> (p. 177)

* <``str`` 関数については、必ずデフォルトエンコーディングで変換されます> (p. 179)
  ``encode`` メソッドのほうが柔軟だということか。

* 囲み記事。文字列の他に ``bytes``, ``bytearray`` 型というのがある。
  後者はバイナリの取り扱いに有効らしいので、イメージファイルを解析するのに応用してみたい。

第 11 章 ファイル入出力
===================================
11.1 ファイルの基本操作
-----------------------------------
* ``read`` メソッドはファイルの内容を一気に文字列として読み込む。
* ``read``, ``readlines``, ``write``, ``writelines`` を使い分ける。
  lines 系は各文字列の末尾に改行文字が付く。

11.2 日本語ファイルを扱う
-----------------------------------
* 前章の文字列メソッドを駆使して、ファイルの文字列の文字コードをプログラム中で適宜変換する。
* ``codecs`` というモジュールがあり、ファイルオープン時に文字コードを指定することができる。(p. 189)

  >>> import codecs
  >>> f = codecs.open('temp.txt', 'w', 'utf8', 'ignore')
  >>> f.write(u'あいう') # ファイル内に UTF-8 で出力される。
  >>> f.close()

  読み込みも同様。

* <BOM 付きファイルを適切に読み取るには、明示的にその BOM を取り除くか、
  ``codecs`` モジュールにおいて ``utf_8_sig`` という名のエンコードを指定します> (p. 190)
  掲載のサンプルコードでは ``lstrip(codecs.BOM_UTF8)`` と
  ``codes.open('temp.txt', 'r', 'utf_8_sig', 'ignore')`` の両方の手法を紹介している。

11.3 パスの構築
-----------------------------------
ファイルパスの文字列を取り扱う方法を習得すること。

* <セパレーターは ``os.path.sep`` または ``os.sep`` に格納されています> (p. 191)
  手元の環境で調べたら、両者は同じものだ。

* <パスを分解する方法は幾つかあります> (p. 193)
  基本的には split と名の付く関数を利用する。

* ``os.path.commonprefix`` 関数は使いどころがわからない。

11.4 ファイルシステム上の操作
-----------------------------------
ファイルの移動・コピー・属性操作関連の処理を習得すること。

* それらしい機能を探すときは ``os.path``, ``shutil``, ``os``
  モジュールを当たるとよさそうだ。

* ``os.mkdirs`` (p. 197) は UNIX で言うところの ``mkdir -p`` のようなもの。
* ディレクトリ削除が色々ある。直感的には ``shutil.rmtree`` が普通の削除に相当するような。
* これ重要。
  ``shutil.copy2`` 関数は <最終アクセス時間や最終更新時間などのメタデータもコピー> (p. 199)
  する。

* ディレクトリのコピーは ``shutil.copytree`` (p. 201) を利用する。引数が多い。

* ``os.walk`` 関数ではディレクトリを <デフォルトでは最上層から下に辿っていきます。
  引数で ``topdown=False`` とすると、最下層から辿るようになります> (p. 202)

* ``os.environ`` 変数に環境変数が格納されている。(p. 205)

  >>> os.environ['PATH'].split(';')
  ['C:\\WINDOWS\\system32',
   'C:\\WINDOWS',
   'C:\\WINDOWS\\System32\\Wbem',
   'C:\\cygwin\\bin',
   'D:\\Python26\\Scripts',
   'D:\\Python26\\Lib\\site-packages\\PyQt4\\bin',
   'C:\\Program Files\\SlikSvn\\bin\\',
   'C:\\Program Files\\TortoiseSVN\\bin']

11.5 テンポラリファイルの作成
-----------------------------------
* ``tempfile.mkdtemp`` 関数で一時ディレクトリを作成する。
* ``tempfile.mkstemp`` と ``tempfile.NamedTemporaryFile`` 関数で一時ファイルを作成する。
  ファイルを削除するのを自分でやりたければ前者を利用する、という具合に使い分ける。

11.6 ファイルライクオブジェクト
-----------------------------------
* <文字列オブジェクトをファイルオブジェクトのように扱う> (p. 208) クラスが ``StringIO`` なのか。
* <``StringIO`` の内部を C で実装した ``cStringIO`` モジュール> (p. 208) は速そうだが、
  ユニコード周りで制限あり。

* 囲み記事で紹介されている Python 3 の ``io`` モジュール。
  Python 2.6.5 でも使用可能になっていた。

第 12 章 関数
===================================
12.1 関数の引数
-----------------------------------
* キーワード引数の指定は順不同。(p. 213)
* 可変長引数は面白い。

  * <シーケンス型と辞書型の 2 つの指定方法があります。（略）
    引数宣言の前に "*" を付けると、複数の引数をタプル型として受け入れます> (p. 214)

  * <引数宣言の前に "**" を付けると、キーワード付き引数を辞書型として受け入れます> (p. 215)

  * 実引数の順序は、

    #. 一般的な変数、
    #. デフォルト値のある引数、
    #. シーケンス型の可変長引数、
    #. 辞書型の可変長引数

    の順でなければならない。(p. 216)

* 引数は <変更不可能なオブジェクトの場合は、実質的に値渡しとなります> (p. 216)

* 囲み記事の <ある種グローバルな変数> (p. 218) の指摘を心に留めておく。

12.3 関数オブジェクト
-----------------------------------
* <制限のないオブジェクト> (p. 221) の意味がまったくわからない。

12.4 デコレーター
-----------------------------------
これがまったくわからない。コードを手で打ち込んで実行してみても何をされたのかわからない。

* <デコレーターは関数を受け取り、修飾した関数を返す関数です> (p. 223)
* 修飾のしかたは、修飾したい関数の定義の前に ``@デコレーター関数`` と書くだけ。
* <デコレーター関数内で新たに関数を定義することが多い> (p. 224)
* デコレーターはネストできる。

* <デコレーターがよく用いられる用途としては、
  時間計測や型チェック、キャッシュ、アクセス制御、初期化・後始末の処理、トレースなどがあります>
  (p. 226) とあるので、存在意義は小さくないはずなのだが、わからない。

なんでデコレーターになじめないんだろう。

12.5 スコープ
-----------------------------------
* 関数内ではグローバル変数を無条件に右辺値参照できる。
  ただし、たまたま同名なローカル変数として解釈されるため、左辺値参照はできない。

  * そのような場合は ``global`` 文に頼ればよい。

* ``globals``, ``locals`` 関数で、グローバル変数、ローカル変数をそれぞれ表示できる。

第 13 章 クラス
===================================
今まで散々オブジェクトがどうのこうのと話があったのに、このタイミングでクラスとは。

13.1 インスタンスの係わる文法
-----------------------------------
* <全てのクラスは、この ``object`` を根底に継承します> (p. 232)
* <Python のオブジェクトとは、クラスのインスタンスだけでなく、クラスや関数自身も該当します> (p. 233)
* <特殊メソッドの名前は ``__xxx__`` のように 2 つのアンダースコアが両端に付いたものになります> (p. 234)
* ``property`` はおさえておく。

13.2 クラスに係わる文法
-----------------------------------
* クラス属性は C++ で言うところの static メンバーみたいなものらしい。
* ``@classmethod`` と ``@staticmethod`` の使い分けかたがわからない。

13.3 継承
-----------------------------------
あとで読む。

第 14 章 例外処理
===================================
14.1 処理の分岐
-----------------------------------
* Python 独特の ``else`` だが、
  ``try`` の本処理の後に行うような（本来捕捉したくない部分だということを）
  コードに示すという狙いがあるのか。

* ``finally`` よりは ``with`` の利用を好む。

14.2 例外情報を取り出す
-----------------------------------
* Python 2.6 以降では ``except ... as ...:`` が使える。(p. 252)

14.4 独自の例外
-----------------------------------
* <全ての例外クラスは、
  ``Exception`` クラスを継承して作ります> (p. 256)

第 15 章 モジュール
===================================
15.1 単一ファイルのモジュール
-----------------------------------
* ``import`` 文で参照したいファイルは、
  <ファイルのディレクトリをカレントディレクトリとすれば> (p. 262) 可能。

15.2 複数ファイルのモジュール
-----------------------------------
* ``__init__.py`` のあるフォルダをパッケージと呼ぶ。
  パッケージは入れ子になっていることがある。

15.3 モジュールのパスを通す
-----------------------------------
* <モジュールをインポートする時に、どのフォルダ・ファイルを参照するかは、
  ``sys`` モジュールの ``sys.path`` にリストとして格納されているモジュールの検索パスに基づいて決められます>
  (p. 266)

  リスト ``sys.path`` を Python 実行中に直接変更することができる。

15.4 スクリプト化
-----------------------------------
.. code:: python

   if __name__ == '__main__':
       # スクリプトとして実行された場合、ここに来る。

15.5 ライブラリの利用
-----------------------------------
* PyPI (http://pypi.python.org/pypi) では、いろんな人が作ったライブラリーを配布している。
  ライブラリーを指定して easy_install を実行してインストールする。

  * easy_install を入手するには、ez_setup.py を入手する必要がある。
    入手して Python で実行すると、easy_install 自体がインストールされる。

    インターネットに接続できない環境では、
    setuptools のインストーラー (exe) を先に入手しておく必要があるのか。

* bitbucket は知らなかった。後で調べよう。
