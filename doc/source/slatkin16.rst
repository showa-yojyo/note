======================================================================
Effective Python 読書ノート
======================================================================

いつの間にか Effective 本の Python モノが出版されていた。

未取得な必修事項がかなり残っていることを教えてくれた。私の場合は 4 章以降の知識
がかなり危ない。

.. include:: /_include/book-details/slakin16.txt

.. contents:: ノート目次

1 章 Python 流思考
======================================================================

* スライスのときに ``[0:i]`` とか ``[i:-1]`` とは書かずに ``[:i]`` とか ``[i:]``
  と書くのを推奨。
* スライスの stride 機能は扱いが難しいので基本的には避ける。
* ``range`` よりも ``enumerate`` を好むとあるが、言わんとすることに注意。リスト
  を反復するときに添字が必要であれば、下のようにするなという意味だろう。どのよう
  なときにも ``enumerate`` を使えと言っているのではない。

  .. code:: python3

     for i in range(len(a)):
         handle(a[i])

2 章 関数
======================================================================

* 項目 14 で <``None`` を返すよりは例外を選ぶ> とある。これはもう当然だろう。
* 高級な概念だが、closure とか ``nonlocal`` とかを人に説明できるように理解してお
  きたい。
* ``__iter__`` の実装演習をしておきたい。
* キーワード専用引数のための構文が Python にはある（関数引数リスト内に単体の
  ``*`` でそれを示す）。

3 章 クラスと継承
======================================================================

* 組み込みデコレーターの ``@classmethod`` は「クラス全体」に効く。これはけっこう
  便利なので愛用している。
* 普通の用途においては ``super()`` は引数なしで OK だ。いつも派生クラスの
  ``__init__`` を書くときに「何だっけ」となるので、忘れないようにする。
* C++ とは事情が逆で、Python では private より public を好むようだ。これについて
  人に理由を説明できるようにしておきたい。

4 章 メタクラスと属性
======================================================================

* これも C++ とは反対に getter や setter を提供する代わりに、剥き出しの属性を参
  照させるほうが良いとされる。おそらく理由も先程のものと似ているのだろう。
* ``@property`` という組み込みデコレーターがあるので、
  一度定義した属性に対して後からどうとでもできる。
* ``__get__`` も ``__set__`` も使ったことがない。これも練習しよう。
* 項目 32 で紹介されている ``__getattr__``, ``__getattribute__``,
  ``__setattr__`` はまったく馴染みがない。実装の練習をしておきたい。
* ``metaclass=Meta`` と ``__new__`` に馴染みがないので、要演習。<メタクラスの
  ``__new__`` メソッドは ``class`` 文の本体全体が処理された後に実行される>
  (p. 108) そうだ。
* 項目 34 で議論されている ``register_class`` の技法は是非押さえたい。昔書いた
  コードではまさに手動でやっていた気がする。

5 章 並行性と並列性
======================================================================

この章の内容はどれもがほぼ未経験。致命的かもしれない。

* モジュール ``subprocess`` の提供する機能はかつての ``popen``, ``popen2``,
  ``os.exec*`` の系譜の最新進化形と捉えてよろしいか。
* GIL とは <マルチコア CPU でバイトコードを並列に実行することができない> ように
  するPython のロックという位置づけ。
* ``Lock`` は要演習。
* ``Queue`` は要演習。
* 関数を並行実行する機能の枠組の一つに coroutines というものがある。これも演習し
  たい。特に :program:`pdb` でトレース実行してみたい。
* さらに ``concurrent.futures`` なる新機能がある。

6 章 組み込みモジュール
======================================================================

* ``@functools.wraps`` は入れ子になった関数の内側の方を修飾するものなのか。既存
  の自作コードですぐにでも試せそうだ。
* ``@contextlib.contextmanager`` を利用することで、自分でクラスを作って
  ``__enter__`` と ``__exit__`` を定義する手間が省けるかもしれない。これは既存の
  自作コードを改造するほうが高く付くので、残念だが見送ろう。これから作るものにつ
  いては、当然デコレーターのほうを先に検討したい。
* モジュール ``itertools`` については、Python コードを書く機会に参照する。個人的
  には C++ で言うところの ``<algorithm>`` や、 C# で言うところの LINQ に相当する
  概念を提供するモジュールだと思っているので。

7 章 協働作業（コラボレーション）
======================================================================

* <例外は定義している関数やクラスのインターフェースの一部です> まさにその通りだ。
* 仮想環境の話。今なら Anaconda/Miniconda ということだな。

8 章 本番運用準備
======================================================================

* <``repr`` で返される文字列は正当な Python 式です> とある。それゆえ
  ``__repr__`` を実装するときには <オブジェクトを複製する Python 式を含んだ文字
  列を返す> ようにするべきだ。

  * ただし「含んだ」というのがミソ。

* 関数 ``pdb.set_trace`` については必修。いつでもスクリプトの先頭からデバッグ実
  行するには及ばない。
* ``tracemalloc`` の練習をしたいが、何か良い練習台はないものか。もっと言えば、
  Python でメモリーリークを引き起こすコードを書く方法とは何か。
