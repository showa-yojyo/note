======================================================================
WebGL Specification 1.0 読書ノート 1 of 4
======================================================================

`WebGL Specification <https://www.khronos.org/registry/webgl/specs/latest/1.0/>`__
を読んでいく。

.. contents:: ノート目次

Abstract
======================================================================

* 本仕様は HTML 5 要素 ``canvas`` [CANVAS]_ に対する追加的なレンダリングコンテキ
  ストおよびサポートオブジェクトについて記述するものだ。
* このコンテキストは OpenGL ES 2.0 API に忠実に準拠した API を使用してレンダリン
  グをすることができる。

Status of this document
======================================================================

* 本文書は編集者の草稿だ。この文書を work in progress 以外の目的で引用してはなら
  ない。

本ノートもそういうつもりで記していく。

Feedback
======================================================================

* 本仕様についての一般的な議論はメーリングリストで歓迎される。
* 本仕様やその適合試験に関するバグは GitHub のアカウントに報告する。プルリクエス
  トもウェルカム。

各 URL は本仕様書のオリジナルを参照して欲しい。当ノートには明記しない。

1 Introduction
======================================================================

.. admonition:: Non-normative

   * WebGL はウェブ用に設計された即時モードの 3D レンダリング API だ。

     * OpenGL ES 2.0 から派生したもので、同様のレンダリング機能を HTML のコンテ
       キストで提供している。
     * WebGL は HTML ``Canvas`` 要素のレンダリングコンテキストとして設計されてい
       る。
     * ``Canvas`` の仕様の一部として記述されているインターフェイスは 2D のレンダ
       リングコンテキストである ``CanvasRenderingContext2D`` だが、この文書では
       もう一つのインターフェイスである ``WebGLRenderingContext`` について説明す
       る。こちらはWebGL の API を表す。

   * この API の即時モードの性質は、ほとんどの Web APIとは異なる。

     * WebGL は、どのような使用例にも適用できる柔軟なプリミティブを用意するとい
       う方法論を採用している。ライブラリーは WebGL の上に特定の分野に特化した
       API を提供することができて、 WebGL に利便性の高いレイヤーを追加し、開発を
       加速、簡略化することができる。
     * OpenGL ES 2.0 の伝統を受け継いでいるため、最新のデスクトップ OpenGL や
       OpenGL ES 2.0 の開発に慣れている開発者であれば、WebGL の開発に移行するの
       は簡単なはずだ。

1.1 Conventions
----------------------------------------------------------------------

* 本文には OpenGL ES のマニュアルページへのリンクが多く含まれてるので、当ノート
  ではばっさり削る。
* OpenGL ES 2.0 [GLES20]_ と合致するように努力しているが、誤りを含む場合がある。
  矛盾が生じた場合は、OpenGL ES 2.0 [GLES20]_ を正とする。
* 本文書は OpenGL ES 2.0 仕様と併読することを意図している。特に指定のない限り、
  各メソッドの動作は OpenGL ES 2.0 で定義されている。この仕様は、相互運用性やセ
  キュリティーを担保するために、OpenGL ES 2.0 から分岐している場合がある。

  * OpenGL ES 2.0 には実装上の定義を残している部分があり、それらを当仕様で定義す
    るものが多い。そのような違いについては、:ref:`khronos15-6` でまとめられてい
    る。

2 Context Creation and Drawing Buffer Presentation
======================================================================

WebGL API を使用する前に、プログラム作者は以下に示すように、指定された
``HTMLCanvasElement`` [CANVAS]_ または ``OffscreenCanvas`` [OFFSCREENCANVAS]_ の
``WebGLRenderingContext`` オブジェクトを取得する必要がある。このオブジェクトは
OpenGL の状態を管理し、描画バッファーへのレンダリングを行うためのもので、コンテ
キスト作成時に作成する必要がある。

.. _khronos15-2.1:

2.1 Context Creation
----------------------------------------------------------------------

本節で述べられている仕様を ``canvas.getContext("webgl")`` の呼び出しが実現するも
のと思われる。

----

* ``WebGLRenderingContext`` には作成時に設定されるキャンバス([CANVAS]_,
  [OFFSCREENCANVAS]_) が関連付けられている。
* ``WebGLRenderingContext`` は |WebGLContextAttributes| オブジェクトの中に
  :ref:`context creation parameters<khronos15-5.2.1>` を持つ。
* ``WebGLRenderingContext`` は描画バッファーが作成されるたびに設定される
  **actual context parameters** を |WebGLContextAttributes| オブジェクトに持つ。
* ``WebGLRenderingContext`` は最初は設定されていない **webgl context lost**
  フラグを持つ。

キャンバスのメソッド呼び出し ``getContext('webgl')`` が ``contextId`` webgl
[CANVASCONTEXTS]_ の新しいオブジェクトを返す場合、ブラウザーは以下の手順を実行す
る必要がある：

1. 新しい ``WebGLRenderingContext`` オブジェクトであるコンテキストを作成する。
2. そのコンテキストのキャンバスをメソッド ``getContext`` が関連付けられている
   キャンバスとする。
3. 新しい ``WebGLContextAttributes`` オブジェクト ``contextAttributes`` を作成す
   る。
4. ``getContext()`` に第二引数として ``options`` を指定していた場合、指定した属
   性を ``contextAttributes`` に設定する。
5. ``contextAttributes`` で指定された設定を使用して :ref:`描画バッファーを作成
   <khronos15-2.2>` し、その描画バッファーとコンテキストを関連付ける。
6. 描画バッファーの作成に失敗した場合は、以下の手順を実行する：

   * 6.1 キャンバスで :ref:`WebGL コンテキスト作成エラーを発生させる
     <khronos15-5.15.4>`。
   * 6.2 ``null`` を返してこれらの手順を終了する。

7. 新しい ``WebGLContextAttributes`` オブジェクトである ``actualAttributes`` を
   作成する。
8. 新しく作成した描画バッファーのプロパティに基づいて ``actualAttributes`` の属
   性を設定する。
9. コンテキストの :ref:`context creation parameters<khronos15-2.1>` を
   ``contextAttributes`` に設定する。
10. コンテキストの :ref:`actual context parameters<khronos15-2.1>` を
    ``actualAttributes`` に設定する。
11. コンテキストを返す。

``experimental-webgl`` に関する記述は軽視する。

.. _khronos15-2.2:

2.2 The Drawing Buffer
----------------------------------------------------------------------

API 呼び出しがレンダリングされる描画バッファーは |WebGLContextAttributes|
オブジェクトの生成時に定義されるものとする。以下、描画バッファーの作成方法を定義
する。

* この表は、描画バッファーを構成するすべてのバッファーごとに、その最小サイズと、
  デフォルトで定義されているかどうかを示している。

  * この描画バッファーのサイズは、キャンバスの ``width`` および ``height`` に
    よって決定される。
  * 下の表では、

    * 最初に作成されたとき、
    * サイズが変更されたとき、
    * または ``preserveDrawingBuffer`` コンテキスト作成属性が ``false`` のときの
      出現後に

    各バッファーがクリアされるべき値も併せて示す。

.. csv-table::
   :delim: @
   :header-rows: 1
   :widths: auto

   バッファー @ クリア値 @ 最小サイズ @ 既定値が存在するか
   色 @ ``(0, 0, 0, 0)`` @ 8 ビット @ 存在する
   奥行き @ ``1.0`` @ 16 ビット整数 @ 存在する
   ステンシル @ ``0`` @ 8 ビット @ 存在しない

* 寸法が :math:`{0 \times 0}` のキャンバスでは :math:`{1 \times 1}` の
  ``drawingBufferWidth``, ``drawingBufferHeight`` になる。
* 要求された幅や高さを満たすことができない場合、描画バッファーが最初に作成された
  とき、またはキャンバスの幅や高さの属性が変更されたときに、より小さな寸法の描画
  バッファーが作成される。実際に使用される寸法は実装に依存し、同じアスペクト比の
  バッファーが作成されることは保証されない。

  * 実際の描画バッファーのサイズは属性 ``drawingBufferWidth`` と
    ``drawingBufferHeight`` から得ることができる。

* WebGL の実装では、高解像度のディスプレイで描画バッファーのサイズを自動的に拡縮
  してはならない。コンテキストの ``drawingBufferWidth`` および
  ``drawingBufferHeight`` は、実装依存の制約を除いて、キャンバスの属性 ``width``
  および ``height`` に可能なかぎり一致しなければならない。

.. admonition:: Non-normative

   * 上記の制約は、高精細ディスプレイであっても、キャンバス要素がウェブページ上
     で消費する空間の大きさを変えるものではない。キャンバスの固有寸法 [CANVAS]_
     はその座標空間のサイズに等しく、数値は CSS ピクセルで解釈されるのであって、
     解像度に依存しない [CSS]_。
   * WebGL アプリケーションは、プロパティー ``window.devicePixelRatio`` などを確
     認し、キャンバスの幅と高さをその係数で乗じて、CSS の幅と高さを元の幅と高さ
     に設定することで、高解像度のディスプレイ上で、描画バッファーのピクセルと画
     面上のそれの比率を 1:1 にすることができる。

* オプションの |WebGLContextAttributes| オブジェクトを使って、バッファーを定義す
  るかどうかを変更することができる。また、色バッファーにアルファーチャンネルを含
  めるかどうかを定義するのにも使用できる。

  * 定義する場合、アルファーチャンネルは、HTML 合成器が色バッファーをページの残
    りの部分と結合するために使用される。
  * ``WebGLContextAttributes`` オブジェクトは ``getContext`` の最初の呼び出し時
    にしか用いられない。描画バッファーの作成後にその属性を変更する機能はない。

* 奥行き、ステンシル、アンチエイリアスの属性は、``true`` に設定されている場合、
  要求であって要件ではない。WebGL の実装はこれらの属性を考慮するように努力をする
  必要がある。ただし、これらの属性が ``false`` に設定されている場合、WebGL の実
  装は関連する機能を提供しない。

  * WebGL の実装やグラフィックスハードウェアでサポートされていない属性を組み合わ
    せても、|WebGLContextAttributes| の作成に失敗す
    ることはない。
  * :ref:`actual context parameters<khronos15-2.1>` には、作成された描画バッ
    ファーの属性が設定される。
  * 属性 ``alpha``, ``premultipliedAlpha``, ``preserveDrawingBuffer`` は WebGL
    の実装に従わなければならない。

* WebGL は、合成操作の直前にその描画バッファーを HTML ページの合成器に提示する
  が、それは前回の合成操作以降に以下の少なくとも一つが発生している場合に限る：

  * コンテキストの作成
  * キャンバスのサイズ変更
  * 描画バッファーが現在束縛されているフレームバッファーである間に、``clear``,
    ``drawArrays`` または ``drawElements`` が呼び出された。

* 描画バッファーが合成のために提示される前に、実装はすべてのレンダリング操作が描
  画バッファーに　flush されていることを確認する。デフォルトでは、合成後、描画
  バッファーの内容は、上の表に示されているように、それらの既定値に消去されなけれ
  ばならない。

* この既定の動作を |WebGLContextAttributes| オブジェクトの属性
  ``preserveDrawingBuffer`` を設定することで変更できる。

  * このフラグが ``true`` の場合、描画バッファーの内容は、作者が消去するか上書き
    するまで保存される。
  * このフラグが ``false`` の場合、レンダリング関数が戻ってきた後に、このコンテ
    キストを元画像として使用した操作を実行しようとすると、未定義の動作を引き起こ
    す可能性がある。これには、

    * ``readPixels`` や ``toDataURL`` の呼び出し、
    * 他のコンテキストの ``texImage2D`` や ``drawImage`` の呼び出しのソース画像
      としてのこのコンテキストの使用、
    * このコンテキストのキャンバスからの ``ImageBitmap`` [HTML]_ の作成

    などがある。

.. admonition:: Non-normative

   * 描画バッファーを保持することが望ましい場合もあるが、プラットフォームによっ
     てはパフォーマンスが著しく低下する可能性がある。可能な限り、このフラグは
     ``false`` のままにして、他の手法を使うべきだ。

     描画バッファーの内容を取得するには、同期的な描画バッファーアクセス、例え
     ば、描画バッファーへのレンダリングを行うのと同じ関数内で ``readPixels`` や
     ``toDataURL`` を呼び出す、などの手法を使用できる。

     一連の呼び出しで同じ描画バッファーにレンダリングする必要がある場合は、
     :ref:`Frame buffer<khronos15-5.5>` オブジェクトを使用することができ
     る。

   * バッファー作者が他のプロセスからバッファーの内容にアクセスできないことを保
     証する限り、実装は、必要な描画バッファーの暗黙の消去操作を最適化することが
     できる。例えば、バッファー作者が明示的な消去を行った場合、暗黙の消去は必要
     ない。

.. _khronos15-2.3:

2.3 The WebGL Viewport
----------------------------------------------------------------------

* OpenGL は、描画バッファー内のレンダリング結果の配置を定義する状態の一部とし
  て、長方形のビューポートをやりくりする。WebGL コンテキストの作成時に、ビュー
  ポートを、

  * 原点が ``(0, 0)`` で、
  * 幅と高さが ``(gl.drawingBufferWidth, gl.drawingBufferHeight)`` に等しい長方
    形に初期化する。

* WebGL の実装では、キャンバス要素のサイズ変更に応じて OpenGL ビューポートの状態
  に影響を与えてはならない。

.. admonition:: Example I

   WebGL プログラムにビューポートを設定するロジックが含まれていないと、キャンバ
   スのサイズが変更された場合に適切に対処できないことに注意。次の例は、WebGL プ
   ログラムが（ユーザーの操作によるものではなく）プログラムによってキャンバスの
   サイズを変更する方法を示す：

   .. code:: javascript

      const canvas = document.getElementById('canvas1');
      const gl = canvas.getContext('webgl');
      canvas.width = newWidth;
      canvas.height = newHeight;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

そうする根拠としては、ビューポートを自動的に設定すると、それを手動で設定するアプ
リケーションと干渉するからだ。アプリケーションは ``onresize`` イベントハンドラー
を使用して、キャンバスのサイズの変更に応答し、OpenGL ビューポートを設定すること
が期待される。

.. _khronos15-2.4:

2.4 Premultiplied Alpha, Canvas APIs and ``texImage2D``
----------------------------------------------------------------------

* OpenGL API では、アプリケーションがレンダリング時に使用するブレンドモードを変
  更することができる。そのため、描画バッファー内のアルファー値の解釈様式を制御す
  ることができる。|WebGLContextAttributes| の ``premultipliedAlpha``
  引数を見ろ。

* HTML キャンバス API の ``toDataURL`` および ``drawImage`` は、
  ``premultipliedAlpha`` コンテキスト生成パラメーターを考慮する必要がある。
  WebGL がレンダリングされているキャンバスに対して ``toDataURL`` が呼び出された
  とき、

  * 要求された画像フォーマットが ``premultipliedAlpha`` を指定しておらず、
  * WebGL コンテキストの ``premultipliedAlpha`` パラメーターが ``true`` に設定さ
    れている場合は、

  ピクセル値を逆乗算、すなわち色チャンネルをアルファーチャンネルで除算する必要が
  ある。この操作は非可逆的だ。

* WebGL でレンダリングされたキャンバスを

  * ``CanvasRenderingContext2D`` の ``drawImage`` メソッドに渡す場合、
    ``CanvasRenderingContext2D`` の実装の乗算の必要性に応じて、描画操作中にレン
    ダリングされた WebGL 内容を変更する必要がある場合とない場合がある。
  * ``texImage2D`` に渡す場合、渡されたキャンバスの ``premultipliedAlpha`` コン
    テキスト作成パラメーターと、送信先の WebGL コンテキストの
    ``UNPACK_PREMULTIPLY_ALPHA_WEBGL`` ピクセル格納パラメーターの設定に応じて、
    ピクセルデータを事前に乗算された形式に変更したり、乗算された形式から変更した
    りする必要がある。

----

WebGL でもアルファブレンディングは難しい仕事らしい。

3 WebGL Resources
======================================================================

* OpenGL は、その状態の部分として、いくつかの型のリソースを統制している。これら
  のオブジェクトには整数の名前が付けられ、それにより識別され、さまざまな作成コー
  ルによって OpenGL から得る。一方、WebGL はこれらのリソースを DOM オブジェクト
  として表現する。各オブジェクトは、``WebGLObject`` インターフェースから派生して
  いる。現在サポートされているリソースは次のようなものだ：

  * テクスチャー
  * バッファー (e.g. VBO)
  * フレームバッファー
  * レンダーバッファー
  * シェーダー
  * プログラム

* インターフェース ``WebGLRenderingContext`` には、型ごとに ``WebGLObject`` のサ
  ブクラスを作成するためのメソッドが用意されている。基礎にあるグラフィックライブ
  ラリーから来るデータは、これらのオブジェクトに格納され、完全に管理される。
* DOM オブジェクトは、オーナーが明示的な参照を保持している間だけでなく、内包され
  ているグラフィックスライブラリーが使用している間じゅう存続する。
* DOM オブジェクトが破壊されると、そのリソースに削除のマークを付ける。破壊される
  前にオブジェクトを削除するようにマークしたい場合、オーナーは ``deleteTexture``
  などの、それぞれに対応する ``delete`` 関数を明示的に呼び出せる。

4 Security
======================================================================

この章はなぜかセキュリティーという名前だ。

4.1 Resource Restrictions
----------------------------------------------------------------------

* テクスチャーや頂点バッファーオブジェクト (VBO) などの WebGL リソースは、ユー
  ザーデータの初期値を含まずに作成された場合でも、初期化されたデータを含まねばな
  らない。

  * 初期値なしでリソースを作成するのは、テクスチャーや VBO のための領域を確保す
    るためで、その後 ``texSubImage`` や ``bufferSubData`` 呼び出しを使って変更す
    る。
  * これらの呼び出しに初期データが与えられない場合、WebGL の実装ではその内容をゼ
    ロで初期化する。このためには、要求された VBO のサイズに合わせてゼロの一時
    バッファーを作成し、正しく初期化できなければならない。
  * テクスチャーや VBO にデータをロードする他のすべての形式は、``ArrayBuffer``
    または画像などの DOM オブジェクトを含むため、すでに初期化されていなければな
    らない。

* WebGL リソースが ``drawElements`` や ``drawArrays`` などの呼び出しによって
  シェーダーからアクセスされる場合、 WebGL の実装はシェーダーが境界外のデータや
  初期化されていないデータにアクセスさせないものとする。

  * WebGL の実装で実施しなければならない制限事項については :ref:`khronos15-6.6`
    に記述がある。

----

ユーザー側に有利なように仕様が決められていることがうかがえる。

4.2 Origin Restrictions
----------------------------------------------------------------------

情報漏洩を防ぐため、WebGL では次に挙げるものをテクスチャーとしてアップロードする
ことを禁じる：

* ``WebGLRenderingContext`` の ``canvas`` 要素を含む ``Document`` の発信元と同じ
  ではない発信元を持つイメージまたはビデオ要素
* ビットマップの ``origin-clean`` フラグが ``false`` に設定されている ``canvas``
  要素
* ビットマップの ``origin-clean`` フラグが ``false`` に設定されている
  ``ImageBitmap`` オブジェクト

``texImage2D`` メソッドまたは ``texSubImage2D`` メソッドが、これらの制限に違反す
る

* ``HTMLImageElement``,
* ``HTMLVideoElement``,
* ``HTMLCanvasElement`` または
* ``ImageBitmap``

を含む正しい引数で呼び出された場合に ``SECURITY_ERR`` 例外を送出するものとする。

.. admonition:: Non-normative

   * WebGL ではシェーダーを使用して GPU にアップロードされたテクスチャーの内容を
     間接的に推測することができることから、クロスドメインメディアの使用に 2D
     キャンバスレンダリングコンテキストなどの他の API よりも強い制限を課すのは当
     然だ。
   * WebGL アプリケーションは、目的のメディアを置いているサーバーの許可を得て、
     Cross-Origin Resource Sharing [CORS]_ を使用して、他のドメインから来た画像
     やビデオを利用できる。

     * このようなメディアを使用するには、アプリケーションとサーバーの間でその許
       可をやりとりする必要がある。
     * CORS を利用して他のドメインから画像やビデオの要素を取得すると、これらの要
       素の発信元は含まれる ``Document`` [HTML]_ のものに設定される。

   .. admonition:: Example II

      次の例では、別のドメインから送られてくる画像に対して CORS リクエストを発行
      する方法を示している。画像は、認証情報 (cookie) なしでサーバーから得られ
      る：

      .. code:: javascript

         const gl = document.querySelector("canvas").getContext("webgl");
         const image = new Image();

         // The onload handler should be set to a function which uploads the ``HTMLImageElement``
         // using texImage2D or texSubImage2D.
         image.onload = ...;
         image.crossOrigin = "anonymous";
         image.src = "http://other-domain.com/image.jpg";

   * なお、これらのルールは、WebGL を使用してレンダリングされた ``canvas`` の
     ``origin-clean`` フラグが決して ``false`` に設定されないことを含意すること
     に注意。
   * 詳しくは以下を見ろとある：

     * CORS settings attributes [HTML]_
     * The ``img`` element [HTML]_
     * Media elements [HTML]_

.. _khronos15-4.3:

4.3 Supported GLSL Constructs
----------------------------------------------------------------------

WebGL 1.0 における GLSL の仕様。基本的には OpenGL ES の GLSL ver 1.0
[GLES20GLSL]_ であり（これは別にノートをとる予定）、そこからいくつかの機能を削っ
たものとみなしてよいようだ。

----

WebGL は、The OpenGL ES Shading Language, Version 1.00 に準拠し、Appendix A のセ
クション 4 および 5 で義務付けられている最小機能を超えないシェーダーしか受け入れ
てはならない。具体的には：

* デスクトップ版 OpenGL など、他のバージョンの GLSL で利用可能な状態変数や関数を
  参照するシェーダーに対して、ロードを許可しない。
* ``for`` ループは Appendix A の構造的制約に従うものとする。
* ``while`` および ``do`` ... ``while`` ループは、Appendix A ではオプションと
  なっているため、許可しない。
* Appendix A では、配列のインデックス付けの特定の形式を義務付けている。例えば、
  フラグメントシェーダー内では、インデックス付けは *constant-index-expression*
  でしかできない（[GLES20GLSL]_ 参照）。 WebGL API は Appendix A で義務付けられ
  ているインデックス付与の形式しかサポートしない。

前述の仕様にある予約済み識別子に加えて、``webgl_`` および ``_webgl_`` で始まる識
別子が WebGL のために予約済みだ。これらの接頭辞で始まる関数、変数、構造体名、構
造体フィールドを宣言しているシェーダーのロードを許可してはならない。

WebGL 1.0 では、シェーダーの中で行継続文字 ``\`` を追加サポートする必要がある。

4.4 Defense Against Denial of Service
----------------------------------------------------------------------

.. admonition:: Non-normative

   * レンダリングに時間がかかることはたいへん起こりがちだ。レンダリングがなくて
     も時間がかかるスクリプトについても言えることなのだが、長時間の描画呼び出し
     はブラウザーだけでなく、ウィンドウシステム全体の操作性を損ねる可能性が高
     い。
   * この問題を防衛するのに入力シェーダーの構造に何か制約を加えるということは、
     一般的にはできない。
   * ブラウザーは過度に長い描画時間や、それに付随する操作性の低下を防ぐために
     セーフガードを実装する必要がある。次のようなセーフガードを推奨する：

     * 多数の要素を含む描画呼び出しを、より小さなものに分割する。
     * 個々の描画呼び出しにタイミングを合わせ、特定のタイムアウトを超えた場合に
       は、そのページでの追加的描画を禁止する。
     * ユーザーレベル、グラフィックス API レベル、OS レベルのどれかで利用可能な
       監視機能を使用して、描画呼び出しの継続時間を制限する。
     * ブラウザーのグラフィックレンダリングを、アプリケーションの状態を失うこと
       なく終了および再起動できる別個のシステムプロセスに分離する。

   OS やグラフィックス API 層の基盤は時間の経過とともに改善されることが期待され
   るため、これらの保護機能の正確な性質を規定することはしない。

4.5 Out-of-Range Array Accesses
----------------------------------------------------------------------

シェーダーは、アプリケーション自身のデータの外側にある配列要素を読み書きすること
はできない。これは、配列型の変数や、配列添字構文を使ってアクセスされる ``vec3``
や ``mat4`` などのベクトル型や行列型を含む。コンパイル中にこのようなアクセスが検
出された場合、エラーが発生し、シェーダーのコンパイルができなくなる。そうでなけれ
ば、実行時において、範囲外の読み取りは以下のいずれかの値を返さなければならないも
のとする：

* プログラムがアクセス可能な記憶域内の任意の場所から得られる値。
* 値ゼロ、または読み取りベクトルに対しては ``(0, 0, 0, x)`` の形のベクトル。ここ
  で ``x`` はそのベクトル成分の型で表現される有効な値であり、以下のいずれかだ：

  * 成分が整数の場合は 0, 1, あるいは表現可能な最大の正の整数値
  * 浮動小数点成分の場合は 0.0 または 1.0

範囲外の書き込みは、破棄されるか、プログラムがアクセス可能な記憶域内の不特定の値
を変更する。

.. admonition:: Non-normative

   * この動作は [KHRROBUSTACCESS]_ で定義されたものと同じだ。
   * シェーダー内の配列インデックス操作の静的解析を簡素化する制限については
     :ref:`khronos15-4.3` を参照。

.. |WebGLContextAttributes| replace:: :ref:`WebGLContextAttributes<khronos15-5.2>`
