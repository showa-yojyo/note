======================================================================
Python NumPy 利用ノート
======================================================================

.. contents:: ノート目次

導入
======================================================================
自分の Python_ 環境に NumPy_ をインストールする方法を記す。

また、NumPy に関する各種ドキュメント、リファレンスが
HTML と PDF ファイルの形で利用できるようになっている。
これらのドキュメントをローカルディスクに保存しておき、
オフラインでもすぐにアクセスできるようにする。

ライブラリーをインストールする
----------------------------------------------------------------------
* Windows 環境ではインストーラーからインストールするのが吉。
  ``numpy-x.y.z-win32-superpack-python2.6.exe`` みたいな名前のインストーラーを
  NumPy_ のサイトから検索して入手しておけばよい。

* インストールを終了したら、何はさておき ``README.txt`` と ``INSTALL.txt`` を一読すること。
  目をひくのは単体テストが実行できるということだが、
  これには別途 Nose_ というサードパーティー製のライブラリーを
  Python 環境にインストールしておく必要がある。

  実際にやってみるとこのような感じになる::

    >>> import numpy
    >>> numpy.test()
    Running unit tests for numpy
    NumPy version 1.3.0
    NumPy is installed in D:\Python26\lib\site-packages\numpy
    Python version 2.6.5 (r265:79096, Mar 19 2010, 21:48:26) [MSC v.1500 32 bit (Intel)]
    nose version 0.10.4
    （略。ドットの列）
    ----------------------------------------------------------------------
    Ran 1882 tests in 63.040s
    
    OK (KNOWNFAIL=3, SKIP=1)
    <nose.result.TextTestResult run=1882 errors=0 failures=0>

ドキュメントをローカルディスクに保存する
----------------------------------------------------------------------
オンラインであれば `Numpy and Scipy Documentation`_ のページから欲しい情報に辿り着けるだろう。
クラス名や関数名を調べるときは、キーワード検索よりもインデックスページでのサーチのほうが早い。

オフライン環境で作業せざるを得ないの場合が多いので、
上述のページからダウンロードできる次のファイルをローカルに保存しておくのが望ましい。
同じ内容ならば PDF 版よりも HTML-help (CHM) のほうを優先して入手すること。
そうすればブラウザーでも閲覧できる。

* NumPy Reference Guide (numpy.chm)

  全関数リファレンスが含まれている。

* Guide to NumPy

  こちらはどちらかと言えば読み物。読書家向けか。

doc/
======================================================================
NumPy のインストールフォルダの直下 doc フォルダにはドキュメンテーション専用の py ファイルが多数ある。
NumPy の開発者はこれらを基に NumPy User Guide を作成していると思われる。
下にファイルとその内容を表にまとめる。array に関するトピックが圧倒的に多い。

============================== ====
ファイル                       内容
============================== ====
basics.py                      array に関する基本的な内容。
broadcasting.py                array の broadcasting rules についての議論。
constants.py                   NumPy が提供する各種定数に関する文書。
creation.py                    array オブジェクトの生成に関する文書。
glossary.py                    用語集。
howtofind.py                   まだ文書化されていない。
indexing.py                    array オブジェクトの要素を参照する手段に関する議論。
internals.py                   array の実装詳細を説明。
io.py                          まだ文書化されていない。
jargon.py                      まだ文書化されていない。
methods_vs_functions.py        まだ文書化されていない。
misc.py                        雑多なメモ。
performance.py                 まだ文書化されていない。
structured_arrays.py           変わった型の array について。
subclassing.py                 ``ndarray`` のサブクラス化に関する文書。
ufuncs.py                      Universal functions に関する文書。
============================== ====

glossary.py
----------------------------------------------------------------------
まず用語集を見るのがよいか。

ファイル ``doc/glossary.py`` が用語集を docstring の体裁でまとめている。
書式は reStructuredText のようだ。

収録対象は NumPy 独自に使われるものだけでなく、数学、計算機科学、
さらには Python 言語に関係するものにも及ぶ。
ここでは気になる用語に絞ってノートをとる。

along on axis
    行列では axis は二つあるが、縦方向の並びが axis 0 で、横方向の並びが axis 1 だ。
    縦方向の方がインデックスが若いことになっているのは row-major rule によるのだろう。
    array 関連の関数では「axis を引数に取れる」ものが多数ある
    (``sum``, ``var``, ``sort``, ``any``, ``mean``, etc.)

array
    **同種の要素からなる** 配列であることを強調している。
    なお ``ndarray`` のことを単に array と呼ぶ場合が多い。

array_like
    ``ndarray`` に解釈される任意のコンテナーと思ってよいようだ。
    なので ``ndarray`` オブジェクトやスカラーも array_like だ。

broadcast
    array 間の演算は同型が基本だが、若干 shape が異なっていても OK な場合がある。

C order/row-major, Fortran order/column-major
    多次元配列のメモリレイアウトに関する話題をきれいにまとめてある。
    NumPy の array は前者を採用している。
    C 言語がそれを利用していることによる。

    OpenGL は column-major だから、
    PyOpenGL のコードを書くときにはその辺の事情を意識しないとだめだろう。

flattened
    array を一次元の shape になるように「折りたたむ」ことができる。

mask, masked array
    OpenGL の ``glColorMask`` の概念みたいなものか。

matrix
    2 次元の ``ndarray`` を何らかの点において最適化した matrix クラスがあるらしい。
    演算経過によって shape が変わるようなことがないことを保証するようだ。

slice
    Python の ``list`` オブジェクトに対するスライスを、
    array でもサポートするという話だ。多次元版スライス。

ufunc
    個々の要素ごとに演算するようなタイプの演算を高速に処理する。
    後で ``doc/ufuncs.py`` に目を通す程度でいいだろう。

view
    既存の array からスライシング等の操作で別の array を作成することがある。
    この種の操作で新しくできた array は、
    実は参照ベースの proxy オブジェクトであることが多いようだ。

ライブラリーを利用してコードを書く
======================================================================
とりあえず ``from numpy import *`` だけで利用可能になる機能から習得していこう。

array
-----
まずは array 周辺から習得する。

オブジェクトを生成する
~~~~~~~~~~~~~~~~~~~~~~
NumPy Reference の Array creation routines のセクションできれいにまとめてある。

* array オブジェクトの生成方法の基本は関数 ``array`` 呼び出しだ。
  関数 ``array`` はたいていの場合 ``ndarray`` 型のオブジェクトを返すようだ。
  ::

    from numpy import *

    # ベクトル（と勝手に思う）を生成するにはこのようにする。
    v = array([0., 0., 1.])

    # 行列（と勝手に思う）はこう。
    m = array([[1., 0., 0.],
               [0., 1., 0.],
               [0., 0., 1.]])

* ``zeros_like``, ``ones_like``, ``empty_like`` をワンセットで習得すること。
  既存の array_like オブジェクトから同じ shape の array を生み出す関数だ。

* よく利用するのは ``ndarray`` だが、コンストラクターを直接利用せずに、
  関数 ``array``, ``zeros``, ``empty`` 等からオブジェクトを作成すること。

* ``copy`` 関数で array_like オブジェクトのコピーオブジェクトを
  同一あるいは別の array オブジェクトとして作成することができる。

    >>> import numpy as np
    >>> a = [1., 2., 3.]
    >>> np.copy(a)
    array([ 1.,  2.,  3.])

* 変わったところでは ``arange`` 関数で「連番」配列を生成できる。
  Python の ``range`` 関数の array 版といったところだ。

    >>> import numpy as np
    >>> np.arange(3.0)
    array([ 0.,  1.,  2.])

array の shape を変える
~~~~~~~~~~~~~~~~~~~~~~~
NumPy Reference の Array manipulation routines のセクションで表にまとめてある。

* 1-D array_like オブジェクトを多次元化するには ``reshape`` メソッドまたは同名の関数を利用する。
  ``order`` 引数でメモリレイアウトを指示できる。

* 多次元 array を「一次元配列化」するには ``flatten`` メソッドまたは関数 ``ravel`` を利用する。

  確実にコピーオブジェクトが欲しい場合は ``flatten`` を利用するのがよい？

  引数が ``order`` を表すので、PyOpenGL の行列系関数に渡すときに調整できるかも。

    >>> import numpy as np
    >>> a = np.arange(16).reshape(4, 4)
    >>> a
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])
    >>> a.flatten()
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15])
    >>> a.flatten('F')
    array([ 0,  4,  8, 12,  1,  5,  9, 13,  2,  6, 10, 14,  3,  7, 11, 15])

同次元 array_like オブジェクト同士で算術演算子が使える
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
``+``, ``-`` 等の二項演算子を同型 array オブジェクト同士に作用させることができる。
各演算の定義は、成分ごとの算術演算のようだ。
また、同型でなくとも broadcasting rule が適用できる場合は二項演算が実現できる。
特にスカラーを作用させる場合は常に可能と考えていい。

array オブジェクトのスライシング
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
行列を表現する array オブジェクトから部分ベクトルを得るようなときには、
Python の ``list`` 同様、スライシングの技法を利用する。

  >>> import numpy as np
  >>> a = np.arange(24).reshape(3, 8)
  >>> a
  array([[ 0,  1,  2,  3,  4,  5,  6,  7],
         [ 8,  9, 10, 11, 12, 13, 14, 15],
         [16, 17, 18, 19, 20, 21, 22, 23]])
  >>> a[:,0]
  array([ 0,  8, 16])
  >>> a[0,:]
  array([0, 1, 2, 3, 4, 5, 6, 7])

NumPy はより高性能なスライスをサポートしているが、深みにはまると危ないのでこの辺で。

線形代数関連
------------

スカラー積、ベクトル積
~~~~~~~~~~~~~~~~~~~~~~
スカラー積、ベクトル積を求めたい場合、それぞれ関数 ``dot``, ``cross`` を利用すること。

  >>> import numpy as np
  >>> x = [1., 0., 0.]
  >>> y = [0., 1., 0.]
  >>> np.dot(x, y)
  0.0
  >>> np.cross(x, y)
  array([ 0.,  0.,  1.])

``dot`` については引数の shape さえ適合すれば行列の乗算もサポートする。

  >>> import numpy as np
  >>> x = [100., 200.]
  >>> M = np.array([[1., 2.],
  ...               [3., 4.]])
  >>> np.dot(x, M)
  array([  700.,  1000.])
  >>> np.dot(M, x)
  array([  500.,  1100.])

ベクトルの長さ
~~~~~~~~~~~~~~
二項演算が幅広くサポートされているので、1-D array オブジェクトをベクトルとみなすのが楽だ。
が、ベクトルならば「長さ」を計算する関数が欲しい。
ここでは ``dot`` を利用する。

 >>> import math, numpy as np
 >>> v = array([1., 1., 1.])
 >>> math.sqrt(np.dot(v, v)) # ちなみに sqrt 関数は np にもある。
 1.7320508075688772

あるいは linalg パッケージにある ``norm`` 関数も有用だ。
デフォルト引数をそのまま利用すれば 2-norm を計算してくれる。

 >>> # v は上と同じ
 >>> vlen = np.linalg.norm(v)
 >>> vlen
 1.7320508075688772

ベクトル正規化
~~~~~~~~~~~~~~
正規化とは長さが 1 になるようにベクトルの成分を定数倍することとする。
それには、ベクトルの長さを上述の方法で得てから、
長さが非ゼロであることを確認後、array オブジェクトに対して ``/=`` する。

 >>> v /= vlen
 >>> v
 array([ 0.57735027,  0.57735027,  0.57735027])

ベクトルの一致
~~~~~~~~~~~~~~
同次元空間にある 2 ベクトル ``v1``, ``v2`` が等しいか否かのテストをする。
要するに、アプリケーション定義のトレランスを与えて、
両者の差ベクトルの長さがそれ以内に収まっているかどうかを調べる。

関数 ``allclose`` をアプリケーション由来のトレランスを明示的に与えた上で適用するのがよかろう。
デフォルトのトレランスではモデリング等で利用するには厳しすぎる。

ベクトルのなす角
~~~~~~~~~~~~~~~~
これも自分でコードを書く。
2 ベクトルのスカラー積 (``dot``) とそれぞれの長さからなす角の cos が求まる。

2 ベクトルの位置関係判定
~~~~~~~~~~~~~~~~~~~~~~~~
2 ベクトルが平行なのか、または直交するのかをテストしたい場合、
``dot`` と ``cross`` を組み合わせれば何とかなる。

一発で identity matrix を生成する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
関数 ``eye`` を利用する。

  >>> import numpy as np
  >>> np.eye(4)
  array([[ 1.,  0.,  0.,  0.],
         [ 0.,  1.,  0.,  0.],
         [ 0.,  0.,  1.,  0.],
         [ 0.,  0.,  0.,  1.]])

ずばり ``identity`` という関数も存在するが、タイプし易いほうを選ぶ。

対角行列を生成する
~~~~~~~~~~~~~~~~~~
関数 ``diag`` を利用すると、手軽に対角行列を作成できる。

  >>> import numpy as np
  >>> A = np.diag([1.,2.,3.])
  >>> A
  array([[ 1.,  0.,  0.],
         [ 0.,  2.,  0.],
         [ 0.,  0.,  3.]])

行列から対角成分を抽出する
~~~~~~~~~~~~~~~~~~~~~~~~~~
やはり関数 ``diag`` を利用する。
引数に二次元の array オブジェクトを渡すこと。

  >>> # 上の続き
  >>> np.diag(A)
  array([1., 2., 3.])

統計関連
--------
NumPy は標本を表現するデータ構造としても array を利用している。
NumPy Reference の Statistics のセクションでまとめてある。

* 統計関連の機能がまれにメソッドの形式で提供されていることがある？

* 個人的な用途では 1-D array オブジェクトを主に対象とする（このノートでも）が、
  当然 n-D array オブジェクトについても各種統計関数を適用できる。
  サンプリングの対象は array オブジェクトの各要素でも、
  along on axis でも OK だ。

総和
~~~~
Python 組み込み関数の ``sum`` を含む、色々な選択肢がある。
ここは ``np.sum`` に統一したい。

 >>> import numpy as np
 >>> v = np.arange(100.)
 >>> np.sum(v)
 4950.0

最小値、最大値
~~~~~~~~~~~~~~
``np.min``, ``np.max`` 関数がそれぞれ array オブジェクトの最小値、最大値を検索できる。

 >>> # v は先ほどと同じもの
 >>> np.amin(v)
 0.0
 >>> np.amax(v)
 99.0

平均値
~~~~~~
細かいことを言えば平均値の定義によるが、
``np.average`` と ``np.mean`` が利用できる。
両者の機能が若干異なるようだが、タイプし易いほうを選ぶ。

 >>> # v は先ほどと同じもの
 >>> np.mean(v)
 49.5

ヒストグラム
~~~~~~~~~~~~

未整理メモ
======================================================================


.. _Numpy: http://scipy.org/NumPy/
.. _Python: http://www.python.org/
.. _Nose: http://somethingaboutorange.com/mrl/projects/nose/
.. _Sphinx: http://sphinx.pocoo.org/
.. _Numpy and Scipy Documentation: http://docs.scipy.org/doc/
