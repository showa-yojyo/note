<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>整数論 &#8212; 読書ノート 1.6dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=1a9a5cd9" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=5a6f99c4"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="../_static/mathjax-v3.js?v=bf1ec211"></script>
    <script src="../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="ディオファントス方程式" href="diophantine.html" />
    <link rel="prev" title="多項式" href="polynomials.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
    <div class="related top">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="polynomials.html" title="Previous">多項式</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">SymPy 利用ノート</a>
        </li>
        <li>
          <a href="diophantine.html" title="Next">ディオファントス方程式</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>


          <div class="body" role="main">
            
  <section id="id1">
<h1><a class="toc-backref" href="#id10" role="doc-backlink">整数論</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p><a class="reference external" href="https://www.sympy.org/">SymPy</a> の整数論モジュール <code class="docutils literal notranslate"><span class="pre">sympy.ntheory</span></code> について記す。</p>
<nav class="contents" id="id2">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id10">整数論</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id11">素数</a></p>
<ul>
<li><p><a class="reference internal" href="#sieve" id="id12">クラス Sieve</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id13">素数に関連する関数</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id5" id="id14">素因数分解と約数</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id15">合同式</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id16">二項係数と多項係数</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id17">剰余</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id18">連分数</a></p></li>
</ul>
</li>
</ul>
</nav>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>本文中のすべての IPython セッション中のサンプルコードで、以下のインポートおよび出力書式設定が済んでいるものとする。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">init_printing</span><span class="p">(</span><span class="n">pretty_print</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<section id="id3">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">素数</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<section id="sieve">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">クラス Sieve</a><a class="headerlink" href="#sieve" title="Permalink to this heading">¶</a></h3>
<p>クラス Sieve は素数全体を表現する。または表現したい。 「エラトステネスのふるい」にちなんだクラス名は、クラスの素数の管理方法をなんとなく示唆している。</p>
<ul class="simple">
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">extend</span></code> で、指定素数までの全ての素数をオブジェクトが保持するようにできる。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">extend_to_no</span></code> で任意番目の素数までの以下同文。</p></li>
</ul>
<p>ユーザーが自分でコンストラクター経由でオブジェクトを生成するのもよいが、実は
<code class="docutils literal notranslate"><span class="pre">sympy</span></code> スコープにオブジェクト <code class="docutils literal notranslate"><span class="pre">sieve</span></code> が存在している。まずはこれを試すとよい。</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">p</span> <span class="pre">in</span> <span class="pre">sieve</span></code> で <code class="docutils literal notranslate"><span class="pre">p</span></code> が素数がどうかをテストできる。</p>
<ul>
<li><p>テストまでにユーザーが <code class="docutils literal notranslate"><span class="pre">sieve</span></code> を大きくする必要はない。オブジェクト自身が必要に応じて <code class="code docutils literal notranslate"><span class="pre">extend(p)</span></code> のようなことをする。</p></li>
<li><p>運が悪いとメソッドが例外 <code class="docutils literal notranslate"><span class="pre">MemoryError</span></code> を送出する。</p></li>
</ul>
</li>
<li><p><code class="code docutils literal notranslate"><span class="pre">sieve.primerange(a,</span> <span class="pre">b)</span></code> で <code class="docutils literal notranslate"><span class="pre">a</span></code> 以上 <code class="docutils literal notranslate"><span class="pre">b</span></code> 未満のすべての素数を列挙するジェネレーターを生成する。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">sieve.search(n)</span></code> が少しわかりづらい。ドキュメントによると <code class="code docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">n</span>
<span class="pre">&lt;</span> <span class="pre">j</span></code> なる素数列の添字 <code class="code docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> を返すようだが、<code class="docutils literal notranslate"><span class="pre">n</span></code> が素数ならば
<code class="code docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">i)</span></code> を返す。はて <code class="docutils literal notranslate"><span class="pre">j</span></code> は常に <code class="docutils literal notranslate"><span class="pre">i</span></code> または <code class="code docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code> ではないのだろうか。</p></li>
</ul>
</section>
<section id="id4">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">素数に関連する関数</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<p>素数に関連する関数は主にモジュール <code class="docutils literal notranslate"><span class="pre">sympy.ntheory.generate</span></code> に定義されている。憶測だが（コードを読めば直ちに判明するが）、これらの関数の内部では上述のオブジェクト <code class="docutils literal notranslate"><span class="pre">sieve</span></code> を参照しているのではないだろうか。</p>
<dl>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">prime(i)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">i</span></code> 番目の素数を得られる。ただし <code class="code docutils literal notranslate"><span class="pre">prime(1)</span> <span class="pre">==</span> <span class="pre">2</span></code> だ。</p>
</dd>
<dt>ジェネレーター <code class="code docutils literal notranslate"><span class="pre">primerange(a,</span> <span class="pre">b)</span></code></dt><dd><p>Python 組み込み関数 <code class="docutils literal notranslate"><span class="pre">range</span></code> の素数版だ。区間 <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b)</span></code> に含まれる素数を小さい順に生成する。</p>
<p>このジェネレーターは整数の性質をいろいろと試すのに有用だ。</p>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">primepi(n)</span></code></dt><dd><p>指定した数よりも小さい素数の個数を返す。引数が素数の場合はそれも含んで計上する。</p>
<ul class="simple">
<li><p>10 億を試したら <code class="docutils literal notranslate"><span class="pre">MemoryError</span></code> で失敗。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">integrate</span></code> の被積分関数として扱えない。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">nextprime(n,</span> <span class="pre">i=1)</span></code>, <code class="code docutils literal notranslate"><span class="pre">prevprime(n,</span> <span class="pre">i=1)</span></code></dt><dd><p>指定した数から大きい、または小さい <code class="docutils literal notranslate"><span class="pre">i</span></code> 番目の素数を返す。</p>
<ul class="simple">
<li><p>キーワード引数 <code class="docutils literal notranslate"><span class="pre">i</span></code> に負の値を指定すると、直感に反する値が返る。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prevprime</span></code> のほうは例外 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> を送出することがある。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">primorial(n,</span> <span class="pre">nth=True)</span></code></dt><dd><p>最初の <code class="docutils literal notranslate"><span class="pre">n</span></code> 個の素数の積を返す。引数の意味をキーワード引数 <code class="docutils literal notranslate"><span class="pre">nth</span></code> で変えられることに注意。</p>
</dd>
</dl>
<p>次の素数に関連する関数はモジュール <code class="docutils literal notranslate"><span class="pre">primetest</span></code> に存在する：</p>
<dl>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">isprime(p)</span></code></dt><dd><p>指定した数が素数かどうかテストする。</p>
<p>ただし、この関数が正確にテストするために <code class="docutils literal notranslate"><span class="pre">p</span></code> に上限があるようだ。</p>
</dd>
</dl>
</section>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">素因数分解と約数</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>モジュール <code class="docutils literal notranslate"><span class="pre">sympy.ntheory.factor_</span></code> には素因数分解や約数にまつわる関数がある。本当は 10 個を軽く超える関数が提供されているのだが、私が理解できるものだけをここに記す。</p>
<dl>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">factorint(n)</span></code></dt><dd><p>正の整数 <code class="docutils literal notranslate"><span class="pre">n</span></code> を素因数分解して、結果を通常は <code class="docutils literal notranslate"><span class="pre">dict</span></code> オブジェクトの形で返す。</p>
<ul class="simple">
<li><p>例えば <code class="code docutils literal notranslate"><span class="pre">factorint(2000)</span></code> は <code class="code docutils literal notranslate"><span class="pre">{2:4,</span> <span class="pre">5:3}</span></code> を返す。キーが素因数、値が指数のペアの辞書。</p></li>
<li><p>キーワード引数がたくさんある。</p></li>
<li><p>実装コードを見たらわけがわからない。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">primefactors(n)</span></code></dt><dd><p>因数のリストだけを返す。指数は捨てられる。</p>
<p>内部で <code class="docutils literal notranslate"><span class="pre">factorint</span></code> を利用しており、キーワード引数 <code class="docutils literal notranslate"><span class="pre">limit</span></code> と <code class="docutils literal notranslate"><span class="pre">verbose</span></code>
が引き継がれる。</p>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">divisors(n,</span> <span class="pre">generator=False)</span></code></dt><dd><p>整数 <code class="docutils literal notranslate"><span class="pre">n</span></code> の約数を 1 から <code class="docutils literal notranslate"><span class="pre">n</span></code> までソートして <code class="docutils literal notranslate"><span class="pre">list</span></code> オブジェクトで返す。</p>
<p>ただしキーワード引数で <code class="code docutils literal notranslate"><span class="pre">generator=True</span></code> とするとき、動きが全く異なる。関数が約数を列挙するジェネレーターを返す。さらに <code class="docutils literal notranslate"><span class="pre">yield</span></code> する値の順番は関数のそれとは異なる。</p>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">divisor_count(n,</span> <span class="pre">modulus=1)</span></code></dt><dd><p>整数 <code class="docutils literal notranslate"><span class="pre">n</span></code> の約数の個数を返す。</p>
<p>実装は関数 <code class="docutils literal notranslate"><span class="pre">factorint</span></code> の返す各素因数の指数を利用している。</p>
</dd>
</dl>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">udivisors</span></code>, <code class="docutils literal notranslate"><span class="pre">udivisor_count</span></code> というものもある。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">antidivisors</span></code>, <code class="docutils literal notranslate"><span class="pre">antidivisor_count</span></code> というものもある。</p></li>
</ul>
<dl>
<dt>クラス <code class="docutils literal notranslate"><span class="pre">totient</span></code></dt><dd><p>オイラーの totient 関数を計算するクラス。実装で関数 <code class="docutils literal notranslate"><span class="pre">factorint</span></code> の結果をフル活用している。</p>
<ul>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Function</span></code> のサブクラスなので、評価をするには <code class="code docutils literal notranslate"><span class="pre">totient(n)</span></code> のようにする。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="p">[</span><span class="n">totient</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="gh">Out[1]: </span><span class="go">[1, 4, 40, 400, 4000, 40000, 400000, 4000000, 40000000, 400000000]</span>
</pre></div>
</div>
</li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">digits(n,</span> <span class="pre">p=10)</span></code></dt><dd><p>任意整数 <code class="docutils literal notranslate"><span class="pre">n</span></code> を <code class="docutils literal notranslate"><span class="pre">p</span></code> 進数表現して、その各桁をリストする。戻り値は <code class="docutils literal notranslate"><span class="pre">list</span></code>
オブジェクトだが、最初の要素は <code class="docutils literal notranslate"><span class="pre">p</span></code> そのものなので捨ててよい。</p>
</dd>
</dl>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">合同式</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<p>モジュール <code class="docutils literal notranslate"><span class="pre">sympy.ntheory.modular</span></code> は合同式に関係する機能を提供する。使えそうなものをピックアップしていこう。</p>
<dl>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">crt(m,</span> <span class="pre">v,</span> <span class="pre">symmetric=False,</span> <span class="pre">check=True)</span></code></dt><dd><p>中国剰余定理に基づく問題を解くのに利用できる。同定理の名前の由来となった問題を解いてみる：</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">crt</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gh">Out[1]: </span><span class="go">(23, 105)</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\({23 + 105k}\)</span> を 3, 5, 7 でそれぞれ割ると余りが 2, 3, 2 になるという解が得られた。</p>
<ul>
<li><p>キーワード引数 <code class="code docutils literal notranslate"><span class="pre">symmetric=True</span></code> とすると、剰余が対称になるように、解が必要に応じて非負で得られる。</p></li>
<li><p>キーワード引数 <code class="code docutils literal notranslate"><span class="pre">check=False</span></code> の使いどころが不明。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">crt</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [2]: </span><span class="n">crt</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gh">Out[2]: </span><span class="go">(14, 60)</span>
</pre></div>
</div>
</li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">solve_congruence(*remainder_modulus_pairs,</span> <span class="pre">**hint)</span></code></dt><dd><p>合同式を解くわけだが、前述の関数 <code class="docutils literal notranslate"><span class="pre">crt</span></code> と同様だと思う。ただし引数の順序が異なる。</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">solve_congruence((2,</span> <span class="pre">3),</span> <span class="pre">(3,</span> <span class="pre">5),</span> <span class="pre">(2,</span> <span class="pre">7))</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">solve_congruence(*zip((2,</span> <span class="pre">3,</span> <span class="pre">2),</span> <span class="pre">(3,</span> <span class="pre">5,</span> <span class="pre">7)))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">crt</span></code> が <code class="docutils literal notranslate"><span class="pre">solve_congruence</span></code> を利用している。</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">二項係数と多項係数</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>モジュール <code class="docutils literal notranslate"><span class="pre">sympy.ntheory.multinomial</span></code> にある関数について記す。モジュール名は多項係数だが、二項係数に特化した関数も存在する。</p>
<dl>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">binomial_coefficients(n)</span></code></dt><dd><p>Pascal の三角形の <code class="docutils literal notranslate"><span class="pre">n</span></code> 段目を <code class="docutils literal notranslate"><span class="pre">dict</span></code> で返す。</p>
<p>辞書のキーは <code class="docutils literal notranslate"><span class="pre">tuple</span></code> オブジェクト <code class="code docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">n)</span></code>, <code class="code docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">1)</span></code>, … ,
<code class="code docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">0)</span></code> である。分母に来る階乗ふたつの引数と覚えられる。辞書の値は、それぞれのキーに対応する二項係数を表す。</p>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">binomial_coefficients_list(n)</span></code></dt><dd><p>Pascal の三角形の <code class="docutils literal notranslate"><span class="pre">n</span></code> 段目を全部得る。戻り値は <code class="docutils literal notranslate"><span class="pre">list</span></code> である。</p>
<p>こちらは単に二項係数が一列に並んだものが得られる。</p>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">multinomial_coefficients(m,</span> <span class="pre">n)</span></code></dt><dd><p>二項係数を得る関数 <code class="code docutils literal notranslate"><span class="pre">binomial_coefficients(n)</span></code> の一般化版。</p>
<p>二項係数は <span class="math notranslate nohighlight">\({(a_1 + a_2) ^ n}\)</span> の各項の係数だが、多項係数は <span class="math notranslate nohighlight">\({(a_1 +
a_2 + ... + a_k) ^ n}\)</span> の各項の係数を表現する。</p>
</dd>
<dt>ジェネレーター <code class="code docutils literal notranslate"><span class="pre">multinomial_coefficients_iterator(m,</span> <span class="pre">n)</span></code></dt><dd><p>関数 <code class="code docutils literal notranslate"><span class="pre">multinomial_coefficients(m,</span> <span class="pre">n)</span></code> のジェネレーター版。関数版よりも空間的にも時間的にも効率的であることが期待できる。</p>
</dd>
</dl>
</section>
<section id="id8">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">剰余</a><a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h2>
<p>モジュール <code class="docutils literal notranslate"><span class="pre">sympy.ntheory.residue_ntheory</span></code> にある関数について記す。ただしインポートは <code class="code docutils literal notranslate"><span class="pre">from</span> <span class="pre">sympy.ntheory</span> <span class="pre">import</span> <span class="pre">...</span></code> で可能。</p>
<dl>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">n_order(a,</span> <span class="pre">n)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">n</span></code> を法とする <code class="docutils literal notranslate"><span class="pre">a</span></code> の位数、すなわち <code class="code docutils literal notranslate"><span class="pre">a</span> <span class="pre">**</span> <span class="pre">k</span> <span class="pre">%</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">1</span></code> を満たす最小の整数 <code class="docutils literal notranslate"><span class="pre">k</span></code> を返す。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">n_order</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">100</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prime</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
<span class="gh">Out[1]: </span><span class="go">3959</span>

<span class="gp">In [2]: </span><span class="n">Pow</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="mi">3959</span><span class="p">)</span> <span class="o">%</span> <span class="n">prime</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gh">Out[2]: </span><span class="go">1</span>
</pre></div>
</div>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">is_primitive_root(a,</span> <span class="pre">p)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">a</span></code> が <code class="docutils literal notranslate"><span class="pre">p</span></code> の原始根であるかをテストする。</p>
<p>ただし <span class="math notranslate nohighlight">\(\gcd(a, p) = 1\)</span> は呼び出し側が保証する必要がある。</p>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">primitive_root(p)</span></code></dt><dd><p>存在するときに限り <code class="docutils literal notranslate"><span class="pre">p</span></code> の最小の原始根を一つ返す。つまり巡回群
<span class="math notranslate nohighlight">\({(\ZZ/p\ZZ)^\cross}\)</span> の生成元を求める。</p>
<p><span class="math notranslate nohighlight">\({27 = 3^3}\)</span> の原始根を一つ求める：</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">primitive_root</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span>
<span class="gh">Out[1]: </span><span class="go">2</span>

<span class="gp">In [2]: </span><span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_order</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">27</span><span class="p">),</span> <span class="mi">27</span><span class="p">)</span>
<span class="gh">Out[2]: </span><span class="go">1</span>
</pre></div>
</div>
<ul class="simple">
<li><p>原始根があるかどうかを判定する関数を本関数から括り出すといい。</p></li>
</ul>
</dd>
</dl>
<p>次に平方剰余に関係するものをまとめておく。</p>
<dl>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">is_quad_residue(a,</span> <span class="pre">p)</span></code></dt><dd><p>整数 <code class="docutils literal notranslate"><span class="pre">a</span></code> が <code class="docutils literal notranslate"><span class="pre">p</span></code> を法とする平方剰余であるか、つまり、合同式 <span class="math notranslate nohighlight">\({x^2
\equiv a \pmod{p}}\)</span> に解があるかどうかを判定する。</p>
<ul class="simple">
<li><p>引数 <code class="docutils literal notranslate"><span class="pre">p</span></code> が一般的な素数の場合には Euler の基準を利用していることがわかる。</p></li>
<li><p>引数 <code class="docutils literal notranslate"><span class="pre">p</span></code> が一般的な偶数の場合には Jacobi 記号の値を計算する。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">quadratic_residues(p)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">p</span></code> を法とする平方剰余の集合をソート済みリストとして返す。つまり、合同式
<span class="math notranslate nohighlight">\({x^2 \equiv a \pmod{p}}\)</span> が解を持つような <span class="math notranslate nohighlight">\(a\)</span> をゼロを含めてすべて返す。</p>
<ul class="simple">
<li><p>IPython 上で <code class="docutils literal notranslate"><span class="pre">%is_quad_residue??</span></code> と入力して実装を見るといい。それで全て理解できる。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">sqrt_mod(a,</span> <span class="pre">p,</span> <span class="pre">all_roots=False)</span></code></dt><dd><p>合同式 <span class="math notranslate nohighlight">\(x^2 \equiv a \pmod{p}\)</span> を解く。</p>
<p>解が存在しない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> を返す：</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">sqrt_mod</span>

<span class="gp">In [2]: </span><span class="n">sqrt_mod</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5987</span><span class="p">)</span>

<span class="gp">In [3]:</span>
</pre></div>
</div>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">legendre_symbol(a,</span> <span class="pre">p)</span></code></dt><dd><p>整数 <code class="docutils literal notranslate"><span class="pre">a</span></code> と奇素数 <code class="docutils literal notranslate"><span class="pre">p</span></code> に対する Legendre 記号の値を返す。すなわち <code class="docutils literal notranslate"><span class="pre">a</span></code> が
<code class="docutils literal notranslate"><span class="pre">p</span></code> を法とする平方剰余ならば 1 を返し、平方非剰余ならば -1 を返す。ただし 0
に合同ならば 0 を返す。</p>
<p>平方剰余の相互法則第一法則および第二法則を実験してみよう：</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">legendre_symbol</span><span class="p">,</span> <span class="n">primerange</span>

<span class="gp">In [2]: </span><span class="nb">all</span><span class="p">(</span><span class="n">legendre_symbol</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">primerange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[2]: </span><span class="go">True</span>

<span class="gp">In [3]: </span><span class="nb">all</span><span class="p">(</span><span class="n">legendre_symbol</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">primerange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
<span class="gh">Out[3]: </span><span class="go">True</span>

<span class="gp">In [4]: </span><span class="nb">all</span><span class="p">(</span><span class="n">legendre_symbol</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">primerange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">8</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gh">Out[4]: </span><span class="go">True</span>

<span class="gp">In [5]: </span><span class="nb">all</span><span class="p">(</span><span class="n">legendre_symbol</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">primerange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">8</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gh">Out[5]: </span><span class="go">True</span>
</pre></div>
</div>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">jacobi_symbol(m,</span> <span class="pre">n)</span></code></dt><dd><p>整数 <code class="docutils literal notranslate"><span class="pre">a</span></code> と正の奇数 <code class="docutils literal notranslate"><span class="pre">n</span></code> に対する Jacobi 記号の値を返す。</p>
<ul class="simple">
<li><p>Jacobi 記号は Legendre 記号の上位互換のようなものだが、コードを見ると、記号の簡略化アルゴリズムを実装していることがうかがえて面白い。</p></li>
</ul>
</dd>
</dl>
<p>離散対数に関する関数もある。</p>
<dl>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">discrete_log(n,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">order=None,</span> <span class="pre">prime_order=None</span></code></dt><dd><p>離散対数、つまり <span class="math notranslate nohighlight">\({b^x \equiv a \pmod{n}}\)</span> を満たす数を返す。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">discrete_log</span>

<span class="gp">In [2]: </span><span class="n">b</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span>

<span class="gp">In [3]: </span><span class="p">[</span><span class="n">discrete_log</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>
<span class="gh">Out[3]: </span><span class="go">[0, 1, 4, 2, 9, 5, 11, 3, 8, 10, 7, 6]</span>

<span class="gp">In [4]: </span><span class="p">[</span><span class="nb">pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_</span><span class="p">]</span>
<span class="gh">Out[4]: </span><span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span>
</pre></div>
</div>
</dd>
</dl>
</section>
<section id="id9">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">連分数</a><a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h2>
<p>モジュール <code class="docutils literal notranslate"><span class="pre">sympy.ntheory.continued_fraction</span></code> に置いてある、連分数を扱う関数各種について記す。</p>
<dl>
<dt>ジェネレーター <code class="code docutils literal notranslate"><span class="pre">continued_fraction_iterator(x)</span></code></dt><dd><p>引数 <code class="docutils literal notranslate"><span class="pre">x</span></code> の連分数展開（分子は全部 1 とする）を求め、その分母を一つずつ
<code class="docutils literal notranslate"><span class="pre">yield</span></code> する。</p>
<p>一度実装を見ておいたほうがよい。</p>
<ul>
<li><p>これは微妙に使いにくい。値によっては自分でループを書く必要があるだろう。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

<span class="gp">In [2]: </span><span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">continued_fraction_iterator</span><span class="p">(</span><span class="n">coth</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">20</span><span class="p">))</span>
<span class="gh">Out[2]: </span><span class="go">[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]</span>

<span class="gp">In [3]: </span><span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">continued_fraction_iterator</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">),</span> <span class="mi">20</span><span class="p">))</span>
<span class="gh">Out[3]: </span><span class="go">[3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2]</span>
</pre></div>
</div>
</li>
</ul>
</dd>
<dt>ジェネレーター <code class="code docutils literal notranslate"><span class="pre">continued_fraction_convergents(cf)</span></code></dt><dd><p>連分数 <code class="docutils literal notranslate"><span class="pre">cf</span></code> の「真の値」に収束する数列の数を一つずつ <code class="docutils literal notranslate"><span class="pre">yield</span></code> する。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cf</span></code> は連分数の各項（分母）を <code class="docutils literal notranslate"><span class="pre">list</span></code> オブジェクト等に収容したもの。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cf</span></code> の各項の分子が 1 であるという条件は特に課せられていない。</p></li>
</ul>
<p><span class="math notranslate nohighlight">\({\sqrt{2} + \sqrt{3}}\)</span> を 30 項ほど連分数展開し、近似分数を求めるには次のようにする：</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

<span class="gp">In [2]: </span><span class="n">L</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">continued_fraction_iterator</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="mi">30</span><span class="p">))</span>

<span class="gp">In [3]: </span><span class="nb">list</span><span class="p">(</span><span class="n">ntheory</span><span class="o">.</span><span class="n">continued_fraction_convergents</span><span class="p">(</span><span class="n">L</span><span class="p">[:</span><span class="mi">8</span><span class="p">]))</span>
<span class="gh">Out[3]: </span><span class="go">[3, 19/6, 22/7, 129/41, 925/294, 1054/335, 1979/629, 8970/2851]</span>

<span class="gp">In [4]: </span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_</span><span class="p">]</span>
<span class="gh">Out[4]:</span>
<span class="go">[3.00000000000000,</span>
<span class="go"> 3.16666666666667,</span>
<span class="go"> 3.14285714285714,</span>
<span class="go"> 3.14634146341463,</span>
<span class="go"> 3.14625850340136,</span>
<span class="go"> 3.14626865671642,</span>
<span class="go"> 3.14626391096979,</span>
<span class="go"> 3.14626446860751]</span>
</pre></div>
</div>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">continued_fraction_periodic(p,</span> <span class="pre">q,</span> <span class="pre">d=0)</span></code></dt><dd><p>整数係数二次方程式の根となる無理数の循環連分数展開を返す。単に <code class="code docutils literal notranslate"><span class="pre">(p</span> <span class="pre">+</span>
<span class="pre">sqrt(d))</span> <span class="pre">/</span> <span class="pre">q</span></code> の連分数を返すと覚えておいて支障はない。</p>
<ul class="simple">
<li><p>戻り値は入れ子の <code class="docutils literal notranslate"><span class="pre">list</span></code> オブジェクトで、内側のそれが循環部分を示す。</p></li>
<li><p>根号の中 <code class="docutils literal notranslate"><span class="pre">d</span></code> が平方数の場合は連分数は循環しない。戻り値はフラットな
<code class="docutils literal notranslate"><span class="pre">list</span></code> オブジェクトとなる。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">continued_fraction_reduce(cf)</span></code></dt><dd><p>連分数 <code class="docutils literal notranslate"><span class="pre">cf</span></code> を連分数でない形で返す。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>

<span class="gp">In [2]: </span><span class="n">continued_fraction_reduce</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="gh">Out[2]: </span><span class="go">(a + c*(a*b + 1))/(b*c + 1)</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(\pi^2\)</span> を 6 項で近似する：</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">ntheory</span>

<span class="gp">In [2]: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

<span class="gp">In [3]: </span><span class="n">L</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">ntheory</span><span class="o">.</span><span class="n">continued_fraction_iterator</span><span class="p">(</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">6</span><span class="p">))</span>

<span class="gp">In [4]: </span><span class="n">ntheory</span><span class="o">.</span><span class="n">continued_fraction_reduce</span><span class="p">(</span><span class="n">L</span><span class="p">[:</span><span class="mi">6</span><span class="p">])</span>
<span class="gh">Out[4]: </span><span class="go">10748/1089</span>

<span class="gp">In [5]: </span><span class="p">(</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">_</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
<span class="gh">Out[5]: </span><span class="go">-7.41243056440853e-7</span>
</pre></div>
</div>
</dd>
</dl>
</section>
</section>


          </div>
    <div class="related bottom">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="polynomials.html" title="Previous">多項式</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">SymPy 利用ノート</a>
        </li>
        <li>
          <a href="diophantine.html" title="Next">ディオファントス方程式</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>

      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="../index.html" title="読書ノート Home"><img src="../_images/logo.svg"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2024, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>