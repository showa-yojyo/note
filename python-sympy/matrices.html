
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>行列 &#8212; 読書ノート v1.4</title>
    <link rel="stylesheet" href="../_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/mathjaxconf.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="next" title="多項式" href="polynomials.html" />
    <link rel="prev" title="ベクトル" href="vector.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="polynomials.html" title="多項式"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="vector.html" title="ベクトル"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">SymPy 利用ノート</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id27">行列</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>モジュール <code class="docutils literal notranslate"><span class="pre">sympy.matrices</span></code> に関するメモを記す。ここにある機能は、行列を処理するものと、行列に関する数式を処理するものとに分類できる。</p>
<div class="contents topic" id="id2">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id27">行列</a><ul>
<li><a class="reference internal" href="#id3" id="id28">クラス図</a><ul>
<li><a class="reference internal" href="#id4" id="id29">行列を表現するクラス</a></li>
<li><a class="reference internal" href="#id5" id="id30">行列を構成要素とする数式のためのクラス</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6" id="id31">色々な行列の生成方法</a></li>
<li><a class="reference internal" href="#id7" id="id32">基本的な操作</a></li>
<li><a class="reference internal" href="#id8" id="id33">線形代数的操作</a></li>
<li><a class="reference internal" href="#matrixbase" id="id34">クラス MatrixBase</a><ul>
<li><a class="reference internal" href="#id9" id="id35">プロパティー</a></li>
<li><a class="reference internal" href="#id10" id="id36">要素の物理的な操作</a></li>
<li><a class="reference internal" href="#id11" id="id37">部分空間</a></li>
<li><a class="reference internal" href="#id12" id="id38">乗法</a></li>
<li><a class="reference internal" href="#id13" id="id39">ノルム</a></li>
<li><a class="reference internal" href="#id14" id="id40">行列式</a></li>
<li><a class="reference internal" href="#id15" id="id41">余因子</a></li>
<li><a class="reference internal" href="#id16" id="id42">対角行列</a></li>
<li><a class="reference internal" href="#id17" id="id43">分解</a></li>
<li><a class="reference internal" href="#id18" id="id44">ソルバー</a></li>
<li><a class="reference internal" href="#id19" id="id45">逆行列</a></li>
<li><a class="reference internal" href="#berkowitz" id="id46">Berkowitz のアルゴリズム</a></li>
<li><a class="reference internal" href="#id21" id="id47">特異値</a></li>
<li><a class="reference internal" href="#id22" id="id48">微積分</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numpy" id="id49">NumPy インターフェイス</a></li>
<li><a class="reference internal" href="#id23" id="id50">演習</a><ul>
<li><a class="reference internal" href="#id24" id="id51">Berkowitz のアルゴリズムを検証する</a></li>
<li><a class="reference internal" href="#lu" id="id52">LU 分解再挑戦</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25" id="id53">関連ノート</a></li>
</ul>
</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>紙幅の都合上、出力を一部手で改行した。</p>
<p>本文中のすべての IPython セッション中のサンプルコードで、以下のインポートおよび出力書式設定が済んでいるものとする。</p>
<div class="code python3 last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">init_printing</span><span class="p">(</span><span class="n">pretty_print</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id28">クラス図</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>行列関連の単純なクラス図を示す。</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id29">行列を表現するクラス</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>行列オブジェクトの基本単位を表現するためのクラスの論理的な継承関係は次のようになっている。</p>
<div class="code text highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MatrixBase</span>
    <span class="n">MutableDenseMatrix</span>
    <span class="n">ImmutableDenseMatrix</span>

    <span class="n">ImmutableSparseMatrix</span>
    <span class="n">MutableSparseMatrix</span>
</pre></div>
</div>
<ul class="simple">
<li>モジュール <code class="docutils literal notranslate"><span class="pre">__init__</span></code> で別名が付けられる等されているため、クラス名中の Mutable と Dense の部分は省略できる。例を挙げると、単に Matrix と書いたとしても、実際はクラス MutableDenseMatrix である。</li>
<li>Mutable と Immutable の違いは Python のプログラマーが思い浮かべるものと同じ。</li>
<li>Dense と Sparse の違いは疎行列性を意味する。</li>
<li>MatrixBase のスーパークラスは Python のクラス object である。</li>
</ul>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id30">行列を構成要素とする数式のためのクラス</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>行列オブジェクトを各種演算で構成した数式を表現するためのクラスが多数存在する。そのクラス群はモジュール <code class="docutils literal notranslate"><span class="pre">matrices.expressions</span></code> 以下で定義されており、それらの継承関係は次のようになっている。全サブクラスを書き出す必要はまったくないが、何かのために記す。</p>
<p>継承ツリーの右側に関連するフリー関数、行列クラスのメソッド、メモを併記する。</p>
<div class="code text highlight-default notranslate"><div class="highlight"><pre><span></span>MatrixExpr
    MatrixSymbol                    シンボル（記号）としての行列

    Identity
    ZeroMatrix

    MatAdd                          加法
    MatMul                          乗法
    MatPow                          M ** n
        Inverse                     M ** -1, M.inverse(), M.I

    Transpose                       transpose(M), M.T
    Adjoint                         adjoint(M)

    Trace                           trace(M)
    DiagonalMatrix
    DiagonalOf

    Determinant                     det(M)

    DFT                             離散 Fourier 変換の行列表現
        IDFT                        逆離散 Fourier 変換の行列表現

    MatrixSlice                     M[start:stop:step, ...]

    HadamardProduct                 hadamard_product(M, ...)

    FunctionMatrix                  ラムダ式による行列生成

    Factorization
        LofLU                       lu(M)
            LofCholesky
        UofLU                       lu(M)
            UofCholesky

        QofQR                       qr(M)
        RofQR                       qr(M)

        EigenVectors                eig(M)
        EigenValues                 eig(M)

        UofSVD                      svd(M)
        SofSVD                      svd(M)
        VofSVD                      svd(M)

    BlockMatrix                     blockcut(M, rsize, csize)
        BlockDiagMatrix
</pre></div>
</div>
<ul class="simple">
<li>クラス MatrixExpr のスーパークラスは SymPy のクラス Basic である。</li>
</ul>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id31">色々な行列の生成方法</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>まず、行列以外の要素から行列オブジェクトを直接生成する方法を記す。</p>
<p>他のライブラリーの類似機能を利用した経験から言えば、クラス Matrix のコンストラクターを直接する場合は、おそらく行列の各成分を細かく指示する場合に限られると思われる。</p>
<dl class="docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">Matrix(([[1,0,0],</span> <span class="pre">[0,0,0]])</span></code></dt>
<dd>入れ子の list は行 (row) を上から下に並べたものとして扱われる。</dd>
<dt><code class="code docutils literal notranslate"><span class="pre">Matrix([[1,</span> <span class="pre">2,</span> <span class="pre">3]])</span></code></dt>
<dd>上の特別な場合だが、入れ子の中身が list ひとつの場合は行ベクトルと等価な行列となる。</dd>
<dt><code class="code docutils literal notranslate"><span class="pre">Matrix([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code></dt>
<dd>入れ子になっていない場合は列ベクトルと等価な行列となる。</dd>
<dt><code class="code docutils literal notranslate"><span class="pre">Matrix(2,</span> <span class="pre">3,</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6])</span></code></dt>
<dd><p class="first">行列の寸法と成分すべてを行を先に埋める順で指示して生成する。</p>
<ul class="last simple">
<li>寸法は行数、列数の順。タテ、ヨコ。</li>
</ul>
</dd>
<dt><code class="code docutils literal notranslate"><span class="pre">Matrix(3,</span> <span class="pre">4,</span> <span class="pre">lambda</span> <span class="pre">i,j:</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">(i+j)</span> <span class="pre">%</span> <span class="pre">2)</span></code></dt>
<dd>行列を寸法と添字を引数に取る関数とで生成する。</dd>
</dl>
<p>成分に特徴のある行列を生成する場合は、それに適する関数、メソッドが用意されているので利用する。</p>
<ul class="simple">
<li>関数 <code class="code docutils literal notranslate"><span class="pre">eyes</span></code> と <code class="code docutils literal notranslate"><span class="pre">zeros</span></code> は <a class="reference external" href="http://www.numpy.org/">NumPy</a> のそれと同様。</li>
<li>関数 <code class="code docutils literal notranslate"><span class="pre">diag</span></code> は対角行列の生成であるが、より小さい行列を主対角線上に配列するようなこともできる。</li>
</ul>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id32">基本的な操作</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>要素アクセス<ul>
<li>行列の要素ひとつにアクセスするには、適切な添え字を用いて <code class="code docutils literal notranslate"><span class="pre">M[i]</span></code> や <code class="code docutils literal notranslate"><span class="pre">M[i,</span> <span class="pre">j]</span></code> とする。添字がひとつの場合は、要素を row-major でアクセスする。</li>
<li>NumPy の array と同様にスライスもサポートしている。<ul>
<li>記法も同様に <code class="code docutils literal notranslate"><span class="pre">M[start:stop:step]</span></code> のようにする。</li>
<li>右辺値としてスライスする場合は、元のオブジェクトの一部のコピーとして機能する。一方、左辺値としてスライスする場合は、元のオブジェクトのビューのように機能する。</li>
</ul>
</li>
</ul>
</li>
<li>行列代数<ul>
<li>少なくとも同型の行列同士では加法と乗法が成立する。これは標準的な算術演算子 <code class="code docutils literal notranslate"><span class="pre">+</span></code>, <code class="code docutils literal notranslate"><span class="pre">-</span></code>, <code class="code docutils literal notranslate"><span class="pre">*</span></code> で表現する。</li>
</ul>
</li>
<li>ベクトル演算<ul>
<li>例えばメソッド <code class="code docutils literal notranslate"><span class="pre">dot</span></code> と <code class="code docutils literal notranslate"><span class="pre">cross</span></code> が利用可能になる。詳細は後述する。</li>
</ul>
</li>
<li>各要素に関数を適用するには、メソッド <code class="code docutils literal notranslate"><span class="pre">applyfunc</span></code> を用いる。</li>
</ul>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id33">線形代数的操作</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">GramSchmidt(vlist,</span> <span class="pre">orthonormal=False)</span></code></dt>
<dd><p class="first">ベクトルの集合を基に直交基底を得る。</p>
<ul class="last simple">
<li>引数 <code class="code docutils literal notranslate"><span class="pre">vlist</span></code> は同じサイズのベクトルのコレクション。断りがないが、線形独立である必要があるはずだ。</li>
<li>キーワード引数 <code class="code docutils literal notranslate"><span class="pre">orthonormal</span></code> で得られるベクトルの長さを 1 にするかどうかを指定する。</li>
<li>実装を見ると、メソッド <code class="code docutils literal notranslate"><span class="pre">project</span></code> を利用していることがわかる。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="matrixbase">
<h2><a class="toc-backref" href="#id34">クラス MatrixBase</a><a class="headerlink" href="#matrixbase" title="Permalink to this headline">¶</a></h2>
<p>このクラスにはメソッドが大量にある。要所に絞って記す。演算子は省略。</p>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id35">プロパティー</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>プロパティーのほぼすべてを記す。下の表のもの以外にも、例えば <code class="code docutils literal notranslate"><span class="pre">.rows</span></code> のようにしてオブジェクトの属性を得ることができるものもあるようだが、コードから拾えないので割愛した。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">プロパティー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">C</span></code></td>
<td>要素ごとに複素共役をとった行列を返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">D</span></code></td>
<td>Dirac 共役行列を返す。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">H</span></code></td>
<td>Hermite 共役を返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">T</span></code></td>
<td>転置行列を返す。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">is_hermitian</span></code></td>
<td>Hermite 行列かどうかを返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">is_lower</span></code></td>
<td>下三角行列かどうかを返す。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">is_lower_hessenberg</span></code></td>
<td>下 Hessenberg 行列かどうかを返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">is_square</span></code></td>
<td>正方行列かどうかを返す。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">is_upper</span></code></td>
<td>上三角行列かどうかを返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">is_upper_hessenberg</span></code></td>
<td>上 Hessenberg 行列かどうかを返す。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">is_zero</span></code></td>
<td>零行列かどうかを返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">shape</span></code></td>
<td>行列の寸法を返す。必ず (r, c) の型をとる。</td>
</tr>
</tbody>
</table>
<ul>
<li><p class="first"><code class="code docutils literal notranslate"><span class="pre">C</span></code> はメソッド <code class="code docutils literal notranslate"><span class="pre">conjugate</span></code> のエイリアス。</p>
</li>
<li><p class="first"><code class="code docutils literal notranslate"><span class="pre">D</span></code> は結局はモジュール <code class="docutils literal notranslate"><span class="pre">sympy.physics.matrices</span></code> の機能を利用している。そのときにまた調べよう。</p>
</li>
<li><p class="first"><code class="code docutils literal notranslate"><span class="pre">H</span></code> は <code class="code docutils literal notranslate"><span class="pre">T.C</span></code> と同じ。</p>
</li>
<li><p class="first"><code class="code docutils literal notranslate"><span class="pre">T</span></code> はメソッド <code class="code docutils literal notranslate"><span class="pre">transpose</span></code> のエイリアス。</p>
</li>
<li><p class="first">三角行列判定系のメソッドは for ループを二重にまわして、テストに必要な各成分を要素オブジェクトのプロパティー <code class="code docutils literal notranslate"><span class="pre">is_zero</span></code> でゼロかどうかをテストしている。</p>
<p>また、必ずしも正方行列でなくてよい。</p>
</li>
</ul>
</div>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id36">要素の物理的な操作</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>行や列のデータを物理的に操作するタイプのものを次の表に記す。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">hstack(*args)</span></code></td>
<td>複数の行列を横に連結する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">vstack(*args)</span></code></td>
<td>複数の行列を縦に連結する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">col_insert(pos,</span> <span class="pre">mti)</span></code></td>
<td>行列に列を挿入する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">row_insert(pos,</span> <span class="pre">mti)</span></code></td>
<td>行列に行を挿入する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">col_join(bott)</span></code></td>
<td>行列同士を縦に連結する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">row_join(rhs)</span></code></td>
<td>行列同士を横に連結する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">permuteBkwd(perm)</span></code></td>
<td>行を指定の置換で入れ替える。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">permuteFwd(perm)</span></code></td>
<td>行を指定の置換で入れ替える。</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>どのメソッドも inplace な振る舞いをしない。</li>
<li><code class="code docutils literal notranslate"><span class="pre">hstack</span></code>, <code class="code docutils literal notranslate"><span class="pre">vstack</span></code> はクラスメソッド。余談だが同名のものが NumPy にもある。</li>
<li>挿入系メソッドの引数 <code class="code docutils literal notranslate"><span class="pre">mti</span></code> は <code class="code docutils literal notranslate"><span class="pre">shape</span></code> の縦横の一致を問う。</li>
<li>置換系メソッドの核となるのはメソッド <code class="code docutils literal notranslate"><span class="pre">row_swap</span></code> である。</li>
</ul>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id37">部分空間</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>部分空間に関するメソッドを下の表に示す。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">columnspace(simplify=False)</span></code></td>
<td>列空間を返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">nullspace(simplify=False)</span></code></td>
<td>零空間を返す。</td>
</tr>
</tbody>
</table>
<p>どちらもメソッド <code class="code docutils literal notranslate"><span class="pre">rref</span></code> が重要な働きをする。</p>
</div>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id38">乗法</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>行列またはベクトルの乗算に関するメソッドを下の表に示す。行か列のどちらかのサイズを 1 にすれば Matrix を列ベクトル、行ベクトルとして扱える。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">cross(b)</span></code></td>
<td>ベクトルのクロス積、ベクトル積を計算する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">dot(b)</span></code></td>
<td>ベクトルのドット積、スカラー積を計算する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">multiply(b)</span></code></td>
<td>行列の乗算を行う。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">multiply_elementwise(b)</span></code></td>
<td>行列の成分ごとの乗算を行う。</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>メソッド <code class="code docutils literal notranslate"><span class="pre">dot</span></code> はベクトル同士だけではなく、サイズさえ合えば行列対ベクトルでもよい。ただし <code class="code docutils literal notranslate"><span class="pre">cross</span></code> のほうは本当にベクトル限定。しかも 3 次元のみ。</li>
<li>メソッド <code class="code docutils literal notranslate"><span class="pre">multiply</span></code> は演算子 <code class="code docutils literal notranslate"><span class="pre">*</span></code> で実装されている。</li>
<li>メソッド <code class="code docutils literal notranslate"><span class="pre">multiply_elementwise</span></code> は関数 <code class="code docutils literal notranslate"><span class="pre">matrix_multiply_elementwise</span></code> で実装されている。</li>
</ul>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id39">ノルム</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>ノルムに関係するメソッドを次に示す。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">norm(ord=None)</span></code></td>
<td>行列またはベクトルのノルムを返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">normalized()</span></code></td>
<td>正規化した行列またはノルムを返す。</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>ノルムはデフォルトでは行列に対しては Frobenius ノルムを、ベクトルに関しては 2-ノルムをそれぞれ返す。</li>
<li>ノルムの種類に関しては help を参照。いつも使うものは揃っている。</li>
<li>メソッド <code class="code docutils literal notranslate"><span class="pre">normalized</span></code> で用いられるノルムはデフォルトのノルム。</li>
</ul>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id40">行列式</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>行列式に関係するメソッドを次に示す。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">det(method='bareis')</span></code></td>
<td>正方行列の行列式を計算する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">det_bareis()</span></code></td>
<td>Baries のアルゴリズムにより行列式を計算する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">det_LU_decomposition()</span></code></td>
<td>LU 分解により行列式を計算する。</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><code class="code docutils literal notranslate"><span class="pre">det</span></code> は結局は残りのふたつか、後述するメソッド <code class="code docutils literal notranslate"><span class="pre">berkowitz_det</span></code> のいずれかである。</li>
<li>Baries のアルゴリズムというのは、Gauss の消去法の拡張版みたいなもので、丸め誤差に強いという性質が期待できる。</li>
<li>LU 分解による行列式の計算は、分解行列の主対角線の成分だけを見ればよいというものだ。後述するメソッド <code class="code docutils literal notranslate"><span class="pre">LUdecomposition</span></code> も参照。</li>
</ul>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id41">余因子</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>余因子に関係するメソッドを次に示す。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="38%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">adjugate(method=&quot;berkowitz&quot;)</span></code></td>
<td>余因子行列を生成する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">cofactor(i,</span> <span class="pre">j,</span> <span class="pre">method=&quot;berkowitz&quot;)</span></code></td>
<td>指定成分の符号調整を施した余因子を計算する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">cofactorMatrix(method=&quot;berkowitz&quot;)</span></code></td>
<td>転置を施していない余因子行列を生成する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">minorEntry(i,</span> <span class="pre">j,</span> <span class="pre">method=&quot;berkowitz&quot;)</span></code></td>
<td>指定成分の符号調整を施していない余因子を計算する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">minorMatrix(i,</span> <span class="pre">j)</span></code></td>
<td>元の行列から指定行と指定列を削った、一回り小さい行列を生成する。</td>
</tr>
</tbody>
</table>
<p>これらのメソッドの実装は線形の依存関係がある。</p>
<p>まずメソッド <code class="code docutils literal notranslate"><span class="pre">adjugate</span></code> は <code class="code docutils literal notranslate"><span class="pre">cofactorMatrix</span></code> の転置行列を返す。その <code class="code docutils literal notranslate"><span class="pre">cofactorMatrix</span></code> は単に <code class="code docutils literal notranslate"><span class="pre">cofactor</span></code> を成分ごとに計算して、その値を成分とする行列を生成する。メソッド <code class="code docutils literal notranslate"><span class="pre">cofactor</span></code> は対応する成分の <code class="code docutils literal notranslate"><span class="pre">minorEntry</span></code> の戻り値に、成分の添字から決まる符号を付けるだけだ。最後にメソッド <code class="code docutils literal notranslate"><span class="pre">minorEntry</span></code> は指定成分の <code class="code docutils literal notranslate"><span class="pre">minorMatrix</span></code> の行列式を単に返す。</p>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id42">対角行列</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>対角行列に関係するメソッドを次に示す。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">diagonalize(...)</span></code></td>
<td>対角化可能な行列を対角化する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">is_diagonal()</span></code></td>
<td>行列が対角行列かどうかを返す。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">is_diagonalizable(...)</span></code></td>
<td>行列が対角化可能かどうかを返す。</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>行列 <code class="code docutils literal notranslate"><span class="pre">M</span></code> に対して <span class="math notranslate nohighlight">\(D = P\inv M P\)</span> とすると、メソッド <code class="code docutils literal notranslate"><span class="pre">diagonalize</span></code> は <code class="code docutils literal notranslate"><span class="pre">(P,</span> <span class="pre">D)</span></code> を返す。</li>
<li>対角化可能性の判定は、各固有値の多重度をチェックすることでなされる。この過程で行列オブジェクトのメンバーデータに中間生成物的なものが残る。これをクリアしたい場合に、キーワード引数 <code class="code docutils literal notranslate"><span class="pre">clear_subproducts=True</span></code> を指定する。</li>
<li>ちなみに対角行列を生成する機能は関数 <code class="code docutils literal notranslate"><span class="pre">diag</span></code> である。</li>
</ul>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id43">分解</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>行列の分解 (decomposition, factorization) に関係するメソッドを次に示す。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">cholesky()</span></code></td>
<td>行列の Cholesky 分解を行う。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">LDLdecomposition()</span></code></td>
<td>行列の LDL 分解を行う。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">LUdecomposition(...)</span></code></td>
<td>行列の LU 分解を行う。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">LUdecomposition_Simple(...)</span></code></td>
<td>行列の LU 分解を単純なアルゴリズムで実装したもの。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">LUdecompositionFF()</span></code></td>
<td>行列の LU 分解を fraction-free なアルゴリズムで実装したもの。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">QRdecomposition()</span></code></td>
<td>行列の QR 分解を行う。</td>
</tr>
</tbody>
</table>
<p>Cholesky 分解は <span class="math notranslate nohighlight">\(A = L L^\top\)</span> なる <code class="code docutils literal notranslate"><span class="pre">L</span></code> を計算する。与える行列が正定値実対象行列である必要がある。</p>
<p>LDL 分解は <span class="math notranslate nohighlight">\(A = L D L^\top\)</span> を満たす行列を計算してペア <code class="code docutils literal notranslate"><span class="pre">(L,</span> <span class="pre">D)</span></code> を返す。</p>
<ul class="simple">
<li>これもまた与える行列が正定値実対象行列である必要がある。</li>
<li>行列 <code class="code docutils literal notranslate"><span class="pre">L</span></code> は下三角行列であり、対角成分はすべて 1 である。</li>
<li>行列 <code class="code docutils literal notranslate"><span class="pre">D</span></code> は対角行列である。</li>
</ul>
<p>LU 分解は <span class="math notranslate nohighlight">\(A = LU\)</span> というものだ。</p>
<ul class="simple">
<li><code class="code docutils literal notranslate"><span class="pre">LUdecomposition</span></code> の戻り値は <code class="code docutils literal notranslate"><span class="pre">(L,</span> <span class="pre">U,</span> <span class="pre">p)</span></code> の形である。ここで <code class="code docutils literal notranslate"><span class="pre">p</span></code> は行の交換情報を表現する list である。なぜ行列ではなくリストの形式を返すのかがよくわからない。</li>
<li><code class="code docutils literal notranslate"><span class="pre">LUdecomposition_Simple</span></code> の戻り値は <code class="code docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">p)</span></code> の形である。ただし <code class="code docutils literal notranslate"><span class="pre">A</span></code> は <code class="code docutils literal notranslate"><span class="pre">L</span></code> と <code class="code docutils literal notranslate"><span class="pre">U</span></code> の合いの子のような行列だ。</li>
<li><code class="code docutils literal notranslate"><span class="pre">LUdecompositionFF</span></code> は <span class="math notranslate nohighlight">\(PA = L D\inv U\)</span> を満たす行列の組
<code class="code docutils literal notranslate"><span class="pre">(P,</span> <span class="pre">L,</span> <span class="pre">D,</span> <span class="pre">U)</span></code> を返す。特徴は元の行列がある整域上のものであるとき、
<code class="code docutils literal notranslate"><span class="pre">L</span></code>, <code class="code docutils literal notranslate"><span class="pre">D</span></code>, <code class="code docutils literal notranslate"><span class="pre">U</span></code> のいずれも同じ整域に属するというものだ。</li>
<li>QR 分解は行列を <span class="math notranslate nohighlight">\(A = QR\)</span> の形に分解するアルゴリズムだ。行列 <code class="code docutils literal notranslate"><span class="pre">Q</span></code> は直交行列で、行列 <code class="code docutils literal notranslate"><span class="pre">R</span></code> は上三角行列となる。</li>
</ul>
</div>
<div class="section" id="id18">
<h3><a class="toc-backref" href="#id44">ソルバー</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>線形連立方程式を解くことに関係するメソッドを次に示す。基本的には <span class="math notranslate nohighlight">\(A \mathbf{x} = \mathbf{b}\)</span> に対して、</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(A\)</span> が行列オブジェクト自身、</li>
<li><span class="math notranslate nohighlight">\(\mathbf{x}\)</span> が各メソッドの戻り値（の一部）、</li>
<li><span class="math notranslate nohighlight">\(\mathbf{b}\)</span> が各メソッドの最初の引数</li>
</ul>
<p>に相当する。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">cholesky_solve(rhs)</span></code></td>
<td>Cholesky 分解によるソルバー。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">diagonal_solve(rhs)</span></code></td>
<td>対角行列を係数とする方程式を解く。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">gauss_jordan_solve(b,</span> <span class="pre">freevar=False)</span></code></td>
<td>Gauss-Jordan 消去法によるソルバー。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">LDLsolve(rhs)</span></code></td>
<td>LDL 分解によるソルバー。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">LUsolve(rhs,</span> <span class="pre">...)</span></code></td>
<td>LU 分解によるソルバー。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">QRsolve(b)</span></code></td>
<td>QR 分解によるソルバー。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">pinv_solve(B,</span> <span class="pre">arbitrary_matrix=None)</span></code></td>
<td>Moore-Penrose の擬逆行列によるソルバー。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">lower_triangular_solve(rhs)</span></code></td>
<td>下三角行列を係数とする方程式を解く。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">upper_triangular_solve(rhs)</span></code></td>
<td>上三角行列を係数とする方程式を解く。</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><code class="code docutils literal notranslate"><span class="pre">cholesky_solve</span></code>,  <code class="code docutils literal notranslate"><span class="pre">LDLsolve</span></code> は係数（自身の行列）が対称行列であるか、行数が列数よりも大きい行列であればなんとか動く。</li>
<li><code class="code docutils literal notranslate"><span class="pre">diagonal_solve</span></code> は対角成分にゼロがあってはならない（解を得るときの除算の分母だから）。</li>
<li><code class="code docutils literal notranslate"><span class="pre">gauss_jordan_solve</span></code> は連立方程式の条件が不足して解が不定個求まる場合に適宜パラメーターを導入する。解の行列に加えて、このパラメーターを別途行列にまとめて同時に返す。</li>
<li><code class="code docutils literal notranslate"><span class="pre">LUsolve</span></code> の利用する分解メソッドは <code class="code docutils literal notranslate"><span class="pre">LUdecomposition_Simple</span></code> である。その後に前進代入と後退代入を行って解となる行列を返す。<ul>
<li>対称行列向け。</li>
</ul>
</li>
<li><code class="code docutils literal notranslate"><span class="pre">QRsolve</span></code> は <code class="code docutils literal notranslate"><span class="pre">QRdecomposition</span></code> の結果から後退代入だけで解が得られる。<ul>
<li>これは教育目的かつシンボル含みの行列用のメソッドとのこと。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id19">
<h3><a class="toc-backref" href="#id45">逆行列</a><a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>逆行列に関係するメソッドを次に示す。数値計算の観点から言えば、逆行列の計算は相当なコストがかかるため、なるべく避けるのが原則だ。可能な限り先述した分解アルゴリズムやソルバーを利用するのが普通だ。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="38%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">inv(method=None,</span> <span class="pre">**kwargs)</span></code></td>
<td>逆行列を計算する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">inv_mod(m)</span></code></td>
<td>法を <code class="code docutils literal notranslate"><span class="pre">m</span></code> とするときの逆行列を計算する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">pinv()</span></code></td>
<td>Moore-Penrose の擬逆行列を計算する。</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><code class="code docutils literal notranslate"><span class="pre">inv</span></code> ではキーワード引数 <code class="code docutils literal notranslate"><span class="pre">method</span></code> で行列式を計算するアルゴリズムを選択できる。<ul>
<li><code class="docutils literal notranslate"><span class="pre">'GE'</span></code>: Gauss の消去法。デフォルトのアルゴリズム。</li>
<li><code class="docutils literal notranslate"><span class="pre">'LU'</span></code>: LU 分解。</li>
<li><code class="docutils literal notranslate"><span class="pre">'ADJ'</span></code>: 余因子行列と行列式を用いて逆行列を得る。</li>
</ul>
</li>
<li>面白いのは <code class="code docutils literal notranslate"><span class="pre">inv_mod</span></code> だろう。整数論的処理が一部入っていて、オイラー関数、余因子行列、行列式を組み合わせて所望の行列を生成する。</li>
</ul>
</div>
<div class="section" id="berkowitz">
<h3><a class="toc-backref" href="#id46">Berkowitz のアルゴリズム</a><a class="headerlink" href="#berkowitz" title="Permalink to this headline">¶</a></h3>
<p>Berkowitz のアルゴリズムと、それに関係するメソッドを次に示す。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">berkowitz()</span></code></td>
<td>Berkowitz のアルゴリズムを実装する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">berkowitz_det()</span></code></td>
<td>Berkowitz のアルゴリズムにより行列式を計算する。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">berkowitz_minors()</span></code></td>
<td>Berkowitz のアルゴリズムにより主小行列を計算する。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">berkowitz_charpoly(x,</span> <span class="pre">simplify)</span></code></td>
<td>Berkowitz のアルゴリズムにより特性多項式を求める。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">berkowitz_eigenvals(**flags)</span></code></td>
<td>Berkowitz のアルゴリズムにより固有値を計算する。</td>
</tr>
</tbody>
</table>
<p>まずメソッド <code class="code docutils literal notranslate"><span class="pre">berkowitz</span></code> の中身について。
<a class="reference external" href="https://de.wikipedia.org/wiki/Algorithmus_von_Samuelson-Berkowitz">この記事</a> のアルゴリズムを実装している。</p>
<p>Berkowitz のアルゴリズムを単純に説明すると、正方行列の対角線に沿って、サイズの小さい順にミニ正方行列を取る。各ミニ正方行列の特性多項式を求めていくのだが、あるステップのミニ正方行列の特性多項式を得るのに、その直前に求めたサイズが一回り小さいミニ正方行列の計算結果を利用できるというものだ。</p>
<p>固有多項式がわければ行列式、行列因子、固有値等が芋づる式にわかるので、クラス MatrixBase のメソッドの大部分がこのアルゴリズムに頼っている。</p>
</div>
<div class="section" id="id21">
<h3><a class="toc-backref" href="#id47">特異値</a><a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>特異値に関するメソッドを記す。固有値に関するメソッドも参照。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">condition_number()</span></code></td>
<td>行列の条件数、つまり最大特異値と最小特異値の比を返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">singular_values()</span></code></td>
<td>行列の特異値をすべて返す。</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><code class="code docutils literal notranslate"><span class="pre">singular_values</span></code> はすべての特異値を list に詰めて返す。これらの値が大きい順にソートされている。</li>
</ul>
</div>
<div class="section" id="id22">
<h3><a class="toc-backref" href="#id48">微積分</a><a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>微積分に関するメソッドを次の表に記す。実装はすべて想像通りになっている。</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">シグニチャー</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">diff(*args)</span></code></td>
<td>各成分を微分して得られる行列を返す。</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">integrate(*args)</span></code></td>
<td>各成分を積分して得られる行列を返す。</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">limit(*args)</span></code></td>
<td>各成分に対して極限をとった行列を返す。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="numpy">
<h2><a class="toc-backref" href="#id49">NumPy インターフェイス</a><a class="headerlink" href="#numpy" title="Permalink to this headline">¶</a></h2>
<p>モジュール <code class="docutils literal notranslate"><span class="pre">sympy.matrices.dense</span></code> には SymPy の行列オブジェクトを
NumPy の <code class="code docutils literal notranslate"><span class="pre">numpy.array</span></code> オブジェクトにコンバートするための関数が少々ある。</p>
<dl class="docutils">
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">list2numpy(l,</span> <span class="pre">dtype=object)</span></code></dt>
<dd><p class="first">Python の list オブジェクトを <code class="code docutils literal notranslate"><span class="pre">numpy.array</span></code> オブジェクトにコンバートする。</p>
<ul class="last simple">
<li>実は SymPy は関係ない。</li>
<li>キーワード引数 <code class="code docutils literal notranslate"><span class="pre">dtype=object</span></code> が存在するということは、リストの要素の型を完全に無視できることを示唆している。</li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">matrix2numpy(m,</span> <span class="pre">dtype=object)</span></code></dt>
<dd><p class="first">SymPy の行列オブジェクトを <code class="code docutils literal notranslate"><span class="pre">numpy.array</span></code> オブジェクトにコンバートする。</p>
<ul class="last simple">
<li>実装を説明すると、この関数はまず行列のサイズ <code class="code docutils literal notranslate"><span class="pre">m.shape</span></code> と同じサイズの空の <code class="code docutils literal notranslate"><span class="pre">numpy.array</span></code> を生成する。次に <code class="code docutils literal notranslate"><span class="pre">m</span></code> の各要素を対応する成分にセットして戻すというものだ。</li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">symarray(prefix,</span> <span class="pre">shape)</span></code></dt>
<dd><p class="first">説明するよりも動きを示したほうが早い。</p>
<div class="code ipython highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">symarray</span><span class="p">(</span><span class="s1">&#39;ppppp&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">array</span><span class="p">([[</span><span class="n">ppppp_0_0</span><span class="p">,</span> <span class="n">ppppp_0_1</span><span class="p">,</span> <span class="n">ppppp_0_2</span><span class="p">],</span>
               <span class="p">[</span><span class="n">ppppp_1_0</span><span class="p">,</span> <span class="n">ppppp_1_1</span><span class="p">,</span> <span class="n">ppppp_1_2</span><span class="p">],</span>
               <span class="p">[</span><span class="n">ppppp_2_0</span><span class="p">,</span> <span class="n">ppppp_2_1</span><span class="p">,</span> <span class="n">ppppp_2_2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
</pre></div>
</div>
<ul class="last simple">
<li>実際の戻り値は <code class="code docutils literal notranslate"><span class="pre">numpy.array</span></code> オブジェクト。</li>
<li>行列の各要素は SymPy の Symbol オブジェクト。オブジェクトの <code class="code docutils literal notranslate"><span class="pre">name</span></code> が出力に表れている。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id23">
<h2><a class="toc-backref" href="#id50">演習</a><a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id24">
<h3><a class="toc-backref" href="#id51">Berkowitz のアルゴリズムを検証する</a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>シンボルベースの 3 次正方行列を定義して、メソッド <code class="code docutils literal notranslate"><span class="pre">berkowitz</span></code> を呼び出して戻り値を得る。この戻り値から行列のさまざまな属性が得られることを見よう。</p>
<div class="code ipython highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a:3:3&#39;</span><span class="p">));</span> <span class="n">M</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="n">Matrix</span><span class="p">([[</span><span class="n">a00</span><span class="p">,</span> <span class="n">a01</span><span class="p">,</span> <span class="n">a02</span><span class="p">],</span>
        <span class="p">[</span><span class="n">a10</span><span class="p">,</span> <span class="n">a11</span><span class="p">,</span> <span class="n">a12</span><span class="p">],</span>
        <span class="p">[</span><span class="n">a20</span><span class="p">,</span> <span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">]])</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">Mberk</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">berkowitz</span><span class="p">();</span> <span class="n">Mberk</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="p">((</span><span class="mi">1</span><span class="p">,),</span>
         <span class="p">(</span><span class="mi">1</span><span class="p">,</span>
          <span class="o">-</span><span class="n">a00</span><span class="p">),</span>
         <span class="p">(</span><span class="mi">1</span><span class="p">,</span>
          <span class="o">-</span><span class="n">a00</span> <span class="o">-</span> <span class="n">a11</span><span class="p">,</span>
          <span class="n">a00</span><span class="o">*</span><span class="n">a11</span> <span class="o">-</span> <span class="n">a01</span><span class="o">*</span><span class="n">a10</span><span class="p">),</span>
         <span class="p">(</span><span class="mi">1</span><span class="p">,</span>
          <span class="o">-</span><span class="n">a00</span> <span class="o">-</span> <span class="n">a11</span> <span class="o">-</span> <span class="n">a22</span><span class="p">,</span>
          <span class="n">a00</span><span class="o">*</span><span class="n">a11</span> <span class="o">-</span> <span class="n">a01</span><span class="o">*</span><span class="n">a10</span> <span class="o">-</span> <span class="n">a02</span><span class="o">*</span><span class="n">a20</span> <span class="o">-</span> <span class="n">a12</span><span class="o">*</span><span class="n">a21</span> <span class="o">-</span> <span class="n">a22</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">a00</span> <span class="o">-</span> <span class="n">a11</span><span class="p">),</span>
          <span class="o">-</span><span class="n">a20</span><span class="o">*</span><span class="p">(</span><span class="n">a00</span><span class="o">*</span><span class="n">a02</span> <span class="o">+</span> <span class="n">a01</span><span class="o">*</span><span class="n">a12</span><span class="p">)</span> <span class="o">-</span> <span class="n">a21</span><span class="o">*</span><span class="p">(</span><span class="n">a02</span><span class="o">*</span><span class="n">a10</span> <span class="o">+</span> <span class="n">a11</span><span class="o">*</span><span class="n">a12</span><span class="p">)</span> <span class="o">-</span> <span class="n">a22</span><span class="o">*</span><span class="p">(</span><span class="n">a00</span><span class="o">*</span><span class="n">a11</span> <span class="o">-</span> <span class="n">a01</span><span class="o">*</span><span class="n">a10</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">a00</span> <span class="o">-</span> <span class="n">a11</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">a02</span><span class="o">*</span><span class="n">a20</span> <span class="o">-</span> <span class="n">a12</span><span class="o">*</span><span class="n">a21</span><span class="p">)))</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">Mcharpoly</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">charpoly</span><span class="p">()</span><span class="o">.</span><span class="n">coeffs</span><span class="p">();</span> <span class="n">Mcharpoly</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
         <span class="o">-</span><span class="n">a00</span> <span class="o">-</span> <span class="n">a11</span> <span class="o">-</span> <span class="n">a22</span><span class="p">,</span>
         <span class="n">a00</span><span class="o">*</span><span class="n">a11</span> <span class="o">+</span> <span class="n">a00</span><span class="o">*</span><span class="n">a22</span> <span class="o">-</span> <span class="n">a01</span><span class="o">*</span><span class="n">a10</span> <span class="o">-</span> <span class="n">a02</span><span class="o">*</span><span class="n">a20</span> <span class="o">+</span> <span class="n">a11</span><span class="o">*</span><span class="n">a22</span><span class="o">-</span> <span class="n">a12</span><span class="o">*</span><span class="n">a21</span><span class="p">,</span>
         <span class="o">-</span><span class="n">a00</span><span class="o">*</span><span class="n">a11</span><span class="o">*</span><span class="n">a22</span> <span class="o">+</span> <span class="n">a00</span><span class="o">*</span><span class="n">a12</span><span class="o">*</span><span class="n">a21</span> <span class="o">+</span> <span class="n">a01</span><span class="o">*</span><span class="n">a10</span><span class="o">*</span><span class="n">a22</span> <span class="o">-</span> <span class="n">a01</span><span class="o">*</span><span class="n">a12</span><span class="o">*</span><span class="n">a20</span> <span class="o">-</span> <span class="n">a02</span><span class="o">*</span><span class="n">a10</span><span class="o">*</span><span class="n">a21</span><span class="o">+</span> <span class="n">a02</span><span class="o">*</span><span class="n">a11</span><span class="o">*</span><span class="n">a20</span><span class="p">]</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="nb">all</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Mcharpoly</span><span class="p">,</span> <span class="n">Mberk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="kc">True</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">simplify</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">cofactor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">Mberk</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="mi">0</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">simplify</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">det</span><span class="p">()</span> <span class="o">+</span> <span class="n">Mberk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="mi">0</span>
</pre></div>
</div>
<ul>
<li><p class="first">[1] 全成分を記号とする 3 次正方行列 <code class="code docutils literal notranslate"><span class="pre">M</span></code> を定義する。</p>
</li>
<li><p class="first">[2] メソッド <code class="code docutils literal notranslate"><span class="pre">berkowitz</span></code> の戻り値を確認する。</p>
</li>
<li><p class="first">[3][4] <code class="code docutils literal notranslate"><span class="pre">M</span></code> の特性多項式の係数を出力する。これは 4 次多項式の係数を降べきの順に並べた list オブジェクトとして得られる。</p>
<p>次にこの係数と <code class="code docutils literal notranslate"><span class="pre">berkowitz</span></code> の戻り値の tuple オブジェクトの末尾の要素とを比較して、両者が一致することを見る。</p>
</li>
<li><p class="first">[5] <code class="code docutils literal notranslate"><span class="pre">M</span></code> の対角成分末端（行列の右下）要素の余因子は
<code class="code docutils literal notranslate"><span class="pre">berkowitz</span></code> の戻り値の 2 ステップ目 <code class="code docutils literal notranslate"><span class="pre">Mberk[2]</span></code> の末尾の要素に等しい。これは同ステップのミニ正方行列の行列式でもある。</p>
</li>
<li><p class="first">[6] <code class="code docutils literal notranslate"><span class="pre">M</span></code> の行列式は <code class="code docutils literal notranslate"><span class="pre">berkowitz</span></code> の戻り値の末尾の末尾に符号を考慮したものである。符号の決まり方は、特性多項式の次数の偶奇性による。</p>
</li>
</ul>
<p>最後に固有値が特性多項式の解であることを見せて締めたいところだが、紙幅の都合上、どうしても長い数式をきれいに表示できないため、割愛する。</p>
</div>
<div class="section" id="lu">
<h3><a class="toc-backref" href="#id52">LU 分解再挑戦</a><a class="headerlink" href="#lu" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../python-scipy/linear-equations.html"><span class="doc">線形方程式を解く</span></a> で LU 分解した行列を SymPy で分解すると結果が異なるのではないか。</p>
<div class="code ipython highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUdecomposition</span><span class="p">()</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">L</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">U</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">p</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="p">[]</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">L</span> <span class="o">*</span> <span class="n">U</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
</pre></div>
</div>
<ul class="simple">
<li>[2][3] 期待しているようなきれいな三角行列が得られている。</li>
<li>[4] 行の入れ替えはない。</li>
</ul>
</div>
</div>
<div class="section" id="id25">
<h2><a class="toc-backref" href="#id53">関連ノート</a><a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><a class="reference internal" href="../python-numpy/tutorial.html"><span class="doc">Tentative NumPy Tutorial ノート</span></a></dt>
<dd>NumPy の array と SymPy の MatrixBase には共通する機能が多数ある。</dd>
<dt><a class="reference internal" href="../python-scipy/linear-equations.html"><span class="doc">線形方程式を解く</span></a></dt>
<dd>SciPy の機能で LU 分解をする例を記した。</dd>
</dl>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="polynomials.html" title="多項式"
             >next</a></li>
        <li class="right" >
          <a href="vector.html" title="ベクトル"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">読書ノート</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >SymPy 利用ノート</a> &#187;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2018, プレハブ小屋 All rights reserved.
      </div>
    </div>
  </body>
</html>