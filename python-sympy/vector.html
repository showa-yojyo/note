
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ベクトル &#8212; 読書ノート 1.5dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script async="async" src="../_static/mathjax-v3.js"></script>
    <script src="../_static/mermaid.js"></script>
    <link rel="next" title="行列" href="matrices.html" />
    <link rel="prev" title="組合せ論と群論" href="combinatorics.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="combinatorics.html" title="Previous document">組合せ論と群論</a>
        </li>
        <li>
          <a href="matrices.html" title="Next document">行列</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id20">ベクトル</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>モジュール <code class="docutils literal notranslate"><span class="pre">sympy.vector</span></code> に関するメモを記す。ベクトル解析寄りの機能が目立つという印象を受ける。もっと言うと 3 次元空間用の座標系だけを利用の対象と想定している節がある。</p>
<div class="contents topic" id="id2">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id20">ベクトル</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id21">基本編</a></p>
<ul>
<li><p><a class="reference internal" href="#id4" id="id22">座標系およびベクトル</a></p></li>
<li><p><a class="reference internal" href="#sympy" id="id23">ベクトルに対する SymPy 演算</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id24">点</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id25">二項テンソル</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id7" id="id26">複数座標系</a></p>
<ul>
<li><p><a class="reference internal" href="#id8" id="id27">並進のみによる指定</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id28">回転のみによる指定</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id29">並進と回転による指定</a></p></li>
<li><p><a class="reference internal" href="#express" id="id30">関数 <code class="code docutils literal notranslate"><span class="pre">express</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id11" id="id31">スカラー場とベクトル場</a></p>
<ul>
<li><p><a class="reference internal" href="#id12" id="id32">ナブラ</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id33">回転</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id34">発散</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id35">勾配</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id36">方向微分</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id37">ポテンシャル</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id18" id="id38">演習</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>紙幅の都合上、出力を一部手で改行した。</p>
<p>本文中のすべての IPython セッション中のサンプルコードで、以下の出力書式設定が済んでいるものとする。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">init_printing</span><span class="p">(</span><span class="n">pretty_print</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id21">基本編</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id22">座標系およびベクトル</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>座標系としては現在は 3 次元直交座標系を表現するクラス CoordSysCartesian だけがある。</p></li>
<li><p>オブジェクトの生成はコンストラクターでの直接生成でよい。その際には簡単な名前をつける。</p></li>
</ul>
<p>以下 <code class="code docutils literal notranslate"><span class="pre">N</span></code> をクラス CoordSysCartesian のオブジェクトとする。</p>
<ul class="simple">
<li><p>座標系の基底ベクトルに次の方法でアクセスできる。</p>
<ul>
<li><p>プロパティー <code class="code docutils literal notranslate"><span class="pre">N.i</span></code>, <code class="code docutils literal notranslate"><span class="pre">N.j</span></code>, <code class="code docutils literal notranslate"><span class="pre">N.k</span></code></p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">N.base_vectors</span></code></p></li>
</ul>
</li>
<li><p>一応記すが、各基底ベクトルは対応する座標軸に沿う長さ 1 のものである。正規直交基底。</p></li>
<li><p>基底ベクトルはクラス BaseVector のオブジェクトである。これの「線形結合」を表現しようとすると、SymPy 的には
BaseVector, VectorAdd, VectorMul オブジェクトの composite になる。</p></li>
<li><p>名前が紛らわしいので要注意だが、これらのベクトル関連クラスの基底クラスが Vector である。</p></li>
<li><p>零ベクトルは <code class="code docutils literal notranslate"><span class="pre">Vector.zero</span></code> オブジェクトで表現されている。</p></li>
</ul>
<p>以下 <code class="code docutils literal notranslate"><span class="pre">u</span></code> および <code class="code docutils literal notranslate"><span class="pre">v</span></code> をベクトルオブジェクトとする。</p>
<ul class="simple">
<li><p>ベクトルのドット積 <span class="math notranslate nohighlight">\(\mathbf{u} \cdot \mathbf{v}\)</span> は次のどちらかで表現する。</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">u.dot(v)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">u</span> <span class="pre">&amp;</span> <span class="pre">v</span></code></p></li>
</ul>
</li>
<li><p>ベクトルのクロス積 <span class="math notranslate nohighlight">\(\mathbf{u} \times \mathbf{v}\)</span> は次のどちらかで表現する。</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">u.cross(v)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">u</span> <span class="pre">^</span> <span class="pre">v</span></code></p></li>
</ul>
</li>
</ul>
<p>オブジェクト指向プログラミング言語のコードでベクトルをクラスとして表現することはしばしばある。演算子オーバーロードをサポートする言語では、このふたつの積を計算する処理を演算子として実装することが多い。その時は常にプログラマーは演算子の優先順位に注意することになる。</p>
<ul class="simple">
<li><p>ベクトルの長さはメソッド <code class="code docutils literal notranslate"><span class="pre">magnitude()</span></code> を用いる。</p></li>
<li><p>ベクトルの長さを単位化するメソッドは <code class="code docutils literal notranslate"><span class="pre">normalize()</span></code> である。新しいベクトルを返し、自分自身は変わらない。</p></li>
<li><p>ベクトルの成分はプロパティー <code class="code docutils literal notranslate"><span class="pre">components</span></code> で確認できる。ただし型が dict で使い勝手に疑問点がある。キーが BaseVector オブジェクトで、値が係数すなわち成分である。こういう設計になっている理由は、「関連のない別々の座標系からとってきたベクトルの和」のようなオブジェクトが許されることから来るものと思う。</p></li>
</ul>
</div>
<div class="section" id="sympy">
<h3><a class="toc-backref" href="#id23">ベクトルに対する SymPy 演算</a><a class="headerlink" href="#sympy" title="Permalink to this heading">¶</a></h3>
<p>Vector オブジェクトに対して、次の関数およびクラスによる SymPy 演算を適用することができる。ベクトルの各要素ごと、つまり各基底ベクトルの係数に演算がそれぞれ作用する。</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">simplify</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">trigsimp</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">factor</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">diff</span></code>, Derivative</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">integrate</span></code>, Integral</p></li>
</ul>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id24">点</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>ある座標系に点を生成することができるのだが、少し特徴的な方法による。</p>
<ul class="simple">
<li><p>プロパティー <code class="code docutils literal notranslate"><span class="pre">origin</span></code> が座標系原点を表現する。すなわち <code class="code docutils literal notranslate"><span class="pre">N.origin</span></code> は座標系 <code class="code docutils literal notranslate"><span class="pre">N</span></code> の原点を意味する。このオブジェクトの型がクラス Point である。</p></li>
<li><p>新しく点を生成するには、この原点なり既存の点なりのメソッド <code class="code docutils literal notranslate"><span class="pre">locate_new</span></code> を用いる。引数にはその点から生成したい点への変位をベクトルで指定する。</p></li>
</ul>
<p>以下 <code class="code docutils literal notranslate"><span class="pre">P</span></code>, <code class="code docutils literal notranslate"><span class="pre">Q</span></code> をクラス Point のオブジェクトとする。</p>
<ul class="simple">
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">position_wrt</span></code> を用いて位置ベクトルを得られる。点 <code class="code docutils literal notranslate"><span class="pre">P</span></code> の <code class="code docutils literal notranslate"><span class="pre">Q</span></code> に対する位置ベクトルは <code class="code docutils literal notranslate"><span class="pre">P.position_wrt(Q)</span></code> である。</p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">express_coordinates</span></code> により、点の座標を得られる。引数は座標系を指定する。</p></li>
</ul>
<p>設計は常識的なのだが、実際使うときにはクセがあるように感じられる。点を生成するのも、その位置を確認するのも、基本的な操作のはずなのだが、その割には手間がかかる。</p>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id25">二項テンソル</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<p>ベクトル同士の二項テンソルをオブジェクトとして表現するクラス Dyadic がある。</p>
<ul>
<li><p>オブジェクトをコンストラクターで直接生成することはまれであり、通常は Vector のメソッド <code class="code docutils literal notranslate"><span class="pre">outer</span></code> もしくは演算子 <code class="code docutils literal notranslate"><span class="pre">|</span></code> により生成する。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="o">*</span>

<span class="gp">In [2]: </span><span class="n">N</span> <span class="o">=</span> <span class="n">CoordSysCartesian</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">a</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a0:3&#39;</span><span class="p">),</span> <span class="n">N</span><span class="o">.</span><span class="n">base_vectors</span><span class="p">())),</span> <span class="n">Vector</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">b</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;b0:3&#39;</span><span class="p">),</span> <span class="n">N</span><span class="o">.</span><span class="n">base_vectors</span><span class="p">())),</span> <span class="n">Vector</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="c1"># i.e. a.outer(b)</span>
<span class="gh">Out[5]: </span><span class="go">a0*b0*(N.i|N.i) + a0*b1*(N.i|N.j) + a0*b2*(N.i|N.k)</span>
<span class="go">      + a1*b0*(N.j|N.i) + a1*b1*(N.j|N.j) + a1*b2*(N.j|N.k)</span>
<span class="go">      + a2*b0*(N.k|N.i) + a2*b1*(N.k|N.j) + a2*b2*(N.k|N.k)</span>
</pre></div>
</div>
</li>
<li><p>Dyadic の関連クラスは Vector のそれと酷似している。すなわち BaseDyadic, DyadicAdd, DyadicMul, etc. である。</p></li>
<li><p>零元はオブジェクト <code class="code docutils literal notranslate"><span class="pre">Dyaric.zero</span></code> で表現している。</p></li>
<li><p>ベクトルのスカラー積、クロス積とも混ぜて利用可能。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">c</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;c0:3&#39;</span><span class="p">),</span> <span class="n">N</span><span class="o">.</span><span class="n">base_vectors</span><span class="p">())),</span> <span class="n">Vector</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span>

<span class="gp">In [7]: </span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="gh">Out[7]: </span><span class="go">(a0*b0*c0 + a1*b1*c0 + a2*b2*c0)*N.i</span>
<span class="go">      + (a0*b0*c1 + a1*b1*c1 + a2*b2*c1)*N.j</span>
<span class="go">      + (a0*b0*c2 + a1*b1*c2 + a2*b2*c2)*N.k</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id26">複数座標系</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>既存の座標系オブジェクト <code class="code docutils literal notranslate"><span class="pre">N</span></code> から、新たに別の座標系オブジェクト <code class="code docutils literal notranslate"><span class="pre">M</span></code> を生成することができる。モデリングソフト等でお馴染みの方法論でもある。</p>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id27">並進のみによる指定</a><a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>メソッド <code class="code docutils literal notranslate"><span class="pre">locate_new(name,</span> <span class="pre">position,</span> <span class="pre">vector_names=None,</span> <span class="pre">variable_names=None)</span></code></dt><dd><p>新しく CoordSysCartesian オブジェクトを生成できる。</p>
<ul class="simple">
<li><p>引数 <code class="code docutils literal notranslate"><span class="pre">name</span></code> は座標系の名前を指定する。主にデバッグ作業用？</p></li>
<li><p>引数 <code class="code docutils literal notranslate"><span class="pre">position</span></code> にはその点から生成したい点への変位をベクトルで指定する。</p></li>
<li><p>残りのキーワード引数は <code class="code docutils literal notranslate"><span class="pre">base_vectors</span></code> と <code class="code docutils literal notranslate"><span class="pre">base_scalars</span></code> の名前のためのもの。</p></li>
</ul>
</dd>
</dl>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">N</span></code> に対する <code class="code docutils literal notranslate"><span class="pre">M</span></code> の変位を得るには、次のどちらかを行う。</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">M.position_wrt(N)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">M.origin.express_coordinates(N)</span></code></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id28">回転のみによる指定</a><a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h3>
<p>次は新たな座標系に回転（だけ）を施す。</p>
<dl class="simple">
<dt>メソッド <code class="code docutils literal notranslate"><span class="pre">orient_new_axis(name,</span> <span class="pre">angle,</span> <span class="pre">axis,</span> <span class="pre">location=None,</span> <span class="pre">vector_names=None,</span> <span class="pre">variable_names=None)</span></code></dt><dd><p>座標系 <code class="code docutils literal notranslate"><span class="pre">M</span></code> に対してベクトル <code class="code docutils literal notranslate"><span class="pre">axis</span></code> 周りに角度 <code class="code docutils literal notranslate"><span class="pre">angle</span></code> だけ回転して得られる座標系 <code class="code docutils literal notranslate"><span class="pre">N</span></code> を生成する。</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">axis</span></code> に関しては細かい条件が不明。零ベクトルだとアウトなことは想像できる。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">location</span></code> にベクトルを指定すると、回転プラス並進となるが、後述。</p></li>
</ul>
</dd>
</dl>
<p>その他にも次のようなメソッドにより、新しい座標系を生成できる。</p>
<dl>
<dt>メソッド <code class="code docutils literal notranslate"><span class="pre">orient_new_body(name,</span> <span class="pre">angle1,</span> <span class="pre">angle2,</span> <span class="pre">angle3,</span> <span class="pre">rotation_order,</span> <span class="pre">...)</span></code></dt><dd><p>座標系を 3 回の座標軸周りの回転により生成する。</p>
<ul class="simple">
<li><p>引数 <code class="code docutils literal notranslate"><span class="pre">angle1</span></code>, <code class="code docutils literal notranslate"><span class="pre">angle2</span></code>, <code class="code docutils literal notranslate"><span class="pre">angle3</span></code> が各座標軸に関する回転角を表す。</p></li>
<li><p>引数 <code class="code docutils literal notranslate"><span class="pre">rotation_order</span></code> が回転を施す座標軸の順序を示す文字列。例えば x, z, y 軸の順に回転する場合は <code class="docutils literal notranslate"><span class="pre">'132'</span></code> または <code class="docutils literal notranslate"><span class="pre">'XZY'</span></code> を指定する。</p></li>
<li><p>回転軸が新座標系のそれを基準とすることに注意。最初の回転は新旧一致しているが、次の回転は前の回転の影響を受けている。</p></li>
</ul>
</dd>
<dt>メソッド <code class="code docutils literal notranslate"><span class="pre">orient_new_space(name,</span> <span class="pre">angle1,</span> <span class="pre">angle2,</span> <span class="pre">angle3,</span> <span class="pre">rotation_order,</span> <span class="pre">...)</span></code></dt><dd><p>上のものと似ているが、回転の基準が 3 回転とも <code class="code docutils literal notranslate"><span class="pre">M</span></code> の座標軸に沿う。</p>
</dd>
<dt>メソッド <code class="code docutils literal notranslate"><span class="pre">orient_new_quaternion(name,</span> <span class="pre">q0,</span> <span class="pre">q1,</span> <span class="pre">q2,</span> <span class="pre">q3,</span> <span class="pre">...)</span></code></dt><dd><p>Hamilton の四元数による回転を与えて新たな座標系を生成する。</p>
<p>単位ベクトル <span class="math notranslate nohighlight">\((n_x, n_y, n_z)\)</span> の周りに角度 <span class="math notranslate nohighlight">\(\theta\)</span> だけの回転を表す四元数は</p>
<div class="math notranslate nohighlight">
\begin{align*}
\left(\cos \frac{\theta}{2},\
      n_x\!\sin \frac{\theta}{2},\
      n_y\!\sin \frac{\theta}{2},\
      n_z\!\sin \frac{\theta}{2}\right)
\end{align*}</div><p>となる。この各成分を <code class="code docutils literal notranslate"><span class="pre">q0</span></code> から <code class="code docutils literal notranslate"><span class="pre">q3</span></code> までこの順序で指定する。</p>
</dd>
</dl>
<p>より一般的には、メソッド <code class="code docutils literal notranslate"><span class="pre">orient_new</span></code> および以下のクラスのオブジェクトを用いる。</p>
<ul class="simple">
<li><p>AxisOrienter</p></li>
<li><p>BodyOrienter</p></li>
<li><p>SpaceOrienter</p></li>
<li><p>QuaternionOrienter</p></li>
</ul>
<p>生成手順は <code class="code docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">N.orient_new(name,</span> <span class="pre">(orienter1,</span> <span class="pre">orienter2,</span> <span class="pre">...))</span></code> である。</p>
<ul>
<li><p>以上の 4 つの座標変換について、新旧座標系の原点は一致している。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">N.rotation_matrix(M)</span></code> にて、回転変換を表現する 3 次正則行列を得られる。すべての上記 4 つの座標変換について、行列式の絶対値が 1 になると思われる。</p>
<p>ここでは控えめに絶対値と言ったが、座標系の向きがどの変換でも右手系（オリジナルの向き）を保つならば真に 1 になる。現在確認中。</p>
</li>
</ul>
</div>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id29">並進と回転による指定</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<p>最後に並進と回転を組み合わせる方法を記す。</p>
<ul class="simple">
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">orient_new</span></code> およびその仲間たちには、キーワード引数 <code class="code docutils literal notranslate"><span class="pre">locate</span></code> が指定できる。これを用いて変位量をベクトルで与えれば、新しい座標系は、原点の周りに指定の回転を施された後、指定の変位だけ移動したものになる。</p></li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">express</span></code> を用いて、一方の座標系の座標を他方の座標系のそれで表現できる。呼び出し形式は <code class="code docutils literal notranslate"><span class="pre">express(point,</span> <span class="pre">coord_sys)</span></code> である。</p></li>
</ul>
</div>
<div class="section" id="express">
<h3><a class="toc-backref" href="#id30">関数 <code class="code docutils literal notranslate"><span class="pre">express</span></code></a><a class="headerlink" href="#express" title="Permalink to this heading">¶</a></h3>
<p>関数 <code class="code docutils literal notranslate"><span class="pre">express</span></code> が指定の座標系の表現に書き直せるのは点やベクトルだけではない。</p>
<ul class="simple">
<li><p>ベクトルを含む SymPy 式</p></li>
<li><p>Dyaric オブジェクト</p>
<ul>
<li><p>座標系オブジェクトを 2 個引数として渡せる。特に、引数の二項テンソルがふたつの座標系にまたがるようなものに対して有効。</p></li>
</ul>
</li>
<li><p>BaseScalar オブジェクト</p>
<ul>
<li><p>ポイントはキーワード引数 <code class="code docutils literal notranslate"><span class="pre">variables=True</span></code> を指定すること。例えば座標系 <code class="code docutils literal notranslate"><span class="pre">N</span></code> で定義したスカラー場を <code class="code docutils literal notranslate"><span class="pre">M</span></code> での表現に書き直せる。</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id31">スカラー場とベクトル場</a><a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h2>
<p>内容が若干 <a class="reference internal" href="diffgeom.html"><span class="doc">微分幾何</span></a> で見る外積周りの話題と重複する。</p>
<ul class="simple">
<li><p>座標系 <code class="code docutils literal notranslate"><span class="pre">R</span></code> でのスカラー場やベクトル場を構成するには、クラス BaseScalar のオブジェクトである
<code class="code docutils literal notranslate"><span class="pre">R.x</span></code>, <code class="code docutils literal notranslate"><span class="pre">R.y</span></code>, <code class="code docutils literal notranslate"><span class="pre">R.z</span></code> を用いる。</p></li>
</ul>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id32">ナブラ</a><a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h3>
<p>クラス CoordSysCartesian のプロパティー <code class="code docutils literal notranslate"><span class="pre">delop</span></code> がナブラ <span class="math notranslate nohighlight">\(\nabla\)</span> を表現する。英語圏の人はこれをデルと呼ぶことが多い。そしてみんなが知っているが、小文字の <code class="code docutils literal notranslate"><span class="pre">del</span></code> は Python の予約語である。</p>
<p>例を示す。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="o">*</span>

<span class="gp">In [2]: </span><span class="n">N</span> <span class="o">=</span> <span class="n">CoordSysCartesian</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)(</span><span class="n">N</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">z</span><span class="p">);</span> <span class="n">f</span>
<span class="gh">Out[3]: </span><span class="go">f(N.x, N.y, N.z)</span>

<span class="gp">In [4]: </span><span class="n">N</span><span class="o">.</span><span class="n">delop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">(Derivative(f(N.x, N.y, N.z), N.x))*N.i</span>
<span class="go">      + (Derivative(f(N.x, N.y, N.z), N.y))*N.j</span>
<span class="go">      + (Derivative(f(N.x, N.y, N.z), N.z))*N.k</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id33">回転</a><a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h3>
<p>3 次元空間のベクトルの回転 <span class="math notranslate nohighlight">\(\nabla \times \mathbf{F}\)</span> を計算する方法がふたつある。</p>
<ul class="simple">
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">delop.cross</span></code> を用いる。</p></li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">curl</span></code> を用いる。</p></li>
</ul>
<p>例を示す。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="o">*</span>

<span class="gp">In [2]: </span><span class="n">N</span> <span class="o">=</span> <span class="n">CoordSysCartesian</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;fx fy fz&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">Function</span><span class="p">)]</span>

<span class="gp">In [4]: </span><span class="n">curl</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">fy</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">fz</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">(-Subs(Derivative(fy(N.x, N.y, _xi_2), _xi_2), (_xi_2,), (N.z,)) + Subs(Derivative(fz(N.x, _xi_2, N.z), _xi_2), (_xi_2,), (N.y,)))*N.i</span>
<span class="go">      + (Subs(Derivative(fx(N.x, N.y, _xi_2), _xi_2), (_xi_2,), (N.z,)) - Subs(Derivative(fz(_xi_2, N.y, N.z), _xi_2), (_xi_2,), (N.x,)))*N.j</span>
<span class="go">      + (-Subs(Derivative(fx(N.x, _xi_2, N.z), _xi_2), (_xi_2,), (N.y,)) + Subs(Derivative(fy(_xi_2, N.y, N.z), _xi_2), (_xi_2,), (N.x,)))*N.k</span>

<span class="gp">In [5]: </span><span class="n">N</span><span class="o">.</span><span class="n">delop</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">fy</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">fz</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
<span class="gh">Out[5]: </span><span class="go">(-Derivative(fy(N.x, N.y, N.z), N.z) + Derivative(fz(N.x, N.y, N.z), N.y))*N.i</span>
<span class="go">      + (Derivative(fx(N.x, N.y, N.z), N.z) - Derivative(fz(N.x, N.y, N.z), N.x))*N.j</span>
<span class="go">      + (-Derivative(fx(N.x, N.y, N.z), N.y) + Derivative(fy(N.x, N.y, N.z), N.x))*N.k</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id34">発散</a><a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h3>
<p>3 次元空間のベクトルの発散 <span class="math notranslate nohighlight">\(\nabla \cdot \mathbf{F}\)</span> を計算する方法がふたつある。</p>
<ul class="simple">
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">delop.dot</span></code> を用いる。</p></li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">divergence</span></code> を用いる。</p></li>
</ul>
<p>例を示す。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="o">*</span>

<span class="gp">In [2]: </span><span class="c1"># Create N, fx, fy, and fz...</span>

<span class="gp">In [3]: </span><span class="n">divergence</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">fy</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">fz</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="gh">Out[3]: </span><span class="go">Subs(Derivative(fx(_xi_2, N.y, N.z), _xi_2), (_xi_2,), (N.x,))</span>
<span class="go">      + Subs(Derivative(fy(N.x, _xi_2, N.z), _xi_2), (_xi_2,), (N.y,))</span>
<span class="go">      + Subs(Derivative(fz(N.x, N.y, _xi_2), _xi_2), (_xi_2,), (N.z,))</span>

<span class="gp">In [4]: </span><span class="n">N</span><span class="o">.</span><span class="n">delop</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">fy</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">fz</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">Derivative(fx(N.x, N.y, N.z), N.x)</span>
<span class="go">      + Derivative(fy(N.x, N.y, N.z), N.y)</span>
<span class="go">      + Derivative(fz(N.x, N.y, N.z), N.z)</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id35">勾配</a><a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<p>3 次元空間上の実数値関数の勾配 <span class="math notranslate nohighlight">\(\nabla f\)</span> を計算する方法がふたつある。</p>
<ul class="simple">
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">delop.gradient</span></code> を用いる。</p></li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">gradient</span></code> を用いる。</p></li>
</ul>
<p>例を示す。または関数メソッド <code class="code docutils literal notranslate"><span class="pre">gradient</span></code> を呼ぶことで、スカラー関数から勾配ベクトル場オブジェクトが生成できている。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="o">*</span>

<span class="gp">In [2]: </span><span class="c1"># Create N, and f(x, y, z).</span>

<span class="gp">In [3]: </span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="gh">Out[3]: </span><span class="go">(Subs(Derivative(f(_xi_2, N.y, N.z), _xi_2), (_xi_2,), (N.x,)))*N.i</span>
<span class="go">      + (Subs(Derivative(f(N.x, _xi_2, N.z), _xi_2), (_xi_2,), (N.y,)))*N.j</span>
<span class="go">      + (Subs(Derivative(f(N.x, N.y, _xi_2), _xi_2), (_xi_2,), (N.z,)))*N.k</span>

<span class="gp">In [4]: </span><span class="n">N</span><span class="o">.</span><span class="n">delop</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">(Derivative(f(N.x, N.y, N.z), N.x))*N.i</span>
<span class="go">      + (Derivative(f(N.x, N.y, N.z), N.y))*N.j</span>
<span class="go">      + (Derivative(f(N.x, N.y, N.z), N.z))*N.k</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id36">方向微分</a><a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h3>
<p>方向微分は <code class="code docutils literal notranslate"><span class="pre">(v.dot(coord_sys.delop))(field)</span></code> のようにする。ここで、</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">coord_sys</span></code> はクラス CoordSysCartesian オブジェクト、</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">v</span></code> は <code class="code docutils literal notranslate"><span class="pre">coord_sys</span></code> 上のクラス Vector オブジェクト、</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">field</span></code> は <code class="code docutils literal notranslate"><span class="pre">coord_sys.base_scalars()</span></code> で表現されているスカラー場なりベクトル場である。</p></li>
</ul>
<p>例を示す。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="c1"># Create N, a, b, f(x, y, z), fx, fy, and fz.</span>

<span class="gp">In [2]: </span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">delop</span><span class="p">))(</span><span class="n">f</span><span class="p">)</span>
<span class="gh">Out[2]: </span><span class="go">a0*Subs(Derivative(f(_xi_2, N.y, N.z), _xi_2), (_xi_2,), (N.x,))</span>
<span class="go">      + a1*Subs(Derivative(f(N.x, _xi_2, N.z), _xi_2), (_xi_2,), (N.y,))</span>
<span class="go">      + a2*Subs(Derivative(f(N.x, N.y, _xi_2), _xi_2), (_xi_2,), (N.z,))</span>

<span class="gp">In [3]: </span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">delop</span><span class="p">))(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">fy</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">fz</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
<span class="gh">Out[3]: </span><span class="go">(b0*Subs(Derivative(fx(_xi_2, N.y, N.z), _xi_2), (_xi_2,), (N.x,))</span>
<span class="go">       + b1*Subs(Derivative(fx(N.x, _xi_2, N.z), _xi_2), (_xi_2,), (N.y,))</span>
<span class="go">       + b2*Subs(Derivative(fx(N.x, N.y, _xi_2), _xi_2), (_xi_2,), (N.z,)))*N.i</span>
<span class="go">      + (b0*Subs(Derivative(fy(_xi_2, N.y, N.z),_xi_2), (_xi_2,), (N.x,))</span>
<span class="go">       + b1*Subs(Derivative(fy(N.x, _xi_2, N.z), _xi_2), (_xi_2,), (N.y,))</span>
<span class="go">       + b2*Subs(Derivative(fy(N.x, N.y, _xi_2), _xi_2), (_xi_2,), (N.z,)))*N.j</span>
<span class="go">      + (b0*Subs(Derivative(fz(_xi_2, N.y, N.z), _xi_2), (_xi_2,), (N.x,))</span>
<span class="go">       + b1*Subs(Derivative(fz(N.x, _xi_2, N.z), _xi_2), (_xi_2,), (N.y,))</span>
<span class="go">       + b2*Subs(Derivative(fz(N.x, N.y, _xi_2), _xi_2), (_xi_2,), (N.z,)))*N.k</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id37">ポテンシャル</a><a class="headerlink" href="#id17" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">is_conservative(field)</span></code></dt><dd><p>ベクトル場が保存場であるかどうかをテストする。</p>
<ul class="simple">
<li><p>実装は <code class="code docutils literal notranslate"><span class="pre">curl(field,</span> <span class="pre">coord_sys)</span> <span class="pre">==</span> <span class="pre">Vector.zero</span></code> を丁寧に調べている。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">is_solenoidal(field)</span></code></dt><dd><p>ベクトル場がソレノイド場であるかどうかをテストする。</p>
<ul class="simple">
<li><p>実装は <code class="code docutils literal notranslate"><span class="pre">divergence(field,</span> <span class="pre">coord_sys)</span> <span class="pre">==</span> <span class="pre">0</span></code> を丁寧に調べている。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">scalar_potential(field,</span> <span class="pre">coord_sys)</span></code></dt><dd><p>保存場に関するスカラーポテンシャルを（積分定数を除いて）求める。</p>
<ul class="simple">
<li><p>実装では実際に各座標軸の区間ごとに積分を一度ずつ都合 3 回計算している。</p></li>
</ul>
</dd>
<dt>関数 <code class="code docutils literal notranslate"><span class="pre">scalar_potential_difference(field,</span> <span class="pre">coord_sys,</span> <span class="pre">point1,</span> <span class="pre">point2)</span></code></dt><dd><p>保存場に関する指定 2 点間のポテンシャルの差を計算する。引数は保存ベクトル場でも、そのスカラーポテンシャルでもよい。</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">point2</span></code> でのポテンシャルと <code class="code docutils literal notranslate"><span class="pre">point1</span></code> でのそれとの差。</p></li>
</ul>
</dd>
</dl>
</div>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id38">演習</a><a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h2>
<p>3 次元空間上のベクトル場
<span class="math notranslate nohighlight">\(\mathbf{F} = 2 x y^3 z^4 \mathbf{i} + 3 x^2 y^2 z^4 \mathbf{j} + 4 x^2 y^3 z^3 \mathbf{k}\)</span>
が保存場であることを確認し、そのスカラーポテンシャルを先述の関数で求める。また、このベクトル場の始点と終点をそれぞれ <span class="math notranslate nohighlight">\(P_0(0, 0, 0)\)</span> と <span class="math notranslate nohighlight">\(P_1(10, 10, 10)\)</span> とする、何らかの経路上の線積分を関数 <code class="code docutils literal notranslate"><span class="pre">scalar_potential_difference</span></code> を利用して求める手続きの例を示す。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="o">*</span>

<span class="gp">In [2]: </span><span class="n">N</span> <span class="o">=</span> <span class="n">CoordSysCartesian</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">z</span> <span class="o">**</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">i</span>\
<span class="gp">   ....: </span><span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">z</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">j</span>\
<span class="gp">   ....: </span><span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">z</span><span class="o">**</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">k</span>

<span class="gp">In [4]: </span><span class="n">is_conservative</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">True</span>

<span class="gp">In [5]: </span><span class="n">f</span> <span class="o">=</span> <span class="n">scalar_potential</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span> <span class="n">f</span>
<span class="gh">Out[5]: </span><span class="go">N.x**2*N.y**3*N.z**4</span>

<span class="gp">In [6]: </span><span class="n">p0</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">origin</span>

<span class="gp">In [7]: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">locate_new</span><span class="p">(</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>

<span class="gp">In [8]: </span><span class="n">scalar_potential_difference</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
<span class="gh">Out[8]: </span><span class="go">1000000000</span>
</pre></div>
</div>
<ul class="simple">
<li><p>[1] 面倒なので全てをインポートする。</p></li>
<li><p>[3] この保存ベクトル場は <a class="reference external" href="http://tutorial.math.lamar.edu/Classes/CalcIII/ConservativeVectorField.aspx">Paul’s Online Math Notes</a> から拝借した。</p></li>
<li><p>[5] 求めたスカラーポテンシャルには定数項が表現されていないので注意。</p></li>
<li><p>[7] どう考えても点の座標の指定が面倒だ。</p></li>
<li><p>[8] ここでは上品に求めたばかりのスカラーポテンシャルを引数として指定したが、先述のように <code class="code docutils literal notranslate"><span class="pre">F</span></code> を直接渡してよい。その場合は上における [5] が不要になる。</p></li>
</ul>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="combinatorics.html" title="Previous document">組合せ論と群論</a>
        </li>
        <li>
          <a href="matrices.html" title="Next document">行列</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">読書ノート</a></h1>



<p class="blurb">個人的な読書、学習、研究ノート。</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mathseminar72.html">数学 100 の発見 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gamma95/index.html">オブジェクト指向における再利用のためのデザインパターン改訂版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hunt00/index.html">達人プログラマー 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter00.html">Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alexandrescu01/index.html">Modern C++ Design 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meyers01.html">Effective STL 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sutter02.html">More Exceptional C++ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joel04/index.html">Joel on Software 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graham04.html">ハッカーと画家 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../angel05/index.html">OpenGL: A Primer Second Edition 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yamamoto05/index.html">入門 xyzzy 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../newham05/index.html">入門 bash 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi05/index.html">幾何学 I 多様体入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subramaniam06.html">アジャイルプラクティス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asaoka06.html">SE・製造技術者・理工系学生のための技術文書の作り方・書き方 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../levin06/index.html">Shaping Functions 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tsuboi08/index.html">幾何学 III 微分形式 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loeliger09.html">実用 Git 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../griffiths10.html">プログラミング C# 第 6 版 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../onodera10.html">ORACLE MASTER Bronze 11g SQL 基礎 I 必修教本 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hosoda10/index.html">Python 入門［２＆３対応］読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nishiyama12/index.html">幾何学と不変量 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../omg15/index.html">Unified Modeling Language 2.5 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gorelick14.html">ハイパフォーマンス Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stroustrup14.html">C++ のエッセンス 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stepanov15.html">その数式、プログラムできますか？ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos15/index.html">WebGL Specification 1.0 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vivo15/index.html">The Book of Shaders 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../saha16.html">Python からはじめる数学入門 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slatkin16.html">Effective Python 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guntheroth16.html">Optimized C++ 下読みノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../speinellis17.html">Effective Debugging 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bancila18.html">Modern C++ チャレンジ 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../haverbeke18/index.html">Eloquent JavaScript 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../khronos18/index.html">OpenGL Shading Language 4.60 Specification 読書ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kantor22/index.html">The Modern JavaScript Tutorial 読書ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2014.html">ノート準備中書籍群 2014 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2015.html">ノート準備中書籍群 2015 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2016.html">ノート準備中書籍群 2016 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2017.html">ノート準備中書籍群 2017 年編</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preliminary2018.html">ノート準備中書籍群 2018 年編</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bash-v2.html">What’s New In Bash 2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v3.html">What’s New In Bash 3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash-v4.html">What’s New In Bash 4 ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cpp11/index.html">What’s New In C++11 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp14/index.html">What’s New In C++14 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp17/index.html">What’s New In C++17 ノート</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../python-3.0.html">What’s New In Python 3.0 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.1.html">What’s New In Python 3.1 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.2.html">What’s New In Python 3.2 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.3.html">What’s New In Python 3.3 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.4.html">What’s New In Python 3.4 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.5.html">What’s New In Python 3.5 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.6.html">What’s New In Python 3.6 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.7.html">What’s New In Python 3.7 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.8.html">What’s New In Python 3.8 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.9.html">What’s New In Python 3.9 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-3.10.html">What’s New In Python 3.10 ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pip.html">pip 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pylint.html">Pylint 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-docutils/index.html">Docutils 解読ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-restview.html">Restview 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-nose.html">Nose 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-ipython.html">IPython 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jupyter.html">Jupyter 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-numpy/index.html">NumPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scipy/index.html">SciPy 利用ノート</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">SymPy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-apgl.html">Another Python Graph Library (APGL) 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pil.html">PIL 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pillow.html">Pillow 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-matplotlib/index.html">Matplotlib 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-networkx/index.html">NetworkX 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-quaternion.html">Quaternion 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-jinja2.html">Jinja2 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygments.html">Pygments 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-bs4.html">BeautifulSoup4 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-selenium.html">Selenium 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-scrapy.html">Scrapy 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-twitter/index.html">Python Twitter Tools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-isbn-hyphenate.html">isbn-hyphenate 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyopengl/index.html">PyOpenGL 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt4.html">PyQt4 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pyqt5.html">PyQt5 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pandas/index.html">Pandas 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pygame.html">Pygame 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-pytube.html">Pytube 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-py2exe.html">Py2exe 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-upgrade.html">Python 移行ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python-miniconda.html">Miniconda 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../freeware.html">Windows 用フリーウェア 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deepl-translator.html">DeepL Translator 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../winget.html">Windows Package Manager CLI 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power-toys.html">Microsoft PowerToys 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows-terminal.html">Windows Terminal 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wsl.html">Windows Subsystem for Linux 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vscode/index.html">Visual Studio Code 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cygwin.html">Cygwin 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chrome.html">Chrome DevTools 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/index.html">Git 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../twitter.html">Twitter 利用ノート [obsolete]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inkscape/index.html">Inkscape 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathjax.html">MathJax 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript-mermaid/index.html">Mermaid 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css-selector.html">CSS セレクター学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xpath.html">XPath 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hxutils.html">HTML-XML-utils 利用ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../webgl.html">WebGL 学習ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandoc.html">Pandoc 利用ノート</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../milestone09/index.html">ラジルギノア プレイノート</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">SymPy 利用ノート</a><ul>
      <li>Previous: <a href="combinatorics.html" title="previous chapter">組合せ論と群論</a></li>
      <li>Next: <a href="matrices.html" title="next chapter">行列</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2022, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>