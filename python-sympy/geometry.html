<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>幾何 &#8212; 読書ノート 1.6dev</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=c9b0a06a" />
    <script src="../_static/documentation_options.js?v=4354bf25"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="級数" href="series.html" />
    <link rel="prev" title="ディオファントス方程式" href="diophantine.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
    <div class="related top">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="diophantine.html" title="Previous">ディオファントス方程式</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">SymPy 利用ノート</a>
        </li>
        <li>
          <a href="series.html" title="Next">級数</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>


          <div class="body" role="main">
            
  <section id="id1">
<h1><a class="toc-backref" href="#id14" role="doc-backlink">幾何</a><a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
<p><a class="reference external" href="https://www.sympy.org/">SymPy</a> のサブパッケージ <code class="docutils literal notranslate"><span class="pre">sympy.geometry</span></code> に関わる覚え書きを記す。</p>
<nav class="contents" id="id2">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id14">幾何</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id15">主要クラス図</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id16">クラス継承関係</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id17">共通機能</a></p>
<ul>
<li><p><a class="reference internal" href="#geometryentity" id="id18">クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> のオブジェクトを引数に取る関数</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id19">クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> の静的・クラスメソッド</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id20">クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> のメソッド</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id8" id="id21">サブクラス</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id22">デモ</a></p>
<ul>
<li><p><a class="reference internal" href="#id10" id="id23">メネラウスの定理</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id24">チェバの定理</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id25">方べきの定理</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="id3">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">主要クラス図</a><a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p>サブパッケージ <code class="docutils literal notranslate"><span class="pre">sympy.geometry</span></code> が提供する主要クラスの継承関係のみを図示するとこういう感じになる。</p>
<div class="mermaid">
            classDiagram
    GeometryEntity &lt;|-- Point
    GeometryEntity &lt;|-- Point3D
    GeometryEntity &lt;|-- LinearEntity
        LinearEntity &lt;|-- Segment
        LinearEntity &lt;|-- Ray
        LinearEntity &lt;|-- Line
    GeometryEntity &lt;|-- LinearEntity3D
        LinearEntity3D &lt;|-- Line3D
        LinearEntity3D &lt;|-- Ray3D
        LinearEntity3D &lt;|-- Segment3D
    GeometryEntity &lt;|-- Plane
    GeometryEntity &lt;|-- Polygon
        Polygon &lt;|-- Triangle
        Polygon &lt;|-- RegularPolygon
    GeometryEntity &lt;|-- Ellipse
        Ellipse &lt;|-- Circle
    GeometryEntity &lt;|-- Curve
        </div><ul class="simple">
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> のスーパークラスはクラス <code class="docutils literal notranslate"><span class="pre">Basic</span></code> である。</p></li>
</ul>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">クラス継承関係</a><a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>基本的に二次元幾何。同じ幾何要素で次元が異なるものはクラスも別々に定義がある。例えば <code class="docutils literal notranslate"><span class="pre">Point</span></code> と <code class="docutils literal notranslate"><span class="pre">Point3D</span></code> が存在する。</p>
<ul>
<li><p>ここにあるあらゆるメソッド、関数は 2D と 3D を混ぜて利用することを想定していない。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">RegularPolygon</span></code> is-a <code class="docutils literal notranslate"><span class="pre">Polygon</span></code> だったり <code class="docutils literal notranslate"><span class="pre">Circle</span></code> is-a <code class="docutils literal notranslate"><span class="pre">Ellipse</span></code> だったりする。オブジェクト指向プログラミングの本からするとこういう設計はするなと言われそうだが、SymPy は記号数学のライブラリーなのでむしろアリということだろう。</p></li>
</ul>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">共通機能</a><a class="headerlink" href="#id5" title="Link to this heading">¶</a></h2>
<p>ここでは便宜上、次のものを共通機能と呼んで理解を深める。</p>
<ol class="arabic simple">
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> のオブジェクトを引数に取る関数</p></li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> の静的・クラスメソッド</p></li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> のメソッド</p></li>
</ol>
<section id="geometryentity">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> のオブジェクトを引数に取る関数</a><a class="headerlink" href="#geometryentity" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">intersection</span></code></p>
<ul>
<li><p>引数は複数個の <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> オブジェクト。</p></li>
<li><p>戻り値は <code class="docutils literal notranslate"><span class="pre">list</span></code> で、その要素は <code class="docutils literal notranslate"><span class="pre">Point</span></code> や <code class="docutils literal notranslate"><span class="pre">Segment</span></code> になるのだろう。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">convex_hull</span></code></p>
<ul>
<li><p>複数個の <code class="docutils literal notranslate"><span class="pre">Point</span></code>, <code class="docutils literal notranslate"><span class="pre">Segment</span></code>, <code class="docutils literal notranslate"><span class="pre">Polygon</span></code> オブジェクトを引数に取る。</p></li>
<li><p>戻り値は基本的には凸包を表現する <code class="docutils literal notranslate"><span class="pre">Polygon</span></code> オブジェクトだが、場合によっては <code class="docutils literal notranslate"><span class="pre">Segment</span></code> かもしれない。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">are_coplanar</span></code></p>
<ul>
<li><p>引数は複数個の <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> オブジェクト。</p></li>
<li><p>引数のすべての 3D オブジェクト全部がある平面上に乗っているかどうかをテストする。</p></li>
<li><p>そのような平面が <code class="docutils literal notranslate"><span class="pre">Plane</span></code> オブジェクトとして返るわけではないようだ？</p></li>
<li><p>2D のオブジェクトは一応 3D 化してから計算してくれる。計算するまでもないだろう。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">are_similar</span></code></p>
<ul>
<li><p>ふたつの <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> オブジェクトが相似かどうかをテストする。</p></li>
<li><p>単に <code class="code docutils literal notranslate"><span class="pre">entity1.is_similar(entity2)</span></code> よりも気が利いた処理をするに過ぎない。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">centroid</span></code></p>
<ul>
<li><p>引数は複数個の <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> オブジェクト。</p></li>
<li><p>おそらく同型でなければならない。</p></li>
<li><p>戻り値は <code class="docutils literal notranslate"><span class="pre">Point</span></code> オブジェクトで、オブジェクト全部が決定する重心の座標を表現する。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> の静的・クラスメソッド</a><a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> の静的・クラスメソッドは存在しない。</p>
</section>
<section id="id7">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> のメソッド</a><a class="headerlink" href="#id7" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">intersection</span></code> は先述の同名関数を参照。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_similar</span></code> は先述の関数 <code class="docutils literal notranslate"><span class="pre">are_similar</span></code> を参照。</p></li>
<li><p>変形系メソッド <code class="docutils literal notranslate"><span class="pre">rotate</span></code>, <code class="docutils literal notranslate"><span class="pre">scale</span></code>, <code class="docutils literal notranslate"><span class="pre">translate</span></code>, <code class="docutils literal notranslate"><span class="pre">reflect</span></code> が提供されている。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">rotate</span></code>, <code class="docutils literal notranslate"><span class="pre">scale</span></code> は変形の原点を指定できる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reflect</span></code> には <code class="docutils literal notranslate"><span class="pre">LinearEntity</span></code> オブジェクトを渡すようだ。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">encloses</span></code></p>
<ul>
<li><p>自身のオブジェクトの内側に与えられたオブジェクト全体を含むかどうかをテストする。</p></li>
<li><p>実装にはサブクラスのメソッド <code class="docutils literal notranslate"><span class="pre">encloses_point</span></code> を利用している。</p></li>
<li><p>造りが美しくない。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">equals</span></code> が提供されており、オーバーライドがなければ <code class="code docutils literal notranslate"><span class="pre">e1</span> <span class="pre">==</span>
<span class="pre">e2</span></code> と同値。</p></li>
<li><p>演算子がいくつか定義されているが、これらの存在はひとまず忘れておく。</p></li>
</ul>
</section>
</section>
<section id="id8">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">サブクラス</a><a class="headerlink" href="#id8" title="Link to this heading">¶</a></h2>
<p>以下、クラス <code class="docutils literal notranslate"><span class="pre">GeometryEntity</span></code> の各サブクラスについての感想やら何やらを記す。</p>
<ul>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Point</span></code></p>
<ul class="simple">
<li><p>座標成分は具体的な数値でもよいし、シンボルでもよい。ただし、いくつかの判定モノの関数は具体的な <code class="docutils literal notranslate"><span class="pre">Point</span></code> で計算しないと意味がなくなる。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">length</span></code> は必ずゼロを返す。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_collinear</span></code> と <code class="docutils literal notranslate"><span class="pre">is_concyclic</span></code> はクラスメソッドである。</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>類似したライブラリーを色々知っているが <code class="docutils literal notranslate"><span class="pre">is_concyclic</span></code> 的なものは初めてお目にかかる。</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">evalf</span></code> は各座標を浮動小数点数で表現し直した <code class="docutils literal notranslate"><span class="pre">Point</span></code> を返す。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">dot</span></code> でドット積を計算する。</p></li>
<li><p>演算子で加算、減算、スカラー倍、etc. が実現できる。単項マイナスと絶対値もサポート。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">transform</span></code> は行列を右から掛けるようだ。vM 方式。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Point3D</span></code></p>
<ul class="simple">
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Point</span></code> にあるものは、だいたいその三次元版メンバーが存在する。</p></li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Point</span></code> にはない次のメソッドに注意。</p>
<ul>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">direction_ratio</span></code>, <code class="docutils literal notranslate"><span class="pre">direction_cosine</span></code></p></li>
<li><p>クラスメソッド <code class="docutils literal notranslate"><span class="pre">are_collinear</span></code>, <code class="docutils literal notranslate"><span class="pre">are_coplanar</span></code></p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_collinear</span></code> と <code class="docutils literal notranslate"><span class="pre">is_concyclic</span></code> は存在しない。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">LinearEntity</span></code></p>
<ul class="simple">
<li><p>二次元空間内のまっすぐな線のためのスーパークラス。</p></li>
<li><p>この手のクラスによくあるプロパティー、メソッドがやはりある。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">parallel_line</span></code>, <code class="docutils literal notranslate"><span class="pre">perpendicular_line</span></code> は <code class="docutils literal notranslate"><span class="pre">Line</span></code> オブジェクトを生成する。</p>
<ul>
<li><p>一方、メソッド <code class="docutils literal notranslate"><span class="pre">perpendicular_segment</span></code> は <code class="docutils literal notranslate"><span class="pre">Segment</span></code> オブジェクトを生成する。</p></li>
</ul>
</li>
<li><p>クラスメソッド <code class="docutils literal notranslate"><span class="pre">are_concurrent</span></code> 的なものは初めてお目にかかる。すべての引数が「一点で交差する」かどうかをテストする。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">intersection</span></code> の対象は <code class="docutils literal notranslate"><span class="pre">Point</span></code> か <code class="docutils literal notranslate"><span class="pre">LinearEntity</span></code> に限定している？</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">arbitrary_point</span></code> で線上の任意の一点を返す。</p>
<ul>
<li><p>デフォルトでは線のパラメーターシンボルを <code class="docutils literal notranslate"><span class="pre">t</span></code> とする。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">random_point</span></code> で線上の勝手な一点を返す。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_similar</span></code> は線の傾きを比較する。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">contains</span></code> は形状を集合と見たときの包含関係のテストと思ってよい。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">distance</span></code> はここにはなく、各サブクラスにある。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Segment</span></code></p>
<ul class="simple">
<li><p>有限の線分を表現する。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">plot_interval</span></code> は <code class="code docutils literal notranslate"><span class="pre">list(t,</span> <span class="pre">0,</span> <span class="pre">1)</span></code> を返す。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">perpendicular_bisector</span></code> の仕様が CAD の感覚だとやや不親切な気がする。指定点が bisector に乗らない場合は、直線ではなくて中点から投影点までの線分を生成するのかと思った。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Ray</span></code></p>
<ul class="simple">
<li><p>半直線を表現する。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">plot_interval</span></code> は <code class="code docutils literal notranslate"><span class="pre">list(t,</span> <span class="pre">0,</span> <span class="pre">10)</span></code> を返す。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">xdirection</span></code>, <code class="docutils literal notranslate"><span class="pre">ydirection</span></code> により、形状がどの座標軸に沿って無限なのかがわかる。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Line</span></code></p>
<ul class="simple">
<li><p>直線を表現する。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">plot_interval</span></code> は <code class="code docutils literal notranslate"><span class="pre">list(t,</span> <span class="pre">-5,</span> <span class="pre">5)</span></code> を返す。</p></li>
<li><p>こいつだけメソッド <code class="docutils literal notranslate"><span class="pre">equation</span></code> を持っていて、直線の式 <code class="code docutils literal notranslate"><span class="pre">simplify(a*x</span> <span class="pre">+</span>
<span class="pre">b*y</span> <span class="pre">+</span> <span class="pre">c)</span></code> を生成する。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">LinearEntity3D</span></code> およびそのサブクラス群が <code class="docutils literal notranslate"><span class="pre">LinearEntity</span></code> 系と同じ階層構造で存在する。</p></li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Plane</span></code></p>
<ul class="simple">
<li><p>平面を表現する。平面に期待するメンバーが存在する。</p></li>
<li><p>平行、垂直のテストは <code class="docutils literal notranslate"><span class="pre">LinearEntity3D</span></code> または <code class="docutils literal notranslate"><span class="pre">Plane</span></code> に対するものだ。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">distance</span></code> の対象は <code class="docutils literal notranslate"><span class="pre">Point3D</span></code>, <code class="docutils literal notranslate"><span class="pre">LinearEntity3D</span></code> または
<code class="docutils literal notranslate"><span class="pre">Plane</span></code> のいずれか。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">arbitrary_point</span></code>, <code class="docutils literal notranslate"><span class="pre">random_point</span></code> がある。</p></li>
<li><p>クラスメソッド <code class="docutils literal notranslate"><span class="pre">are_concurrent</span></code> は複数の平面が共通の直線で交わるかどうかをテストする珍しいものだ。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_coplanar</span></code> で平面に乗るかどうかをテスト。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Polygon</span></code></p>
<ul class="simple">
<li><p>xy 平面上の多角形を表現する。</p></li>
<li><p>コンストラクターが気を利かせて、別のクラスのオブジェクトを生成することがある。極端な例を挙げると、一直線上に並ぶ任意の点列を <code class="docutils literal notranslate"><span class="pre">Polygon</span></code> のコンストラクターに与えると、得られるオブジェクトの型はなんと <code class="docutils literal notranslate"><span class="pre">Segment</span></code> である。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">area</span></code> で面積を計算する。符号付きの可能性がある。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">angles</span></code> で内角の <code class="docutils literal notranslate"><span class="pre">list</span></code> を返す。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">perimeter</span></code> は周長を返す。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">centroid</span></code> で重心に位置する <code class="docutils literal notranslate"><span class="pre">Point</span></code> オブジェクトを生成する。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">sides</span></code> で各辺を <code class="docutils literal notranslate"><span class="pre">Segment</span></code> で表現するオブジェクトの
<code class="docutils literal notranslate"><span class="pre">list</span></code> を返す。</p>
<ul>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">intersection</span></code> の計算はこれに基づく。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_convex</span></code> でこの多角形が凸かどうかをテストする。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">arbitrary_point</span></code> について</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">t=0</span></code> で始点</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">t=1</span></code> で終点</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">plot_interval</span></code> は <code class="code docutils literal notranslate"><span class="pre">list(t,</span> <span class="pre">0,</span> <span class="pre">1)</span></code> を返す。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Triangle</span></code></p>
<ul>
<li><p>三角形は多角形の中でも別格の存在ということで、専用クラスとして存在するようだ。</p></li>
<li><p>コンストラクターは色々な引数指定をサポートしている。使いやすいものを覚えておくこと。</p>
<ul class="simple">
<li><p>単に三頂点を <code class="docutils literal notranslate"><span class="pre">Point</span></code> オブジェクトで指定する。</p></li>
<li><p>キーワード引数 <code class="docutils literal notranslate"><span class="pre">sss</span></code> 等と辺の長さ・角度を列挙を組み合わせて指定する。</p>
<ul>
<li><p>オブジェクトの座標があらかじめ想像しづらい。</p></li>
</ul>
</li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_similar</span></code> の実装は、三辺の比をテストするだけ。辺の順序の組み合わせはすべて考慮する。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_equilateral</span></code> で正三角形テスト。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_isosceles</span></code> で二等辺三角形テスト。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_right</span></code> で直角三角形テスト。</p></li>
<li><p>五心</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>名前</p></th>
<th class="head"><p>Point</p></th>
<th class="head"><p>Circle</p></th>
<th class="head"><p>何の交点か</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>外心 (O)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">circumcenter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">circumcircle</span></code></p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">sides().perpendicular_bisector()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>垂心 (H)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">orthocenter</span></code></p></td>
<td><p>なし</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">altitudes</span></code></p></td>
</tr>
<tr class="row-even"><td><p>内心 (I)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">incenter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">incircle</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bisectors</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>傍心 (J)</p></td>
<td><p>なし</p></td>
<td><p>なし</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-even"><td><p>重心 (G)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">centroid</span></code></p></td>
<td><p>なし</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">medians</span></code></p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">RegularPolygon</span></code></p>
<ul class="simple">
<li><p>正多角形を表現するクラス。</p></li>
<li><p>頂点の位置を直接指定してオブジェクトを生成するというよりは、半径と頂点数を指定する。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">length</span></code> の実装を見ると非効率的な印象を受けるが、記号数学演算的にはこれしかない。</p>
<ul>
<li><p>これは <code class="docutils literal notranslate"><span class="pre">perimeter</span></code> を利用しない。</p></li>
</ul>
</li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">apothem</span></code> および <code class="docutils literal notranslate"><span class="pre">inradius</span></code> で内接円の半径を得る。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">interior_angle</span></code> と <code class="docutils literal notranslate"><span class="pre">exterior_angle</span></code> で多角形の内角、外角をそれぞれ得る。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">incircle</span></code> と <code class="docutils literal notranslate"><span class="pre">circumcircle</span></code> で内接円、外接円を Circle オブジェクトとしてそれぞれ得る。</p></li>
<li><p>コンストラクターおよびメソッド <code class="docutils literal notranslate"><span class="pre">spin</span></code> で多角形の中心点を軸に回転をかけられる。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Ellipse</span></code></p>
<ul class="simple">
<li><p>コンストラクターが色々ある。</p>
<ul>
<li><p>長軸・短軸ではなく <code class="docutils literal notranslate"><span class="pre">hradius</span></code>, <code class="docutils literal notranslate"><span class="pre">vradius</span></code> のような扱いをする。</p></li>
</ul>
</li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">minor</span></code>, <code class="docutils literal notranslate"><span class="pre">major</span></code> で長軸、短軸の半分の長さを得る。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">circumference</span></code> で楕円の周長が得られる。定積分オブジェクトかもしれない。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">periapsis</span></code>, <code class="docutils literal notranslate"><span class="pre">apoapsis</span></code> で楕円の焦点から近点、焦点から遠点の距離がそれぞれ得られる。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">tangent_lines</span></code> である点から楕円上に接線を求める。</p>
<ul>
<li><p>たいていの場合、戻り値は <code class="docutils literal notranslate"><span class="pre">Line</span></code> オブジェクト二個の <code class="docutils literal notranslate"><span class="pre">list</span></code> となる。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">is_tangent</span></code> は <code class="docutils literal notranslate"><span class="pre">Ellipse</span></code> にも対応している。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">normal_lines</span></code> はある点から楕円に垂直に交差する <code class="docutils literal notranslate"><span class="pre">Line</span></code> を求める。</p>
<ul>
<li><p>要素数は 1, 2, 4 のいずれか。</p></li>
<li><p>キーワード引数 <code class="docutils literal notranslate"><span class="pre">prec</span></code> の存在に注意。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">plot_interval</span></code> は <code class="code docutils literal notranslate"><span class="pre">list(t,</span> <span class="pre">-S.Pi,</span> <span class="pre">S.Pi)</span></code> を返す。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">equation</span></code> で楕円の方程式（の左辺）を得る。</p></li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">evolute</span></code> で楕円の縮閉線の方程式（の左辺）を得る。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Circle</span></code></p>
<ul class="simple">
<li><p>コンストラクターは次のどちらかの引数リストを受け付ける。</p>
<ul>
<li><p>通過点を表現する <code class="docutils literal notranslate"><span class="pre">Point</span></code> オブジェクト三つ。</p></li>
<li><p>中心を表現する <code class="docutils literal notranslate"><span class="pre">Point</span></code> と半径。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">scale</span></code> で <code class="docutils literal notranslate"><span class="pre">Ellipse</span></code> オブジェクトが生成することがある。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Curve</span></code></p>
<ul class="simple">
<li><p>平面的なパラメトリック曲線を表現するクラス。</p></li>
<li><p>コンストラクターの例： <code class="code docutils literal notranslate"><span class="pre">Curve((sin(t),</span> <span class="pre">cos(t)),</span> <span class="pre">(t,</span> <span class="pre">0,</span> <span class="pre">2))</span></code></p></li>
<li><p>プロパティー</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">limits</span></code> は曲線のパラメーター定義域を表現する <code class="docutils literal notranslate"><span class="pre">tuple</span></code> である。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parameter</span></code> は曲線のパラメーターのためのシンボルである。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">functions</span></code> は各座標成分の関数の <code class="docutils literal notranslate"><span class="pre">tuple</span></code> である。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="id9">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">デモ</a><a class="headerlink" href="#id9" title="Link to this heading">¶</a></h2>
<section id="id10">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">メネラウスの定理</a><a class="headerlink" href="#id10" title="Link to this heading">¶</a></h3>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;meneraus.py: Demonstrate Menelaus&#39; theorem with SymPy.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">Line</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demonstrate_menelaus</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate Menelaus&#39; theorem.&quot;&quot;&quot;</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Line</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">Line</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">Line</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;P=&quot;</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Q=&quot;</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;R=&quot;</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>

    <span class="n">numer</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;numer=&quot;</span><span class="p">,</span> <span class="n">numer</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;denom=&quot;</span><span class="p">,</span> <span class="n">denom</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>

    <span class="c1"># Or show simplify(numer/denom).</span>
    <span class="nb">print</span><span class="p">((</span><span class="n">numer</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">Line</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">344</span><span class="p">),</span>
                    <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">143</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="p">),</span>
                    <span class="n">Point</span><span class="p">(</span><span class="mi">59</span><span class="p">,</span> <span class="mi">300</span><span class="p">),)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">Line</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span>
                      <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;X1:3&#39;</span><span class="p">),</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;Y1:3&#39;</span><span class="p">))])</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x1:4&#39;</span><span class="p">),</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;y1:4&#39;</span><span class="p">))]</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">demonstrate_menelaus</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">*</span><span class="n">vertices</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>本当は数値的でないほうの座標で検証したかったが、私の環境では
<code class="code docutils literal notranslate"><span class="pre">simplify(numer/denom)</span></code> が返って来なかった。</p></li>
<li><p>具体的な座標を与えた方の検証はうまくいく。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bash$ ./menelaous.py</span>
<span class="go">P= Point(-346.683333333333, -346.683333333333)</span>
<span class="go">Q= Point(170.682926829268, 170.682926829268)</span>
<span class="go">R= Point(-241.237623762376, -241.237623762376)</span>
<span class="go">numer= 41999675.9784931</span>
<span class="go">denom= 41999675.9784931</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id11">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">チェバの定理</a><a class="headerlink" href="#id11" title="Link to this heading">¶</a></h3>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;ceva.py: Demonstrate Ceva&#39;s theorem with SymPy.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">Line</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demonstrate_ceva</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate Ceva&#39;s theorem.&quot;&quot;&quot;</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Line</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">Line</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">Line</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
    <span class="n">OA</span><span class="p">,</span> <span class="n">OB</span><span class="p">,</span> <span class="n">OC</span> <span class="o">=</span> <span class="p">(</span><span class="n">Line</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span>
               <span class="nb">zip</span><span class="p">((</span><span class="n">OA</span><span class="p">,</span> <span class="n">OB</span><span class="p">,</span> <span class="n">OC</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;P=&quot;</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Q=&quot;</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;R=&quot;</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>

    <span class="n">numer</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;numer=&quot;</span><span class="p">,</span> <span class="n">numer</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;denom=&quot;</span><span class="p">,</span> <span class="n">denom</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>

    <span class="c1"># Or show simplify(numer/denom).</span>
    <span class="nb">print</span><span class="p">((</span><span class="n">numer</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">Point</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">344</span><span class="p">),</span>
                    <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">143</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="p">),</span>
                    <span class="n">Point</span><span class="p">(</span><span class="mi">59</span><span class="p">,</span> <span class="mi">300</span><span class="p">),)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x0:4&#39;</span><span class="p">),</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;y0:4&#39;</span><span class="p">))]</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
    <span class="n">demonstrate_ceva</span><span class="p">(</span><span class="o">*</span><span class="n">vertices</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>本当は数値的でないほうの座標で検証したかったが、私の環境では
<code class="code docutils literal notranslate"><span class="pre">simplify(numer/denom)</span></code> が返って来なかった。</p></li>
<li><p>具体的な座標を与えた方の検証はうまくいく。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bash$ ./ceva.py</span>
<span class="go">P= Point(13.9279086822051, 228.152408889456)</span>
<span class="go">Q= Point(280.783950617284, 43.1975308641975)</span>
<span class="go">R= Point(104.14656234152, 529.558791567051)</span>
<span class="go">numer= 20374326.3842940</span>
<span class="go">denom= 20374326.3842940</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id12">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">方べきの定理</a><a class="headerlink" href="#id12" title="Link to this heading">¶</a></h3>
<p>具体的な座標を与えないとどうも上手くいかないようなので、数値計算に切り替えて様子見だ。さらに難易度？を落とし、方べきの定理を再現してみたい。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;circle_power.py: Demonstrate power-of-a-point theorem with SymPy.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">Line</span><span class="p">,</span> <span class="n">Circle</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demonstrate_circle_power</span><span class="p">(</span><span class="n">circle</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate power-of-a-point theorem.&quot;&quot;&quot;</span>

    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">circle</span><span class="o">.</span><span class="n">random_point</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">Line</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">Line</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">Line</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">PAPB</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">PCPD</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PA * PB =&quot;</span><span class="p">,</span> <span class="n">PAPB</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PC * PD =&quot;</span><span class="p">,</span> <span class="n">PCPD</span><span class="o">.</span><span class="n">evalf</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">demonstrate_circle_power</span><span class="p">(</span><span class="n">Circle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">))</span>
</pre></div>
</div>
<p>円を単位円に固定する代わり、円周上の四点をランダムにとり、それらを結ぶ二弦の交点に対する方べきの定理を検証しよう。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bash$ ./circle_power.py</span>
<span class="go">PA * PB = 0.245325501000245</span>
<span class="go">PC * PD = 0.245325501000245</span>
<span class="go">bash$ ./circle_power.py</span>
<span class="go">PA * PB = 0.0519999915840500</span>
<span class="go">PC * PD = 0.0519999915840500</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="admonition-todo admonition" id="id13">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>プロットは実現したい。</p></li>
<li><p>上の例で <code class="docutils literal notranslate"><span class="pre">distance</span></code> を多用しているが、値一致テストの目的なら <code class="docutils literal notranslate"><span class="pre">dot</span></code> を用いるのが常識的か。</p></li>
<li><p>もっとサンプルを作りたい。</p></li>
</ul>
</div>
</section>
</section>
</section>


          </div>
    <div class="related bottom">
      &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="diophantine.html" title="Previous">ディオファントス方程式</a>
        </li>
      
        <li>
          &uarr;
          <a href="index.html" title="Parent">SymPy 利用ノート</a>
        </li>
        <li>
          <a href="series.html" title="Next">級数</a>
          &rarr;
        </li>
    </ul>
  </nav>
    </div>

      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="../index.html" title="読書ノート Home"><img src="../_images/logo.svg"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2024, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>