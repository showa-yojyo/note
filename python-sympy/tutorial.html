<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>チュートリアルを読む &#8212; 読書ノート 1.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=1a9a5cd9" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=d21ed4cc"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/mermaid.js?v=578dbed1"></script>
    <link rel="next" title="プロットを利用する" href="plotting.html" />
    <link rel="prev" title="ドキュメントをビルドする" href="doc.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="doc.html" title="Previous document">ドキュメントをビルドする</a>
        </li>
        <li>
          <a href="plotting.html" title="Next document">プロットを利用する</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="id1">
<h1><a class="toc-backref" href="#id4" role="doc-backlink">チュートリアルを読む</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>本稿は <a class="reference external" href="https://www.sympy.org/">SymPy</a> の SymPy Tutorial を読んだときのメモである。</p>
<nav class="contents" id="id2">
<p class="topic-title">ノート目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id4">チュートリアルを読む</a></p>
<ul>
<li><p><a class="reference internal" href="#preliminaries" id="id5">Preliminaries</a></p>
<ul>
<li><p><a class="reference internal" href="#installtion" id="id6">Installtion</a></p></li>
<li><p><a class="reference internal" href="#exercises" id="id7">Exercises</a></p></li>
<li><p><a class="reference internal" href="#about-this-tutorial" id="id8">About This Tutorial</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#introduction" id="id9">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#what-is-symbolic-computation" id="id10">What is Symbolic Computation?</a></p></li>
<li><p><a class="reference internal" href="#a-more-interesting-example" id="id11">A More Interesting Example</a></p></li>
<li><p><a class="reference internal" href="#the-power-of-symbolic-computation" id="id12">The Power of Symbolic Computation</a></p></li>
<li><p><a class="reference internal" href="#why-sympy" id="id13">Why SymPy?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#gotchas" id="id14">Gotchas</a></p>
<ul>
<li><p><a class="reference internal" href="#symbols" id="id15">Symbols</a></p></li>
<li><p><a class="reference internal" href="#equals-signs" id="id16">Equals signs</a></p></li>
<li><p><a class="reference internal" href="#two-final-notes-and" id="id17">Two Final Notes: <code class="docutils literal notranslate"><span class="pre">^</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#basic-operations" id="id18">Basic Operations</a></p>
<ul>
<li><p><a class="reference internal" href="#substitution" id="id19">Substitution</a></p></li>
<li><p><a class="reference internal" href="#converting-strings-to-sympy-expressions" id="id20">Converting Strings to SymPy Expressions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#printing" id="id21">Printing</a></p>
<ul>
<li><p><a class="reference internal" href="#printers" id="id22">Printers</a></p></li>
<li><p><a class="reference internal" href="#setting-up-pretty-printing" id="id23">Setting up Pretty Printing</a></p></li>
<li><p><a class="reference internal" href="#printing-functions" id="id24">Printing Functions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#simplification" id="id25">Simplification</a></p>
<ul>
<li><p><a class="reference internal" href="#simplify" id="id26"><code class="docutils literal notranslate"><span class="pre">simplify</span></code></a></p></li>
<li><p><a class="reference internal" href="#polynomial-rational-function-simplification" id="id27">Polynomial/Rational Function Simplification</a></p></li>
<li><p><a class="reference internal" href="#trigonometric-simplification" id="id28">Trigonometric Simplification</a></p></li>
<li><p><a class="reference internal" href="#powers" id="id29">Powers</a></p></li>
<li><p><a class="reference internal" href="#exponentials-and-logarithms" id="id30">Exponentials and logarithms</a></p></li>
<li><p><a class="reference internal" href="#special-functions" id="id31">Special Functions</a></p></li>
<li><p><a class="reference internal" href="#example-continued-fractions" id="id32">Example: Continued Fractions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#calculus" id="id33">Calculus</a></p>
<ul>
<li><p><a class="reference internal" href="#derivatives" id="id34">Derivatives</a></p></li>
<li><p><a class="reference internal" href="#integrals" id="id35">Integrals</a></p></li>
<li><p><a class="reference internal" href="#limits" id="id36">Limits</a></p></li>
<li><p><a class="reference internal" href="#series-expansion" id="id37">Series Expansion</a></p></li>
<li><p><a class="reference internal" href="#finite-differences" id="id38">Finite differences</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#solvers" id="id39">Solvers</a></p>
<ul>
<li><p><a class="reference internal" href="#a-note-about-equations" id="id40">A Note about Equations</a></p></li>
<li><p><a class="reference internal" href="#solving-equations-algebraically" id="id41">Solving Equations Algebraically</a></p></li>
<li><p><a class="reference internal" href="#solving-differential-equations" id="id42">Solving Differential Equations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#matrices" id="id43">Matrices</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id44">Basic Operations</a></p></li>
<li><p><a class="reference internal" href="#basic-methods" id="id45">Basic Methods</a></p></li>
<li><p><a class="reference internal" href="#matrix-constructors" id="id46">Matrix Constructors</a></p></li>
<li><p><a class="reference internal" href="#advanced-methods" id="id47">Advanced Methods</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#advanced-expression-manipulation" id="id48">Advanced Expression Manipulation</a></p>
<ul>
<li><p><a class="reference internal" href="#understanding-expression-trees" id="id49">Understanding Expression Trees</a></p></li>
<li><p><a class="reference internal" href="#recursing-through-an-expression-tree" id="id50">Recursing through an Expression Tree</a></p></li>
<li><p><a class="reference internal" href="#walking-the-tree" id="id51">Walking the Tree</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="preliminaries">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Preliminaries</a><a class="headerlink" href="#preliminaries" title="Permalink to this heading">¶</a></h2>
<p>読者は Python プログラミングの基本と、それなりの数学の知識があればよい。チュートリアルに出てくる例はだいたい微分積分レベル。</p>
<section id="installtion">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Installtion</a><a class="headerlink" href="#installtion" title="Permalink to this heading">¶</a></h3>
<p>私はインストールは無事に出来たので、ここは読み飛ばした。</p>
<ul>
<li><p>ドキュメント内の至る所にサンプルコードがあり、Sphinx の拡張機能で SymPy Live
shell が試せる。よく出来ている。</p>
<ul class="simple">
<li><p>デフォルトの出力書式が LaTeX なので見栄えがする。</p></li>
</ul>
</li>
<li><p>最初のサンプル、私の <a class="reference external" href="https://ipython.org/">IPython</a> シェルで実行したら次のようになった。若干異なる。おそらく関数 <code class="docutils literal notranslate"><span class="pre">init_printing</span></code> を異なる引数で適用したか、利用するコンソール環境の Unicode サポート状況に違いがあるのだろう。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>

<span class="gp">In [2]: </span><span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
<span class="gh">Out[2]:</span>
<span class="go">  /</span>
<span class="go"> |                 x           x</span>
<span class="go"> |  x             e *sin(x)   e *cos(x)</span>
<span class="go"> | e *cos(x) dx = --------- + ---------</span>
<span class="go"> |                    2           2</span>
<span class="go">/</span>
</pre></div>
</div>
<p>以下追記。起動直後に <code class="code docutils literal notranslate"><span class="pre">init_printing(pretty_print=False)</span></code> を呼び出すか、または起動時にコマンドラインオプション <code class="docutils literal notranslate"><span class="pre">--pretty=no</span></code> とすれば、出力の書式がコンソールにやさしいものに変わる。</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">init_printing</span><span class="p">(</span><span class="n">pretty_print</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
<span class="gh">Out[4]: </span><span class="go">Eq(Integral(exp(x)*cos(x), x), exp(x)*sin(x)/2 + exp(x)*cos(x)/2)</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="exercises">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Exercises</a><a class="headerlink" href="#exercises" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>このチュートリアルの基となっている &lt;the 2013 SciPy conference in Austin, TX&gt;
とやらを後でチェックしたい。</p>
<ul>
<li><p>HTML 版はほとんどこのチュートリアルと同じ内容だった。</p></li>
<li><p>YouTube にビデオ版が公開されている。Part 5 of 6 がおもしろかった。</p></li>
</ul>
</li>
</ul>
</section>
<section id="about-this-tutorial">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">About This Tutorial</a><a class="headerlink" href="#about-this-tutorial" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>このチュートリアルは SymPy の機能をたくさん紹介するが、余すところなくというほどではない。</p></li>
<li><p>紹介している機能についても、その全てのオプションや性能を説明しているとは限らない。</p></li>
<li><p>全部見たければ API リファレンスを当たればよい。</p></li>
<li><p>&lt;These are the goals of this tutorial&gt; の内容がすばらしい。特に後半。</p>
<ul>
<li><p>良い実践、用法を使い、アンチパターンを避けること。</p></li>
<li><p>一貫性を保つこと。</p></li>
<li><p>不必要な重複を避けること。</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="introduction">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<section id="what-is-symbolic-computation">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">What is Symbolic Computation?</a><a class="headerlink" href="#what-is-symbolic-computation" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>以下、symbolic computation を記号計算と訳しておく。</p></li>
<li><p>数学オブジェクトを近似ではなく、厳密に表現する。</p>
<ul>
<li><p>（例）関数 <code class="docutils literal notranslate"><span class="pre">sympy.sqrt</span></code> と <code class="docutils literal notranslate"><span class="pre">math.sqrt</span></code> の違い。</p></li>
<li><p>さらに <code class="code docutils literal notranslate"><span class="pre">sympy.sqrt(9)</span></code> と <code class="code docutils literal notranslate"><span class="pre">sympy.sqrt(8)</span></code> の違いについて。</p></li>
</ul>
</li>
</ul>
</section>
<section id="a-more-interesting-example">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">A More Interesting Example</a><a class="headerlink" href="#a-more-interesting-example" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>上で見たように、SymPy を用いて無理数を操作できる。</p></li>
<li><p>記号計算システムは「変数のある記号式の計算」機能を有する。変な訳だ。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> や <code class="docutils literal notranslate"><span class="pre">y</span></code> など、記号の定義をするには関数 <code class="docutils literal notranslate"><span class="pre">symbols</span></code> を用いる。</p>
<ul>
<li><p>記号は参照する前に定義しなければならない。Python だから。</p></li>
<li><p>式 <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">y</span></code> は <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">y</span></code> とは書けない。Python だから。</p></li>
</ul>
</li>
<li><p>本ノートでは simplify を簡略化と訳すことにする。</p></li>
<li><p>大部分の簡略化は自動的にはなされない。</p></li>
<li><p>まずは関数 <code class="docutils literal notranslate"><span class="pre">expand</span></code> と <code class="docutils literal notranslate"><span class="pre">factor</span></code> を試す。</p></li>
</ul>
</section>
<section id="the-power-of-symbolic-computation">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">The Power of Symbolic Computation</a><a class="headerlink" href="#the-power-of-symbolic-computation" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>記号計算システムの本来の力は、あらゆる種類の計算を記号的に行うことにある。</p></li>
<li><p>SymPy は次のことができる。すべてを記号的に計算する。</p>
<ul>
<li><p>式を簡略化する</p></li>
<li><p>微分を計算する</p></li>
<li><p>積分を計算する</p></li>
<li><p>極限を求める</p></li>
<li><p>方程式を解く</p></li>
<li><p>行列を用いる</p></li>
<li><p>and more</p></li>
</ul>
</li>
<li><p>SymPy は次の機能のためのモジュールからなる。</p>
<ul>
<li><p>プロット</p></li>
<li><p>出力（数式をアスキーアートで表現したり LaTeX 記法で表記したり）</p></li>
<li><p>コード生成</p></li>
<li><p>物理学</p></li>
<li><p>統計学</p></li>
<li><p>組合せ論（この日本語何とかならないか）</p></li>
<li><p>数論</p></li>
<li><p>幾何学</p></li>
<li><p>論理学</p></li>
<li><p>and more</p></li>
</ul>
</li>
<li><p><code class="code docutils literal notranslate"><span class="pre">init_printing(use_unicode=True)</span></code> を私のコンソールで実行したら、豆腐系の文字化けが発生した。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">latex</span></code> で式の LaTeX コードを出力する。これはたいへん便利なので多用したい。</p></li>
</ul>
</section>
<section id="why-sympy">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Why SymPy?</a><a class="headerlink" href="#why-sympy" title="Permalink to this heading">¶</a></h3>
<p>CAS としての SymPy の利点を三つ挙げる。</p>
<ol class="arabic simple">
<li><p>完全フリー（自由・無料）である。</p></li>
<li><p>Python を利用する。Python で実行できる。</p></li>
<li><p>SymPy をライブラリーとして利用できる。</p></li>
</ol>
</section>
</section>
<section id="gotchas">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">Gotchas</a><a class="headerlink" href="#gotchas" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>SymPy は Python ライブラリーであるので、Python から来る制限は SymPy でも引き継がれる。</p>
<ul>
<li><p>さっきも書いたが、例えば Mathematica みたいに <code class="code docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span></code> と書いてしまうのはダメ。</p></li>
</ul>
</li>
</ul>
<section id="symbols">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Symbols</a><a class="headerlink" href="#symbols" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>さっきも書いたが、いきなり <code class="docutils literal notranslate"><span class="pre">x</span></code> は使えない。関数 <code class="docutils literal notranslate"><span class="pre">symbols</span></code> を呼び出してシンボルオブジェクトを生成する必要がある。</p>
<ul>
<li><p>この際可能な限り Python の変数と SymPy シンボルとを同じ名前に割り当てるようにする。この例では <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">symbols('x')</span></code> のようにする。</p></li>
<li><p>呼び出し <code class="code docutils literal notranslate"><span class="pre">symbols('x</span> <span class="pre">y</span> <span class="pre">z')</span></code> で三つのシンボルを一度に生成できる。</p></li>
</ul>
</li>
<li><p>式中のシンボルに値を代入（代入にも置換にも解釈できるのがミソ）するにはメソッド
<code class="docutils literal notranslate"><span class="pre">subs</span></code> を用いる。</p></li>
</ul>
</section>
<section id="equals-signs">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Equals signs</a><a class="headerlink" href="#equals-signs" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Eq</span></code> のオブジェクトは方程式を表現する。</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">Eq(lhs,</span> <span class="pre">rhs)</span></code> で <code class="code docutils literal notranslate"><span class="pre">lhs</span> <span class="pre">==</span> <span class="pre">rhs</span></code> を表現する方程式オブジェクトとなるわけだ。</p></li>
<li><p>単に <code class="code docutils literal notranslate"><span class="pre">lhs</span> <span class="pre">==</span> <span class="pre">rhs</span></code> とすると、両辺が構造的に一致していれば <code class="docutils literal notranslate"><span class="pre">True</span></code> が得られる。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">simplify</span></code> で引数の数式を簡略化する。</p>
<ul>
<li><p>詳しい説明は後述するらしい。</p></li>
<li><p>おそらく、式に含まれるシンボルの量をなるべく少なくするような式変形をするのだろう。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">equals</span></code> で式同士が同値かテストする。</p></li>
</ul>
</section>
<section id="two-final-notes-and">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Two Final Notes: <code class="docutils literal notranslate"><span class="pre">^</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code></a><a class="headerlink" href="#two-final-notes-and" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>演算子 <code class="docutils literal notranslate"><span class="pre">^</span></code> は Python の規約に従い排他的論理和とする。</p>
<ul>
<li><p>Xor という型のオブジェクトになるらしい。</p></li>
</ul>
</li>
<li><p>二項演算子 <code class="docutils literal notranslate"><span class="pre">/</span></code> の <code class="docutils literal notranslate"><span class="pre">int</span></code> 型値への適用は Python のバージョンにより整数除算か浮動小数点除算のどちらかになる。</p>
<ul>
<li><p>私は Python 3 を使うので、常に浮動小数点型の値を商として得る。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Integer</span></code> は整数を表現する。</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">Integer(a)/Integer(b)</span></code> は <code class="code docutils literal notranslate"><span class="pre">Integer(a)</span></code> が <code class="code docutils literal notranslate"><span class="pre">Integer(b)</span></code> の倍数でなければ <code class="docutils literal notranslate"><span class="pre">Rational</span></code> 型オブジェクトとなる。</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="basic-operations">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Basic Operations</a><a class="headerlink" href="#basic-operations" title="Permalink to this heading">¶</a></h2>
<section id="substitution">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Substitution</a><a class="headerlink" href="#substitution" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>式 <code class="docutils literal notranslate"><span class="pre">expr</span></code> 内のシンボル <code class="docutils literal notranslate"><span class="pre">x</span></code> に式 <code class="docutils literal notranslate"><span class="pre">y</span></code> を代入する操作は <code class="code docutils literal notranslate"><span class="pre">expr.subs(x,</span>
<span class="pre">y)</span></code> のように書く。</p></li>
<li><p>代入機能を利用する理由はふつうは次のうちのどれかである。</p>
<ol class="arabic simple">
<li><p>式をある値で評価するとき</p></li>
<li><p>式の部分に別の式を代入するようなとき</p></li>
</ol>
<p>式の簡略化や展開には微妙なケースがあるらしく、例えばある数式の特定の項だけを展開したいような場合は <code class="docutils literal notranslate"><span class="pre">subs</span></code> がうってつけらしい。</p>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">subs</span></code> は元の式を壊さない。そもそも SymPy の式オブジェクトは
immutable である。</p></li>
<li><p>多変数の同時代入例</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">expr</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span>

<span class="gp">In [2]: </span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gh">Out[2]: </span><span class="go">40</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="converting-strings-to-sympy-expressions">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Converting Strings to SymPy Expressions</a><a class="headerlink" href="#converting-strings-to-sympy-expressions" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">sympify</span></code> と <code class="docutils literal notranslate"><span class="pre">simplify</span></code> は違う。前者は文字列を SymPy の式にする関数。</p>
<ul>
<li><p>内部で Python の <code class="docutils literal notranslate"><span class="pre">eval</span></code> を呼び出すので危ないとのこと。</p></li>
<li><p>とは言え、数式の LaTeX 記法を手っ取り早く得る手段として有力のように思う。</p></li>
</ul>
</li>
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">evalf</span></code> で式全体を数値的に評価する。e.g. <code class="code docutils literal notranslate"><span class="pre">sqrt(8).evalf()</span></code></p>
<ul>
<li><p>引数で精度を指定できる。任意精度なのですごい。</p></li>
<li><p>キーワード引数 <code class="docutils literal notranslate"><span class="pre">chop</span></code> で丸め誤差を削れる。<code class="code docutils literal notranslate"><span class="pre">chop=True</span></code> とする。</p></li>
</ul>
</li>
<li><p>多数の値で評価するような場合は効率の観点から <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> の出番。
<code class="code docutils literal notranslate"><span class="pre">lambdify(x,</span> <span class="pre">expr,</span> <span class="pre">&quot;numpy&quot;)(a),</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">array()</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy.sin</span></code> を利用するという意味か？</p></li>
<li><p>自作関数を利用する方法も提供しているが、これ使うか？</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="printing">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Printing</a><a class="headerlink" href="#printing" title="Permalink to this heading">¶</a></h2>
<p>ところで pretty print を日本語でどう表現するのがよいだろうか。</p>
<section id="printers">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Printers</a><a class="headerlink" href="#printers" title="Permalink to this heading">¶</a></h3>
<p>SymPy は数式をさまざまなフォームで出力するように制御できる。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>str</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">print</span></code> による出力形式</p></td>
</tr>
<tr class="row-even"><td><p>repr</p></td>
<td><p>式を厳密な表現で出力する</p></td>
</tr>
<tr class="row-odd"><td><p>ASCII pretty printer</p></td>
<td><p>アスキーアート</p></td>
</tr>
<tr class="row-even"><td><p>Unicode pretty printer</p></td>
<td><p>豆腐</p></td>
</tr>
<tr class="row-odd"><td><p>LaTeX</p></td>
<td><p>標準的な数式の記法</p></td>
</tr>
<tr class="row-even"><td><p>MathML</p></td>
<td><p>XML による</p></td>
</tr>
<tr class="row-odd"><td><p>Dot</p></td>
<td><p>Graphviz 向け</p></td>
</tr>
</tbody>
</table>
</section>
<section id="setting-up-pretty-printing">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Setting up Pretty Printing</a><a class="headerlink" href="#setting-up-pretty-printing" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">init_printing</span></code> を引数なしで呼び出して、出力制御を初期化する。</p>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">init_session</span></code> が <code class="docutils literal notranslate"><span class="pre">init_printing</span></code> を内部で呼び出す。</p></li>
</ul>
</li>
<li><p><strong class="command">ipython qtconsole</strong> かつ LaTeX がインストール済みならば、 LaTeX を使用する printer を採用する。</p>
<ul>
<li><p><strong class="command">conda install qtconsole</strong> で調達可能。同時に Jupyter のコアパッケージもインストールされる。</p></li>
<li><p>以前は <code class="docutils literal notranslate"><span class="pre">--pylab=inline</span></code> のようなコマンドラインオプションも書いていたと記憶しているが、現在では deprecated である。</p></li>
<li><p>出来た！</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/sympy-printing-latex.png"><img alt="数式を LaTeX によるイメージで出力する" src="../_images/sympy-printing-latex.png" style="width: 303.5px; height: 283.0px;" /></a>
</figure>
</li>
<li><p><a class="reference external" href="https://matplotlib.org/">Matplotlib</a> がインストール済みでも OK とのこと。</p></li>
<li><p>IPython notebook では MathJax を使って LaTeX を描画する。</p></li>
</ul>
</li>
<li><p>IPython もしくは Python セッションでは Unicode 出力。ターミナルによる。私のコンソールは豆腐になる。</p>
<ul class="simple">
<li><p>豆腐が嫌なら <code class="code docutils literal notranslate"><span class="pre">init_printing(use_unicode=False)</span></code> する。</p></li>
</ul>
</li>
</ul>
</section>
<section id="printing-functions">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Printing Functions</a><a class="headerlink" href="#printing-functions" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>ユーザーが出力関数を明示的に指示することが可能。</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">str(expr)</span></code> と <code class="code docutils literal notranslate"><span class="pre">print(expr)</span></code> の見てくれは同じ。</p></li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">srepr(expr)</span></code>: <code class="docutils literal notranslate"><span class="pre">expr</span></code> の「厳密な」表現。</p></li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">pprint()</span></code>: ASCII; Unicode をサポートしないターミナルでのデフォルト。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">pretty</span></code></p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">pretty(expr,</span> <span class="pre">use_unicode=False)</span></code>: string form</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">pretty(expr,</span> <span class="pre">use_unicode=True)</span></code>: Unicode form</p></li>
</ul>
</li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">latex(expr)</span></code> で LaTex form にする。</p></li>
<li><p>MathML は少し面倒。関数 <code class="docutils literal notranslate"><span class="pre">print_mathml</span></code> がサブモジュール <code class="docutils literal notranslate"><span class="pre">sympy.printing.mathml</span></code> にある。</p></li>
<li><p>Graphviz 用の <code class="code docutils literal notranslate"><span class="pre">dotprint(expr)</span></code> もある。</p></li>
</ul>
</section>
</section>
<section id="simplification">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">Simplification</a><a class="headerlink" href="#simplification" title="Permalink to this heading">¶</a></h2>
<section id="simplify">
<h3><a class="toc-backref" href="#id26" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">simplify</span></code></a><a class="headerlink" href="#simplify" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">simplify</span></code> は数式をもっとも単純な形になるようにがんばる。</p>
<ul>
<li><p>ただ単によくある単純化操作を適用するだけなので、思うような結果にならないこともある。</p></li>
<li><p>ムダに遅い。</p></li>
<li><p>ヒューリスティック。</p></li>
<li><p>対話的に利用するのがよいだろう。</p></li>
</ul>
</li>
</ul>
</section>
<section id="polynomial-rational-function-simplification">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Polynomial/Rational Function Simplification</a><a class="headerlink" href="#polynomial-rational-function-simplification" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">expand</span></code></p>
<ul>
<li><p>単項式の和の canonical form への展開。何？</p></li>
<li><p>名前からは簡略化をするものという印象はないし、実際大きくなる。しかし、しばしば式内の項同士でキャンセルが起こって小さくなる。よって、本関数を簡略化関数とみなすことがある。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">factor</span></code></p>
<ul>
<li><p>多項式の因数分解。有理数上での規約多項式の積の形に分解する。</p></li>
<li><p>多変数も OK だ。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">factor_list</span></code> は因数分解の結果をリストで返す。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">collect</span></code></p>
<ul>
<li><p>同類項をまとめる。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">expr.coeff(x,</span> <span class="pre">2)</span></code>: 式 <code class="docutils literal notranslate"><span class="pre">expr</span></code> の <code class="code docutils literal notranslate"><span class="pre">x**2</span></code> の係数を返す。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">cancel</span></code></p>
<ul>
<li><p>有理関数の約分。分子分母を共通因数のない多項式同士にする。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">factor</span></code> でも cancel できるが、式がすでに約分されているものかどうかを確認することだけ知りたければ <code class="docutils literal notranslate"><span class="pre">cancel</span></code> のほうがよい。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">apart</span></code></p>
<ul>
<li><p>部分分数分解。</p></li>
<li><p>本文のサンプルは pritty print の表示がズレていて読みづらい。</p></li>
</ul>
</li>
</ul>
</section>
<section id="trigonometric-simplification">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Trigonometric Simplification</a><a class="headerlink" href="#trigonometric-simplification" title="Permalink to this heading">¶</a></h3>
<p>三角関数編。</p>
<ul class="simple">
<li><p>SymPy 版の三角関数と逆三角関数の名前は Python 版の対応するものに準拠する。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">trigsimp</span></code></p>
<ul>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">simplify</span></code> の三角関数版。三角関数の恒等式に対して適用するのに向いている？</p></li>
<li><p>双曲線関数も OK だ。</p></li>
<li><p>例によってヒューリスティック。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">expand_trig</span></code></p>
<ul>
<li><p>三角関数の加法定理や倍角の公式を展開する場合に使える。e.g.
<code class="code docutils literal notranslate"><span class="pre">expand_trig(sin(x</span> <span class="pre">+</span> <span class="pre">y))</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="powers">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Powers</a><a class="headerlink" href="#powers" title="Permalink to this heading">¶</a></h3>
<p>べき乗・指数編。</p>
<ul class="simple">
<li><p>本節冒頭にある指数演算法則の説明が初心を思い出させる。Sufficient conditions to
hold は意外に頭にない。</p></li>
<li><p>デフォルトでは SymPy はシンボルを複素数の元とみなすことが判明。</p>
<ul>
<li><p>それを回避したければ <code class="docutils literal notranslate"><span class="pre">symbols</span></code> 呼び出し時にキーワード引数を適宜指定。</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">positive=True</span></code> と <code class="code docutils literal notranslate"><span class="pre">real=True</span></code> を例示。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ここではシンボル <code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> を正の実数とし、シンボル <code class="docutils literal notranslate"><span class="pre">a</span></code> と <code class="docutils literal notranslate"><span class="pre">b</span></code> を実数とする。</p>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">powsimp</span></code></p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">x**a</span> <span class="pre">*</span> <span class="pre">x**b</span></code> を <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code> に展開する。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">x**a</span> <span class="pre">*</span> <span class="pre">y**a</span></code> を <code class="code docutils literal notranslate"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">y)</span> <span class="pre">**</span> <span class="pre">a</span></code> に展開する。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">expand_power_exp</span></code> は <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code> を <code class="code docutils literal notranslate"><span class="pre">x**a</span> <span class="pre">*</span> <span class="pre">x**b</span></code> に展開する。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">expand_power_base</span></code> は <code class="code docutils literal notranslate"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">y)</span> <span class="pre">**</span> <span class="pre">a</span></code> を <code class="code docutils literal notranslate"><span class="pre">x**a</span> <span class="pre">*</span> <span class="pre">y**a</span></code> に展開する。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">powdenest</span></code> は <code class="code docutils literal notranslate"><span class="pre">(x**a)**b)</span></code> を <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">(a*b)</span></code> に展開する。</p></li>
<li><p>どの関数にもキーワード引数 <code class="docutils literal notranslate"><span class="pre">force</span></code> がある。シンボルが複素数でもムリヤリ展開するようだ。</p></li>
</ul>
</section>
<section id="exponentials-and-logarithms">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">Exponentials and logarithms</a><a class="headerlink" href="#exponentials-and-logarithms" title="Permalink to this heading">¶</a></h3>
<p>指数と対数編。</p>
<ul class="simple">
<li><p>SymPy が気を利かせて Python では与えていない <code class="code docutils literal notranslate"><span class="pre">ln</span> <span class="pre">=</span> <span class="pre">log</span></code> のような定義をしている。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">log</span></code> の引数は複素数でも当然構わないのだが、最初は面倒だからやめるか？ここで言う <code class="code docutils literal notranslate"><span class="pre">positive=True</span></code>, <code class="code docutils literal notranslate"><span class="pre">real=True</span></code> を暗黙に前提としていることが多いから。</p></li>
</ul>
<p>ここではシンボル <code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> を正の実数とし、シンボル <code class="docutils literal notranslate"><span class="pre">n</span></code> を実数とする。</p>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">expand_log</span></code></p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">log(x</span> <span class="pre">+</span> <span class="pre">y)</span></code> を <code class="code docutils literal notranslate"><span class="pre">log(x)</span> <span class="pre">+</span> <span class="pre">log(y)</span></code> に展開する。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">log(x</span> <span class="pre">**</span> <span class="pre">n)</span></code> を <code class="code docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">log(x)</span></code> に展開する。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">logcombine</span></code></p>
<ul>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">expand_log</span></code> の逆関数的なはたらきをする。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">log(x)</span> <span class="pre">+</span> <span class="pre">log(y)</span></code> を <code class="code docutils literal notranslate"><span class="pre">log(x</span> <span class="pre">+</span> <span class="pre">y)</span></code> に展開する。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">log(x)</span></code> を <code class="code docutils literal notranslate"><span class="pre">log(x</span> <span class="pre">**</span> <span class="pre">n)</span></code> に展開する。</p></li>
</ul>
</li>
<li><p>どちらの関数にもキーワード引数 <code class="docutils literal notranslate"><span class="pre">force</span></code> がある。</p></li>
</ul>
</section>
<section id="special-functions">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">Special Functions</a><a class="headerlink" href="#special-functions" title="Permalink to this heading">¶</a></h3>
<p>SymPy の実装している特別関数のうちのいくつかを紹介している。</p>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">factorial</span></code>: <code class="code docutils literal notranslate"><span class="pre">n</span> <span class="pre">=&gt;</span> <span class="pre">n!</span></code></p></li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">binomial(n,</span> <span class="pre">k)</span></code>: 記法はタテ括弧による。</p></li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">gamma(x)</span></code>: ガンマ関数そのもの。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">hyper</span></code></p>
<ul>
<li><p>これは知らん。Wikipedia のページを見たところ、初めて見る式だらけだ。</p></li>
</ul>
</li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.rewrite()</span></code>: 与えた関数で式を書き直す。</p>
<ul>
<li><p>E.g. <code class="docutils literal notranslate"><span class="pre">tan</span></code> を <code class="docutils literal notranslate"><span class="pre">sin</span></code> で書き換える。</p></li>
<li><p>E.g. <code class="docutils literal notranslate"><span class="pre">factorial</span></code> を <code class="docutils literal notranslate"><span class="pre">gamma</span></code> で書き換える。</p></li>
</ul>
</li>
<li><p>関数 <code class="code docutils literal notranslate"><span class="pre">expand_func(expr)</span></code>: 特別関数を恒等式を用いて展開する。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">hyperexpand</span></code>: 関数 <code class="docutils literal notranslate"><span class="pre">hyper</span></code> をもっと標準的な関数で書き換える。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">combsimp</span></code>: 組み合わせ関連の式の簡略化。</p>
<ul>
<li><p>E.g. <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 式同士の商を単純な式に簡略化する。</p></li>
<li><p>E.g. <code class="docutils literal notranslate"><span class="pre">binomial</span></code> 式同士の商を単純な式に簡略化する。</p></li>
<li><p>E.g. <code class="docutils literal notranslate"><span class="pre">gamma</span></code> 式同士の積を単純な三角関数の式に簡略化する。</p></li>
</ul>
</li>
</ul>
</section>
<section id="example-continued-fractions">
<h3><a class="toc-backref" href="#id32" role="doc-backlink">Example: Continued Fractions</a><a class="headerlink" href="#example-continued-fractions" title="Permalink to this heading">¶</a></h3>
<p>連分数の例。英語で continued fractions というのか。</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">symbols('a0:5')</span></code> の記法はおもしろい。</p></li>
<li><p>連分数を cancel する。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">apart</span></code> で部分分数分解しまくり。</p></li>
</ul>
</section>
</section>
<section id="calculus">
<h2><a class="toc-backref" href="#id33" role="doc-backlink">Calculus</a><a class="headerlink" href="#calculus" title="Permalink to this heading">¶</a></h2>
<section id="derivatives">
<h3><a class="toc-backref" href="#id34" role="doc-backlink">Derivatives</a><a class="headerlink" href="#derivatives" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">diff</span></code></p>
<ul>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">diff(x**4,</span> <span class="pre">x,</span> <span class="pre">x,</span> <span class="pre">x)</span></code>: 三階微分。</p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">diff(x**4,</span> <span class="pre">x,</span> <span class="pre">3)</span></code>: 同じ三階微分。</p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">diff(expr,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">z,</span> <span class="pre">z,</span> <span class="pre">z)</span></code>: 偏微分。</p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">diff(expr,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">2,</span> <span class="pre">z,</span> <span class="pre">4)</span></code>: 同じ偏微分。</p></li>
<li><p>メソッド形式の <code class="code docutils literal notranslate"><span class="pre">expr.diff(...)</span></code> も可。</p></li>
</ul>
</li>
<li><p>クラス Derivative</p>
<ul>
<li><p>未評価の微分オブジェクトのためのクラス。</p></li>
<li><p>あるいは SymPy が微分を求められないような式のためのクラス。</p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.doit()</span></code> で関数 <code class="docutils literal notranslate"><span class="pre">diff</span></code> と同じ結果を得る。</p></li>
<li><p>遅延評価に有用。</p></li>
</ul>
</li>
</ul>
</section>
<section id="integrals">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">Integrals</a><a class="headerlink" href="#integrals" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">integrate</span></code></p>
<ul>
<li><p>不定積分（原始関数）を得るのにも定積分を得るのにも用いる。</p></li>
<li><p>（例） <code class="code docutils literal notranslate"><span class="pre">integrate(cos(x),</span> <span class="pre">x)</span></code></p></li>
<li><p>定数項は含まないのでユーザーが適宜はからう。</p></li>
<li><p>定積分は積分域を指定する。</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">integrate(exp(-x),</span> <span class="pre">(x,</span> <span class="pre">0,</span> <span class="pre">oo))</span></code></p>
<ul>
<li><p>オブジェクト <code class="docutils literal notranslate"><span class="pre">oo</span></code> が無限大を表現するシンボルか。</p></li>
</ul>
</li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">integrate(exp(-x**2</span> <span class="pre">-</span> <span class="pre">y**2),</span> <span class="pre">(x,</span> <span class="pre">-oo,</span> <span class="pre">oo),</span> <span class="pre">(y,</span> <span class="pre">-oo,</span> <span class="pre">oo))</span></code>: 重積分</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Integral</span></code></p>
<ul>
<li><p>用途は <code class="docutils literal notranslate"><span class="pre">Derivative</span></code> の積分版といったところ。</p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.doit()</span></code> で関数 <code class="docutils literal notranslate"><span class="pre">integrate</span></code> と同じ結果を得る。</p></li>
</ul>
</li>
<li><p>最後のほう、何を述べているのかわからない。</p></li>
</ul>
</section>
<section id="limits">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">Limits</a><a class="headerlink" href="#limits" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">limit</span></code></p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">expr.subs(x,</span> <span class="pre">oo)</span></code> などのようにせず <code class="code docutils literal notranslate"><span class="pre">limit(expr,</span> <span class="pre">x,</span> <span class="pre">oo)</span></code> とすること</p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">limit(sin(x)/x,</span> <span class="pre">x,</span> <span class="pre">0)</span></code>: <code class="docutils literal notranslate"><span class="pre">x</span></code> が 0 に近づくときの極限。</p></li>
</ul>
</li>
<li><p>クラス <code class="docutils literal notranslate"><span class="pre">Limit</span></code></p>
<ul>
<li><p>用途は <code class="docutils literal notranslate"><span class="pre">Derivative</span></code> や <code class="docutils literal notranslate"><span class="pre">Integral</span></code> の極限版といったところ。</p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.doit()</span></code> で関数 <code class="docutils literal notranslate"><span class="pre">limit</span></code> と同じ結果を得る。</p></li>
</ul>
</li>
<li><p>右極限、左極限</p>
<ul>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">limit(1/x,</span> <span class="pre">x,</span> <span class="pre">0,</span> <span class="pre">'+')</span></code></p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">limit(1/x,</span> <span class="pre">x,</span> <span class="pre">0,</span> <span class="pre">'-')</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="series-expansion">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">Series Expansion</a><a class="headerlink" href="#series-expansion" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>メソッド <code class="docutils literal notranslate"><span class="pre">series</span></code></p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">expr.series(x,</span> <span class="pre">x0,</span> <span class="pre">n)</span></code> のようにして、関数 <code class="docutils literal notranslate"><span class="pre">expr</span></code> のある点 <code class="docutils literal notranslate"><span class="pre">x0</span></code> における <code class="docutils literal notranslate"><span class="pre">n</span></code> 次の級数展開を得る。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">x0</span></code> のデフォルト値は 0 である。Maclaurin 展開。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> のデフォルト値は 6 である。</p></li>
</ul>
</li>
<li><p>出力に <code class="code docutils literal notranslate"><span class="pre">O(x**n)</span></code> のような項が出てくる。</p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.removeO()</span></code> でオーダー項が省略できる。</p></li>
</ul>
</li>
</ul>
</section>
<section id="finite-differences">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">Finite differences</a><a class="headerlink" href="#finite-differences" title="Permalink to this heading">¶</a></h3>
<p>差分商はわからん。</p>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">as_finite_diff</span></code></p>
<ul>
<li><p>任意の <code class="docutils literal notranslate"><span class="pre">Derivative</span></code> オブジェクトに対して、任意階数の微分値の近似を生成できる。</p></li>
<li><p>ここの最初の例は「ある関数 <code class="docutils literal notranslate"><span class="pre">f</span></code> の一次微分」を <code class="code docutils literal notranslate"><span class="pre">f(x</span> <span class="pre">-</span> <span class="pre">1/2)</span></code> と
<code class="code docutils literal notranslate"><span class="pre">f(x</span> <span class="pre">+</span> <span class="pre">1/2)</span></code> で近似している。</p></li>
<li><p>その次の例は「ある関数 <code class="docutils literal notranslate"><span class="pre">f</span></code> の二次微分」を定義域内の値 <code class="docutils literal notranslate"><span class="pre">h</span></code> について、以下の値を用いて近似している：</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">f(-3</span> <span class="pre">*</span> <span class="pre">h)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">f(-h)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">f(2</span> <span class="pre">*</span> <span class="pre">h)</span></code></p></li>
</ul>
</li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">finite_diff_weights</span></code></p>
<ul>
<li><p>各 <code class="code docutils literal notranslate"><span class="pre">f(h)</span></code> の項の係数だけ欲しい場合に用いる。</p></li>
<li><p>もはや <code class="docutils literal notranslate"><span class="pre">f</span></code> も <code class="docutils literal notranslate"><span class="pre">h</span></code> も引数に要求されないことに注意。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">apply_finite_diff</span></code></p>
<ul>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">finite_diff_weights</span></code> を直に使うのは複雑だし、関数 <code class="docutils literal notranslate"><span class="pre">as_finite_diff</span></code>
を <code class="docutils literal notranslate"><span class="pre">f</span></code> 的なものに操作するのは柔軟性に欠くようならば、本関数を検討する。</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="solvers">
<h2><a class="toc-backref" href="#id39" role="doc-backlink">Solvers</a><a class="headerlink" href="#solvers" title="Permalink to this heading">¶</a></h2>
<p>方程式を解く。</p>
<section id="a-note-about-equations">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">A Note about Equations</a><a class="headerlink" href="#a-note-about-equations" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>もう一度言うが SymPy では記号方程式を <code class="docutils literal notranslate"><span class="pre">Eq</span></code> オブジェクトを用いて表現する。</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> を表現したいならばオブジェクト <code class="code docutils literal notranslate"><span class="pre">Eq(x,</span> <span class="pre">y)</span></code> を生成する。</p></li>
</ul>
</li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">solve</span></code></p>
<ul>
<li><p>方程式を指定した未知数シンボルについて解く。</p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">solve(Eq(x**2,</span> <span class="pre">1),</span> <span class="pre">x)</span></code>: プラマイ 1 を根とする <code class="docutils literal notranslate"><span class="pre">x</span></code> の二次方程式を解く。</p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">solve(x**2</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">x)</span></code>: 同上。</p></li>
</ul>
</li>
</ul>
</section>
<section id="solving-equations-algebraically">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">Solving Equations Algebraically</a><a class="headerlink" href="#solving-equations-algebraically" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">solve</span></code></p>
<ul>
<li><p>呼び出しの構文は <code class="code docutils literal notranslate"><span class="pre">solve(equations</span> <span class="pre">variables)</span></code></p></li>
<li><p>単一の方程式を解くときは、関数 <code class="docutils literal notranslate"><span class="pre">solve</span></code> の戻り値は解の <code class="docutils literal notranslate"><span class="pre">list</span></code> である。</p></li>
<li><p>解が見つからない（存在しないとは言っていない）場合、次のどちらかが起こる。</p>
<ul>
<li><p>空の <code class="docutils literal notranslate"><span class="pre">list</span></code> が返る。</p></li>
<li><p>例外 <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code> が発生する。</p></li>
</ul>
</li>
<li><p><code class="code docutils literal notranslate"><span class="pre">solve(f(x,</span> <span class="pre">y),</span> <span class="pre">[x,</span> <span class="pre">y])</span></code> の形で連立方程式が解けるかもしれない。</p>
<ul>
<li><p>多項方程式の重根の多重度も欲しい場合は、関数 <code class="docutils literal notranslate"><span class="pre">roots</span></code> を用いる。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="solving-differential-equations">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">Solving Differential Equations</a><a class="headerlink" href="#solving-differential-equations" title="Permalink to this heading">¶</a></h3>
<p>ここの例に出てくるのは常微分方程式。</p>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">dsolve</span></code> は微分方程式の解を求める。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Function</span></code> オブジェクトが要る。</p>
<ul>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">symbols</span></code> でキーワード引数 <code class="code docutils literal notranslate"><span class="pre">cls=Function</span></code> を指定する。</p></li>
</ul>
</li>
<li><p><code class="code docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">f(x))</span></code> の形。</p></li>
<li><p>戻り値は <code class="docutils literal notranslate"><span class="pre">Eq</span></code> オブジェクトである。解が <code class="code docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">...</span></code> の形に解けるとは限らないため。</p></li>
<li><p>不定積分のときとは異なり、今度は解に任意定数が出てくる。</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="matrices">
<h2><a class="toc-backref" href="#id43" role="doc-backlink">Matrices</a><a class="headerlink" href="#matrices" title="Permalink to this heading">¶</a></h2>
<p>クラス <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> のコンストラクターは <code class="code docutils literal notranslate"><span class="pre">np.array</span></code> のそれに似ている。</p>
<ul class="simple">
<li><p>ただし単リストを引数とすると、生成する行列は列ベクトルの形になる。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Matrix</span></code> のオブジェクトは SymPy の型にしては珍しく mutable である。</p></li>
<li><p>一応 immutable 版の行列型 <code class="docutils literal notranslate"><span class="pre">ImmutableMatrix</span></code> も提供している。</p></li>
</ul>
<section id="id3">
<h3><a class="toc-backref" href="#id44" role="doc-backlink">Basic Operations</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<p>どうも NumPy の array にインターフェイスがよく似ているようだ。</p>
<ul class="simple">
<li><p>プロパティー <code class="code docutils literal notranslate"><span class="pre">.shape</span></code>: 行列の寸法。</p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.row(i)</span></code>, および <code class="code docutils literal notranslate"><span class="pre">.col(i)</span></code>: 列全体および行全体にアクセス。</p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.row_del(i)</span></code>, <code class="code docutils literal notranslate"><span class="pre">.col_del(i)</span></code>: 列全体および行全体を削除。</p>
<ul>
<li><p>これらは in-place に作用する。</p></li>
</ul>
</li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.row_insert(i,</span> <span class="pre">M)</span></code>, <code class="code docutils literal notranslate"><span class="pre">.col_insert(i,</span> <span class="pre">M)</span></code>: 列全体および行全体を追加。</p>
<ul>
<li><p>これらは in-place に作用しない。</p></li>
</ul>
</li>
</ul>
</section>
<section id="basic-methods">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">Basic Methods</a><a class="headerlink" href="#basic-methods" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>加算、乗算は普通に演算子で行える。</p>
<ul>
<li><p>二項演算子 <code class="docutils literal notranslate"><span class="pre">+</span></code> で加算。</p></li>
<li><p>二項演算子 <code class="docutils literal notranslate"><span class="pre">*</span></code> でスカラー倍あるいは行列同士の乗算。</p></li>
<li><p>二項演算子 <code class="docutils literal notranslate"><span class="pre">**</span></code> でべき乗。逆行列もこの記法で <code class="code docutils literal notranslate"><span class="pre">M</span> <span class="pre">**</span> <span class="pre">-1</span></code> のように表現する。</p></li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">.T</span></code> で転置行列を返す。</p></li>
</ul>
</li>
</ul>
</section>
<section id="matrix-constructors">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">Matrix Constructors</a><a class="headerlink" href="#matrix-constructors" title="Permalink to this heading">¶</a></h3>
<p>これも NumPy のスタイルを踏襲しているように見える。もしかすると逆かもしれない。</p>
<ul class="simple">
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">eye</span></code> で指定次元の単位行列を生成する。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">zeros</span></code> で指定サイズの零行列を生成する。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">ones</span></code> で指定サイズの行列を生成する。各成分は 1 である。</p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">diag</span></code> で対角行列を生成する。次のどれかが引数になる。</p>
<ul>
<li><p>スカラーのみを左上から右下までカンマ区切りで一気に指定する。結果は正方行列になる。</p></li>
<li><p>スカラーか行列で同様にカンマ区切りで一気に指定する。</p></li>
</ul>
</li>
</ul>
</section>
<section id="advanced-methods">
<h3><a class="toc-backref" href="#id47" role="doc-backlink">Advanced Methods</a><a class="headerlink" href="#advanced-methods" title="Permalink to this heading">¶</a></h3>
<p>NumPy にあるものとないものがあるようだ。</p>
<ul class="simple">
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.det()</span></code> で行列式の値を返す。</p></li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.rref()</span></code> は行列の reduced row echelon form を得る。</p>
<ul>
<li><p>戻り値は行列の reduced row echelon form とピボット列の添字の <code class="docutils literal notranslate"><span class="pre">list</span></code> のペアである。</p></li>
</ul>
</li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.nullspace()</span></code> で行列の nullspace を探す。</p>
<ul>
<li><p>戻り値はその nullspace を張る列ベクトルの <code class="docutils literal notranslate"><span class="pre">list</span></code> である。</p></li>
</ul>
</li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.eigenvals()</span></code> は行列の固有値を探す。</p>
<ul>
<li><p>戻り値はキーと値がそれぞれ固有値と（固有多項式の根としての）多重度の
<code class="docutils literal notranslate"><span class="pre">dict</span></code> である。</p></li>
</ul>
</li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.eigenvects()</span></code> は行列の固有ベクトルを探す。</p>
<ul>
<li><p>戻り値は中身が次のような造りの <code class="docutils literal notranslate"><span class="pre">tuple</span></code> の <code class="docutils literal notranslate"><span class="pre">list</span></code> である。</p>
<ol class="arabic simple">
<li><p>固有値</p></li>
<li><p>多重度</p></li>
<li><p>固有ベクトルの <code class="docutils literal notranslate"><span class="pre">list</span></code></p></li>
</ol>
</li>
<li><p>固有ベクトルの計算はたいていコストがかかるので、固有値だけ欲しい場合は <code class="code docutils literal notranslate"><span class="pre">.eigenvals()</span></code> で済ませるのがよい。</p></li>
</ul>
</li>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.diagonalize()</span></code> は行列を対角化する。</p>
<ul>
<li><p>戻り値は <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> のペアである。それぞれ <code class="code docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">P</span> <span class="pre">*</span> <span class="pre">D</span> <span class="pre">*</span> <span class="pre">(P</span> <span class="pre">**</span> <span class="pre">-1)</span></code> なる <code class="docutils literal notranslate"><span class="pre">P</span></code> と <code class="docutils literal notranslate"><span class="pre">D</span></code> である。</p></li>
</ul>
</li>
<li><p>行列の固有多項式が欲しいだけならばメソッド <code class="code docutils literal notranslate"><span class="pre">.charpoly</span></code> を使う。</p>
<ul>
<li><p>メソッド <code class="code docutils literal notranslate"><span class="pre">.eigenvals()</span></code> よりも効率が良い。</p></li>
</ul>
</li>
<li><p>SymPy では <code class="docutils literal notranslate"><span class="pre">lambda</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">lamda</span></code> とつづる。スペリングをうろ覚えの人のようでみっともないが、仕方がない。</p></li>
</ul>
</section>
</section>
<section id="advanced-expression-manipulation">
<h2><a class="toc-backref" href="#id48" role="doc-backlink">Advanced Expression Manipulation</a><a class="headerlink" href="#advanced-expression-manipulation" title="Permalink to this heading">¶</a></h2>
<section id="understanding-expression-trees">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">Understanding Expression Trees</a><a class="headerlink" href="#understanding-expression-trees" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>SymPy は数式を木のように表現する。</p>
<ul>
<li><p>この木を見るには関数 <code class="docutils literal notranslate"><span class="pre">srepr</span></code> を用いる。数式の木構造を文字列の形で見られる。</p></li>
</ul>
</li>
<li><p>チュートリアルの図は Graphviz と関数 <code class="docutils literal notranslate"><span class="pre">dotprint</span></code> を組み合わせて作られた。</p>
<ul>
<li><p>木の葉に相当する要素は <code class="docutils literal notranslate"><span class="pre">Symbol</span></code> や <code class="docutils literal notranslate"><span class="pre">Integer</span></code> など。</p></li>
<li><p>それ以外の要素は <code class="docutils literal notranslate"><span class="pre">Add</span></code> や <code class="docutils literal notranslate"><span class="pre">Mul</span></code> がある。</p></li>
</ul>
</li>
<li><p>除算のクラスは SymPy には存在しない。<code class="docutils literal notranslate"><span class="pre">Pow</span></code> と <code class="docutils literal notranslate"><span class="pre">-1</span></code> を組み合わせて表現する。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Rational</span></code> は数同士</p></li>
</ul>
</li>
<li><p><code class="code docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">x</span></code> を評価すると <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> と出力されるのは、SymPy の <code class="docutils literal notranslate"><span class="pre">Add</span></code> がオペランドを任意の（とはいえ整合性のある）順序に並べることから。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Add</span></code> というよりは、可換則の成り立つ演算の際には、ということ。</p></li>
</ul>
</li>
</ul>
</section>
<section id="recursing-through-an-expression-tree">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">Recursing through an Expression Tree</a><a class="headerlink" href="#recursing-through-an-expression-tree" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">func</span></code></p>
<ul>
<li><p>式の「先頭」のオブジェクトである。</p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">(x*y).func</span></code> は <code class="docutils literal notranslate"><span class="pre">Mul</span></code> オブジェクトである。</p></li>
<li><p>ふつうは式オブジェクトのクラスと一致する。</p></li>
<li><p>一致しない場合もあり得る。</p>
<ul>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">Add(x,</span> <span class="pre">x)</span></code> は実は <code class="code docutils literal notranslate"><span class="pre">Mul(2,</span> <span class="pre">x)</span></code> である。</p></li>
<li><p>SymPy は <code class="docutils literal notranslate"><span class="pre">__new__</span></code> を多用していて、別のクラスのコンストラクターが返されることがあり得る。</p></li>
</ul>
</li>
</ul>
</li>
<li><p>プロパティー <code class="docutils literal notranslate"><span class="pre">args</span></code></p>
<ul>
<li><p>式オブジェクトの（木を逆さに見るときの）トップレベルの引数を指す。</p></li>
<li><p>E.g. <code class="code docutils literal notranslate"><span class="pre">(3*y**2*x).args</span></code> は <code class="code docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">x,</span> <span class="pre">y**2)</span></code> である。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code> と <code class="docutils literal notranslate"><span class="pre">args</span></code> から、元の式が完全に再現できる。</p></li>
</ul>
</section>
<section id="walking-the-tree">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">Walking the Tree</a><a class="headerlink" href="#walking-the-tree" title="Permalink to this heading">¶</a></h3>
<p>ジェネレーター <code class="docutils literal notranslate"><span class="pre">preorder_traversal</span></code> と <code class="docutils literal notranslate"><span class="pre">postorder_traversal</span></code> で数式の木構造を走査できる。</p>
</section>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="doc.html" title="Previous document">ドキュメントをビルドする</a>
        </li>
        <li>
          <a href="plotting.html" title="Next document">プロットを利用する</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
      </div>
      <div class="clearer"></div>
    </div>
<div class="footer">
  <ul>
    <li id="footer_logo">
      <a class="image-reference" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="../_static/logos.png"/></a>
    </li>
    <li id="footer_copyright">
      Copyright &copy; 1999-2023, プレハブ小屋 All rights reserved.
    </li>
  </ul>
</div>
  </body>
</html>