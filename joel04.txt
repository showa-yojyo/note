======================================================================
Joel on Software 読書ノート
======================================================================

この手の本も読んでみようと思ったら、なんとも内容が濃い。
ページが下線だらけになってしまった。

:著者: Joel Spolsky
:訳者: 青木靖
:出版社: オーム社
:ISBN: ISBN4-274-06630-4

.. contents:: ノート目次

イントロダクション
======================================================================
* <この本はとても主観的だ。私は簡潔さのため、
  強いて「私の意見では」という言葉を文章の先頭に入れなかった。
  それというのも、読んでいけば分かることなのだが、
  この本の文章の一行一行がすべて私の意見だからだ。> (p. 4)

* <私はこの本を三つのパートに分けた。
  最初のパートは小規模ソフトウェアに関すること。
  人を苦しめないソフトウェアを作るために、
  あなたのチームがすべきことがすべて、そこに書かれている。> (p. 5)
  本書全体についてノートを取るのはキツいので、
  著者の言う「最初のパート」だけ挑戦してみる。

第 1 章
----------------------------------------------------------------------
* 著者は短期開発で GUI プログラムを製作する必要に迫られたならば、
  VB を好んで選択するが、
  <配布ファイルのサイズが大きくなるのは避けられず、
  Windows にロックインされることになる> (p. 9) と考えている。
  前者はそれほど大したことないが、後者がイタイ。
* VB. NET と C# .NET は事実上同じもの。

第 2 章
----------------------------------------------------------------------
* <人々が犯す大きな誤りの中には、（略）
  最も低いレベルの単純な事柄に対する貧弱な理解や破綻した理解が原因で生まれているものがある> (p. 11)
* C 言語でよく使うスタイルの文字列のことを ASCIZ と呼んでいる。
  この章では Pascal 式文字列とASICZ との対比を議論している。
  これを読むと Pascal 式の方が利点が多いようだ。
* <宿題として、なぜ（以下略）> (p. 20) は、
  著者が「最も低いレベルの単純な事柄」を軽視していないことが窺える。

第 3 章
----------------------------------------------------------------------
著名な「ジョエルテスト」に関する記事。これをノートしないわけにはいかない。

1. ソース管理してる？
2. ワンステップでビルドできる？
3. デイリービルドしてる？
4. バグデータベースはある？
5. 新しいコードを書く前にバグを直している？
6. アップデートされているスケジュールがある？
7. 仕様書はある？
8. プログラマは静かな環境で仕事してる？
9. 手に入る最高のツールを使っている？
10. テスタはいる？
11. 採用面接のときにコードを書かせている？
12. ユーザビリティテストはしてる？ (p.23)

* <ジョエルテストの欠点は、原子力発電所向けソフトウェアが安全かどうかのチェックには使えない> (p. 24)
* <Miscrosoft のような会社は常に 12 ポイントで運営されている> (p. 24)
* <他の全ての条件が同じなら、この 12 項目をちゃんとやることで、
  堅実に製品をリリースできる統率の取れたチームができるだろう> (p. 24)

* 項目 2 の要点は、<最新のソースコードのスナップショットからリリース用のビルドを作るのに、
  どれくらいのステップが必要かということ> (p. 25)
  で、もっと突っ込むと、このステップ数が 1 であることを理想とする。

* デイリービルドの目的は、ビルドが壊れているのに気づかないという事態がないようにするため。

* <バグデータベースは複雑なものでもシンプルなものでもいい> (p. 26)
  エクセル一丁だろうが Trac だろうがいいということと解釈して構わないだろう。

* 無限欠陥法 (return 12;) のエピソードは面白い。
* 新コードを書く前にバグを修正することの重要性を、紙幅を裂いて説いている。
  一番の理由は時間が経ってから修正するのは通常困難だということのようだ。

* 言われてみると、放っておくと仕様書を書かない。

* 「ゾーン状態に入る」というのは「精神を集中して作業に没頭する」ことか。
  同僚の割り込みはその気になれば追い返せるが、
  客の電話問い合わせという割り込みがあるとキツイ。

* いいツールを利用するというのは大前提。
  <もしコンパイルに数秒よりも長くかかっているようなら、
  一番新しくて性能のいいコンピュータを買えば時間を節約できる> (p. 32) というセンスが我々には必要。
  トイレットペーパーと HDD の値段比較の話もインパクトがあっていい。

* <テスタの費用をケチるというのは非常に不経済> (p. 32)

* 最後にジョエルテストの使い方を指南して、この章を終えている。

  * <あなたがプログラミングチームのマネージャなら、
    このチェックリストでチームが最大限にうまく機能しているかどうか確かめてほしい> (p. 35)
  * 新しい仕事を受注する場合、ジョエルテストをしてスコアが低かったとする。
    そのときには <あなたにそれを改善する権限が与えられることを確認しよう> (p. 35)

* あとがきで、著者が受け取った世界中の開発者からのレポートを分析している。

  * スコアの分布は 2 と 3 の間に山がある。
  * <ジョエルテストのスコアが病的に低い> (p. 36) と思える会社からのオファーを蹴った開発者多数。

* <Visual なんたらかんたら Enterprise Architect> (p. 36)

第 4 章
----------------------------------------------------------------------
* <キャラクタセット、エンコーディング、Unicode などの謎めいた世界について、
  多くのソフトウェア開発者がまったく理解していない> (p. 37)
* ASCII: 32 より小さい文字は印字不能文字

  * <彼らは皆それぞれ、128〜255 のスペースの使い方に独自の考えを持っていた> (p. 40)
  * <上位の 128 文字を独自の目的に使っていた> (p. 40)
  * <これらの異なるシステムは **コードページ** と呼ばれた> (p. 41)

* DBCS: Double Byte Character Set

  * 1 バイト文字と 2 バイト文字が混在しているゆえ、
    <後ろから読んでいくことはほとんど不可能> (p. 41)

Unicode
~~~~~~~
* <これまでは、文字はディスクやメモリに格納されるビット列にマップされるものだと想定していた。
  一方 Unicode では、文字は **コードポイント** と呼ばれるものにマップされる> (p. 42)
  コードポイントとは単なる整数と思っていたほうがいいようだ。
  A は U+0041 のように表現できる。

  * Unicode は集合で、自然数全体からなる集合と一対一対応がとれるものだと解釈して差し支えなさそう。

エンコーディング
~~~~~~~~~~~~~~~~
* ``FE FF`` (or ``FF FE``): バイトマークオーダー
* <UTF-8 は、Unicode コードポイント、つまりあの U+ マジックナンバーの文字列を、
  8 ビットバイトを使ってメモリに格納する新しい仕組みだ> (p. 45)
  
  * コードポイントの範囲ごとに、消費するバイト数を変えている。
    特に 127 以下のコードポイントは 1 バイトで格納するようにしたので、
    <英語のテキストが UTF-8 と ASCII でまったく同じになるという具合のいい副作用がある> (p. 45)

* 3 種類のエンコード方法

  * UCS-2 (UTF-16): エンディアンを見分ける方法が必要。
  * UTF-8

* 英語のテキストで人気があるのは、Windows-1252 と ISO-8859-1 (Latin-1) だそうだ。

エンコーディングに関する最も重要な事実
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* 文字列がどのエンコーディングなのかを知る方法について議論している。

  * メールの場合は ``Content-Type: text/plain; charset="UTF-8"`` のような文字列を探す。
  * Web ページの場合は、``meta`` タグの中にある同様の文字列を探す。
    ただし、見つけたらページの解析を途中で捨てて、そのエンコーディングで先頭から解析しなおす。

* 著者の会社で開発している Web サイト管理ソフトでは、
  <すべての内部的処理を Visual Basic, COM, Windows NT/2000/XP のネイティブな文字列型である
  UCS-2 で行うようにした> (p. 49) とある。
  C++ のコードならば wchar_t 系のデータ、API を利用するわけだ。
  UTF-8 に変換しやすい？

* この章の締め括りの言葉がふるっている。
  <後はあなたにゆだねることにしよう> (p. 49)

第 5 章
----------------------------------------------------------------------
* <ジョエルテストを発表したとき、読者から寄せられた最大の不満の種は、
  仕様書を書かなければいけないということだった> (p. 51) みんな同じ感想を持つのだな。
* 仕様書を書かないことは、<**最大かつ不必要なリスク**> (p. 51)
* <仕様書の最も重要な役割は、 **プログラムをデザインすること**> (p. 51)
  で、<あなたがプログラミング言語で製品をデザインしているなら、
  反復デザインには **何週間** もかかる> (p. 54)
* 仕様書を書いておくことで、もうひとつの時間も節約できる。
  <あなたが仕様書を書いておけば、プログラムがどう動くと想定されているかを
  **一度だけ** 説明すれば済む> (p. 54)
* そもそも <詳細な仕様書がないと、スケジュールが立てられない> (p. 56)
* 難しい決断を最後に残さないこと。プロジェクトは失敗する。
* 著者自身は、<仕様書が書かれない理由は、多くの人々が書くことを嫌いなためだと思っている> (p. 57)

第 6 章
----------------------------------------------------------------------
* 冒頭で「技術仕様」と「機能仕様」の定義を行い、
  著者はここでは後者を議論すると宣言している。

  * <機能仕様書には、ユーザーの観点から製品がどのように動くかを記述する> (p. 59)

* ここからたっぷり紙幅を裂いて、サンプル仕様書を紙上に再現している。
  何と言うか、情感豊かな表現になっている。役所の書類とかとは全然違う。

* <仕様書は **1 人の人間** によって書かれ、所有されるべきだ> (p. 68)
* <製品のターゲット層から、製品をまったく典型的な仕方で使うような、
  まったく想像上のまったく類型的なユーザをイメージしよう> (p. 68)
* 対象外の項目をできる限り早く表明しておくことが重要。
  さもないと、開発に際限なく時間を費やすことになる。
* 仕様書に概要を入れておくことで、読者に機能の全体像を把握させる。
* <**詳細** は、機能仕様書で最も重要な部分> (p. 70)
* 未解決の問題も記入しておく。
* 機能仕様書ではあるが、技術的なノートも入れておく。
  <たとえば、実装上の技術的詳細について述べたプログラマ向けのメッセージを
  「テクニカルノート」として記す。マーケティングの人々はその部分を無視し、
  プログラマは食い入るように読む> (p. 70)

* <**仕様書は生きている必要がある**> (p. 71)

  * 私（著者）の仕様書はいつもアップデートされている。
  * 通常は、アップデートした仕様書をサーバーのどこか、
    チームが参照できるところに置いておく。
  * 仕様書を凍結するのは、コードフリーズと同時。
