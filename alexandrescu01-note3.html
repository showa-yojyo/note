<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modern C++ Design 読書ノート 3/3 &mdash; 読書ノート v1.2.0</title>
    
    <link rel="stylesheet" href="_static/prefab.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/twitter-button.js"></script>
    <link rel="top" title="読書ノート v1.2.0" href="index.html" />
    <link rel="up" title="Modern C++ Design 読書ノート" href="alexandrescu01.html" />
    <link rel="next" title="Effective STL 読書ノート" href="meyers01.html" />
    <link rel="prev" title="Modern C++ Design 読書ノート 2/3" href="alexandrescu01-note2.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート v1.2.0</a> &raquo;</li>
          <li><a href="alexandrescu01.html" accesskey="U">Modern C++ Design 読書ノート</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="modern-c-design-3-3">
<h1><a class="toc-backref" href="#id4">Modern C++ Design 読書ノート 3/3</a><a class="headerlink" href="#modern-c-design-3-3" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="alexandrescu01-note2.html"><em>Modern C++ Design 読書ノート 2/3</em></a> からの続き。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Andrey Alexandrescu</td>
</tr>
<tr class="field-even field"><th class="field-name">訳者:</th><td class="field-body">村上雅章</td>
</tr>
<tr class="field-odd field"><th class="field-name">出版社:</th><td class="field-body">ピアソン・エデュケーション</td>
</tr>
<tr class="field-even field"><th class="field-name">ISBN:</th><td class="field-body">4-89471-435-3</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">ノート目次</p>
<ul class="simple">
<li><a class="reference internal" href="#modern-c-design-3-3" id="id4">Modern C++ Design 読書ノート 3/3</a><ul>
<li><a class="reference internal" href="#abstract-factory" id="id5">第 9 章 Abstract Factory</a></li>
<li><a class="reference internal" href="#visitor" id="id6">第 10 章 Visitor</a></li>
<li><a class="reference internal" href="#id2" id="id7">第 11 章 マルチメソッド</a></li>
<li><a class="reference internal" href="#a" id="id8">付録 A 最小限のマルチスレッド・ライブラリ</a></li>
<li><a class="reference internal" href="#id3" id="id9">感想</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract-factory">
<h2><a class="toc-backref" href="#id5">第 9 章 Abstract Factory</a><a class="headerlink" href="#abstract-factory" title="Permalink to this headline">¶</a></h2>
<p>&lt;もしも、 <tt class="docutils literal"><span class="pre">ConventionalDialog</span></tt> 中では <tt class="docutils literal"><span class="pre">FunkyButton</span></tt> を使用させたくないのであれば、
Abstract Factory デザイン・パターンを使用することによって <tt class="docutils literal"><span class="pre">FunkyDialog</span></tt> 中でのみ
<tt class="docutils literal"><span class="pre">FunkyButton</span></tt> が使用されるように保証することができます&gt; (p. 231)</p>
<hr class="docutils" />
<p>&lt;ゲーム中に登場する全てのオブジェクトを生成する関数を 1 ヶ所に集めておくのが良いでしょう&gt; (p. 232)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AbstractEnemyFactory</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Soldier</span><span class="o">*</span> <span class="n">MakeSoldier</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">MakeMonster</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">SuperMonster</span><span class="o">*</span> <span class="n">MakeSuperMonster</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">EasyLevelEnemyFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractEnemyFactory</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">DieHardLevelEnemyFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractEnemyFactory</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;Abstract Factory の主な欠点は、それが型と強く結びついている点です。
（略）Abstract Factory の基底クラスは、
生成を行う全ての抽象的な成果物を知っていなければならないのです&gt; (p. 234)</li>
<li>&lt;型の安全性を取るか、それとも低依存性を取るかという古典的なジレンマが、
C++ ではしばしば発生するわけです&gt; (p. 234)</li>
</ul>
<hr class="docutils" />
<p>ここからジェネリックな Abstract Factory の設計に入る。</p>
<p>構造は、以前取り扱った <tt class="docutils literal"><span class="pre">GenScatterHierarchy</span></tt> と、
ファクトリーユニットなるクラステンプレートの群を合体させたようなもの。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 235 より引用。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">AbstractFactoryUnit</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">T</span><span class="o">*</span> <span class="n">DoCreate</span><span class="p">(</span><span class="n">Type2Type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractFactoryUnit</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span>
<span class="o">&lt;</span>
    <span class="k">class</span> <span class="nc">TList</span><span class="p">,</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Unit</span> <span class="o">=</span> <span class="n">AbstractFactoryUnit</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">AbstractFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GenScatterHierarchy</span><span class="o">&lt;</span><span class="n">TList</span><span class="p">,</span> <span class="n">Unit</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">TList</span> <span class="n">ProductList</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">*</span> <span class="n">Create</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Unit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">unit</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">unit</span><span class="p">.</span><span class="n">DoCreate</span><span class="p">(</span><span class="n">Type2Type</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// p. 236</span>
<span class="k">typedef</span> <span class="n">AbstractFactory</span>
<span class="o">&lt;</span>
   <span class="n">TYPELIST_3</span><span class="p">(</span><span class="n">Soldier</span><span class="p">,</span> <span class="n">Monster</span><span class="p">,</span> <span class="n">SuperMonster</span><span class="p">)</span>
<span class="o">&gt;</span>
<span class="n">AbstractEnemyFactory</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">Type2Type</span></tt> は、オーバーロード関数の曖昧さを無くすという目的のみを持った単純なテンプレート&gt; (p. 235)
&lt;<tt class="docutils literal"><span class="pre">AbstractFactoryUnit</span></tt> の実体が同じ継承階層にいくつも現れることになる&gt; (p. 235) ので、
<tt class="docutils literal"><span class="pre">DoCreate</span></tt> にこの引数が要る。</li>
<li><tt class="docutils literal"><span class="pre">AbstractFactory::Create</span></tt> は、&lt;生成要求を適切な基底クラスへと振り分けるディスパッチャ&gt; (p. 236) となる。</li>
</ul>
<hr class="docutils" />
<p><tt class="docutils literal"><span class="pre">AbstractFactory</span></tt> は固まったので、次は <tt class="docutils literal"><span class="pre">ConcreteFactory</span></tt> を設計する。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ConcreteFactory</span></tt> だけでなく、concrete な <tt class="docutils literal"><span class="pre">AbstractFactoryUnit</span></tt> も必要。</li>
<li><tt class="docutils literal"><span class="pre">ConcreteFactory</span></tt> はクラステンプレート <tt class="docutils literal"><span class="pre">GenLinearHierarchy</span></tt> から導出する。
何をしたいのかと言うと、Factory Unit のクラス継承を直列させたいわけだ。</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 238 より引用</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ConcreteProduct</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Base</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OpNewFactoryUnit</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="c1">// Base は多分 AbstractFactoryUnit&lt;ConcreteProduct&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>

<span class="nl">public:</span>
    <span class="c1">// この AbstractProduct を typedef するのがちょっと頭を使う。</span>
    <span class="n">ConcreteProduct</span><span class="o">*</span> <span class="n">DoCreate</span><span class="p">(</span><span class="n">Type2Type</span><span class="o">&lt;</span><span class="n">AbstractProduct</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ConcreteProduct</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// p. 239</span>
<span class="k">template</span>
<span class="o">&lt;</span>
    <span class="k">class</span> <span class="nc">AbstractFact</span><span class="p">,</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">,</span> <span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Creator</span> <span class="o">=</span> <span class="n">OpNewFactoryUnit</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">TList</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">AbstractFact</span><span class="o">::</span><span class="n">ProductList</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ConcreteFactory</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">GenLinearHierarchy</span><span class="o">&lt;</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Prototype バージョンを設計する。</p>
<ul>
<li><p class="first">テンプレートクラス <tt class="docutils literal"><span class="pre">PrototypeFactoryUnit</span></tt> を定義する。
<tt class="docutils literal"><span class="pre">DoCreate</span></tt> の実装では、何かオブジェクトを参照しておいて、そこからクローン作成。</p>
</li>
<li><p class="first">先程の <tt class="docutils literal"><span class="pre">ConcreteFactory</span></tt> がそのまま利用できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">ConcreteFactory</span>
<span class="o">&lt;</span>
    <span class="n">AbstractEnemyFactory</span><span class="p">,</span>
    <span class="n">PrototypeFactoryUnit</span>
<span class="o">&gt;</span>
<span class="n">EnemyFactory</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;Abstract Factory デザイン・パターンを手作業で実装して、
こういった利点全てを満足するようなものを作る手間を考えてみてください&gt; (p. 244)</p>
<p>→大変なことはよく理解した。</p>
</li>
</ul>
</div>
<div class="section" id="visitor">
<h2><a class="toc-backref" href="#id6">第 10 章 Visitor</a><a class="headerlink" href="#visitor" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>メリット：クラス階層や既存コードを再コンパイルせずに、仮想関数を追加できる。</li>
<li>デメリット：&lt;階層の末端にクラスを追加した場合、
階層や全ての既存のコードの再コンパイルが必要になる&gt; (p. 249)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;機能拡張は、新たなクラスを追加するか、
新たな仮想メンバ関数を追加するかのいずれかによって実現できます&gt; (p. 249)</li>
<li>&lt;新たなクラスの追加は簡単であり、新たな仮想メンバ関数の追加は難しい&gt; (p. 250)</li>
<li>従って、こういう場合の裏に対しては、Visitor が役に立つ。</li>
</ul>
<p>ここから架空の文書エディターを開発する場合を考察していく。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pp. 250-251 引用一部略</span>
<span class="k">class</span> <span class="nc">DocStats</span> <span class="c1">// 文書の統計情報</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">AddChars</span><span class="p">(</span><span class="n">xxxx</span><span class="p">);</span> <span class="c1">// 文字数</span>
    <span class="kt">void</span> <span class="nf">AddWords</span><span class="p">(</span><span class="n">xxxx</span><span class="p">);</span> <span class="c1">// 単語数</span>
    <span class="kt">void</span> <span class="nf">AddImages</span><span class="p">(</span><span class="n">xxxx</span><span class="p">);</span> <span class="c1">// 画像数</span>
    <span class="p">...</span>

    <span class="kt">void</span> <span class="n">Display</span><span class="p">();</span> <span class="c1">// 統計情報表示</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DocElement</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">Paragraph</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">RasterBitmap</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DocElement</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// DocElement が Paragraph だったら AddChars や AddWords を利用するし、</span>
    <span class="c1">// RasterBitmap だったら AddImages を利用して、統計をとる。</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">UpdateStats</span><span class="p">(</span><span class="n">DocStats</span><span class="o">&amp;</span> <span class="n">statistics</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>いくつか欠点がある。</p>
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">DocStats</span></tt> を修正する度に、 <tt class="docutils literal"><span class="pre">DocElement</span></tt> 階層全体を再コンパイルする必要がある&gt; (p. 251)</li>
<li>&lt;統計情報の収集を行う実際の処理が、 <tt class="docutils literal"><span class="pre">UpdateStats</span></tt> の実装全体に散りばめられます&gt; (p. 251)</li>
<li>その他</li>
</ul>
<p>発想を変えて、 <tt class="docutils literal"><span class="pre">UpdateStats</span></tt> を <tt class="docutils literal"><span class="pre">DocStats</span></tt> に移動させてみると、
&lt;今度は <tt class="docutils literal"><span class="pre">DocStats</span></tt> が、処理対象となる具体的な <tt class="docutils literal"><span class="pre">DocElement</span></tt> に依存することになります&gt; (p. 252)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 252 より引用一部略</span>
<span class="kt">void</span> <span class="n">DocStats</span><span class="o">::</span><span class="n">UpdateStats</span><span class="p">(</span><span class="n">DocElement</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Paragraph</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Paragraph</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// Paragraph の統計収集...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">RasterBitmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// RasterBitmap の統計収集...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで Visitor の導入となる。
まずはデザインパターンの教科書通りのインターフェイスを持つクラスを書いてみる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 253 より</span>
<span class="c1">// まず Visitor の抽象基底クラス</span>
<span class="k">class</span> <span class="nc">DocElementVisitor</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">VisitParagraph</span><span class="p">(</span><span class="n">Paragraph</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">VisitRasterBitmap</span><span class="p">(</span><span class="n">RasterBitmap</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// DocElement::Visit を宣言。</span>

<span class="k">class</span> <span class="nc">DocElement</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Accept</span><span class="p">(</span><span class="n">DocElementVisitor</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Paragraph</span><span class="o">::</span><span class="n">Accept</span><span class="p">(</span><span class="n">DocElementVisitor</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">VisitParagraph</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// RasterBitmap も同様。</span>

<span class="c1">// そして DocStats は DocElementVisitor を実装する。</span>

<span class="k">class</span> <span class="nc">DocStats</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DocElementVisitor</span>
<span class="p">{</span>
    <span class="c1">// ... VisitParagraph や VisitRasterBitmap を実装 ...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">VisitXXXX</span></tt> は <tt class="docutils literal"><span class="pre">XXXX</span></tt> の public な部分しかアクセスできない。</li>
<li>新たな操作を追加する場合、
<tt class="docutils literal"><span class="pre">DocElementVisitor</span></tt> から新たなクラスを導出するだけでよい。
p. 254 の <tt class="docutils literal"><span class="pre">IncrementFontSize</span></tt> の例を見るといい。</li>
</ul>
<hr class="docutils" />
<p>オーバーロードについて解説あり。</p>
<ul class="simple">
<li>各 <tt class="docutils literal"><span class="pre">VisitXXXX</span></tt> の関数名は単に <tt class="docutils literal"><span class="pre">Visit</span></tt> とすることができる。</li>
<li><tt class="docutils literal"><span class="pre">DocElementVisitor::Visit(DocElement&amp;)</span></tt> もアイディアとしてはアリ。</li>
</ul>
<hr class="docutils" />
<p>非循環式 Visitor という、魅惑的なタイトル。</p>
<ul>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">DocElementVisitor</span></tt> の <tt class="docutils literal"><span class="pre">VisitXxx</span></tt> メンバ関数名にクラス名が埋め込まれるため、
<tt class="docutils literal"><span class="pre">DocElementVisitor</span></tt> のクラス定義をコンパイルする際には、
<tt class="docutils literal"><span class="pre">DocElement</span></tt> 階層に存在する全ての具体的なクラスに関する知識（少なくとも名前）が必要になります&gt; (p. 257)</p>
</li>
<li><p class="first">&lt;循環依存は、保守上のボトルネックになる&gt; (p. 257)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">DocElement</span></tt> 階層にサブクラスを追加するときに必要な作業を列挙している。
&lt;こういった作業は面倒くさい&gt; (p. 258)</p>
</li>
<li><p class="first">Robert Martin (1996) 考案による dynamic_cast を用いた変形 Visitor パターン。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">DocElementVisitor</span></tt> に <tt class="docutils literal"><span class="pre">VisitXxxx</span></tt> を宣言しない。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">XxxxVisitor</span></tt> は <tt class="docutils literal"><span class="pre">DocElementVisitor</span></tt> を継承しないで、
<tt class="docutils literal"><span class="pre">VisitXxxx</span></tt> を純粋仮想関数として宣言する。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">DocElement</span></tt> のサブクラス <tt class="docutils literal"><span class="pre">Xxxx::Accept</span></tt> 関数にて、
引数の <tt class="docutils literal"><span class="pre">DocElementVisitor</span></tt> を <tt class="docutils literal"><span class="pre">XxxxVisitor</span></tt> に dynamic_cast するテストを加える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 259 より引用</span>
<span class="kt">void</span> <span class="n">Paragraph</span><span class="o">::</span><span class="n">Accept</span><span class="p">(</span><span class="n">DocElementVisitor</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ParagraphVisitor</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">ParagraphVisitor</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">VisitParagraph</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">具体的な Visitor クラスの定義は、例えば次のようになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 260 より引用。</span>
<span class="k">class</span> <span class="nc">DocStats</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">DocElementVisitor</span><span class="p">,</span>
    <span class="k">public</span> <span class="n">ParagraphVisitor</span><span class="p">,</span>
    <span class="k">public</span> <span class="n">RasterBitmapVisitor</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// VisitXxxx をこのクラスで実装する。</span>
    <span class="kt">void</span> <span class="n">VisitParagraph</span><span class="p">(</span><span class="n">Paragraph</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">VisitRasterBitmap</span><span class="p">(</span><span class="n">RasterBitmap</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">非循環式 Visitor パターンは循環依存をなくす代わりに、
&lt;<tt class="docutils literal"><span class="pre">DocElement</span></tt> をルートに持つ被訪問階層のクラス群と、
具体的な被訪問クラス毎に対応する訪問クラス <tt class="docutils literal"><span class="pre">XxxVisitor</span></tt> 群という
2 つの並列したクラス群を保守しなければならなくなります&gt; (p. 261)</p>
</li>
<li><p class="first">&lt;高名な GoF の Ralph Gamma ですら、
Visitor がボトム 10 パターンの中のかなり下の方に位置付けられると言っているのです (Vlissides 1999)&gt;
(p. 262)</p>
</li>
</ul>
<hr class="docutils" />
<p>ここでジェネリック化の議論に入る。</p>
<ul class="simple">
<li>&lt;できるだけ多くのコードをライブラリに収納するようにするのです&gt; (p. 262)</li>
<li>最初に非循環式 Visitor を実装し、その後 &lt;標準とも言える&gt; (p. 262) GoF 版 Visitor を実装する流れ。</li>
</ul>
<p>非循環式。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">BaseVisitor</span></tt> - 先の例の <tt class="docutils literal"><span class="pre">DocElementVisitor</span></tt> と同じ。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Visitor</span></tt> - <tt class="docutils literal"><span class="pre">XxxxVisitor</span></tt> 用。クラステンプレートとして宣言。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 263</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Visitor</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">R</span> <span class="n">ReturnType</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">ReturnType</span> <span class="n">Visit</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">BaseVisitable</span></tt> - <tt class="docutils literal"><span class="pre">Accept</span></tt> するクラスの基底クラスとして利用するためのクラステンプレート。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Visitor</span></tt> 同様に <tt class="docutils literal"><span class="pre">Accept</span></tt> の戻り値がテンプレート引数になる。</li>
<li>ユーザーが <tt class="docutils literal"><span class="pre">Accept</span></tt> を実装をするための補助的なマクロ <tt class="docutils literal"><span class="pre">DEFINE_VISITABLE()</span></tt> と補助関数
<tt class="docutils literal"><span class="pre">AcceptImpl(T&amp;,</span> <span class="pre">BaseVisitor&amp;)</span></tt> を用意する。<ul>
<li>&lt;場合によっては <tt class="docutils literal"><span class="pre">DEFINE_VISITABLE()</span></tt> マクロを用いるのではなく、
自分で <tt class="docutils literal"><span class="pre">Accept</span></tt> を実装する必要が出てくる&gt; (p. 268) が、問題ない。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>続いて循環式。dynamic_cast を用いないために高速に動作する。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CyclicVisitor</span></tt> ではタイプリストを利用する。<ul>
<li><tt class="docutils literal"><span class="pre">GenScatterHierarchy&lt;TList,</span> <span class="pre">略&gt;</span></tt> から継承する。</li>
<li><tt class="docutils literal"><span class="pre">Visit</span></tt> メンバ関数テンプレートは <tt class="docutils literal"><span class="pre">Visitor</span></tt> を用いて実装する。
<tt class="docutils literal"><span class="pre">CyclicVisitor</span></tt> は <tt class="docutils literal"><span class="pre">TList</span></tt> 中の各型 <tt class="docutils literal"><span class="pre">T</span></tt> について、
クラス <tt class="docutils literal"><span class="pre">Visitor&lt;T&gt;</span></tt> の派生クラスであるからできる芸当。</li>
</ul>
</li>
<li>マクロ <tt class="docutils literal"><span class="pre">DEFINE_CYCLIC_VISITABLE()</span></tt> を提供する。</li>
</ul>
<p>循環式の場合、ユーザーコードが圧倒的に少なくて済むようだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pp. 270-271 より引用</span>
<span class="k">typedef</span> <span class="n">CyclicVisitor</span>
<span class="o">&lt;</span>
    <span class="kt">void</span><span class="p">,</span> <span class="c1">// 戻り値</span>
    <span class="n">TYPELIST_3</span><span class="p">(</span><span class="n">DocElement</span><span class="p">,</span> <span class="n">Paragraph</span><span class="p">,</span> <span class="n">RasterBitmap</span><span class="p">)</span>
<span class="o">&gt;</span>
<span class="n">MyVisitor</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DocElement</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Visit</span><span class="p">(</span><span class="n">MyVisitor</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Paragraph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DocElement</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">DEFINE_CYCLIC_VISITABLE</span><span class="p">(</span><span class="n">MyVisitor</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id7">第 11 章 マルチメソッド</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>マルチメソッドという用語は CLOS から借用した (p. 277)</li>
</ul>
<hr class="docutils" />
<p>C++ におけるポリモフィズムとは何かをまず考える。
関数オーバーロード、関数テンプレートはともに静的なディスパッチメカニズムであり、
仮想メンバ関数呼び出しは動的なディスパッチメカニズムであるとみなせる。</p>
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">obj.Fun(引数群)</span></tt> という呼び出しシンタックスでは、
引数群よりも <tt class="docutils literal"><span class="pre">obj</span></tt> に優先的な役割が与えられているのです&gt; (p. 278)</li>
<li>マルチメソッド、多重ディスパッチとは
&lt;関数呼び出しに用いられているオブジェクト群の動的な型に依存して、
異なった関数にディスパッチするようなメカニズム&gt; (p. 278) のこと。</li>
</ul>
<hr class="docutils" />
<p>マルチメソッドの必要性について論じる。
ここでは <tt class="docutils literal"><span class="pre">Shape</span></tt> （のサブクラス）オブジェクト同士の交差部分処理という、
C++ プログラム開発経験者ならまず膝を叩く例が挙げられている。</p>
<p>手許に <tt class="docutils literal"><span class="pre">Shape</span></tt> への異なるポインターが 2 つあるとして、
それをどのオーバーロードに適用するの？ という問題だ。</p>
<hr class="docutils" />
<p>最初に一番愚直と思われる方法、力任せに dynamic_cast テストをして、
動的な型に見合うオーバーロード関数に引き渡すコードを示している。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pp. 280-281 より一部抜粋（一部だけで雰囲気が思い出せるから）</span>

<span class="kt">void</span> <span class="nf">DoHatchArea1</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">DoHatchArea2</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Ellipse</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">DoHatchArea3</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Poly</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">...</span>

<span class="kt">void</span> <span class="n">DoubleDispatch</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Rectangle</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Rectangle</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">))</span>
            <span class="n">DoHatchArea1</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">Ellipse</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Ellipse</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">))</span>
            <span class="n">DoHatchArea2</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span>
            <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>問題点は明らか。<ul>
<li>&lt;この実装は、階層中に存在する全クラスを知っていなければならないのです&gt; (p. 281)</li>
<li>&lt;<tt class="docutils literal"><span class="pre">if</span></tt> ステートメントの順序が処理に影響を与えてしまう&gt; (p. 281) -
&lt;最も下位にあるクラスが最初に判定されるよう、
<tt class="docutils literal"><span class="pre">if</span></tt> の判定を「ソートする」&gt; (p. 282) ようでなければ問題が出る。</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>ここから本書らしいアプローチが始まる。
先程の <tt class="docutils literal"><span class="pre">DoubleDispatch</span></tt> 相当のコードを、クラステンプレート <tt class="docutils literal"><span class="pre">StaticDispatcher</span></tt> と
クラス <tt class="docutils literal"><span class="pre">HatchingExecutor</span></tt> に分割して、次のような構造で表現する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pp. 283-286 から断続的に引用。</span>

<span class="k">template</span><span class="o">&lt;</span> <span class="cm">/* 略 */</span> <span class="o">&gt;</span> <span class="c1">// 本を読んで。</span>
<span class="k">class</span> <span class="nc">StaticDispatcher</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TypesLhs</span><span class="o">::</span><span class="n">Head</span> <span class="n">Head</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TypesLhs</span><span class="o">::</span><span class="n">Tail</span> <span class="n">Tail</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">ResultType</span> <span class="nf">Go</span><span class="p">(</span><span class="n">BaseLhs</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">BaseRhs</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">Executor</span> <span class="n">exec</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">Head</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Head</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">StaticDispatcher</span><span class="o">&lt;</span> <span class="n">NullType</span><span class="p">,</span> <span class="cm">/* 略 */</span> <span class="o">&gt;::</span><span class="n">DispatchRhs</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">exec</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">StaticDispatcher</span><span class="o">&lt;</span> <span class="n">Tail</span><span class="p">,</span> <span class="cm">/* 略 */</span> <span class="o">&gt;::</span><span class="n">Go</span><span class="p">(</span><span class="cm">/* 略 */</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">SomeLhs</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">ResultType</span> <span class="n">DispatchRhs</span><span class="p">(</span><span class="n">SomeLhs</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">BaseRhs</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">Executor</span> <span class="n">exec</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ここで Head, Tail に対する typedef を「上書き」する。</span>

        <span class="k">if</span><span class="p">(</span><span class="n">Head</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Head</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">exec</span><span class="p">.</span><span class="n">Fire</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">StaticDispatcher</span><span class="o">&lt;</span><span class="n">NullType</span><span class="p">,</span> <span class="n">Tail</span><span class="p">,</span> <span class="cm">/* 略 */</span><span class="o">&gt;::</span><span class="n">DispatchRhs</span><span class="p">(</span><span class="cm">/* 略 */</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// TODO: StaticDispatcher の部分特殊化 1: TypeLhs = NullType で</span>
<span class="c1">// ダミーの static メソッド Go を実装する。</span>

<span class="c1">// TODO: StaticDispatcher の部分特殊化 2: TypeRhs = NullType で</span>
<span class="c1">// ダミーの static メソッド DispatchRhs を実装する。</span>

<span class="k">class</span> <span class="nc">HatchingExecutor</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Fire</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Fire</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Ellipse</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="p">...</span>

    <span class="kt">void</span> <span class="n">OnError</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Shape</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Go</span></tt> から <tt class="docutils literal"><span class="pre">Go</span></tt> を呼び出す様子は再帰呼び出しに見えるかもしれないが、
<tt class="docutils literal"><span class="pre">StaticDispatcher</span></tt> の別な実体化の同名メソッドを呼び出している。
<tt class="docutils literal"><span class="pre">DispatchRhs</span></tt> も同様。</li>
<li>&lt;結果的に、 <tt class="docutils literal"><span class="pre">StaticDispatcher</span></tt> は、
2 つのタイプリストと特定のコードから指数に比例した分量のコードを生成するわけです。
（略）つまり、大きなコードによってコンパイル時間、プログラム・サイズ、
実行時間の全てに打撃が与えられるのです&gt; (p. 284)</li>
<li>&lt;<tt class="docutils literal"><span class="pre">StaticDispatcher</span></tt> は境界条件が発生した場合、
元々の（キャストしない） <tt class="docutils literal"><span class="pre">lhs</span></tt> と <tt class="docutils literal"><span class="pre">rhs</span></tt> を用いて単に
<tt class="docutils literal"><span class="pre">Executor::OnError</span></tt> を呼び出します&gt; (p. 286)</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 286 より。</span>
<span class="k">typedef</span> <span class="n">StaticDispatcher</span><span class="o">&lt;</span><span class="n">HatchingExecutor</span><span class="p">,</span> <span class="n">Shape</span><span class="p">,</span>
    <span class="n">TYPELIST_3</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span> <span class="n">Ellipse</span><span class="p">,</span> <span class="n">Poly</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">Dispatcher</span><span class="p">;</span>

<span class="n">Shape</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Shape</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">HatchingExecutor</span> <span class="n">exec</span><span class="p">;</span>
<span class="n">Dispatcher</span><span class="o">::</span><span class="n">Go</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">,</span> <span class="n">exec</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li>タイプリストに記述するクラスの順序に注意。先程と同様の注意が要る。
&lt;継承階層で最も下位にあるものをタイプリストの先頭に持ってくることです&gt; (p. 287)</li>
</ul>
<hr class="docutils" />
<p>次に引数の順序を意識せずに済むように改造していく。対称型マルチメソッド。
<tt class="docutils literal"><span class="pre">BaseLhs</span></tt> と <tt class="docutils literal"><span class="pre">BaseRhs</span></tt> が同一型かつ
<tt class="docutils literal"><span class="pre">TypesLhs</span></tt> と <tt class="docutils literal"><span class="pre">TypesRhs</span></tt> が同一型の場合に意味がある。</p>
<ul>
<li><p class="first">&lt;理想的には、追加の <tt class="docutils literal"><span class="pre">bool</span></tt> テンプレート・パラメータを <tt class="docutils literal"><span class="pre">StaticDispatcher</span></tt> に引き渡して、
対称性が選択できるようにするべきでしょう&gt; (p. 289)</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">StaticDispatcher</span></tt> に <tt class="docutils literal"><span class="pre">bool</span> <span class="pre">symmetric</span></tt> テンプレート引数を追加する。</p>
</li>
<li><p class="first">クラス内の private 部分にクラステンプレート <tt class="docutils literal"><span class="pre">InvocationTraits</span></tt> を定義する。
これは static メンバー関数 <tt class="docutils literal"><span class="pre">DoDispatch</span></tt> だけを含む構造体。</p>
<p><tt class="docutils literal"><span class="pre">DoDispatch</span></tt> の内容は単に <tt class="docutils literal"><span class="pre">exec.Fire(lhs,</span> <span class="pre">rhs);</span></tt> のみ。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">InvocationTraits</span></tt> の部分特殊化版を定義し、そちらの
<tt class="docutils literal"><span class="pre">DoDispatch</span></tt> の内容は <tt class="docutils literal"><span class="pre">exec.Fire(rhs,</span> <span class="pre">lhs);</span></tt> とする。</li>
</ul>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">StaticDispatcher::DispatchRhs</span></tt> の定義で、if ブロック内をこのようにする。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// p. 291 より引用</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">swapArgs</span> <span class="o">=</span> <span class="n">symmetric</span> <span class="o">&amp;&amp;</span>
    <span class="n">IndexOf</span><span class="o">&lt;</span><span class="n">Head</span><span class="p">,</span> <span class="n">TypeRhs</span><span class="o">&gt;::</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">IndexOf</span><span class="o">&lt;</span><span class="n">BaseLhs</span><span class="p">,</span> <span class="n">TypesLhs</span><span class="o">&gt;::</span><span class="n">result</span> <span class="p">};</span>
<span class="k">typedef</span> <span class="n">InvocationTraits</span><span class="o">&lt;</span><span class="n">swapArgs</span><span class="p">,</span> <span class="n">BaseLhs</span><span class="p">,</span> <span class="n">Head</span><span class="o">&gt;</span>
    <span class="n">CallTraits</span><span class="p">;</span>
<span class="k">return</span> <span class="n">CallTraits</span><span class="o">::</span><span class="n">DoDispatch</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p>型リストから型を探索する効率を対数時間に持っていこうとするのか。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">std::type_info::before</span></tt> によって &lt;プログラム中における全ての型に対する順序関係が提供されるのです&gt; (p. 291)</p>
</li>
<li><p class="first">第 2 章で紹介されたラッパークラス <tt class="docutils literal"><span class="pre">TypeInfo</span></tt> を利用する。
&lt;<tt class="docutils literal"><span class="pre">TypeInfo</span></tt> は、値のセマンティックスと演算子 <tt class="docutils literal"><span class="pre">operator&lt;</span></tt> を提供しています。
このため、標準コンテナに <tt class="docutils literal"><span class="pre">TypeInfo</span></tt> オブジェクトを格納することができるのです&gt; (p. 292)</p>
</li>
<li><p class="first">&lt;特に、ソート済みベクタと二分探索アルゴリズムを組み合わせれば、
連想コンテナよりも空間的および時間的に優れたものとなる場合もあるのです。
これは、挿入頻度よりもアクセス頻度の方が多い場合に起こり得ます&gt; (p. 292)</p>
<p>つまり、コンテナ内容がある時点から固定されるような場合は連想コンテナを採用しないように、か。</p>
</li>
<li><p class="first">ただし、便宜的に両者のデータ構造を共に「マップ」と呼ぶことにする。(p. 293)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">BasicDispatcher</span></tt></p>
<ul>
<li><p class="first">最終的なディスパッチ先の関数の引数 <tt class="docutils literal"><span class="pre">(lhs,</span> <span class="pre">rhs)</span></tt> ペアの型を <tt class="docutils literal"><span class="pre">std::pair&lt;TypeInfo,</span> <span class="pre">TypeInfo&gt;</span></tt> で表現する。</p>
</li>
<li><p class="first">上記のペア型をキー型とし、
<tt class="docutils literal"><span class="pre">ResultType</span> <span class="pre">(*)(BaseLhs&amp;,</span> <span class="pre">BaseRhs&amp;)</span></tt> 型の関数ポインタを値型とするマップを定義する。</p>
</li>
<li><p class="first">そのマップオブジェクトをメンバーデータに持つ。</p>
</li>
<li><p class="first">テンプレートメンバー関数 <tt class="docutils literal"><span class="pre">Add</span></tt> を定義し、マップに関数ポインタを動的に追加できるようにする。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Go</span></tt> は次のようになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ResultType</span> <span class="nf">Go</span><span class="p">(</span><span class="n">BaseLhs</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">BaseRhs</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">callbackMap_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span>
        <span class="n">KeyType</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="k">typeid</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">callbackMap_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// ... 例外送出</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">&lt;継承とともに用いると正しく動作しません&gt; (p. 294)</p>
</li>
<li><p class="first">&lt;<tt class="docutils literal"><span class="pre">BasicDispatcher</span></tt> に対して、全てのペアを注意深く登録していかなければならないのです&gt; (p. 295)</p>
</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>次に <tt class="docutils literal"><span class="pre">BasicDispatcher</span></tt> を利用して <tt class="docutils literal"><span class="pre">FnDispatcher</span></tt> を定義するのだが、
もうついていけないのでスキップ。</p>
<p class="last"><tt class="docutils literal"><span class="pre">Trampoline</span></tt> という面白い技法を利用してディスパッチを実現する。</p>
</div>
<hr class="docutils" />
<ul class="simple">
<li>&lt;値のセマンティックスは実行時のポリモフィズムとうまく調和できない&gt; (p. 299)</li>
</ul>
<hr class="docutils" />
<p>static_cast or dynamic_cast という問題。
これまでは dynamic_cast 一丁で押し通してきた理由を解説。</p>
<ul class="simple">
<li>仮想継承を伴なうダイアモンド型クラス階層が対象となるとき、
&lt;仮想基底オブジェクトから導出した型へは static_cast することができない&gt; (p. 302)</li>
<li>仮想継承を伴わないダイアモンド型クラス階層が対象となるとき、
基底クラスが曖昧になるケースがある。</li>
</ul>
<hr class="docutils" />
<p>&lt;多重ディスパッチと C++ において、特にいやらしかった問題は、
可変引数関数を表現する統一した方法が存在しないということだったのです&gt; (p. 312)</p>
</div>
<div class="section" id="a">
<h2><a class="toc-backref" href="#id8">付録 A 最小限のマルチスレッド・ライブラリ</a><a class="headerlink" href="#a" title="Permalink to this headline">¶</a></h2>
<p>C++ に関する書籍は、マルチスレッドをテーマにした文章が付録になる傾向がある。
本書もその例に漏れない。</p>
<ul class="simple">
<li>&lt;ユーザは砂時計のカーソルが表示されることを望んでいないため、
プログラマはマルチスレッド・プログラムを記述しなければならないのです&gt; (p. 317)</li>
<li>&lt;ライブラリもスレッドを考慮する必要があります。
こういった機能は、ライブラリが自身のスレッドを用いていない場合であっても、
組み込んでおかなければならないのです&gt; (p. 317)</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;マルチスレッドがシングルプロセッサ・マシンでも必要となる理由は、
リソースを効果的に使用できるという点があるからです&gt; (p. 318)</li>
<li>&lt;これらは物理的に独立した機器であるため、同時にリソースを使用することができるのです&gt; (p. 318)</li>
<li>&lt;非同期実行は、マルチスレッドの実行と比較すると状態遷移の多いプログラムになるという欠点があります&gt; (p. 318)</li>
<li>&lt;アトミックな操作だと思っていたものがそうではなくなってしまう&gt; (p. 318)</li>
<li>&lt;マルチスレッドのプログラムは、リソースの共有に大きな問題を抱えている&gt; (p. 319)</li>
<li>マルチスレッドプログラミングにおける重要な技法のひとつに、同期化オブジェクトがある。</li>
</ul>
<hr class="docutils" />
<p><tt class="docutils literal"><span class="pre">++x</span></tt> というステートメントに関する考察を始める。</p>
<ul class="simple">
<li>こういう (read-modify-write) 操作を RMW 操作と呼ぶ (p. 320)</li>
<li>マルチプロセッサ環境では、あるプロセッサが変数を更新している間にも、
別のプロセッサがメモリにアクセスできる。</li>
<li>&lt;どちらのプロセッサ（スレッド）も、インクリメントができなかったことを検出できない&gt; (p. 320)</li>
<li>通常、アトミックなインクリメント・デクリメント操作は OS が C 関数の形式でサポートしている。</li>
</ul>
<p>ライブラリでアトミック演算をまとめるようだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SomeThreadingModel</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">IntType</span><span class="p">;</span> <span class="c1">// int にはプラットフォーム規定整数型名がくる。</span>

    <span class="k">static</span> <span class="n">IntType</span> <span class="nf">AtomicAdd</span><span class="p">(</span><span class="k">volatile</span> <span class="n">IntType</span><span class="o">&amp;</span> <span class="n">lval</span><span class="p">,</span> <span class="n">IntType</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>&lt;コピー操作でさえも非アトミックな場合があるため、
<tt class="docutils literal"><span class="pre">AtomicAssign</span></tt> 関数も 2 つ必要となるわけです&gt; (p. 321)</li>
</ul>
<hr class="docutils" />
<p>ミューテックスの話題。</p>
<ul>
<li><p class="first">&lt;マルチスレッド環境下におけるオペレーティング・システムのスケジューラは、
ある種の同期化オブジェクトを提供しなければならないということが、
Edgar Dijkstra によって証明されています。
マルチスレッド・アプリケーションを正しく記述するためには、
こういったものが必要不可欠なのです&gt; (p. 321)</p>
<p>とても重要。丸暗記しよう。</p>
</li>
<li><p class="first">&lt;ミューテックス (mutex) とは、相互排他 (Mutual Exclusive) の略であり、
同期化用のプリミティブ・オブジェクトの機能を解説するための用語です&gt; (p. 321)</p>
</li>
<li><p class="first">&lt;たった 1 つのスレッドのみがミューテックスを獲得できるのです&gt; (p. 322)</p>
<p>獲得は <tt class="docutils literal"><span class="pre">Acquire</span></tt> で、解放は <tt class="docutils literal"><span class="pre">Release</span></tt> か。</p>
</li>
<li><p class="first">コード中の <tt class="docutils literal"><span class="pre">mtx.Acquire()</span></tt> 呼び出しと <tt class="docutils literal"><span class="pre">mtx.Release()</span></tt> 呼び出しで囲まれた部分が、
<tt class="docutils literal"><span class="pre">mtx</span></tt> オブジェクトに関してアトミックとなる。</p>
<p>これを利用して &lt;スレッド間で共有させたいリソース毎にミューテックス・オブジェクトを
1 つ割り当てることになります&gt; (p. 322)</p>
</li>
<li><p class="first">マルチスレッドプログラミングの教科書にありがちな
「銀行口座クラスの預金引き出しメソッド実装例」コードあり。</p>
<ul class="simple">
<li>&lt;<tt class="docutils literal"><span class="pre">Lock</span></tt> オブジェクトをスタック上に割り当てておけば、例外発生の有無とは関係なく、
<tt class="docutils literal"><span class="pre">Acquire</span></tt> と <tt class="docutils literal"><span class="pre">Release</span></tt> のペアが正しく実行される&gt; (p. 323)</li>
</ul>
</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>&lt;オブジェクト指向プログラムでは、リソースはオブジェクトになります&gt; (p. 323)</li>
<li>オブジェクト・レベルのロックと、クラス・レベルのロックがある。</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Host</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ObjectLevelLockable</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">class</span> <span class="nc">Lock</span>
    <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">Lock</span><span class="p">(</span><span class="n">Host</span><span class="o">&amp;</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BankAccount</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ObjectLevelLockable</span><span class="o">&lt;</span><span class="n">BankAccount</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="kt">void</span> <span class="n">Deposite</span><span class="p">(</span><span class="cm">/* 略 */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Lock</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        <span class="c1">// ... 入金トランザクション</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<hr class="docutils" />
<p>&lt;<tt class="docutils literal"><span class="pre">volatile</span></tt> の指定によってコンパイラはある種の最適化を抑止するため、
シングルスレッド・モデルでは指定するべきではないのです&gt; (p. 325)</p>
<hr class="docutils" />
<p>&lt;ポータブルなマルチスレッド・ライブラリとして ACE
(Adaptive Communication Environment) を調査することをお勧めします (Schmidt 2000)&gt; (p. 326)</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">感想</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>一周読むのに鉛筆片手に 10 時間、
このノートをとるのに 13 時間近く要した。
これまで読んできた C++ 関連書籍中「初心者にお勧めできない」度ナンバーワンは間違いなく本書だ。</li>
<li>コーディング・コンパイル・動作確認を一切しないという不埒な読書姿勢。</li>
<li>理解度もかなり低いだろう。</li>
</ul>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html">読書ノート v1.2.0</a> &raquo;</li>
          <li><a href="alexandrescu01.html" >Modern C++ Design 読書ノート</a> &raquo;</li> 
      </ul>
    </div>
    <div id="footer">
      <div id="footer_logo">
        <a class="imga" href="https://showa-yojyo.github.io/" title="プレハブ小屋 Since 1999"><img src="_static/logos.png" width="88" height="31" /></a>
      </div>
      <div id="footer_share">
        <a href="https://twitter.com/share" class="twitter-share-button" data-size="large">Tweet</a>
        <script type="text/javascript">render_twitter_button(document, 'script', 'twitter-wjs')</script>
      </div>
      <div id="footer_copyright">
        Since 1999<br />
        Copyright &copy; 1999-2014, プレハブ小屋 All rights reserved.
      </div>
      <div id="footer_spacer">
        <p>
          Last updated at 2014/11/06 (Thu) 23:22:09.
        </p>
      </div>
    </div>
  </body>
</html>